#!/usr/bin/env node
/* Generated by Spago v0.93.39 */import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));const __filename=new URL(import.meta.url).pathname
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod8) => function __require2() {
  return mod8 || (0, cb[__getOwnPropNames(cb)[0]])((mod8 = { exports: {} }).exports, mod8), mod8.exports;
};
var __copyProps = (to2, from4, except10, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to2, key) && key !== except10)
        __defProp(to2, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod8, isNodeMode, target) => (target = mod8 != null ? __create(__getProtoOf(mod8)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod8 || !mod8.__esModule ? __defProp(target, "default", { value: mod8, enumerable: true }) : target,
  mod8
));

// node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "node_modules/spdx-license-ids/index.json"(exports, module) {
    module.exports = [
      "0BSD",
      "3D-Slicer-1.0",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMD-newlib",
      "AMDPLPA",
      "AML",
      "AML-glslang",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "ASWF-Digital-Assets-1.0",
      "ASWF-Digital-Assets-1.1",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Display-PostScript",
      "Adobe-Glyph",
      "Adobe-Utopia",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Darwin",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-2-Clause-first-lines",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-HP",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-3-Clause-Sun",
      "BSD-3-Clause-acpica",
      "BSD-3-Clause-flex",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Inferno-Nettverk",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSD-Source-beginning-file",
      "BSD-Systemics",
      "BSD-Systemics-W3Works",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Boehm-GC",
      "Borceux",
      "Brian-Gladman-2-Clause",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-AU",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-3.0-IGO",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CMU-Mach-nodoc",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "Caldera-no-preamble",
      "Catharon",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Cronyx",
      "Crossword",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DEC-3-Clause",
      "DL-DE-BY-2.0",
      "DL-DE-ZERO-2.0",
      "DOC",
      "DRL-1.0",
      "DRL-1.1",
      "DSDP",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FBM",
      "FDK-AAC",
      "FSFAP",
      "FSFAP-no-warranty-disclaimer",
      "FSFUL",
      "FSFULLR",
      "FSFULLRWD",
      "FTL",
      "Fair",
      "Ferguson-Twofish",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "Furuseth",
      "GCR-docs",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "Gutmann",
      "HP-1986",
      "HP-1989",
      "HPND",
      "HPND-DEC",
      "HPND-Fenneberg-Livingston",
      "HPND-INRIA-IMAG",
      "HPND-Intel",
      "HPND-Kevlin-Henney",
      "HPND-MIT-disclaimer",
      "HPND-Markus-Kuhn",
      "HPND-Pbmplus",
      "HPND-UC",
      "HPND-UC-export-US",
      "HPND-doc",
      "HPND-doc-sell",
      "HPND-export-US",
      "HPND-export-US-acknowledgement",
      "HPND-export-US-modify",
      "HPND-export2-US",
      "HPND-merchantability-variant",
      "HPND-sell-MIT-disclaimer-xserver",
      "HPND-sell-regexpr",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HPND-sell-variant-MIT-disclaimer-rev",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ISC-Veillard",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Inner-Net-2.0",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kastrup",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPD-document",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Latex2e-translated-notice",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-1-para",
      "Linux-man-pages-copyleft",
      "Linux-man-pages-copyleft-2-para",
      "Linux-man-pages-copyleft-var",
      "Lucida-Bitmap-Fonts",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Festival",
      "MIT-Khronos-old",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MIT-testregex",
      "MITNFA",
      "MMIXware",
      "MPEG-SSG",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "Mackerras-3-Clause",
      "Mackerras-3-Clause-acknowledgment",
      "MakeIndex",
      "Martin-Birgmeier",
      "McPhee-slideshow",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCBI-PD",
      "NCGL-UK-2.0",
      "NCL",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NIST-Software",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTP",
      "NTP-0",
      "Naumen",
      "Net-SNMP",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OAR",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OLFL-1.3",
      "OML",
      "OPL-1.0",
      "OPL-UK-3.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "OpenSSL-standalone",
      "OpenVision",
      "PADL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PPL",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Pixar",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "SAX-PD",
      "SAX-PD-2.0",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SGI-OpenGL",
      "SGP4",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SL",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSLeay-standalone",
      "SSPL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "SimPL-2.0",
      "Sleepycat",
      "Soundex",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "Sun-PPP",
      "Sun-PPP-2000",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TGPPL-1.0",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TTYP0",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "TermReadKey",
      "UCAR",
      "UCL-1.0",
      "UMich-Merit",
      "UPL-1.0",
      "URT-RLE",
      "Unicode-3.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "UnixCrypt",
      "Unlicense",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Widget-Workshop",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "XFree86-1.1",
      "XSkat",
      "Xdebug-1.03",
      "Xerox",
      "Xfig",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zeeff",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "any-OSI",
      "bcrypt-Solar-Designer",
      "blessing",
      "bzip2-1.0.6",
      "check-cvs",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "cve-tou",
      "diffmark",
      "dtoa",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "fwlw",
      "gSOAP-1.3b",
      "gnuplot",
      "gtkbook",
      "hdparm",
      "iMatix",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "lsof",
      "magaz",
      "mailprio",
      "metamail",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "pkgconf",
      "pnmstitch",
      "psfrag",
      "psutils",
      "python-ldap",
      "radvd",
      "snprintf",
      "softSurfer",
      "ssh-keyscan",
      "swrule",
      "threeparttable",
      "ulem",
      "w3m",
      "xinetd",
      "xkeyboard-config-Zinoviev",
      "xlock",
      "xpp",
      "xzoom",
      "zlib-acknowledgement"
    ];
  }
});

// node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "node_modules/spdx-license-ids/deprecated.json"(exports, module) {
    module.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "node_modules/spdx-exceptions/index.json"(exports, module) {
    module.exports = [
      "389-exception",
      "Asterisk-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Autoconf-exception-generic",
      "Autoconf-exception-generic-3.0",
      "Autoconf-exception-macro",
      "Bison-exception-1.24",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "cryptsetup-OpenSSL-exception",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "fmt-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-2.0-note",
      "GCC-exception-3.1",
      "Gmsh-exception",
      "GNAT-exception",
      "GNOME-examples-exception",
      "GNU-compiler-exception",
      "gnu-javamail-exception",
      "GPL-3.0-interface-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "GStreamer-exception-2005",
      "GStreamer-exception-2008",
      "i2p-gpl-java-exception",
      "KiCad-libraries-exception",
      "LGPL-3.0-linking-exception",
      "libpri-OpenH323-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLGPL",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "QPL-1.0-INRIA-2004-exception",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "SANE-exception",
      "SHL-2.0",
      "SHL-2.1",
      "stunnel-exception",
      "SWI-exception",
      "Swift-exception",
      "Texinfo-exception",
      "u-boot-exception-2.0",
      "UBDL-exception",
      "Universal-FOSS-exception-1.0",
      "vsftpd-openssl-exception",
      "WxWindows-exception-3.1",
      "x11vnc-openssl-exception"
    ];
  }
});

// node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "node_modules/spdx-expression-parse/scan.js"(exports, module) {
    "use strict";
    var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module.exports = function(source2) {
      var index5 = 0;
      function hasMore() {
        return index5 < source2.length;
      }
      function read7(value4) {
        if (value4 instanceof RegExp) {
          var chars2 = source2.slice(index5);
          var match5 = chars2.match(value4);
          if (match5) {
            index5 += match5[0].length;
            return match5[0];
          }
        } else {
          if (source2.indexOf(value4, index5) === index5) {
            index5 += value4.length;
            return value4;
          }
        }
      }
      function skipWhitespace() {
        read7(/[ ]*/);
      }
      function operator() {
        var string8;
        var possibilities = [/^WITH/i, /^AND/i, /^OR/i, "(", ")", ":", "+"];
        for (var i = 0; i < possibilities.length; i++) {
          string8 = read7(possibilities[i]);
          if (string8) {
            break;
          }
        }
        if (string8 === "+" && index5 > 1 && source2[index5 - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string8 && {
          type: "OPERATOR",
          string: string8.toUpperCase()
        };
      }
      function idstring() {
        return read7(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string8 = idstring();
        if (!string8) {
          throw new Error("Expected idstring at offset " + index5);
        }
        return string8;
      }
      function documentRef() {
        if (read7("DocumentRef-")) {
          var string8 = expectIdstring();
          return { type: "DOCUMENTREF", string: string8 };
        }
      }
      function licenseRef() {
        if (read7("LicenseRef-")) {
          var string8 = expectIdstring();
          return { type: "LICENSEREF", string: string8 };
        }
      }
      function identifier() {
        var begin = index5;
        var string8 = idstring();
        if (licenses.indexOf(string8) !== -1) {
          return {
            type: "LICENSE",
            string: string8
          };
        } else if (exceptions.indexOf(string8) !== -1) {
          return {
            type: "EXCEPTION",
            string: string8
          };
        }
        index5 = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token2 = parseToken();
        if (!token2) {
          throw new Error("Unexpected `" + source2[index5] + "` at offset " + index5);
        }
        tokens.push(token2);
      }
      return tokens;
    };
  }
});

// node_modules/spdx-expression-parse/parse.js
var require_parse = __commonJS({
  "node_modules/spdx-expression-parse/parse.js"(exports, module) {
    "use strict";
    module.exports = function(tokens) {
      var index5 = 0;
      function hasMore() {
        return index5 < tokens.length;
      }
      function token2() {
        return hasMore() ? tokens[index5] : null;
      }
      function next2() {
        if (!hasMore()) {
          throw new Error();
        }
        index5++;
      }
      function parseOperator2(operator) {
        var t = token2();
        if (t && t.type === "OPERATOR" && operator === t.string) {
          next2();
          return t.string;
        }
      }
      function parseWith() {
        if (parseOperator2("WITH")) {
          var t = token2();
          if (t && t.type === "EXCEPTION") {
            next2();
            return t.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index5;
        var string8 = "";
        var t = token2();
        if (t.type === "DOCUMENTREF") {
          next2();
          string8 += "DocumentRef-" + t.string + ":";
          if (!parseOperator2(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t = token2();
        if (t.type === "LICENSEREF") {
          next2();
          string8 += "LicenseRef-" + t.string;
          return { license: string8 };
        }
        index5 = begin;
      }
      function parseLicense() {
        var t = token2();
        if (t && t.type === "LICENSE") {
          next2();
          var node2 = { license: t.string };
          if (parseOperator2("+")) {
            node2.plus = true;
          }
          var exception = parseWith();
          if (exception) {
            node2.exception = exception;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left3 = parseOperator2("(");
        if (!left3) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator2(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left3 = nextParser();
          if (!left3) {
            return;
          }
          if (!parseOperator2(operator)) {
            return left3;
          }
          var right2 = parseBinaryOp();
          if (!right2) {
            throw new Error("Expected expression");
          }
          return {
            left: left3,
            conjunction: operator.toLowerCase(),
            right: right2
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "node_modules/spdx-expression-parse/index.js"(exports, module) {
    "use strict";
    var scan = require_scan();
    var parse15 = require_parse();
    module.exports = function(source2) {
      return parse15(scan(source2));
    };
  }
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP2 = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity36.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP2;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path14) {
      const ctrl = callVisitor(key, node, visitor, path14);
      if (identity36.isNode(ctrl) || identity36.isPair(ctrl)) {
        replaceNode(key, path14, ctrl);
        return visit_(key, ctrl, visitor, path14);
      }
      if (typeof ctrl !== "symbol") {
        if (identity36.isCollection(node)) {
          path14 = Object.freeze(path14.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path14);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity36.isPair(node)) {
          path14 = Object.freeze(path14.concat(node));
          const ck = visit_("key", node.key, visitor, path14);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path14);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity36.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP2;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path14) {
      const ctrl = await callVisitor(key, node, visitor, path14);
      if (identity36.isNode(ctrl) || identity36.isPair(ctrl)) {
        replaceNode(key, path14, ctrl);
        return visitAsync_(key, ctrl, visitor, path14);
      }
      if (typeof ctrl !== "symbol") {
        if (identity36.isCollection(node)) {
          path14 = Object.freeze(path14.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path14);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity36.isPair(node)) {
          path14 = Object.freeze(path14.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path14);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path14);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path14) {
      if (typeof visitor === "function")
        return visitor(key, node, path14);
      if (identity36.isMap(node))
        return visitor.Map?.(key, node, path14);
      if (identity36.isSeq(node))
        return visitor.Seq?.(key, node, path14);
      if (identity36.isPair(node))
        return visitor.Pair?.(key, node, path14);
      if (identity36.isScalar(node))
        return visitor.Scalar?.(key, node, path14);
      if (identity36.isAlias(node))
        return visitor.Alias?.(key, node, path14);
      return void 0;
    }
    function replaceNode(key, path14, node) {
      const parent = path14[path14.length - 1];
      if (identity36.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity36.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity36.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity36.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line2, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line2.trim().split(/[ \t]+/);
        const name5 = parts.shift();
        switch (name5) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix4] = parts;
            this.tags[handle] = prefix4;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version4] = parts;
            if (version4 === "1.1" || version4 === "1.2") {
              this.yaml.version = version4;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version4);
              onError(6, `Unsupported YAML version ${version4}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name5}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source2, onError) {
        if (source2 === "!")
          return "!";
        if (source2[0] !== "!") {
          onError(`Not a valid tag: ${source2}`);
          return null;
        }
        if (source2[1] === "<") {
          const verbatim = source2.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
            return null;
          }
          if (source2[source2.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix2] = source2.match(/^(.*!)([^!]*)$/s);
        if (!suffix2)
          onError(`The ${source2} tag has no suffix`);
        const prefix4 = this.tags[handle];
        if (prefix4) {
          try {
            return prefix4 + decodeURIComponent(suffix2);
          } catch (error5) {
            onError(String(error5));
            return null;
          }
        }
        if (handle === "!")
          return source2;
        onError(`Could not resolve tag: ${source2}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix4] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix4))
            return handle + escapeTagName(tag.substring(prefix4.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines8 = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity36.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity36.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix4] of tagEntries) {
          if (handle === "!!" && prefix4 === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix4)))
            lines8.push(`%TAG ${handle} ${prefix4}`);
        }
        return lines8.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root2) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root2, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix4, exclude) {
      for (let i = 1; true; ++i) {
        const name5 = `${prefix4}${i}`;
        if (!exclude.has(name5))
          return name5;
      }
    }
    function createNodeAnchors(doc, prefix4) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source2) => {
          aliasObjects.push(source2);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix4, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source2 of aliasObjects) {
            const ref2 = sourceObjects.get(source2);
            if (typeof ref2 === "object" && ref2.anchor && (identity36.isScalar(ref2.node) || identity36.isCollection(ref2.node))) {
              ref2.node.anchor = ref2.anchor;
            } else {
              const error5 = new Error("Failed to resolve repeated object (this should not happen)");
              error5.source = source2;
              throw error5;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    function toJS(value4, arg, ctx) {
      if (Array.isArray(value4))
        return value4.map((v, i) => toJS(v, String(i), ctx));
      if (value4 && typeof value4.toJSON === "function") {
        if (!ctx || !identity36.hasAnchor(value4))
          return value4.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value4, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value4.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value4 === "bigint" && !ctx?.keep)
        return Number(value4);
      return value4;
    }
    exports.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity36 = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity36.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity36.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity36 = require_identity();
    var Node4 = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node4.NodeBase {
      constructor(source2) {
        super(identity36.ALIAS);
        this.source = source2;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source2 = this.resolve(doc);
        if (!source2) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source2);
        if (!data) {
          toJS.toJS(source2, null, ctx);
          data = anchors2.get(source2);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source2, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity36.isAlias(node)) {
        const source2 = node.resolve(doc);
        const anchor = anchors2 && source2 && anchors2.get(source2);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity36.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity36.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Node4 = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value4) => !value4 || typeof value4 !== "function" && typeof value4 !== "object";
    var Scalar = class extends Node4.NodeBase {
      constructor(value4) {
        super(identity36.SCALAR);
        this.value = value4;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value4, tagName, tags) {
      if (tagName) {
        const match5 = tags.filter((t) => t.tag === tagName);
        const tagObj = match5.find((t) => !t.format) ?? match5[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value4) && !t.format);
    }
    function createNode(value4, tagName, ctx) {
      if (identity36.isDocument(value4))
        value4 = value4.contents;
      if (identity36.isNode(value4))
        return value4;
      if (identity36.isPair(value4)) {
        const map154 = ctx.schema[identity36.MAP].createNode?.(ctx.schema, null, ctx);
        map154.items.push(value4);
        return map154;
      }
      if (value4 instanceof String || value4 instanceof Number || value4 instanceof Boolean || typeof BigInt !== "undefined" && value4 instanceof BigInt) {
        value4 = value4.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref2 = void 0;
      if (aliasDuplicateObjects && value4 && typeof value4 === "object") {
        ref2 = sourceObjects.get(value4);
        if (ref2) {
          if (!ref2.anchor)
            ref2.anchor = onAnchor(value4);
          return new Alias.Alias(ref2.anchor);
        } else {
          ref2 = { anchor: null, node: null };
          sourceObjects.set(value4, ref2);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value4, tagName, schema.tags);
      if (!tagObj) {
        if (value4 && typeof value4.toJSON === "function") {
          value4 = value4.toJSON();
        }
        if (!value4 || typeof value4 !== "object") {
          const node2 = new Scalar.Scalar(value4);
          if (ref2)
            ref2.node = node2;
          return node2;
        }
        tagObj = value4 instanceof Map ? schema[identity36.MAP] : Symbol.iterator in Object(value4) ? schema[identity36.SEQ] : schema[identity36.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value4, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value4, ctx) : new Scalar.Scalar(value4);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref2)
        ref2.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity36 = require_identity();
    var Node4 = require_Node();
    function collectionFromPath(schema, path14, value4) {
      let v = value4;
      for (let i = path14.length - 1; i >= 0; --i) {
        const k = path14[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path14) => path14 == null || typeof path14 === "object" && !!path14[Symbol.iterator]().next().done;
    var Collection = class extends Node4.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity36.isNode(it) || identity36.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path14, value4) {
        if (isEmptyPath(path14))
          this.add(value4);
        else {
          const [key, ...rest2] = path14;
          const node = this.get(key, true);
          if (identity36.isCollection(node))
            node.addIn(rest2, value4);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest2, value4));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path14) {
        const [key, ...rest2] = path14;
        if (rest2.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity36.isCollection(node))
          return node.deleteIn(rest2);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path14, keepScalar) {
        const [key, ...rest2] = path14;
        const node = this.get(key, true);
        if (rest2.length === 0)
          return !keepScalar && identity36.isScalar(node) ? node.value : node;
        else
          return identity36.isCollection(node) ? node.getIn(rest2, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity36.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity36.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path14) {
        const [key, ...rest2] = path14;
        if (rest2.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity36.isCollection(node) ? node.hasIn(rest2) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path14, value4) {
        const [key, ...rest2] = path14;
        if (rest2.length === 0) {
          this.set(key, value4);
        } else {
          const node = this.get(key, true);
          if (identity36.isCollection(node))
            node.setIn(rest2, value4);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest2, value4));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment2, indent3) {
      if (/^\n+$/.test(comment2))
        return comment2.substring(1);
      return indent3 ? comment2.replace(/^(?! *$)/gm, indent3) : comment2;
    }
    var lineComment2 = (str2, indent3, comment2) => str2.endsWith("\n") ? indentComment(comment2, indent3) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent3) : (str2.endsWith(" ") ? "" : " ") + comment2;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment2;
    exports.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text3, indent3, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text3;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent3.length);
      if (text3.length <= endStep)
        return text3;
      const folds = [];
      const escapedFolds = {};
      let end4 = lineWidth - indent3.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end4 = lineWidth - indentAtStart;
      }
      let split3 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode2 === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text3, i, indent3.length);
        if (i !== -1)
          end4 = i + endStep;
      }
      for (let ch; ch = text3[i += 1]; ) {
        if (mode2 === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text3[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode2 === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text3, i, indent3.length);
          end4 = i + indent3.length + endStep;
          split3 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next2 = text3[i + 1];
            if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
              split3 = i;
          }
          if (i >= end4) {
            if (split3) {
              folds.push(split3);
              end4 = split3 + endStep;
              split3 = void 0;
            } else if (mode2 === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text3[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text3;
              folds.push(j);
              escapedFolds[j] = true;
              end4 = j + endStep;
              split3 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text3;
      if (onFold)
        onFold();
      let res = text3.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold27 = folds[i2];
        const end5 = folds[i2 + 1] || text3.length;
        if (fold27 === 0)
          res = `
${indent3}${text3.slice(0, end5)}`;
        else {
          if (mode2 === FOLD_QUOTED && escapedFolds[fold27])
            res += `${text3[fold27]}\\`;
          res += `
${indent3}${text3.slice(fold27 + 1, end5)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text3, i, indent3) {
      let end4 = i;
      let start = i + 1;
      let ch = text3[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent3) {
          ch = text3[++i];
        } else {
          do {
            ch = text3[++i];
          } while (ch && ch !== "\n");
          end4 = i;
          start = i + 1;
          ch = text3[start];
        }
      }
      return end4;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value4, ctx) {
      const json4 = JSON.stringify(value4);
      if (ctx.options.doubleQuotedAsJSON)
        return json4;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent3 = ctx.indent || (containsDocumentMarker(value4) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json4[i]; ch; ch = json4[++i]) {
        if (ch === " " && json4[i + 1] === "\\" && json4[i + 2] === "n") {
          str2 += json4.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json4[i + 1]) {
            case "u":
              {
                str2 += json4.slice(start, i);
                const code3 = json4.substr(i + 2, 4);
                switch (code3) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code3.substr(0, 2) === "00")
                      str2 += "\\x" + code3.substr(2);
                    else
                      str2 += json4.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json4[i + 2] === '"' || json4.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json4.slice(start, i) + "\n\n";
                while (json4[i + 2] === "\\" && json4[i + 3] === "n" && json4[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent3;
                if (json4[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json4.slice(start) : json4;
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent3, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value4, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value4.includes("\n") || /[ \t]\n|\n[ \t]/.test(value4))
        return doubleQuotedString(value4, ctx);
      const indent3 = ctx.indent || (containsDocumentMarker(value4) ? "  " : "");
      const res = "'" + value4.replace(/'/g, "''").replace(/\n+/g, `$&
${indent3}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value4, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value4.includes('"');
        const hasSingle = value4.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value4, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment: comment2, type, value: value4 }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value4) || /^\s*$/.test(value4)) {
        return quotedString(value4, ctx);
      }
      const indent3 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value4) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value4, lineWidth, indent3.length);
      if (!value4)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value4.length; endStart > 0; --endStart) {
        const ch = value4[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end4 = value4.substring(endStart);
      const endNlPos = end4.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value4 === end4 || endNlPos !== end4.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end4) {
        value4 = value4.slice(0, -end4.length);
        if (end4[end4.length - 1] === "\n")
          end4 = end4.slice(0, -1);
        end4 = end4.replace(blockEndNewlines, `$&${indent3}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value4.length; ++startEnd) {
        const ch = value4[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value4.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value4 = value4.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent3}`);
      }
      const indentSize = indent3 ? "2" : "1";
      let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment2) {
        header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (literal) {
        value4 = value4.replace(/\n+/g, `$&${indent3}`);
        return `${header}
${indent3}${start}${value4}${end4}`;
      }
      value4 = value4.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent3}`);
      const body = foldFlowLines.foldFlowLines(`${start}${value4}${end4}`, indent3, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
      return `${header}
${indent3}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value: value4 } = item;
      const { actualString, implicitKey, indent: indent3, indentStep, inFlow } = ctx;
      if (implicitKey && value4.includes("\n") || inFlow && /[[\]{},]/.test(value4)) {
        return quotedString(value4, ctx);
      }
      if (!value4 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value4)) {
        return implicitKey || inFlow || !value4.includes("\n") ? quotedString(value4, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value4.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value4)) {
        if (indent3 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent3 === indentStep) {
          return quotedString(value4, ctx);
        }
      }
      const str2 = value4.replace(/\n+/g, `$&
${indent3}`);
      if (actualString) {
        const test2 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str2);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test2) || compat?.some(test2))
          return quotedString(value4, ctx);
      }
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity36 = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match5 = tags.filter((t) => t.tag === item.tag);
        if (match5.length > 0)
          return match5.find((t) => t.format === item.format) ?? match5[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity36.isScalar(item)) {
        obj = item.value;
        const match5 = tags.filter((t) => t.identify?.(obj));
        tagObj = match5.find((t) => t.format === item.format) ?? match5.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name5 = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name5} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity36.isScalar(node) || identity36.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify3(item, ctx, onComment, onChompKeep) {
      if (identity36.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity36.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity36.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity36.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return identity36.isScalar(node) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value: value4 }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent3, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity36.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity36.isCollection(key) || !identity36.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value4 == null && !ctx.inFlow || identity36.isCollection(key) || (identity36.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent3 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str2 = stringify3.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value4 == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
        }
      } else if (allNullValues && !simpleKeys || value4 == null && explicitKey) {
        str2 = `? ${str2}`;
        if (keyComment && !keyCommentDone) {
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        str2 = `? ${str2}
${indent3}:`;
      } else {
        str2 = `${str2}:`;
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity36.isNode(value4)) {
        vsb = !!value4.spaceBefore;
        vcb = value4.commentBefore;
        valueComment = value4.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value4 && typeof value4 === "object")
          value4 = doc.createNode(value4);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity36.isScalar(value4))
        ctx.indentAtStart = str2.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity36.isSeq(value4) && !value4.flow && !value4.tag && !value4.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify3.stringify(value4, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity36.isCollection(value4)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value4.flow ?? value4.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str2 += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str2;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    function debug2(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn2(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug2;
    exports.warn = warn2;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log5 = require_log();
    var stringify3 = require_stringify();
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map154, { key, value: value4 }) {
      if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value4 = identity36.isAlias(value4) ? value4.resolve(ctx.doc) : value4;
        if (identity36.isSeq(value4))
          for (const it of value4.items)
            mergeToJSMap(ctx, map154, it);
        else if (Array.isArray(value4))
          for (const it of value4)
            mergeToJSMap(ctx, map154, it);
        else
          mergeToJSMap(ctx, map154, value4);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map154 instanceof Map) {
          map154.set(jsKey, toJS.toJS(value4, jsKey, ctx));
        } else if (map154 instanceof Set) {
          map154.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value4, stringKey, ctx);
          if (stringKey in map154)
            Object.defineProperty(map154, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map154[stringKey] = jsValue;
        }
      }
      return map154;
    }
    var isMergeKey = (key) => key === MERGE_KEY || identity36.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map154, value4) {
      const source2 = ctx && identity36.isAlias(value4) ? value4.resolve(ctx.doc) : value4;
      if (!identity36.isMap(source2))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source2.toJSON(null, ctx, Map);
      for (const [key, value5] of srcMap) {
        if (map154 instanceof Map) {
          if (!map154.has(key))
            map154.set(key, value5);
        } else if (map154 instanceof Set) {
          map154.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map154, key)) {
          Object.defineProperty(map154, key, {
            value: value5,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map154;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity36.isNode(key) && ctx?.doc) {
        const strCtx = stringify3.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log5.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity36 = require_identity();
    function createPair(key, value4, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value4, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value4 = null) {
        Object.defineProperty(this, identity36.NODE_TYPE, { value: identity36.PAIR });
        this.key = key;
        this.value = value4;
      }
      clone(schema) {
        let { key, value: value4 } = this;
        if (identity36.isNode(key))
          key = key.clone(schema);
        if (identity36.isNode(value4))
          value4 = value4.clone(schema);
        return new _Pair(key, value4);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify4(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent3, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines8 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment3 = null;
        if (identity36.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines8.push("");
          addCommentBefore(ctx, lines8, item.commentBefore, chompKeep);
          if (item.comment)
            comment3 = item.comment;
        } else if (identity36.isPair(item)) {
          const ik = identity36.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines8.push("");
            addCommentBefore(ctx, lines8, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str3 = stringify3.stringify(item, itemCtx, () => comment3 = null, () => chompKeep = true);
        if (comment3)
          str3 += stringifyComment.lineComment(str3, itemIndent, commentString(comment3));
        if (chompKeep && comment3)
          chompKeep = false;
        lines8.push(blockItemPrefix + str3);
      }
      let str2;
      if (lines8.length === 0) {
        str2 = flowChars.start + flowChars.end;
      } else {
        str2 = lines8[0];
        for (let i = 1; i < lines8.length; ++i) {
          const line2 = lines8[i];
          str2 += line2 ? `
${indent3}${line2}` : "\n";
        }
      }
      if (comment2) {
        str2 += "\n" + stringifyComment.indentComment(commentString(comment2), indent3);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str2;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent: indent3, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines8 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity36.isNode(item)) {
          if (item.spaceBefore)
            lines8.push("");
          addCommentBefore(ctx, lines8, item.commentBefore, false);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity36.isPair(item)) {
          const ik = identity36.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines8.push("");
            addCommentBefore(ctx, lines8, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity36.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment2 = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment2 = ik.comment;
          }
        }
        if (comment2)
          reqNewline = true;
        let str2 = stringify3.stringify(item, itemCtx, () => comment2 = null);
        if (i < items.length - 1)
          str2 += ",";
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (!reqNewline && (lines8.length > linesAtValue || str2.includes("\n")))
          reqNewline = true;
        lines8.push(str2);
        linesAtValue = lines8.length;
      }
      const { start, end: end4 } = flowChars;
      if (lines8.length === 0) {
        return start + end4;
      } else {
        if (!reqNewline) {
          const len = lines8.reduce((sum4, line2) => sum4 + line2.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str2 = start;
          for (const line2 of lines8)
            str2 += line2 ? `
${indentStep}${indent3}${line2}` : "\n";
          return `${str2}
${indent3}${end4}`;
        } else {
          return `${start}${fcPadding}${lines8.join(" ")}${fcPadding}${end4}`;
        }
      }
    }
    function addCommentBefore({ indent: indent3, options: { commentString } }, lines8, comment2, chompKeep) {
      if (comment2 && chompKeep)
        comment2 = comment2.replace(/^\n+/, "");
      if (comment2) {
        const ic = stringifyComment.indentComment(commentString(comment2), indent3);
        lines8.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity36 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity36.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity36.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity36.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity36.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map154 = new this(schema);
        const add4 = (key, value4) => {
          if (typeof replacer === "function")
            value4 = replacer.call(obj, key, value4);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value4 !== void 0 || keepUndefined)
            map154.items.push(Pair.createPair(key, value4, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value4] of obj)
            add4(key, value4);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add4(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map154.items.sort(schema.sortMapEntries);
        }
        return map154;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity36.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity36.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity36.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value4) {
        this.add(new Pair.Pair(key, value4), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map154 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map154);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map154, item);
        return map154;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity36.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var YAMLMap = require_YAMLMap();
    var map154 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map155, onError) {
        if (!identity36.isMap(map155))
          onError("Expected a mapping for this tag");
        return map155;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map154;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity36.SEQ, schema);
        this.items = [];
      }
      add(value4) {
        this.items.push(value4);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity36.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value4) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity36.isScalar(prev) && Scalar.isScalarValue(value4))
          prev.value = value4;
        else
          this.items[idx] = value4;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity36.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity36.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string8 = {
      identify: (value4) => typeof value4 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string8;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value4) => value4 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source: source2 }, ctx) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value4) => typeof value4 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar.Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source: source2, value: value4 }, ctx) {
        if (source2 && boolTag.test.test(source2)) {
          const sv = source2[0] === "t" || source2[0] === "T";
          if (value4 === sv)
            return source2;
        }
        return value4 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value: value4 }) {
      if (typeof value4 === "bigint")
        return String(value4);
      const num = typeof value4 === "number" ? value4 : Number(value4);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value4);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2));
        const dot2 = str2.indexOf(".");
        if (dot2 !== -1 && str2[str2.length - 1] === "0")
          node.minFractionDigits = str2.length - dot2 - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value4) => typeof value4 === "bigint" || Number.isInteger(value4);
    var intResolve = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    function intStringify(node, radix, prefix4) {
      const { value: value4 } = node;
      if (intIdentify(value4) && value4 >= 0)
        return prefix4 + value4.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value4) => intIdentify(value4) && value4 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value4) => intIdentify(value4) && value4 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map154 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string8 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map154.map,
      seq.seq,
      string8.string,
      _null2.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map154 = require_map();
    var seq = require_seq();
    function intIdentify(value4) {
      return typeof value4 === "bigint" || Number.isInteger(value4);
    }
    var stringifyJSON = ({ value: value4 }) => JSON.stringify(value4);
    var jsonScalars = [
      {
        identify: (value4) => typeof value4 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value4) => value4 == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value4) => typeof value4 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value4 }) => intIdentify(value4) ? value4.toString() : JSON.stringify(value4)
      },
      {
        identify: (value4) => typeof value4 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    var schema = [map154.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value4) => value4 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment: comment2, type, value: value4 }, ctx, onComment, onChompKeep) {
        const buf = value4;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str2 = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str2.length / lineWidth);
          const lines8 = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines8[i] = str2.substr(o, lineWidth);
          }
          str2 = lines8.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment: comment2, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity36.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity36.isPair(item))
            continue;
          else if (identity36.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity36.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value4;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value4 = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys4 = Object.keys(it);
            if (keys4.length === 1) {
              key = keys4[0];
              value4 = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys4.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value4, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map154 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map154);
        for (const pair of this.items) {
          let key, value4;
          if (identity36.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value4 = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map154.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map154.set(key, value4);
        }
        return map154;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value4) => value4 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity36.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value: value4, source: source2 }, ctx) {
      const boolObj = value4 ? trueTag : falseTag;
      if (source2 && boolObj.test.test(source2))
        return source2;
      return value4 ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value4) => value4 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value4) => value4 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot2 = str2.indexOf(".");
        if (dot2 !== -1) {
          const f = str2.substring(dot2 + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value4) => typeof value4 === "bigint" || Number.isInteger(value4);
    function intResolve(str2, offset, radix, { intAsBigInt }) {
      const sign2 = str2[0];
      if (sign2 === "-" || sign2 === "+")
        offset += 1;
      str2 = str2.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign2 === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign2 === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix4) {
      const { value: value4 } = node;
      if (intIdentify(value4)) {
        const str2 = value4.toString(radix);
        return value4 < 0 ? "-" + prefix4 + str2.substr(1) : prefix4 + str2;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity36.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity36.isPair(pair) ? identity36.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value4) {
        if (typeof value4 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value4}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value4) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value4) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set5 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value4 of iterable) {
            if (typeof replacer === "function")
              value4 = replacer.call(iterable, value4, value4);
            set5.items.push(Pair.createPair(value4, null, ctx));
          }
        return set5;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set4 = {
      collection: "map",
      identify: (value4) => value4 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map154, onError) {
        if (identity36.isMap(map154)) {
          if (map154.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map154);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map154;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set4;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str2, asBigInt) {
      const sign2 = str2[0];
      const parts = sign2 === "-" || sign2 === "+" ? str2.substring(1) : str2;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign2 === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value: value4 } = node;
      let num = (n) => n;
      if (typeof value4 === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value4) || !isFinite(value4))
        return stringifyNumber.stringifyNumber(node);
      let sign2 = "";
      if (value4 < 0) {
        sign2 = "-";
        value4 *= num(-1);
      }
      const _60 = num(60);
      const parts = [value4 % _60];
      if (value4 < 60) {
        parts.unshift(0);
      } else {
        value4 = (value4 - parts[0]) / _60;
        parts.unshift(value4 % _60);
        if (value4 >= 60) {
          value4 = (value4 - parts[0]) / _60;
          parts.unshift(value4);
        }
      }
      return sign2 + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value4) => typeof value4 === "bigint" || Number.isInteger(value4),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value4) => value4 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match5 = str2.match(timestamp.test);
        if (!match5)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month2, day2, hour2, minute2, second3] = match5.map(Number);
        const millisec = match5[7] ? Number((match5[7] + "00").substr(1, 3)) : 0;
        let date2 = Date.UTC(year2, month2 - 1, day2, hour2 || 0, minute2 || 0, second3 || 0, millisec);
        const tz = match5[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date2 -= 6e4 * d;
        }
        return new Date(date2);
      },
      stringify: ({ value: value4 }) => value4.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map154 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string8 = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var omap = require_omap();
    var pairs = require_pairs();
    var set4 = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map154.map,
      seq.seq,
      string8.string,
      _null2.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set4.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map154 = require_map();
    var _null2 = require_null();
    var seq = require_seq();
    var string8 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set4 = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map154.map, seq.seq, string8.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map154.map,
      null: _null2.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set4.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set4.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys4 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys4} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string")
          return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        const keys4 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys4}`);
      });
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var map154 = require_map();
    var seq = require_seq();
    var string8 = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge4, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.merge = !!merge4;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity36.MAP, { value: map154.map });
        Object.defineProperty(this, identity36.SCALAR, { value: string8.string });
        Object.defineProperty(this, identity36.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines8 = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines8.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines8.push("---");
      const ctx = stringify3.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines8.length !== 1)
          lines8.unshift("");
        const cs = commentString(doc.commentBefore);
        lines8.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity36.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines8.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines8.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify3.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines8[lines8.length - 1] === "---") {
          lines8[lines8.length - 1] = `--- ${body}`;
        } else
          lines8.push(body);
      } else {
        lines8.push(stringify3.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines8.push("...");
            lines8.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines8.push(`... ${cs}`);
          }
        } else {
          lines8.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines8[lines8.length - 1] !== "")
            lines8.push("");
          lines8.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines8.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity36 = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document3 = class _Document {
      constructor(value4, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity36.NODE_TYPE, { value: identity36.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version4 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version4 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version4 });
        this.setSchema(version4, options);
        this.contents = value4 === void 0 ? null : this.createNode(value4, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity36.NODE_TYPE]: { value: identity36.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity36.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value4) {
        if (assertCollection(this.contents))
          this.contents.add(value4);
      }
      /** Adds a value to the document. */
      addIn(path14, value4) {
        if (assertCollection(this.contents))
          this.contents.addIn(path14, value4);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name5) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name5 || prev.has(name5) ? anchors.findNewAnchor(name5 || "a", prev) : name5;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value4, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value4 = replacer.call({ "": value4 }, "", value4);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value4, tag, ctx);
        if (flow && identity36.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value4, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value4, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path14) {
        if (Collection.isEmptyPath(path14)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path14) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity36.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path14, keepScalar) {
        if (Collection.isEmptyPath(path14))
          return !keepScalar && identity36.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity36.isCollection(this.contents) ? this.contents.getIn(path14, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity36.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path14) {
        if (Collection.isEmptyPath(path14))
          return this.contents !== void 0;
        return identity36.isCollection(this.contents) ? this.contents.hasIn(path14) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value4) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value4);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value4);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path14, value4) {
        if (Collection.isEmptyPath(path14)) {
          this.contents = value4;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path14), value4);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path14, value4);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version4, options = {}) {
        if (typeof version4 === "number")
          version4 = String(version4);
        let opt;
        switch (version4) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version4;
            else
              this.directives = new directives.Directives({ version: version4 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version4);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json4, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json4,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity36.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document3;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name5, pos2, code3, message3) {
        super();
        this.name = name5;
        this.code = code3;
        this.message = message3;
        this.pos = pos2;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos2, code3, message3) {
        super("YAMLParseError", pos2, code3, message3);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos2, code3, message3) {
        super("YAMLWarning", pos2, code3, message3);
      }
    };
    var prettifyError = (src, lc) => (error5) => {
      if (error5.pos[0] === -1)
        return;
      error5.linePos = error5.pos.map((pos2) => lc.linePos(pos2));
      const { line: line2, col } = error5.linePos[0];
      error5.message += ` at line ${line2}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end4 = error5.linePos[1];
        if (end4 && end4.line === line2 && end4.col > col) {
          count = Math.max(1, Math.min(end4.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error5.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment2 = "";
      let commentSep = "";
      let hasNewline = false;
      let hasNewlineAfterProp = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token2 of tokens) {
        if (reqSpace) {
          if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
            onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token2.type !== "comment" && token2.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token2.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next2?.type !== "flow-collection") && token2.source.includes("	")) {
              tab = token2;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token2.source.substring(1) || " ";
            if (!comment2)
              comment2 = cb;
            else
              comment2 += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment2)
                comment2 += token2.source;
              else
                spaceBefore = true;
            } else
              commentSep += token2.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              hasNewlineAfterProp = true;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token2.source.endsWith(":"))
              onError(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
            if (found)
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow ?? "collection"}`);
            found = token2;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token2;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last4 = tokens[tokens.length - 1];
      const end4 = last4 ? last4.offset + last4.source.length : offset;
      if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
        onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next2?.type === "block-map" || next2?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment: comment2,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end: end4,
        start: start ?? end4
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent3, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end4 = fc.end[0];
        if (end4.indent === indent3 && (end4.source === "]" || end4.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end4, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    function mapIncludes(ctx, items, search2) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity36.isScalar(a) && identity36.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search2));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map154 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep3, value: value4 } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep3) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map154.comment)
                map154.comment += "\n" + keyProps.comment;
              else
                map154.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map154.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep3 ?? [], {
          indicator: "map-value-ind",
          next: value4,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value4?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value4 ? composeNode(ctx, value4, valueProps, onError) : composeEmptyNode(ctx, offset, sep3, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value4, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map154.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map154.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map154.range = [bm.offset, offset, commentEnd ?? offset];
      return map154;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value: value4 } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value4,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value4) {
            if (value4 && value4.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value4 ? composeNode(ctx, value4, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value4, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end4, offset, reqSpace, onError) {
      let comment2 = "";
      if (end4) {
        let hasSpace = false;
        let sep3 = "";
        for (const token2 of end4) {
          const { source: source2, type } = token2;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source2.substring(1) || " ";
              if (!comment2)
                comment2 = cb;
              else
                comment2 += sep3 + cb;
              sep3 = "";
              break;
            }
            case "newline":
              if (comment2)
                sep3 += source2;
              hasSpace = true;
              break;
            default:
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source2.length;
        }
      }
      return { comment: comment2, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep3, value: value4 } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep3?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep3 && !value4) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st of start) {
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity36.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep3 && !props.found) {
          const valueNode = value4 ? composeNode(ctx, value4, props, onError) : composeEmptyNode(ctx, props.end, sep3, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value4))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          const valueProps = resolveProps.resolveProps(sep3 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value4,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep3)
                for (const st of sep3) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value4) {
            if ("source" in value4 && value4.source && value4.source[0] === ":")
              onError(value4, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value4 ? composeNode(ctx, value4, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep3, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value4))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map154 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map154.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map154.items.push(pair);
          } else {
            const map154 = new YAMLMap.YAMLMap(ctx.schema);
            map154.flow = true;
            map154.items.push(pair);
            coll.items.push(map154);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name5 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name5} must end with a ${expectedEnd}` : `${name5} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end4 = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end4.comment) {
          if (coll.comment)
            coll.comment += "\n" + end4.comment;
          else
            coll.comment = end4.comment;
        }
        coll.range = [fc.offset, cePos, end4.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token2, onError, tagName, tag) {
      const coll = token2.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token2, onError, tag) : token2.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token2, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token2, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token2, tagToken, onError) {
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      const expType = token2.type === "block-map" ? "map" : token2.type === "block-seq" ? "seq" : token2.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq" || !expType) {
        return resolveCollection(CN, ctx, token2, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token2, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token2, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity36.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines8 = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines8.length;
      for (let i = lines8.length - 1; i >= 0; --i) {
        const content = lines8[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value5 = header.chomp === "+" && lines8.length > 0 ? "\n".repeat(Math.max(1, lines8.length - 1)) : "";
        let end5 = start + header.length;
        if (scalar.source)
          end5 += scalar.source.length;
        return { value: value5, type, comment: header.comment, range: [start, end5, end5] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent3, content] = lines8[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent3.length > trimIndent)
            trimIndent = indent3.length;
        } else {
          if (indent3.length < trimIndent) {
            const message3 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent3.length, "MISSING_CHAR", message3);
          }
          if (header.indent === 0)
            trimIndent = indent3.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message3 = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message3);
          }
          break;
        }
        offset += indent3.length + content.length + 1;
      }
      for (let i = lines8.length - 1; i >= chompStart; --i) {
        if (lines8[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value4 = "";
      let sep3 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value4 += lines8[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent3, content] = lines8[i];
        offset += indent3.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent3.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message3 = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message3);
          indent3 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value4 += sep3 + indent3.slice(trimIndent) + content;
          sep3 = "\n";
        } else if (indent3.length > trimIndent || content[0] === "	") {
          if (sep3 === " ")
            sep3 = "\n";
          else if (!prevMoreIndented && sep3 === "\n")
            sep3 = "\n\n";
          value4 += sep3 + indent3.slice(trimIndent) + content;
          sep3 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep3 === "\n")
            value4 += "\n";
          else
            sep3 = "\n";
        } else {
          value4 += sep3 + content;
          sep3 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines8.length; ++i)
            value4 += "\n" + lines8[i][0].slice(trimIndent);
          if (value4[value4.length - 1] !== "\n")
            value4 += "\n";
          break;
        default:
          value4 += "\n";
      }
      const end4 = start + header.length + scalar.source.length;
      return { value: value4, type, comment: header.comment, range: [start, end4, end4] };
    }
    function parseBlockScalarHeader({ offset, props }, strict2, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source: source2 } = props[0];
      const mode2 = source2[0];
      let indent3 = 0;
      let chomp = "";
      let error5 = -1;
      for (let i = 1; i < source2.length; ++i) {
        const ch = source2[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent3 && n)
            indent3 = n;
          else if (error5 === -1)
            error5 = offset + i;
        }
      }
      if (error5 !== -1)
        onError(error5, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
      let hasSpace = false;
      let comment2 = "";
      let length9 = source2.length;
      for (let i = 1; i < props.length; ++i) {
        const token2 = props[i];
        switch (token2.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length9 += token2.source.length;
            break;
          case "comment":
            if (strict2 && !hasSpace) {
              const message3 = "Comments must be separated from other tokens by white space characters";
              onError(token2, "MISSING_CHAR", message3);
            }
            length9 += token2.source.length;
            comment2 = token2.source.substring(1);
            break;
          case "error":
            onError(token2, "UNEXPECTED_TOKEN", token2.message);
            length9 += token2.source.length;
            break;
          default: {
            const message3 = `Unexpected token in block scalar header: ${token2.type}`;
            onError(token2, "UNEXPECTED_TOKEN", message3);
            const ts = token2.source;
            if (ts && typeof ts === "string")
              length9 += ts.length;
          }
        }
      }
      return { mode: mode2, indent: indent3, chomp, comment: comment2, length: length9 };
    }
    function splitLines(source2) {
      const split3 = source2.split(/\n( *)/);
      const first2 = split3[0];
      const m = first2.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
      const lines8 = [line0];
      for (let i = 1; i < split3.length; i += 2)
        lines8.push([split3[i], split3[i + 1]]);
      return lines8;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict2, onError) {
      const { offset, type, source: source2, end: end4 } = scalar;
      let _type;
      let value4;
      const _onError = (rel, code3, msg) => onError(offset + rel, code3, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value4 = plainValue(source2, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value4 = singleQuotedValue(source2, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value4 = doubleQuotedValue(source2, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source2.length, offset + source2.length]
          };
      }
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end4, valueEnd, strict2, onError);
      return {
        value: value4,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source2, onError) {
      let badChar = "";
      switch (source2[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source2[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source2[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source2);
    }
    function singleQuotedValue(source2, onError) {
      if (source2[source2.length - 1] !== "'" || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source2) {
      let first2, line2;
      try {
        first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch (_) {
        first2 = /(.*?)[ \t]*\r?\n/sy;
        line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match5 = first2.exec(source2);
      if (!match5)
        return source2;
      let res = match5[1];
      let sep3 = " ";
      let pos2 = first2.lastIndex;
      line2.lastIndex = pos2;
      while (match5 = line2.exec(source2)) {
        if (match5[1] === "") {
          if (sep3 === "\n")
            res += sep3;
          else
            sep3 = "\n";
        } else {
          res += sep3 + match5[1];
          sep3 = " ";
        }
        pos2 = line2.lastIndex;
      }
      const last4 = /[ \t]*(.*)/sy;
      last4.lastIndex = pos2;
      match5 = last4.exec(source2);
      return res + sep3 + (match5?.[1] ?? "");
    }
    function doubleQuotedValue(source2, onError) {
      let res = "";
      for (let i = 1; i < source2.length - 1; ++i) {
        const ch = source2[i];
        if (ch === "\r" && source2[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold: fold27, offset } = foldNewline(source2, i);
          res += fold27;
          i = offset;
        } else if (ch === "\\") {
          let next2 = source2[++i];
          const cc = escapeCodes[next2];
          if (cc)
            res += cc;
          else if (next2 === "\n") {
            next2 = source2[i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "\r" && source2[i + 1] === "\n") {
            next2 = source2[++i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "x" || next2 === "u" || next2 === "U") {
            const length9 = { x: 2, u: 4, U: 8 }[next2];
            res += parseCharCode(source2, i + 1, length9, onError);
            i += length9;
          } else {
            const raw2 = source2.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw2}`);
            res += raw2;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next2 = source2[i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source2[++i + 1];
          if (next2 !== "\n" && !(next2 === "\r" && source2[i + 2] === "\n"))
            res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source2[source2.length - 1] !== '"' || source2.length === 1)
        onError(source2.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source2, offset) {
      let fold27 = "";
      let ch = source2[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source2[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold27 += "\n";
        offset += 1;
        ch = source2[offset + 1];
      }
      if (!fold27)
        fold27 = " ";
      return { fold: fold27, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source2, offset, length9, onError) {
      const cc = source2.substr(offset, length9);
      const ok = cc.length === length9 && /^[0-9a-fA-F]+$/.test(cc);
      const code3 = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code3)) {
        const raw2 = source2.substr(offset - 2, length9 + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw2}`);
        return raw2;
      }
      return String.fromCodePoint(code3);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity36 = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token2, tagToken, onError) {
      const { value: value4, type, comment: comment2, range: range3 } = token2.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token2, onError) : resolveFlowScalar.resolveFlowScalar(token2, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value4, tagName, tagToken, onError) : token2.type === "scalar" ? findScalarTagByTest(ctx, value4, token2, onError) : ctx.schema[identity36.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value4, (msg) => onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity36.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error5) {
        const msg = error5 instanceof Error ? error5.message : String(error5);
        onError(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value4);
      }
      scalar.range = range3;
      scalar.source = value4;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment2)
        scalar.comment = comment2;
      return scalar;
    }
    function findScalarTagByName(schema, value4, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity36.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value4))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity36.SCALAR];
    }
    function findScalarTagByTest({ directives, schema }, value4, token2, onError) {
      const tag = schema.tags.find((tag2) => tag2.default && tag2.test?.test(value4)) || schema[identity36.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value4)) ?? schema[identity36.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token2, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos2) {
      if (before) {
        if (pos2 === null)
          pos2 = before.length;
        for (let i = pos2 - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token2, props, onError) {
      const { spaceBefore, comment: comment2, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token2.type) {
        case "alias":
          node = composeAlias(ctx, token2, onError);
          if (anchor || tag)
            onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token2, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token2, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message3 = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
          onError(token2, "UNEXPECTED_TOKEN", message3);
          node = composeEmptyNode(ctx, token2.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        if (token2.type === "scalar" && token2.source === "")
          node.comment = comment2;
        else
          node.commentBefore = comment2;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token2;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos2, { spaceBefore, comment: comment2, anchor, tag, end: end4 }, onError) {
      const token2 = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos2),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token2, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        node.comment = comment2;
        node.range[2] = end4;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source: source2, end: end4 }, onError) {
      const alias = new Alias.Alias(source2.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end4, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document3 = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value: value4, end: end4 }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document3.Document(void 0, opts);
      const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value4 ?? end4?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value4 && (value4.type === "block-map" || value4.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value4 ? composeNode.composeNode(ctx, value4, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end4, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var directives = require_directives();
    var Document3 = require_Document();
    var errors = require_errors();
    var identity36 = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source: source2 } = src;
      return [offset, offset + (typeof source2 === "string" ? source2.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment2 = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source2 = prelude[i];
        switch (source2[0]) {
          case "#":
            comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment: comment2, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source2, code3, message3, warning) => {
          const pos2 = getErrorPos(source2);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos2, code3, message3));
          else
            this.errors.push(new errors.YAMLParseError(pos2, code3, message3));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment2) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment2;
          } else if (identity36.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity36.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token2 of tokens)
          yield* this.next(token2);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token2) {
        if (process.env.LOG_STREAM)
          console.dir(token2, { depth: null });
        switch (token2.type) {
          case "directive":
            this.directives.add(token2.source, (offset, message3, warning) => {
              const pos2 = getErrorPos(token2);
              pos2[0] += offset;
              this.onError(pos2, "BAD_DIRECTIVE", message3, warning);
            });
            this.prelude.push(token2.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token2, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token2.source);
            break;
          case "error": {
            const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
            const error5 = new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error5);
            else
              this.doc.errors.push(error5);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end4 = resolveEnd.resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end4.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end4.comment}` : end4.comment;
            }
            this.doc.range[2] = end4.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document3.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token2, strict2 = true, onError) {
      if (token2) {
        const _onError = (pos2, code3, message3) => {
          const offset = typeof pos2 === "number" ? pos2 : Array.isArray(pos2) ? pos2[0] : pos2.offset;
          if (onError)
            onError(offset, code3, message3);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code3, message3);
        };
        switch (token2.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token2, strict2, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict: strict2 } }, token2, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value4, context) {
      const { implicitKey = false, indent: indent3, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source2 = stringifyString.stringifyString({ type, value: value4 }, {
        implicitKey,
        indent: indent3 > 0 ? " ".repeat(indent3) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end4 = context.end ?? [
        { type: "newline", offset: -1, indent: indent3, source: "\n" }
      ];
      switch (source2[0]) {
        case "|":
        case ">": {
          const he = source2.indexOf("\n");
          const head6 = source2.substring(0, he);
          const body = source2.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent3, source: head6 }
          ];
          if (!addEndtoBlockProps(props, end4))
            props.push({ type: "newline", offset: -1, indent: indent3, source: "\n" });
          return { type: "block-scalar", offset, indent: indent3, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent3, source: source2, end: end4 };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent3, source: source2, end: end4 };
        default:
          return { type: "scalar", offset, indent: indent3, source: source2, end: end4 };
      }
    }
    function setScalarValue(token2, value4, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent3 = "indent" in token2 ? token2.indent : null;
      if (afterKey && typeof indent3 === "number")
        indent3 += 2;
      if (!type)
        switch (token2.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token2.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source2 = stringifyString.stringifyString({ type, value: value4 }, {
        implicitKey: implicitKey || indent3 === null,
        indent: indent3 !== null && indent3 > 0 ? " ".repeat(indent3) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source2[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token2, source2);
          break;
        case '"':
          setFlowScalarValue(token2, source2, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token2, source2, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token2, source2, "scalar");
      }
    }
    function setBlockScalarValue(token2, source2) {
      const he = source2.indexOf("\n");
      const head6 = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      if (token2.type === "block-scalar") {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head6;
        token2.source = body;
      } else {
        const { offset } = token2;
        const indent3 = "indent" in token2 ? token2.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent3, source: head6 }
        ];
        if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent3, source: "\n" });
        for (const key of Object.keys(token2))
          if (key !== "type" && key !== "offset")
            delete token2[key];
        Object.assign(token2, { type: "block-scalar", indent: indent3, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end4) {
      if (end4)
        for (const st of end4)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token2, source2, type) {
      switch (token2.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token2.type = type;
          token2.source = source2;
          break;
        case "block-scalar": {
          const end4 = token2.props.slice(1);
          let oa = source2.length;
          if (token2.props[0].type === "block-scalar-header")
            oa -= token2.props[0].source.length;
          for (const tok of end4)
            tok.offset += oa;
          delete token2.props;
          Object.assign(token2, { type, source: source2, end: end4 });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token2.offset + source2.length;
          const nl = { type: "newline", offset, indent: token2.indent, source: "\n" };
          delete token2.items;
          Object.assign(token2, { type, source: source2, end: [nl] });
          break;
        }
        default: {
          const indent3 = "indent" in token2 ? token2.indent : -1;
          const end4 = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token2))
            if (key !== "type" && key !== "offset")
              delete token2[key];
          Object.assign(token2, { type, indent: indent3, source: source2, end: end4 });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify3 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token2) {
      switch (token2.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token2.props)
            res += stringifyToken(tok);
          return res + token2.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token2.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token2.start.source;
          for (const item of token2.items)
            res += stringifyItem(item);
          for (const st of token2.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token2);
          if (token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token2.source;
          if ("end" in token2 && token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep3, value: value4 }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep3)
        for (const st of sep3)
          res += st.source;
      if (value4)
        res += stringifyToken(value4);
      return res;
    }
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP2 = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP2;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path14) => {
      let item = cst;
      for (const [field, index5] of path14) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index5];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path14) => {
      const parent = visit.itemAtPath(cst, path14.slice(0, -1));
      const field = path14[path14.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path14, item, visitor) {
      let ctrl = visitor(item, path14);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token2 = item[field];
        if (token2 && "items" in token2) {
          for (let i = 0; i < token2.items.length; ++i) {
            const ci = _visit(Object.freeze(path14.concat([[field, i]])), token2.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token2.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path14);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path14) : ctrl;
    }
    exports.visit = visit;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token2) => !!token2 && "items" in token2;
    var isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
    function prettyToken(token2) {
      switch (token2) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token2);
      }
    }
    function tokenType(source2) {
      switch (source2) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source2[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty8(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source2, incomplete = false) {
        if (source2) {
          if (typeof source2 !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source2 : source2;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next2 = this.next ?? "stream";
        while (next2 && (incomplete || this.hasChars(1)))
          next2 = yield* this.parseNext(next2);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent3 = 0;
          while (ch === " ")
            ch = this.buffer[++indent3 + offset];
          if (ch === "\r") {
            const next2 = this.buffer[indent3 + offset + 1];
            if (next2 === "\n" || !next2 && !this.atEnd)
              return offset + indent3 + 1;
          }
          return ch === "\n" || indent3 >= this.indentNext || !ch && !this.atEnd ? offset + indent3 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty8(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end4 = this.lineEndPos;
        if (typeof end4 !== "number" || end4 !== -1 && end4 < this.pos) {
          end4 = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end4;
        }
        if (end4 === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end4 - 1] === "\r")
          end4 -= 1;
        return this.buffer.substring(this.pos, end4);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state2) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state2;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next2) {
        switch (next2) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line2 = this.getLine();
        if (line2 === null)
          return this.setNext("stream");
        if (line2[0] === cst.BOM) {
          yield* this.pushCount(1);
          line2 = line2.substring(1);
        }
        if (line2[0] === "%") {
          let dirEnd = line2.length;
          let cs = line2.indexOf("#");
          while (cs !== -1) {
            const ch = line2[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line2.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line2[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line2.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line2.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty8(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty8(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty8(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty8(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line2[n]) {
          case "#":
            yield* this.pushCount(line2.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line2.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent3 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent3 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("flow");
        if (indent3 !== -1 && indent3 < this.indentNext && line2[0] !== "#" || indent3 === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty8(line2[3])) {
          const atFlowEndMarker = indent3 === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line2[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line2[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line2.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next2 = this.charAt(1);
            if (this.flowKey || isEmpty8(next2) || next2 === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end4 = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end4 !== -1 && this.buffer[end4 + 1] === "'")
            end4 = this.buffer.indexOf("'", end4 + 2);
        } else {
          while (end4 !== -1) {
            let n = 0;
            while (this.buffer[end4 - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end4 = this.buffer.indexOf('"', end4 + 1);
          }
        }
        const qb = this.buffer.substring(0, end4);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end4 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end4 === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end4 = this.buffer.length;
        }
        yield* this.pushToIndex(end4 + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty8(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent3 = 0;
        let ch;
        loop:
          for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
            switch (ch) {
              case " ":
                indent3 += 1;
                break;
              case "\n":
                nl = i2;
                indent3 = 0;
                break;
              case "\r": {
                const next2 = this.buffer[i2 + 1];
                if (!next2 && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next2 === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent3 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent3;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent3 > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end4 = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next2 = this.buffer[i + 1];
            if (isEmpty8(next2) || inFlow && flowIndicatorChars.has(next2))
              break;
            end4 = i;
          } else if (isEmpty8(ch)) {
            let next2 = this.buffer[i + 1];
            if (ch === "\r") {
              if (next2 === "\n") {
                i += 1;
                ch = "\n";
                next2 = this.buffer[i + 1];
              } else
                end4 = i;
            }
            if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end4 = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end4 + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty8(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty8(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test2) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test2(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list3, type) {
      for (let i = 0; i < list3.length; ++i)
        if (list3[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list3) {
      for (let i = 0; i < list3.length; ++i) {
        switch (list3[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token2) {
      switch (token2?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        while (--i >= 0) {
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser2 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source2, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source2, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source2) {
        this.source = source2;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source2));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source2.length;
          return;
        }
        const type = cst.tokenType(source2);
        if (!type) {
          const message3 = `Not a YAML token: ${source2}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message3, source: source2 });
          this.offset += source2.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source2.length);
              break;
            case "space":
              if (this.atNewLine && source2[0] === " ")
                this.indent += source2.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source2.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source2.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top4 = this.peek(1);
        if (this.type === "doc-end" && (!top4 || top4.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top4)
          return yield* this.stream();
        switch (top4.type) {
          case "document":
            return yield* this.document(top4);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top4);
          case "block-scalar":
            return yield* this.blockScalar(top4);
          case "block-map":
            return yield* this.blockMap(top4);
          case "block-seq":
            return yield* this.blockSequence(top4);
          case "flow-collection":
            return yield* this.flowCollection(top4);
          case "doc-end":
            return yield* this.documentEnd(top4);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error5) {
        const token2 = error5 ?? this.stack.pop();
        if (!token2) {
          const message3 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message3 };
        } else if (this.stack.length === 0) {
          yield token2;
        } else {
          const top4 = this.peek(1);
          if (token2.type === "block-scalar") {
            token2.indent = "indent" in top4 ? top4.indent : 0;
          } else if (token2.type === "flow-collection" && top4.type === "document") {
            token2.indent = 0;
          }
          if (token2.type === "flow-collection")
            fixFlowSeqItems(token2);
          switch (top4.type) {
            case "document":
              top4.value = token2;
              break;
            case "block-scalar":
              top4.props.push(token2);
              break;
            case "block-map": {
              const it = top4.items[top4.items.length - 1];
              if (it.value) {
                top4.items.push({ start: [], key: token2, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token2;
              } else {
                Object.assign(it, { key: token2, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top4.items[top4.items.length - 1];
              if (it.value)
                top4.items.push({ start: [], value: token2 });
              else
                it.value = token2;
              break;
            }
            case "flow-collection": {
              const it = top4.items[top4.items.length - 1];
              if (!it || it.value)
                top4.items.push({ start: [], key: token2, sep: [] });
              else if (it.sep)
                it.value = token2;
              else
                Object.assign(it, { key: token2, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token2);
          }
          if ((top4.type === "document" || top4.type === "block-map" || top4.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
            const last4 = token2.items[token2.items.length - 1];
            if (last4 && !last4.sep && !last4.value && last4.start.length > 0 && findNonEmptyIndex(last4.start) === -1 && (token2.indent === 0 || last4.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
              if (top4.type === "document")
                top4.end = last4.start;
              else
                top4.items.push({ start: last4.start });
              token2.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep3;
          if (scalar.end) {
            sep3 = scalar.end;
            sep3.push(this.sourceToken);
            delete scalar.end;
          } else
            sep3 = [this.sourceToken];
          const map154 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep3 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map154;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map154) {
        const it = map154.items[map154.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end4 = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end4) ? end4[end4.length - 1] : void 0;
              if (last4?.type === "comment")
                end4?.push(this.sourceToken);
              else
                map154.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map154.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map154.indent)) {
                const prev = map154.items[map154.items.length - 2];
                const end4 = prev?.value?.end;
                if (Array.isArray(end4)) {
                  Array.prototype.push.apply(end4, it.start);
                  end4.push(this.sourceToken);
                  map154.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map154.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map154.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map154.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map154.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map154.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map154.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep3 = it.sep;
                  sep3.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep3 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map154.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs16 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map154.items.push({ start, key: fs16, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs16);
              } else {
                Object.assign(it, { key: fs16, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map154);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map154.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end4 = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end4) ? end4[end4.length - 1] : void 0;
              if (last4?.type === "comment")
                end4?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end4 = prev?.value?.end;
                if (Array.isArray(end4)) {
                  Array.prototype.push.apply(end4, it.start);
                  end4.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top4;
          do {
            yield* this.pop();
            top4 = this.peek(1);
          } while (top4 && top4.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs16 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs16, sep: [] });
              else if (it.sep)
                this.stack.push(fs16);
              else
                Object.assign(it, { key: fs16, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep3 = fc.end.splice(1, fc.end.length);
            sep3.push(this.sourceToken);
            const map154 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep3 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map154;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent3) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent3)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token2) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token2.end)
              token2.end.push(this.sourceToken);
            else
              token2.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser2;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document3 = require_Document();
    var errors = require_errors();
    var log5 = require_log();
    var lineCounter = require_line_counter();
    var parser6 = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser6.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs2 = Array.from(composer$1.compose(parser$1.parse(source2)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs2) {
          doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
        }
      if (docs2.length > 0)
        return docs2;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser6.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source2), true, source2.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
      }
      return doc;
    }
    function parse15(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log5.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify3(value4, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent3 = Math.round(options);
        options = indent3 < 1 ? void 0 : indent3 > 8 ? { indent: 8 } : { indent: indent3 };
      }
      if (value4 === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      return new Document3.Document(value4, _replacer, options).toString(options);
    }
    exports.parse = parse15;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document3 = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity36 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser6 = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document3.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity36.isAlias;
    exports.isCollection = identity36.isCollection;
    exports.isDocument = identity36.isDocument;
    exports.isMap = identity36.isMap;
    exports.isNode = identity36.isNode;
    exports.isPair = identity36.isPair;
    exports.isScalar = identity36.isScalar;
    exports.isSeq = identity36.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser6.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// node_modules/xhr2/lib/xhr2.js
var require_xhr2 = __commonJS({
  "node_modules/xhr2/lib/xhr2.js"(exports, module) {
    (function() {
      var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError2, XMLHttpRequest2, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os4, url2;
      XMLHttpRequestEventTarget = function() {
        class XMLHttpRequestEventTarget2 {
          // @private
          // This is an abstract class and should not be instantiated directly.
          constructor() {
            this.onloadstart = null;
            this.onprogress = null;
            this.onabort = null;
            this.onerror = null;
            this.onload = null;
            this.ontimeout = null;
            this.onloadend = null;
            this._listeners = {};
          }
          // Adds a new-style listener for one of the XHR events.
          // @see http://www.w3.org/TR/XMLHttpRequest/#events
          // @param {String} eventType an XHR event type, such as 'readystatechange'
          // @param {function(ProgressEvent)} listener function that will be called when
          //   the event fires
          // @return {undefined} undefined
          addEventListener(eventType, listener) {
            var base;
            eventType = eventType.toLowerCase();
            (base = this._listeners)[eventType] || (base[eventType] = []);
            this._listeners[eventType].push(listener);
            return void 0;
          }
          // Removes an event listener added by calling addEventListener.
          // @param {String} eventType an XHR event type, such as 'readystatechange'
          // @param {function(ProgressEvent)} listener the value passed in a previous
          //   call to addEventListener.
          // @return {undefined} undefined
          removeEventListener(eventType, listener) {
            var index5;
            eventType = eventType.toLowerCase();
            if (this._listeners[eventType]) {
              index5 = this._listeners[eventType].indexOf(listener);
              if (index5 !== -1) {
                this._listeners[eventType].splice(index5, 1);
              }
            }
            return void 0;
          }
          // Calls all the listeners for an event.
          // @param {ProgressEvent} event the event to be dispatched
          // @return {undefined} undefined
          dispatchEvent(event) {
            var eventType, j, len, listener, listeners;
            event.currentTarget = event.target = this;
            eventType = event.type;
            if (listeners = this._listeners[eventType]) {
              for (j = 0, len = listeners.length; j < len; j++) {
                listener = listeners[j];
                listener.call(this, event);
              }
            }
            if (listener = this[`on${eventType}`]) {
              listener.call(this, event);
            }
            return void 0;
          }
        }
        ;
        XMLHttpRequestEventTarget2.prototype.onloadstart = null;
        XMLHttpRequestEventTarget2.prototype.onprogress = null;
        XMLHttpRequestEventTarget2.prototype.onabort = null;
        XMLHttpRequestEventTarget2.prototype.onerror = null;
        XMLHttpRequestEventTarget2.prototype.onload = null;
        XMLHttpRequestEventTarget2.prototype.ontimeout = null;
        XMLHttpRequestEventTarget2.prototype.onloadend = null;
        return XMLHttpRequestEventTarget2;
      }.call(this);
      http = __require("http");
      https = __require("https");
      os4 = __require("os");
      url2 = __require("url");
      XMLHttpRequest2 = function() {
        class XMLHttpRequest3 extends XMLHttpRequestEventTarget {
          // Creates a new request.
          // @param {Object} options one or more of the options below
          // @option options {Boolean} anon if true, the request's anonymous flag
          //   will be set
          // @see http://www.w3.org/TR/XMLHttpRequest/#constructors
          // @see http://www.w3.org/TR/XMLHttpRequest/#anonymous-flag
          constructor(options) {
            super();
            this.onreadystatechange = null;
            this._anonymous = options && options.anon;
            this.readyState = XMLHttpRequest3.UNSENT;
            this.response = null;
            this.responseText = "";
            this.responseType = "";
            this.responseURL = "";
            this.status = 0;
            this.statusText = "";
            this.timeout = 0;
            this.upload = new XMLHttpRequestUpload(this);
            this._method = null;
            this._url = null;
            this._sync = false;
            this._headers = null;
            this._loweredHeaders = null;
            this._mimeOverride = null;
            this._request = null;
            this._response = null;
            this._responseParts = null;
            this._responseHeaders = null;
            this._aborting = null;
            this._error = null;
            this._loadedBytes = 0;
            this._totalBytes = 0;
            this._lengthComputable = false;
          }
          // Sets the XHR's method, URL, synchronous flag, and authentication params.
          // @param {String} method the HTTP method to be used
          // @param {String} url the URL that the request will be made to
          // @param {?Boolean} async if false, the XHR should be processed
          //   synchronously; true by default
          // @param {?String} user the user credential to be used in HTTP basic
          //   authentication
          // @param {?String} password the password credential to be used in HTTP basic
          //   authentication
          // @return {undefined} undefined
          // @throw {SecurityError} method is not one of the allowed methods
          // @throw {SyntaxError} urlString is not a valid URL
          // @throw {Error} the URL contains an unsupported protocol; the supported
          //   protocols are file, http and https
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method
          open(method, url3, async, user, password) {
            var xhrUrl;
            method = method.toUpperCase();
            if (method in this._restrictedMethods) {
              throw new SecurityError(`HTTP method ${method} is not allowed in XHR`);
            }
            xhrUrl = this._parseUrl(url3);
            if (async === void 0) {
              async = true;
            }
            switch (this.readyState) {
              case XMLHttpRequest3.UNSENT:
              case XMLHttpRequest3.OPENED:
              case XMLHttpRequest3.DONE:
                null;
                break;
              case XMLHttpRequest3.HEADERS_RECEIVED:
              case XMLHttpRequest3.LOADING:
                null;
            }
            this._method = method;
            this._url = xhrUrl;
            this._sync = !async;
            this._headers = {};
            this._loweredHeaders = {};
            this._mimeOverride = null;
            this._setReadyState(XMLHttpRequest3.OPENED);
            this._request = null;
            this._response = null;
            this.status = 0;
            this.statusText = "";
            this._responseParts = [];
            this._responseHeaders = null;
            this._loadedBytes = 0;
            this._totalBytes = 0;
            this._lengthComputable = false;
            return void 0;
          }
          // Appends a header to the list of author request headers.
          // @param {String} name the HTTP header name
          // @param {String} value the HTTP header value
          // @return {undefined} undefined
          // @throw {InvalidStateError} readyState is not OPENED
          // @throw {SyntaxError} name is not a valid HTTP header name or value is not
          //   a valid HTTP header value
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method
          setRequestHeader(name5, value4) {
            var loweredName;
            if (this.readyState !== XMLHttpRequest3.OPENED) {
              throw new InvalidStateError("XHR readyState must be OPENED");
            }
            loweredName = name5.toLowerCase();
            if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
              console.warn(`Refused to set unsafe header "${name5}"`);
              return void 0;
            }
            value4 = value4.toString();
            if (loweredName in this._loweredHeaders) {
              name5 = this._loweredHeaders[loweredName];
              this._headers[name5] = this._headers[name5] + ", " + value4;
            } else {
              this._loweredHeaders[loweredName] = name5;
              this._headers[name5] = value4;
            }
            return void 0;
          }
          // Initiates the request.
          // @param {?String, ?ArrayBufferView} data the data to be sent; ignored for
          //   GET and HEAD requests
          // @return {undefined} undefined
          // @throw {InvalidStateError} readyState is not OPENED
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
          send(data) {
            if (this.readyState !== XMLHttpRequest3.OPENED) {
              throw new InvalidStateError("XHR readyState must be OPENED");
            }
            if (this._request) {
              throw new InvalidStateError("send() already called");
            }
            switch (this._url.protocol) {
              case "file:":
                this._sendFile(data);
                break;
              case "http:":
              case "https:":
                this._sendHttp(data);
                break;
              default:
                throw new NetworkError(`Unsupported protocol ${this._url.protocol}`);
            }
            return void 0;
          }
          // Cancels the network activity performed by this request.
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method
          abort() {
            if (!this._request) {
              return;
            }
            this._request.abort();
            this._setError();
            this._dispatchProgress("abort");
            this._dispatchProgress("loadend");
            return void 0;
          }
          // Returns a header value in the HTTP response for this XHR.
          // @param {String} name case-insensitive HTTP header name
          // @return {?String} value the value of the header whose name matches the
          //   given name, or null if there is no such header
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
          getResponseHeader(name5) {
            var loweredName;
            if (!this._responseHeaders) {
              return null;
            }
            loweredName = name5.toLowerCase();
            if (loweredName in this._responseHeaders) {
              return this._responseHeaders[loweredName];
            } else {
              return null;
            }
          }
          // Returns all the HTTP headers in this XHR's response.
          // @return {String} header lines separated by CR LF, where each header line
          //   has the name and value separated by a ": " (colon, space); the empty
          //   string is returned if the headers are not available
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
          getAllResponseHeaders() {
            var lines8, name5, value4;
            if (!this._responseHeaders) {
              return "";
            }
            lines8 = function() {
              var ref2, results;
              ref2 = this._responseHeaders;
              results = [];
              for (name5 in ref2) {
                value4 = ref2[name5];
                results.push(`${name5}: ${value4}`);
              }
              return results;
            }.call(this);
            return lines8.join("\r\n");
          }
          // Overrides the Content-Type
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-overridemimetype()-method
          overrideMimeType(newMimeType) {
            if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
              throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
            }
            this._mimeOverride = newMimeType.toLowerCase();
            return void 0;
          }
          // Network configuration not exposed in the XHR API.
          // Although the XMLHttpRequest specification calls itself "ECMAScript HTTP",
          // it assumes that requests are always performed in the context of a browser
          // application, where some network parameters are set by the browser user and
          // should not be modified by Web applications. This API provides access to
          // these network parameters.
          // NOTE: this is not in the XMLHttpRequest API, and will not work in
          // browsers.  It is a stable node-xhr2 API.
          // @param {Object} options one or more of the options below
          // @option options {?http.Agent} httpAgent the value for the nodejsHttpAgent
          //   property (the agent used for HTTP requests)
          // @option options {?https.Agent} httpsAgent the value for the
          //   nodejsHttpsAgent property (the agent used for HTTPS requests)
          // @return {undefined} undefined
          nodejsSet(options) {
            var baseUrl, parsedUrl;
            if ("httpAgent" in options) {
              this.nodejsHttpAgent = options.httpAgent;
            }
            if ("httpsAgent" in options) {
              this.nodejsHttpsAgent = options.httpsAgent;
            }
            if ("baseUrl" in options) {
              baseUrl = options.baseUrl;
              if (baseUrl !== null) {
                parsedUrl = url2.parse(baseUrl, false, true);
                if (!parsedUrl.protocol) {
                  throw new SyntaxError2("baseUrl must be an absolute URL");
                }
              }
              this.nodejsBaseUrl = baseUrl;
            }
            return void 0;
          }
          // Default settings for the network configuration not exposed in the XHR API.
          // NOTE: this is not in the XMLHttpRequest API, and will not work in
          // browsers.  It is a stable node-xhr2 API.
          // @param {Object} options one or more of the options below
          // @option options {?http.Agent} httpAgent the default value for the
          //   nodejsHttpAgent property (the agent used for HTTP requests)
          // @option options {https.Agent} httpsAgent the default value for the
          //   nodejsHttpsAgent property (the agent used for HTTPS requests)
          // @return {undefined} undefined
          // @see XMLHttpRequest.nodejsSet
          static nodejsSet(options) {
            XMLHttpRequest3.prototype.nodejsSet(options);
            return void 0;
          }
          // Sets the readyState property and fires the readystatechange event.
          // @private
          // @param {Number} newReadyState the new value of readyState
          // @return {undefined} undefined
          _setReadyState(newReadyState) {
            var event;
            this.readyState = newReadyState;
            event = new ProgressEvent("readystatechange");
            this.dispatchEvent(event);
            return void 0;
          }
          // XMLHttpRequest#send() implementation for the file: protocol.
          // @private
          _sendFile() {
            if (this._url.method !== "GET") {
              throw new NetworkError("The file protocol only supports GET");
            }
            throw new Error("Protocol file: not implemented");
          }
          // XMLHttpRequest#send() implementation for the http: and https: protocols.
          // @private
          // This method sets the instance variables and calls _sendHxxpRequest(), which
          // is responsible for building a node.js request and firing it off. The code
          // in _sendHxxpRequest() is separated off so it can be reused when handling
          // redirects.
          // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method
          _sendHttp(data) {
            if (this._sync) {
              throw new Error("Synchronous XHR processing not implemented");
            }
            if (data != null && (this._method === "GET" || this._method === "HEAD")) {
              console.warn(`Discarding entity body for ${this._method} requests`);
              data = null;
            } else {
              data || (data = "");
            }
            this.upload._setData(data);
            this._finalizeHeaders();
            this._sendHxxpRequest();
            return void 0;
          }
          // Sets up and fires off a HTTP/HTTPS request using the node.js API.
          // @private
          // This method contains the bulk of the XMLHttpRequest#send() implementation,
          // and is also used to issue new HTTP requests when handling HTTP redirects.
          // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method
          _sendHxxpRequest() {
            var agent, hxxp, request3;
            if (this._url.protocol === "http:") {
              hxxp = http;
              agent = this.nodejsHttpAgent;
            } else {
              hxxp = https;
              agent = this.nodejsHttpsAgent;
            }
            request3 = hxxp.request({
              hostname: this._url.hostname,
              port: this._url.port,
              path: this._url.path,
              auth: this._url.auth,
              method: this._method,
              headers: this._headers,
              agent
            });
            this._request = request3;
            if (this.timeout) {
              request3.setTimeout(this.timeout, () => {
                return this._onHttpTimeout(request3);
              });
            }
            request3.on("response", (response) => {
              return this._onHttpResponse(request3, response);
            });
            request3.on("error", (error5) => {
              return this._onHttpRequestError(request3, error5);
            });
            this.upload._startUpload(request3);
            if (this._request === request3) {
              this._dispatchProgress("loadstart");
            }
            return void 0;
          }
          // Fills in the restricted HTTP headers with default values.
          // This is called right before the HTTP request is sent off.
          // @private
          // @return {undefined} undefined
          _finalizeHeaders() {
            var base;
            this._headers["Connection"] = "keep-alive";
            this._headers["Host"] = this._url.host;
            if (this._anonymous) {
              this._headers["Referer"] = "about:blank";
            }
            (base = this._headers)["User-Agent"] || (base["User-Agent"] = this._userAgent);
            this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
            return void 0;
          }
          // Called when the headers of an HTTP response have been received.
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   produced this response
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   passed to
          _onHttpResponse(request3, response) {
            var lengthString;
            if (this._request !== request3) {
              return;
            }
            switch (response.statusCode) {
              case 301:
              case 302:
              case 303:
              case 307:
              case 308:
                this._url = this._parseUrl(response.headers["location"]);
                this._method = "GET";
                if ("content-type" in this._loweredHeaders) {
                  delete this._headers[this._loweredHeaders["content-type"]];
                  delete this._loweredHeaders["content-type"];
                }
                if ("Content-Type" in this._headers) {
                  delete this._headers["Content-Type"];
                }
                delete this._headers["Content-Length"];
                this.upload._reset();
                this._finalizeHeaders();
                this._sendHxxpRequest();
                return;
            }
            this._response = response;
            this._response.on("data", (data) => {
              return this._onHttpResponseData(response, data);
            });
            this._response.on("end", () => {
              return this._onHttpResponseEnd(response);
            });
            this._response.on("close", () => {
              return this._onHttpResponseClose(response);
            });
            this.responseURL = this._url.href.split("#")[0];
            this.status = this._response.statusCode;
            this.statusText = http.STATUS_CODES[this.status];
            this._parseResponseHeaders(response);
            if (lengthString = this._responseHeaders["content-length"]) {
              this._totalBytes = parseInt(lengthString);
              this._lengthComputable = true;
            } else {
              this._lengthComputable = false;
            }
            return this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
          }
          // Called when some data has been received on a HTTP connection.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          // @param {String, Buffer} data the data that has been received
          _onHttpResponseData(response, data) {
            if (this._response !== response) {
              return;
            }
            this._responseParts.push(data);
            this._loadedBytes += data.length;
            if (this.readyState !== XMLHttpRequest3.LOADING) {
              this._setReadyState(XMLHttpRequest3.LOADING);
            }
            return this._dispatchProgress("progress");
          }
          // Called when the HTTP request finished processing.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          _onHttpResponseEnd(response) {
            if (this._response !== response) {
              return;
            }
            this._parseResponse();
            this._request = null;
            this._response = null;
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("load");
            return this._dispatchProgress("loadend");
          }
          // Called when the underlying HTTP connection was closed prematurely.
          // If this method is called, it will be called after or instead of
          // onHttpResponseEnd.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          _onHttpResponseClose(response) {
            var request3;
            if (this._response !== response) {
              return;
            }
            request3 = this._request;
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("error");
            return this._dispatchProgress("loadend");
          }
          // Called when the timeout set on the HTTP socket expires.
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   fired this event
          _onHttpTimeout(request3) {
            if (this._request !== request3) {
              return;
            }
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("timeout");
            return this._dispatchProgress("loadend");
          }
          // Called when something wrong happens on the HTTP socket
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   fired this event
          // @param {Error} error emitted exception
          _onHttpRequestError(request3, error5) {
            if (this._request !== request3) {
              return;
            }
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("error");
            return this._dispatchProgress("loadend");
          }
          // Fires an XHR progress event.
          // @private
          // @param {String} eventType one of the XHR progress event types, such as
          //   'load' and 'progress'
          _dispatchProgress(eventType) {
            var event;
            event = new ProgressEvent(eventType);
            event.lengthComputable = this._lengthComputable;
            event.loaded = this._loadedBytes;
            event.total = this._totalBytes;
            this.dispatchEvent(event);
            return void 0;
          }
          // Sets up the XHR to reflect the fact that an error has occurred.
          // The possible errors are a network error, a timeout, or an abort.
          // @private
          _setError() {
            this._request = null;
            this._response = null;
            this._responseHeaders = null;
            this._responseParts = null;
            return void 0;
          }
          // Parses a request URL string.
          // @private
          // This method is a thin wrapper around url.parse() that normalizes HTTP
          // user/password credentials. It is used to parse the URL string passed to
          // XMLHttpRequest#open() and the URLs in the Location headers of HTTP redirect
          // responses.
          // @param {String} urlString the URL to be parsed
          // @return {Object} parsed URL
          _parseUrl(urlString) {
            var absoluteUrlString, index5, password, user, xhrUrl;
            if (this.nodejsBaseUrl === null) {
              absoluteUrlString = urlString;
            } else {
              absoluteUrlString = url2.resolve(this.nodejsBaseUrl, urlString);
            }
            xhrUrl = url2.parse(absoluteUrlString, false, true);
            xhrUrl.hash = null;
            if (xhrUrl.auth && (typeof user !== "undefined" && user !== null || typeof password !== "undefined" && password !== null)) {
              index5 = xhrUrl.auth.indexOf(":");
              if (index5 === -1) {
                if (!user) {
                  user = xhrUrl.auth;
                }
              } else {
                if (!user) {
                  user = xhrUrl.substring(0, index5);
                }
                if (!password) {
                  password = xhrUrl.substring(index5 + 1);
                }
              }
            }
            if (user || password) {
              xhrUrl.auth = `${user}:${password}`;
            }
            return xhrUrl;
          }
          // Reads the headers from a node.js ClientResponse instance.
          // @private
          // @param {http.ClientResponse} response the response whose headers will be
          //   imported into this XMLHttpRequest's state
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
          _parseResponseHeaders(response) {
            var loweredName, name5, ref2, value4;
            this._responseHeaders = {};
            ref2 = response.headers;
            for (name5 in ref2) {
              value4 = ref2[name5];
              loweredName = name5.toLowerCase();
              if (this._privateHeaders[loweredName]) {
                continue;
              }
              if (this._mimeOverride !== null && loweredName === "content-type") {
                value4 = this._mimeOverride;
              }
              this._responseHeaders[loweredName] = value4;
            }
            if (this._mimeOverride !== null && !("content-type" in this._responseHeaders)) {
              this._responseHeaders["content-type"] = this._mimeOverride;
            }
            return void 0;
          }
          // Sets the response and responseText properties when an XHR completes.
          // @private
          // @return {undefined} undefined
          _parseResponse() {
            var arrayBuffer2, buffer, i, j, jsonError, ref2, view;
            if (Buffer.concat) {
              buffer = Buffer.concat(this._responseParts);
            } else {
              buffer = this._concatBuffers(this._responseParts);
            }
            this._responseParts = null;
            switch (this.responseType) {
              case "text":
                this._parseTextResponse(buffer);
                break;
              case "json":
                this.responseText = null;
                try {
                  this.response = JSON.parse(buffer.toString("utf-8"));
                } catch (error1) {
                  jsonError = error1;
                  this.response = null;
                }
                break;
              case "buffer":
                this.responseText = null;
                this.response = buffer;
                break;
              case "arraybuffer":
                this.responseText = null;
                arrayBuffer2 = new ArrayBuffer(buffer.length);
                view = new Uint8Array(arrayBuffer2);
                for (i = j = 0, ref2 = buffer.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
                  view[i] = buffer[i];
                }
                this.response = arrayBuffer2;
                break;
              default:
                this._parseTextResponse(buffer);
            }
            return void 0;
          }
          // Sets response and responseText for a 'text' response type.
          // @private
          // @param {Buffer} buffer the node.js Buffer containing the binary response
          // @return {undefined} undefined
          _parseTextResponse(buffer) {
            var e;
            try {
              this.responseText = buffer.toString(this._parseResponseEncoding());
            } catch (error1) {
              e = error1;
              this.responseText = buffer.toString("binary");
            }
            this.response = this.responseText;
            return void 0;
          }
          // Figures out the string encoding of the XHR's response.
          // This is called to determine the encoding when responseText is set.
          // @private
          // @return {String} a string encoding, e.g. 'utf-8'
          _parseResponseEncoding() {
            var contentType, encoding, match5;
            encoding = null;
            if (contentType = this._responseHeaders["content-type"]) {
              if (match5 = /\;\s*charset\=(.*)$/.exec(contentType)) {
                return match5[1];
              }
            }
            return "utf-8";
          }
          // Buffer.concat implementation for node 0.6.
          // @private
          // @param {Array<Buffer>} buffers the buffers whose contents will be merged
          // @return {Buffer} same as Buffer.concat(buffers) in node 0.8 and above
          _concatBuffers(buffers) {
            var buffer, j, k, len, len1, length9, target;
            if (buffers.length === 0) {
              return Buffer.alloc(0);
            }
            if (buffers.length === 1) {
              return buffers[0];
            }
            length9 = 0;
            for (j = 0, len = buffers.length; j < len; j++) {
              buffer = buffers[j];
              length9 += buffer.length;
            }
            target = Buffer.alloc(length9);
            length9 = 0;
            for (k = 0, len1 = buffers.length; k < len1; k++) {
              buffer = buffers[k];
              buffer.copy(target, length9);
              length9 += buffer.length;
            }
            return target;
          }
        }
        ;
        XMLHttpRequest3.prototype.onreadystatechange = null;
        XMLHttpRequest3.prototype.readyState = null;
        XMLHttpRequest3.prototype.response = null;
        XMLHttpRequest3.prototype.responseText = null;
        XMLHttpRequest3.prototype.responseType = null;
        XMLHttpRequest3.prototype.status = null;
        XMLHttpRequest3.prototype.timeout = null;
        XMLHttpRequest3.prototype.upload = null;
        XMLHttpRequest3.prototype.UNSENT = 0;
        XMLHttpRequest3.UNSENT = 0;
        XMLHttpRequest3.prototype.OPENED = 1;
        XMLHttpRequest3.OPENED = 1;
        XMLHttpRequest3.prototype.HEADERS_RECEIVED = 2;
        XMLHttpRequest3.HEADERS_RECEIVED = 2;
        XMLHttpRequest3.prototype.LOADING = 3;
        XMLHttpRequest3.LOADING = 3;
        XMLHttpRequest3.prototype.DONE = 4;
        XMLHttpRequest3.DONE = 4;
        XMLHttpRequest3.prototype.nodejsHttpAgent = http.globalAgent;
        XMLHttpRequest3.prototype.nodejsHttpsAgent = https.globalAgent;
        XMLHttpRequest3.prototype.nodejsBaseUrl = null;
        XMLHttpRequest3.prototype._restrictedMethods = {
          CONNECT: true,
          TRACE: true,
          TRACK: true
        };
        XMLHttpRequest3.prototype._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          via: true
        };
        XMLHttpRequest3.prototype._privateHeaders = {
          "set-cookie": true,
          "set-cookie2": true
        };
        XMLHttpRequest3.prototype._userAgent = `Mozilla/5.0 (${os4.type()} ${os4.arch()}) node.js/${process.versions.node} v8/${process.versions.v8}`;
        return XMLHttpRequest3;
      }.call(this);
      module.exports = XMLHttpRequest2;
      XMLHttpRequest2.XMLHttpRequest = XMLHttpRequest2;
      SecurityError = class SecurityError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      XMLHttpRequest2.SecurityError = SecurityError;
      InvalidStateError = class InvalidStateError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      InvalidStateError = class InvalidStateError extends Error {
      };
      XMLHttpRequest2.InvalidStateError = InvalidStateError;
      NetworkError = class NetworkError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      XMLHttpRequest2.SyntaxError = SyntaxError2;
      SyntaxError2 = class SyntaxError extends Error {
        // @private:
        constructor() {
          super();
        }
      };
      ProgressEvent = function() {
        class ProgressEvent2 {
          // Creates a new event.
          // @param {String} type the event type, e.g. 'readystatechange'; must be
          //   lowercased
          constructor(type) {
            this.type = type;
            this.target = null;
            this.currentTarget = null;
            this.lengthComputable = false;
            this.loaded = 0;
            this.total = 0;
          }
        }
        ;
        ProgressEvent2.prototype.bubbles = false;
        ProgressEvent2.prototype.cancelable = false;
        ProgressEvent2.prototype.target = null;
        ProgressEvent2.prototype.loaded = null;
        ProgressEvent2.prototype.lengthComputable = null;
        ProgressEvent2.prototype.total = null;
        return ProgressEvent2;
      }.call(this);
      XMLHttpRequest2.ProgressEvent = ProgressEvent;
      XMLHttpRequestUpload = class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
        // @private
        // @param {XMLHttpRequest} the XMLHttpRequest that this upload object is
        //   associated with
        constructor(request3) {
          super();
          this._request = request3;
          this._reset();
        }
        // Sets up this Upload to handle a new request.
        // @private
        // @return {undefined} undefined
        _reset() {
          this._contentType = null;
          this._body = null;
          return void 0;
        }
        // Implements the upload-related part of the send() XHR specification.
        // @private
        // @param {?String, ?Buffer, ?ArrayBufferView} data the argument passed to
        //   XMLHttpRequest#send()
        // @return {undefined} undefined
        // @see step 4 of http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
        _setData(data) {
          var body, i, j, k, offset, ref2, ref1, view;
          if (typeof data === "undefined" || data === null) {
            return;
          }
          if (typeof data === "string") {
            if (data.length !== 0) {
              this._contentType = "text/plain;charset=UTF-8";
            }
            this._body = Buffer.from(data, "utf8");
          } else if (Buffer.isBuffer(data)) {
            this._body = data;
          } else if (data instanceof ArrayBuffer) {
            body = Buffer.alloc(data.byteLength);
            view = new Uint8Array(data);
            for (i = j = 0, ref2 = data.byteLength; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
              body[i] = view[i];
            }
            this._body = body;
          } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
            body = Buffer.alloc(data.byteLength);
            offset = data.byteOffset;
            view = new Uint8Array(data.buffer);
            for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
              body[i] = view[i + offset];
            }
            this._body = body;
          } else {
            throw new Error(`Unsupported send() data ${data}`);
          }
          return void 0;
        }
        // Updates the HTTP headers right before the request is sent.
        // This is used to set data-dependent headers such as Content-Length and
        // Content-Type.
        // @private
        // @param {Object<String, String>} headers the HTTP headers to be sent
        // @param {Object<String, String>} loweredHeaders maps lowercased HTTP header
        //   names (e.g., 'content-type') to the actual names used in the headers
        //   parameter (e.g., 'Content-Type')
        // @return {undefined} undefined
        _finalizeHeaders(headers, loweredHeaders) {
          if (this._contentType) {
            if (!("content-type" in loweredHeaders)) {
              headers["Content-Type"] = this._contentType;
            }
          }
          if (this._body) {
            headers["Content-Length"] = this._body.length.toString();
          }
          return void 0;
        }
        // Starts sending the HTTP request data.
        // @private
        // @param {http.ClientRequest} request the HTTP request
        // @return {undefined} undefined
        _startUpload(request3) {
          if (this._body) {
            request3.write(this._body);
          }
          request3.end();
          return void 0;
        }
      };
      XMLHttpRequest2.XMLHttpRequestUpload = XMLHttpRequestUpload;
    }).call(exports);
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve3(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module) {
    var constants4 = __require("constants");
    var origCwd = process.cwd;
    var cwd3 = null;
    var platform9 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd3)
        cwd3 = origCwd.call(process);
      return cwd3;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir2 = process.chdir;
      process.chdir = function(d) {
        cwd3 = null;
        chdir2.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir2);
    }
    var chdir2;
    module.exports = patch3;
    function patch3(fs16) {
      if (constants4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs16);
      }
      if (!fs16.lutimes) {
        patchLutimes(fs16);
      }
      fs16.chown = chownFix(fs16.chown);
      fs16.fchown = chownFix(fs16.fchown);
      fs16.lchown = chownFix(fs16.lchown);
      fs16.chmod = chmodFix(fs16.chmod);
      fs16.fchmod = chmodFix(fs16.fchmod);
      fs16.lchmod = chmodFix(fs16.lchmod);
      fs16.chownSync = chownFixSync(fs16.chownSync);
      fs16.fchownSync = chownFixSync(fs16.fchownSync);
      fs16.lchownSync = chownFixSync(fs16.lchownSync);
      fs16.chmodSync = chmodFixSync(fs16.chmodSync);
      fs16.fchmodSync = chmodFixSync(fs16.fchmodSync);
      fs16.lchmodSync = chmodFixSync(fs16.lchmodSync);
      fs16.stat = statFix(fs16.stat);
      fs16.fstat = statFix(fs16.fstat);
      fs16.lstat = statFix(fs16.lstat);
      fs16.statSync = statFixSync(fs16.statSync);
      fs16.fstatSync = statFixSync(fs16.fstatSync);
      fs16.lstatSync = statFixSync(fs16.lstatSync);
      if (fs16.chmod && !fs16.lchmod) {
        fs16.lchmod = function(path14, mode2, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs16.lchmodSync = function() {
        };
      }
      if (fs16.chown && !fs16.lchown) {
        fs16.lchown = function(path14, uid2, gid2, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs16.lchownSync = function() {
        };
      }
      if (platform9 === "win32") {
        fs16.rename = typeof fs16.rename !== "function" ? fs16.rename : function(fs$rename) {
          function rename3(from4, to2, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from4, to2, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs16.stat(to2, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from4, to2, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename3, fs$rename);
          return rename3;
        }(fs16.rename);
      }
      fs16.read = typeof fs16.read !== "function" ? fs16.read : function(fs$read) {
        function read7(fd, buffer, offset, length9, position2, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs16, fd, buffer, offset, length9, position2, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs16, fd, buffer, offset, length9, position2, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read7, fs$read);
        return read7;
      }(fs16.read);
      fs16.readSync = typeof fs16.readSync !== "function" ? fs16.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length9, position2) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs16, fd, buffer, offset, length9, position2);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs16.readSync);
      function patchLchmod(fs17) {
        fs17.lchmod = function(path14, mode2, callback) {
          fs17.open(
            path14,
            constants4.O_WRONLY | constants4.O_SYMLINK,
            mode2,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs17.fchmod(fd, mode2, function(err2) {
                fs17.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs17.lchmodSync = function(path14, mode2) {
          var fd = fs17.openSync(path14, constants4.O_WRONLY | constants4.O_SYMLINK, mode2);
          var threw = true;
          var ret;
          try {
            ret = fs17.fchmodSync(fd, mode2);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs17.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs17.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs17) {
        if (constants4.hasOwnProperty("O_SYMLINK") && fs17.futimes) {
          fs17.lutimes = function(path14, at, mt, cb) {
            fs17.open(path14, constants4.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs17.futimes(fd, at, mt, function(er2) {
                fs17.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs17.lutimesSync = function(path14, at, mt) {
            var fd = fs17.openSync(path14, constants4.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs17.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs17.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs17.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs17.futimes) {
          fs17.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs17.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode2, cb) {
          return orig.call(fs16, target, mode2, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode2) {
          try {
            return orig.call(fs16, target, mode2);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid2, gid2, cb) {
          return orig.call(fs16, target, uid2, gid2, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid2, gid2) {
          try {
            return orig.call(fs16, target, uid2, gid2);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs16, target, options, callback) : orig.call(fs16, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs16, target, options) : orig.call(fs16, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    var Stream2 = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs16) {
      return {
        ReadStream: ReadStream2,
        WriteStream: WriteStream2
      };
      function ReadStream2(path14, options) {
        if (!(this instanceof ReadStream2))
          return new ReadStream2(path14, options);
        Stream2.call(this);
        var self2 = this;
        this.path = path14;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys4 = Object.keys(options);
        for (var index5 = 0, length9 = keys4.length; index5 < length9; index5++) {
          var key = keys4[index5];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs16.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream2(path14, options) {
        if (!(this instanceof WriteStream2))
          return new WriteStream2(path14, options);
        Stream2.call(this);
        this.path = path14;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys4 = Object.keys(options);
        for (var index5 = 0, length9 = keys4.length; index5 < length9; index5++) {
          var key = keys4[index5];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs16.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    var fs16 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug2 = noop2;
    if (util.debuglog)
      debug2 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug2 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs16[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs16, queue);
      fs16.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs16, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs16.close);
      fs16.closeSync = function(fs$closeSync) {
        function closeSync2(fd) {
          fs$closeSync.apply(fs16, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync2, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync2;
      }(fs16.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug2(fs16[gracefulQueue]);
          __require("assert").equal(fs16[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs16[gracefulQueue]);
    }
    module.exports = patch3(clone(fs16));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs16.__patched) {
      module.exports = patch3(fs16);
      fs16.__patched = true;
    }
    function patch3(fs17) {
      polyfills(fs17);
      fs17.gracefulify = patch3;
      fs17.createReadStream = createReadStream;
      fs17.createWriteStream = createWriteStream;
      var fs$readFile = fs17.readFile;
      fs17.readFile = readFile4;
      function readFile4(path14, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path14, options, cb);
        function go$readFile(path15, options2, cb2, startTime) {
          return fs$readFile(path15, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path15, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs17.writeFile;
      fs17.writeFile = writeFile6;
      function writeFile6(path14, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path14, data, options, cb);
        function go$writeFile(path15, data2, options2, cb2, startTime) {
          return fs$writeFile(path15, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path15, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs17.appendFile;
      if (fs$appendFile)
        fs17.appendFile = appendFile3;
      function appendFile3(path14, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path14, data, options, cb);
        function go$appendFile(path15, data2, options2, cb2, startTime) {
          return fs$appendFile(path15, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path15, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs17.copyFile;
      if (fs$copyFile)
        fs17.copyFile = copyFile5;
      function copyFile5(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs17.readdir;
      fs17.readdir = readdir5;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir5(path14, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path15, options2, cb2, startTime) {
          return fs$readdir(path15, fs$readdirCallback(
            path15,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path15, options2, cb2, startTime) {
          return fs$readdir(path15, options2, fs$readdirCallback(
            path15,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path14, options, cb);
        function fs$readdirCallback(path15, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path15, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs17);
        ReadStream2 = legStreams.ReadStream;
        WriteStream2 = legStreams.WriteStream;
      }
      var fs$ReadStream = fs17.ReadStream;
      if (fs$ReadStream) {
        ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream2.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs17.WriteStream;
      if (fs$WriteStream) {
        WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream2.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs17, "ReadStream", {
        get: function() {
          return ReadStream2;
        },
        set: function(val) {
          ReadStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs17, "WriteStream", {
        get: function() {
          return WriteStream2;
        },
        set: function(val) {
          WriteStream2 = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream2;
      Object.defineProperty(fs17, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream2;
      Object.defineProperty(fs17, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream2(path14, options) {
        if (this instanceof ReadStream2)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream2(path14, options) {
        if (this instanceof WriteStream2)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path14, options) {
        return new fs17.ReadStream(path14, options);
      }
      function createWriteStream(path14, options) {
        return new fs17.WriteStream(path14, options);
      }
      var fs$open = fs17.open;
      fs17.open = open3;
      function open3(path14, flags, mode2, cb) {
        if (typeof mode2 === "function")
          cb = mode2, mode2 = null;
        return go$open(path14, flags, mode2, cb);
        function go$open(path15, flags2, mode3, cb2, startTime) {
          return fs$open(path15, flags2, mode3, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path15, flags2, mode3, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs17;
    }
    function enqueue(elem7) {
      debug2("ENQUEUE", elem7[0].name, elem7[1]);
      fs16[gracefulQueue].push(elem7);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now3 = Date.now();
      for (var i = 0; i < fs16[gracefulQueue].length; ++i) {
        if (fs16[gracefulQueue][i].length > 2) {
          fs16[gracefulQueue][i][3] = now3;
          fs16[gracefulQueue][i][4] = now3;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs16[gracefulQueue].length === 0)
        return;
      var elem7 = fs16[gracefulQueue].shift();
      var fn = elem7[0];
      var args = elem7[1];
      var err = elem7[2];
      var startTime = elem7[3];
      var lastTime = elem7[4];
      if (startTime === void 0) {
        debug2("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug2("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs16[gracefulQueue].push(elem7);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs16 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs16[key] === "function";
    });
    Object.assign(exports, fs16);
    api.forEach((method) => {
      exports[method] = u(fs16[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs16.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs16.exists(filename, resolve3);
      });
    };
    exports.read = function(fd, buffer, offset, length9, position2, callback) {
      if (typeof callback === "function") {
        return fs16.read(fd, buffer, offset, length9, position2, callback);
      }
      return new Promise((resolve3, reject) => {
        fs16.read(fd, buffer, offset, length9, position2, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs16.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs16.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs16.readv(fd, buffers, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs16.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs16.writev(fd, buffers, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs16.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs16.realpath.native === "function") {
      exports.realpath.native = u(fs16.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    var path14 = __require("path");
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path14.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error5 = new Error(`Path contains invalid characters: ${pth}`);
          error5.code = "EINVAL";
          throw error5;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults2, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs16.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs16.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs16 = require_fs();
    function pathExists(path14) {
      return fs16.access(path14).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs16.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path14, atime, mtime) {
      const fd = await fs16.open(path14, "r+");
      let closeErr = null;
      try {
        await fs16.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs16.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path14, atime, mtime) {
      const fd = fs16.openSync(path14, "r+");
      fs16.futimesSync(fd, atime, mtime);
      return fs16.closeSync(fd);
    }
    module.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var path14 = __require("path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs16.stat(file, { bigint: true }) : (file) => fs16.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs16.statSync(file, { bigint: true }) : (file) => fs16.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path14.basename(src);
          const destBaseName = path14.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path14.basename(src);
          const destBaseName = path14.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path14.resolve(path14.dirname(src));
      const destParent = path14.resolve(path14.dirname(dest));
      if (destParent === srcParent || destParent === path14.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = await fs16.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path14.resolve(path14.dirname(src));
      const destParent = path14.resolve(path14.dirname(dest));
      if (destParent === srcParent || destParent === path14.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs16.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path14.resolve(src).split(path14.sep).filter((i) => i);
      const destArr = path14.resolve(dest).split(path14.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var path14 = __require("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat6 = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat6.checkPaths(src, dest, "copy", opts);
      await stat6.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include)
        return;
      const destParent = path14.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter)
        return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs16.stat : fs16.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile5(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs16.unlink(dest);
        return copyFile5(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile5(srcStat, src, dest, opts) {
      await fs16.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs16.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs16.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs16.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs16.mkdir(dest);
      }
      const items = await fs16.readdir(src);
      await Promise.all(items.map(async (item) => {
        const srcItem = path14.join(src, item);
        const destItem = path14.join(dest, item);
        const include = await runFilter(srcItem, destItem, opts);
        if (!include)
          return;
        const { destStat: destStat2 } = await stat6.checkPaths(srcItem, destItem, "copy", opts);
        return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }));
      if (!destStat) {
        await fs16.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs16.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path14.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs16.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs16.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN")
          return fs16.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path14.resolve(process.cwd(), resolvedDest);
      }
      if (stat6.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat6.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs16.unlink(dest);
      return fs16.symlink(resolvedSrc, dest);
    }
    module.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    var fs16 = require_graceful_fs();
    var path14 = __require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat6 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat6.checkPathsSync(src, dest, "copy", opts);
      stat6.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path14.dirname(dest);
      if (!fs16.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync3 = opts.dereference ? fs16.statSync : fs16.lstatSync;
      const srcStat = statSync3(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile5(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs16.unlinkSync(dest);
        return copyFile5(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile5(srcStat, src, dest, opts) {
      fs16.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs16.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs16.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs16.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs16.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path14.join(src, item);
      const destItem = path14.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat6.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs16.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path14.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs16.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs16.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs16.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path14.resolve(process.cwd(), resolvedDest);
        }
        if (stat6.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat6.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs16.unlinkSync(dest);
      return fs16.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var fs16 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path14, callback) {
      fs16.rm(path14, { recursive: true, force: true }, callback);
    }
    function removeSync(path14) {
      fs16.rmSync(path14, { recursive: true, force: true });
    }
    module.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs16 = require_fs();
    var path14 = __require("path");
    var mkdir7 = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs16.readdir(dir);
      } catch {
        return mkdir7.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path14.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs16.readdirSync(dir);
      } catch {
        return mkdir7.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path14.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path14 = __require("path");
    var fs16 = require_fs();
    var mkdir7 = require_mkdirs();
    async function createFile2(file) {
      let stats;
      try {
        stats = await fs16.stat(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path14.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs16.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir7.mkdirs(dir);
          await fs16.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs16.writeFile(file, "");
      } else {
        await fs16.readdir(dir);
      }
    }
    function createFileSync2(file) {
      let stats;
      try {
        stats = fs16.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path14.dirname(file);
      try {
        if (!fs16.statSync(dir).isDirectory()) {
          fs16.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir7.mkdirsSync(dir);
        else
          throw err;
      }
      fs16.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile2),
      createFileSync: createFileSync2
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path14 = __require("path");
    var fs16 = require_fs();
    var mkdir7 = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs16.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs16.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
      const dir = path14.dirname(dstpath);
      const dirExists = await pathExists(dir);
      if (!dirExists) {
        await mkdir7.mkdirs(dir);
      }
      await fs16.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs16.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs16.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path14.dirname(dstpath);
      const dirExists = fs16.existsSync(dir);
      if (dirExists)
        return fs16.linkSync(srcpath, dstpath);
      mkdir7.mkdirsSync(dir);
      return fs16.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path14 = __require("path");
    var fs16 = require_fs();
    var { pathExists } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path14.isAbsolute(srcpath)) {
        try {
          await fs16.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path14.dirname(dstpath);
      const relativeToDst = path14.join(dstdir, srcpath);
      const exists13 = await pathExists(relativeToDst);
      if (exists13) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs16.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path14.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path14.isAbsolute(srcpath)) {
        const exists14 = fs16.existsSync(srcpath);
        if (!exists14)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path14.dirname(dstpath);
      const relativeToDst = path14.join(dstdir, srcpath);
      const exists13 = fs16.existsSync(relativeToDst);
      if (exists13) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs16.existsSync(srcpath);
      if (!srcExists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path14.relative(dstdir, srcpath)
      };
    }
    module.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = await fs16.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = fs16.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path14 = __require("path");
    var fs16 = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs16.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs16.stat(srcpath),
          fs16.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = await symlinkPaths(srcpath, dstpath);
      srcpath = relative2.toDst;
      const toType = await symlinkType(relative2.toCwd, type);
      const dir = path14.dirname(dstpath);
      if (!await pathExists(dir)) {
        await mkdirs(dir);
      }
      return fs16.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs16.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs16.statSync(srcpath);
        const dstStat = fs16.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative2.toDst;
      type = symlinkTypeSync(relative2.toCwd, type);
      const dir = path14.dirname(dstpath);
      const exists13 = fs16.existsSync(dir);
      if (exists13)
        return fs16.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs16.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var { createFile: createFile2, createFileSync: createFileSync2 } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile: createFile2,
      createFileSync: createFileSync2,
      ensureFile: createFile2,
      ensureFileSync: createFileSync2,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports, module) {
    function stringify3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces: spaces2 } = {}) {
      const EOF3 = finalEOL ? EOL : "";
      const str2 = JSON.stringify(obj, replacer, spaces2);
      return str2.replace(/\n/g, EOL) + EOF3;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify: stringify3, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports, module) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = __require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify3, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs16 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs16.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile4 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs16 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs16.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs16 = options.fs || _fs;
      const str2 = stringify3(obj, options);
      await universalify.fromCallback(fs16.writeFile)(file, str2, options);
    }
    var writeFile6 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      const fs16 = options.fs || _fs;
      const str2 = stringify3(obj, options);
      return fs16.writeFileSync(file, str2, options);
    }
    var jsonfile = {
      readFile: readFile4,
      readFileSync: readFileSync2,
      writeFile: writeFile6,
      writeFileSync: writeFileSync2
    };
    module.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs16 = require_fs();
    var path14 = __require("path");
    var mkdir7 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path14.dirname(file);
      if (!await pathExists(dir)) {
        await mkdir7.mkdirs(dir);
      }
      return fs16.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path14.dirname(file);
      if (!fs16.existsSync(dir)) {
        mkdir7.mkdirsSync(dir);
      }
      fs16.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var { stringify: stringify3 } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str2 = stringify3(data, options);
      await outputFile(file, str2, options);
    }
    module.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var { stringify: stringify3 } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str2 = stringify3(data, options);
      outputFileSync(file, str2, options);
    }
    module.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    var fs16 = require_fs();
    var path14 = __require("path");
    var { copy } = require_copy2();
    var { remove } = require_remove();
    var { mkdirp: mkdirp7 } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var stat6 = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat6.checkPaths(src, dest, "move", opts);
      await stat6.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path14.dirname(dest);
      const parsedParentPath = path14.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp7(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs16.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    var fs16 = require_graceful_fs();
    var path14 = __require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync2 = require_mkdirs().mkdirpSync;
    var stat6 = require_stat();
    function moveSync4(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat6.checkPathsSync(src, dest, "move", opts);
      stat6.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync2(path14.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path14.dirname(dest);
      const parsedPath = path14.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename3(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename3(src, dest, overwrite);
      }
      if (fs16.existsSync(dest))
        throw new Error("dest already exists.");
      return rename3(src, dest, overwrite);
    }
    function rename3(src, dest, overwrite) {
      try {
        fs16.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync4;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min8, max8, step3 = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min8) || !exports.isInteger(max8))
        return false;
      return (Number(max8) - Number(min8)) / Number(step3) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      const node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          const ele = arr[i];
          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }
          if (ele !== void 0) {
            result.push(ele);
          }
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    module.exports = (ast, options = {}) => {
      const stringify3 = (node, parent = {}) => {
        const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output8 = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output8 += stringify3(child);
          }
        }
        return output8;
      };
      return stringify3(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min8, max8, options) => {
      if (isNumber(min8) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max8 === void 0 || min8 === max8) {
        return String(min8);
      }
      if (isNumber(max8) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap8 = String(opts.wrap);
      let cacheKey = min8 + ":" + max8 + "=" + relax + shorthand + capture + wrap8;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min8, max8);
      let b = Math.max(min8, max8);
      if (Math.abs(a - b) === 1) {
        let result = min8 + "|" + max8;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min8) || hasPadding(max8);
      let state2 = { min: min8, max: max8, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state2.isPadded = isPadded;
        state2.maxLen = String(state2.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state2, opts);
        a = state2.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state2, opts);
      }
      state2.negatives = negatives;
      state2.positives = positives;
      state2.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state2.result = `(${state2.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state2.result = `(?:${state2.result})`;
      }
      toRegexRange.cache[cacheKey] = state2;
      return state2.result;
    };
    function collatePatterns(neg, pos2, options) {
      let onlyNegative = filterPatterns(neg, pos2, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos2, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos2, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min8, max8) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min8, nines);
      let stops = /* @__PURE__ */ new Set([max8]);
      while (min8 <= stop && stop <= max8) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min8, nines);
      }
      stop = countZeros(max8 + 1, zeros) - 1;
      while (min8 < stop && stop <= max8) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max8 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare21);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip2(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min8, max8, tok, options) {
      let ranges = splitToRanges(min8, max8);
      let tokens = [];
      let start = min8;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max9 = ranges[i];
        let obj = rangeToPattern(String(start), String(max9), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max9 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max9, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max9 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix4, intersection6, options) {
      let result = [];
      for (let ele of arr) {
        let { string: string8 } = ele;
        if (!intersection6 && !contains2(comparison, "string", string8)) {
          result.push(prefix4 + string8);
        }
        if (intersection6 && contains2(comparison, "string", string8)) {
          result.push(prefix4 + string8);
        }
      }
      return result;
    }
    function zip2(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare21(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min8, len) {
      return Number(String(min8).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros(value4, tok, options) {
      if (!tok.isPadded) {
        return value4;
      }
      let diff6 = Math.abs(tok.maxLen - String(value4).length);
      let relax = options.relaxZeros !== false;
      switch (diff6) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff6}}` : `0{${diff6}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber4) => {
      return (value4) => toNumber4 === true ? Number(value4) : String(value4);
    };
    var isValidValue = (value4) => {
      return typeof value4 === "number" || typeof value4 === "string" && value4 !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value4 = `${input}`;
      let index5 = -1;
      if (value4[0] === "-")
        value4 = value4.slice(1);
      if (value4 === "0")
        return false;
      while (value4[++index5] === "0")
        ;
      return index5 > 0;
    };
    var stringify3 = (start, end4, options) => {
      if (typeof start === "string" || typeof end4 === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber4) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber4 === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix4 = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix4}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix4}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end4, options) => {
      if (Array.isArray(start)) {
        let wrap8 = options.wrap === true;
        let prefix4 = options.capture ? "" : "?:";
        return wrap8 ? `(${prefix4}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end4, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end4, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end4]);
      return [];
    };
    var invalidStep = (step3, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step3}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end4, step3 = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end4);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end4]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end4);
      let stepString = String(step3);
      step3 = Math.max(Math.abs(step3), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber4 = padded === false && stringify3(start, end4, options) === false;
      let format2 = options.transform || transform(toNumber4);
      if (options.toRegex && step3 === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end4, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push3 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range3 = [];
      let index5 = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step3 > 1) {
          push3(a);
        } else {
          range3.push(pad(format2(a, index5), maxLen, toNumber4));
        }
        a = descending ? a - step3 : a + step3;
        index5++;
      }
      if (options.toRegex === true) {
        return step3 > 1 ? toSequence(parts, options, maxLen) : toRegex(range3, null, { wrap: false, ...options });
      }
      return range3;
    };
    var fillLetters = (start, end4, step3 = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end4) && end4.length > 1) {
        return invalidRange(start, end4, options);
      }
      let format2 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end4}`.charCodeAt(0);
      let descending = a > b;
      let min8 = Math.min(a, b);
      let max8 = Math.max(a, b);
      if (options.toRegex && step3 === 1) {
        return toRange(min8, max8, false, options);
      }
      let range3 = [];
      let index5 = 0;
      while (descending ? a >= b : a <= b) {
        range3.push(format2(a, index5));
        a = descending ? a - step3 : a + step3;
        index5++;
      }
      if (options.toRegex === true) {
        return toRegex(range3, null, { wrap: false, options });
      }
      return range3;
    };
    var fill2 = (start, end4, step3, options = {}) => {
      if (end4 == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end4)) {
        return invalidRange(start, end4, options);
      }
      if (typeof step3 === "function") {
        return fill2(start, end4, 1, { transform: step3 });
      }
      if (isObject(step3)) {
        return fill2(start, end4, 0, step3);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step3 = step3 || opts.step || 1;
      if (!isNumber(step3)) {
        if (step3 != null && !isObject(step3))
          return invalidStep(step3, opts);
        return fill2(start, end4, 1, step3);
      }
      if (isNumber(start) && isNumber(end4)) {
        return fillNumbers(start, end4, step3, opts);
      }
      return fillLetters(start, end4, Math.max(Math.abs(step3), 1), opts);
    };
    module.exports = fill2;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill2 = require_fill_range();
    var utils = require_utils3();
    var compile2 = (ast, options = {}) => {
      const walk2 = (node, parent = {}) => {
        const invalidBlock = utils.isInvalidBrace(parent);
        const invalidNode = node.invalid === true && options.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix4 = options.escapeInvalid === true ? "\\" : "";
        let output8 = "";
        if (node.isOpen === true) {
          return prefix4 + node.value;
        }
        if (node.isClose === true) {
          console.log("node.isClose", prefix4, node.value);
          return prefix4 + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix4 + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix4 + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          const range3 = fill2(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
          if (range3.length !== 0) {
            return args.length > 1 && range3.length > 1 ? `(${range3})` : range3;
          }
        }
        if (node.nodes) {
          for (const child of node.nodes) {
            output8 += walk2(child, node);
          }
        }
        return output8;
      };
      return walk2(ast);
    };
    module.exports = compile2;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill2 = require_fill_range();
    var stringify3 = require_stringify2();
    var utils = require_utils3();
    var append48 = (queue = "", stash = "", enclose2 = false) => {
      const result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose2 ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue) {
        if (Array.isArray(item)) {
          for (const value4 of item) {
            result.push(append48(value4, stash, enclose2));
          }
        } else {
          for (let ele of stash) {
            if (enclose2 === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append48(item, ele, enclose2) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand2 = (ast, options = {}) => {
      const rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      const walk2 = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append48(q.pop(), stringify3(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append48(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          const args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range3 = fill2(...args, options);
          if (range3.length === 0) {
            range3 = stringify3(node, options);
          }
          q.push(append48(q.pop(), range3));
          node.nodes = [];
          return;
        }
        const enclose2 = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          const child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append48(q.pop(), queue, enclose2));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append48(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk2(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk2(ast));
    };
    module.exports = expand2;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse15 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options || {};
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max8) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max8})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets2 = 0;
      const length9 = input.length;
      let index5 = 0;
      let depth = 0;
      let value4;
      const advance = () => input[index5++];
      const push3 = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push3({ type: "bos" });
      while (index5 < length9) {
        block = stack[stack.length - 1];
        value4 = advance();
        if (value4 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value4 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value4 === CHAR_BACKSLASH) {
          push3({ type: "text", value: (options.keepEscaping ? value4 : "") + advance() });
          continue;
        }
        if (value4 === CHAR_RIGHT_SQUARE_BRACKET) {
          push3({ type: "text", value: "\\" + value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets2++;
          let next2;
          while (index5 < length9 && (next2 = advance())) {
            value4 += next2;
            if (next2 === CHAR_LEFT_SQUARE_BRACKET) {
              brackets2++;
              continue;
            }
            if (next2 === CHAR_BACKSLASH) {
              value4 += advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets2--;
              if (brackets2 === 0) {
                break;
              }
            }
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_PARENTHESES) {
          block = push3({ type: "paren", nodes: [] });
          stack.push(block);
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push3({ type: "text", value: value4 });
            continue;
          }
          block = stack.pop();
          push3({ type: "text", value: value4 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value4 === CHAR_DOUBLE_QUOTE || value4 === CHAR_SINGLE_QUOTE || value4 === CHAR_BACKTICK) {
          const open3 = value4;
          let next2;
          if (options.keepQuotes !== true) {
            value4 = "";
          }
          while (index5 < length9 && (next2 = advance())) {
            if (next2 === CHAR_BACKSLASH) {
              value4 += next2 + advance();
              continue;
            }
            if (next2 === open3) {
              if (options.keepQuotes === true)
                value4 += next2;
              break;
            }
            value4 += next2;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push3(brace);
          stack.push(block);
          push3({ type: "open", value: value4 });
          continue;
        }
        if (value4 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push3({ type: "text", value: value4 });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push3({ type, value: value4 });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value4 === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open3 = block.nodes.shift();
            block.nodes = [open3, { type: "text", value: stringify3(block) }];
          }
          push3({ type: "comma", value: value4 });
          block.commas++;
          continue;
        }
        if (value4 === CHAR_DOT && depth > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push3({ type: "text", value: value4 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value4;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value4;
            prev = before;
            block.ranges--;
            continue;
          }
          push3({ type: "dot", value: value4 });
          continue;
        }
        push3({ type: "text", value: value4 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index6 = parent.nodes.indexOf(block);
          parent.nodes.splice(index6, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push3({ type: "eos" });
      return ast;
    };
    module.exports = parse15;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify2();
    var compile2 = require_compile();
    var expand2 = require_expand();
    var parse15 = require_parse2();
    var braces2 = (input, options = {}) => {
      let output8 = [];
      if (Array.isArray(input)) {
        for (const pattern of input) {
          const result = braces2.create(pattern, options);
          if (Array.isArray(result)) {
            output8.push(...result);
          } else {
            output8.push(result);
          }
        }
      } else {
        output8 = [].concat(braces2.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output8 = [...new Set(output8)];
      }
      return output8;
    };
    braces2.parse = (input, options = {}) => parse15(input, options);
    braces2.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify3(braces2.parse(input, options), options);
      }
      return stringify3(input, options);
    };
    braces2.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      return compile2(input, options);
    };
    braces2.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      let result = expand2(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces2.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces2.compile(input, options) : braces2.expand(input, options);
    };
    module.exports = braces2;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path14 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path14.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win323) {
        return win323 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path14 = __require("path");
    var win323 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
    exports.isRegexChar = (str2) => str2.length === 1 && exports.hasRegexChars(str2);
    exports.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str2) => {
      return str2.replace(REGEX_REMOVE_BACKSLASH, (match5) => {
        return match5 === "\\" ? "" : match5;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win323 === true || path14.sep === "\\";
    };
    exports.escapeLast = (input, char2, lastIdx) => {
      const idx = input.lastIndexOf(char2, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char2, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state2 = {}) => {
      let output8 = input;
      if (output8.startsWith("./")) {
        output8 = output8.slice(2);
        state2.prefix = "./";
      }
      return output8;
    };
    exports.wrapOutput = (input, state2 = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append48 = options.contains ? "" : "$";
      let output8 = `${prepend}(?:${input})${append48}`;
      if (state2.negated === true) {
        output8 = `(?:^(?!${output8}).*$)`;
      }
      return output8;
    };
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/scan.js
var require_scan2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code3) => {
      return code3 === CHAR_FORWARD_SLASH || code3 === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length9 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index5 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code3;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index5 >= length9;
      const peek2 = () => str2.charCodeAt(index5 + 1);
      const advance = () => {
        prev = code3;
        return str2.charCodeAt(++index5);
      };
      while (index5 < length9) {
        code3 = advance();
        let next2;
        if (code3 === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code3 = advance();
          if (code3 === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code3 === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code3 = advance())) {
            if (code3 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code3 === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code3 === CHAR_DOT && (code3 = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code3 === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code3 === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_FORWARD_SLASH) {
          slashes.push(index5);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index5 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index5 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code3 === CHAR_PLUS || code3 === CHAR_AT || code3 === CHAR_ASTERISK || code3 === CHAR_QUESTION_MARK || code3 === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob = token2.isGlob = true;
            isExtglob = token2.isExtglob = true;
            finished = true;
            if (code3 === CHAR_EXCLAMATION_MARK && index5 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code3 = advance())) {
                if (code3 === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code3 = advance();
                  continue;
                }
                if (code3 === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code3 === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token2.isGlobstar = true;
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_QUESTION_MARK) {
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next2 = advance())) {
            if (next2 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code3 === CHAR_EXCLAMATION_MARK && index5 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code3 === CHAR_LEFT_PARENTHESES) {
          isGlob = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code3 = advance())) {
              if (code3 === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code3 = advance();
                continue;
              }
              if (code3 === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str2;
      let prefix4 = "";
      let glob3 = "";
      if (start > 0) {
        prefix4 = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob3 = str2.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob3 = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob3)
          glob3 = utils.removeBackslashes(glob3);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state2 = {
        prefix: prefix4,
        input,
        start,
        base,
        glob: glob3,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state2.maxDepth = 0;
        if (!isPathSeparator(code3)) {
          tokens.push(token2);
        }
        state2.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value4 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix4;
            } else {
              tokens[idx].value = value4;
            }
            depth(tokens[idx]);
            state2.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value4 !== "") {
            parts.push(value4);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value4 = input.slice(prevIndex + 1);
          parts.push(value4);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value4;
            depth(tokens[tokens.length - 1]);
            state2.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state2.slashes = slashes;
        state2.parts = parts;
      }
      return state2;
    };
    module.exports = scan;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants4 = require_constants2();
    var utils = require_utils4();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants4;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value4 = `[${args.join("-")}]`;
      try {
        new RegExp(value4);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value4;
    };
    var syntaxError = (type, char2) => {
      return `Missing ${type}: "${char2}" - use "\\\\${char2}" to match literal characters`;
    };
    var parse15 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win323 = utils.isWindows(options);
      const PLATFORM_CHARS = constants4.globChars(win323);
      const EXTGLOB_CHARS = constants4.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star3 = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state2 = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state2);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value4;
      const eos = () => state2.index === len - 1;
      const peek2 = state2.peek = (n = 1) => input[state2.index + n];
      const advance = state2.advance = () => input[++state2.index] || "";
      const remaining = () => input.slice(state2.index + 1);
      const consume2 = (value5 = "", num = 0) => {
        state2.consumed += value5;
        state2.index += num;
      };
      const append48 = (token2) => {
        state2.output += token2.output != null ? token2.output : token2.value;
        consume2(token2.value);
      };
      const negate4 = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state2.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state2.negated = true;
        state2.start++;
        return true;
      };
      const increment = (type) => {
        state2[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state2[type]--;
        stack.pop();
      };
      const push3 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state2.output = state2.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star3;
            state2.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append48(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value5) => {
        const token2 = { ...EXTGLOB_CHARS[value5], conditions: 1, inner: "" };
        token2.prev = prev;
        token2.parens = state2.parens;
        token2.output = state2.output;
        const output8 = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push3({ type, value: value5, output: state2.output ? "" : ONE_CHAR });
        push3({ type: "paren", extglob: true, value: advance(), output: output8 });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output8 = token2.close + (opts.capture ? ")" : "");
        let rest2;
        if (token2.type === "negate") {
          let extglobStar = star3;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
            output8 = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest2 = remaining()) && /^\.[^\\/.]+$/.test(rest2)) {
            const expression = parse15(rest2, { ...options, fastpaths: false }).output;
            output8 = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state2.negatedExtglob = true;
          }
        }
        push3({ type: "paren", extglob: true, value: value4, output: output8 });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output8 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first2, rest2, index5) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            if (index5 === 0) {
              return qmarkNoDot + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            return QMARK.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest2 ? star3 : "");
            }
            return star3;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output8 = output8.replace(/\\/g, "");
          } else {
            output8 = output8.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output8 === input && opts.contains === true) {
          state2.output = input;
          return state2;
        }
        state2.output = utils.wrapOutput(output8, state2, options);
        return state2;
      }
      while (!eos()) {
        value4 = advance();
        if (value4 === "\0") {
          continue;
        }
        if (value4 === "\\") {
          const next2 = peek2();
          if (next2 === "/" && opts.bash !== true) {
            continue;
          }
          if (next2 === "." || next2 === ";") {
            continue;
          }
          if (!next2) {
            value4 += "\\";
            push3({ type: "text", value: value4 });
            continue;
          }
          const match5 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match5 && match5[0].length > 2) {
            slashes = match5[0].length;
            state2.index += slashes;
            if (slashes % 2 !== 0) {
              value4 += "\\";
            }
          }
          if (opts.unescape === true) {
            value4 = advance();
          } else {
            value4 += advance();
          }
          if (state2.brackets === 0) {
            push3({ type: "text", value: value4 });
            continue;
          }
        }
        if (state2.brackets > 0 && (value4 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value4 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest3 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest3];
                if (posix2) {
                  prev.value = pre + posix2;
                  state2.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value4 === "[" && peek2() !== ":" || value4 === "-" && peek2() === "]") {
            value4 = `\\${value4}`;
          }
          if (value4 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value4 = `\\${value4}`;
          }
          if (opts.posix === true && value4 === "!" && prev.value === "[") {
            value4 = "^";
          }
          prev.value += value4;
          append48({ value: value4 });
          continue;
        }
        if (state2.quotes === 1 && value4 !== '"') {
          value4 = utils.escapeRegex(value4);
          prev.value += value4;
          append48({ value: value4 });
          continue;
        }
        if (value4 === '"') {
          state2.quotes = state2.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push3({ type: "text", value: value4 });
          }
          continue;
        }
        if (value4 === "(") {
          increment("parens");
          push3({ type: "paren", value: value4 });
          continue;
        }
        if (value4 === ")") {
          if (state2.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state2.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push3({ type: "paren", value: value4, output: state2.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value4 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value4 = `\\${value4}`;
          } else {
            increment("brackets");
          }
          push3({ type: "bracket", value: value4 });
          continue;
        }
        if (value4 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push3({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          if (state2.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push3({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value4 = `/${value4}`;
          }
          prev.value += value4;
          append48({ value: value4 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state2.output = state2.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state2.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state2.output += prev.value;
          continue;
        }
        if (value4 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open3 = {
            type: "brace",
            value: value4,
            output: "(",
            outputIndex: state2.output.length,
            tokensIndex: state2.tokens.length
          };
          braces2.push(open3);
          push3(open3);
          continue;
        }
        if (value4 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push3({ type: "text", value: value4, output: value4 });
            continue;
          }
          let output8 = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range3 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range3.unshift(arr[i].value);
              }
            }
            output8 = expandRange(range3, opts);
            state2.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state2.output.slice(0, brace.outputIndex);
            const toks = state2.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value4 = output8 = "\\}";
            state2.output = out;
            for (const t of toks) {
              state2.output += t.output || t.value;
            }
          }
          push3({ type: "brace", value: value4, output: output8 });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value4 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 === ",") {
          let output8 = value4;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output8 = "|";
          }
          push3({ type: "comma", value: value4, output: output8 });
          continue;
        }
        if (value4 === "/") {
          if (prev.type === "dot" && state2.index === state2.start + 1) {
            state2.start = state2.index + 1;
            state2.consumed = "";
            state2.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push3({ type: "slash", value: value4, output: SLASH_LITERAL });
          continue;
        }
        if (value4 === ".") {
          if (state2.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value4;
            prev.value += value4;
            brace.dots = true;
            continue;
          }
          if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push3({ type: "text", value: value4, output: DOT_LITERAL });
            continue;
          }
          push3({ type: "dot", value: value4, output: DOT_LITERAL });
          continue;
        }
        if (value4 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value4);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next2 = peek2();
            let output8 = value4;
            if (next2 === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next2) || next2 === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output8 = `\\${value4}`;
            }
            push3({ type: "text", value: value4, output: output8 });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push3({ type: "qmark", value: value4, output: QMARK_NO_DOT });
            continue;
          }
          push3({ type: "qmark", value: value4, output: QMARK });
          continue;
        }
        if (value4 === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value4);
              continue;
            }
          }
          if (opts.nonegate !== true && state2.index === 0) {
            negate4();
            continue;
          }
        }
        if (value4 === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value4);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push3({ type: "plus", value: value4, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
            push3({ type: "plus", value: value4 });
            continue;
          }
          push3({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value4 === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push3({ type: "at", extglob: true, value: value4, output: "" });
            continue;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 !== "*") {
          if (value4 === "$" || value4 === "^") {
            value4 = `\\${value4}`;
          }
          const match5 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match5) {
            value4 += match5[0];
            state2.index += match5[0].length;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value4;
          prev.output = star3;
          state2.backtrack = true;
          state2.globstar = true;
          consume2(value4);
          continue;
        }
        let rest2 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest2)) {
          extglobOpen("star", value4);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume2(value4);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest2[0] && rest2[0] !== "/")) {
            push3({ type: "star", value: value4, output: "" });
            continue;
          }
          const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push3({ type: "star", value: value4, output: "" });
            continue;
          }
          while (rest2.slice(0, 3) === "/**") {
            const after = input[state2.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest2 = rest2.slice(3);
            consume2("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = globstar(opts);
            state2.output = prev.output;
            state2.globstar = true;
            consume2(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value4;
            state2.globstar = true;
            state2.output += prior.output + prev.output;
            consume2(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest2[0] === "/") {
            const end4 = rest2[1] !== void 0 ? "|$" : "";
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end4})`;
            prev.value += value4;
            state2.output += prior.output + prev.output;
            state2.globstar = true;
            consume2(value4 + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest2[0] === "/") {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state2.output = prev.output;
            state2.globstar = true;
            consume2(value4 + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          state2.output = state2.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value4;
          state2.output += prev.output;
          state2.globstar = true;
          consume2(value4);
          continue;
        }
        const token2 = { type: "star", value: value4, output: star3 };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push3(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value4;
          push3(token2);
          continue;
        }
        if (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state2.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state2.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state2.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state2.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push3(token2);
      }
      while (state2.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state2.output = utils.escapeLast(state2.output, "[");
        decrement("brackets");
      }
      while (state2.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state2.output = utils.escapeLast(state2.output, "(");
        decrement("parens");
      }
      while (state2.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state2.output = utils.escapeLast(state2.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push3({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state2.backtrack === true) {
        state2.output = "";
        for (const token2 of state2.tokens) {
          state2.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state2.output += token2.suffix;
          }
        }
      }
      return state2;
    };
    parse15.fastpaths = (input, options) => {
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      input = REPLACEMENTS[input] || input;
      const win323 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants4.globChars(win323);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state2 = { negated: false, prefix: "" };
      let star3 = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star3;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create3 = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR}${star3}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
          default: {
            const match5 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match5)
              return;
            const source3 = create3(match5[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL + match5[2];
          }
        }
      };
      const output8 = utils.removePrefix(input, state2);
      let source2 = create3(output8);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL}?`;
      }
      return source2;
    };
    module.exports = parse15;
  }
});

// node_modules/micromatch/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path14 = __require("path");
    var scan = require_scan2();
    var parse15 = require_parse3();
    var utils = require_utils4();
    var constants4 = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob3, options, returnState = false) => {
      if (Array.isArray(glob3)) {
        const fns = glob3.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state3 = isMatch(str2);
            if (state3)
              return state3;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob3) && glob3.tokens && glob3.input;
      if (glob3 === "" || typeof glob3 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = utils.isWindows(options);
      const regex5 = isState ? picomatch2.compileRe(glob3, options) : picomatch2.makeRe(glob3, options, false, true);
      const state2 = regex5.state;
      delete regex5.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match5, output: output8 } = picomatch2.test(input, regex5, options, { glob: glob3, posix: posix2 });
        const result = { glob: glob3, state: state2, regex: regex5, posix: posix2, input, output: output8, match: match5, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state2;
      }
      return matcher;
    };
    picomatch2.test = (input, regex5, options, { glob: glob3, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format2 = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match5 = input === glob3;
      let output8 = match5 && format2 ? format2(input) : input;
      if (match5 === false) {
        output8 = format2 ? format2(input) : input;
        match5 = output8 === glob3;
      }
      if (match5 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match5 = picomatch2.matchBase(input, regex5, options, posix2);
        } else {
          match5 = regex5.exec(output8);
        }
      }
      return { isMatch: Boolean(match5), match: match5, output: output8 };
    };
    picomatch2.matchBase = (input, glob3, options, posix2 = utils.isWindows(options)) => {
      const regex5 = glob3 instanceof RegExp ? glob3 : picomatch2.makeRe(glob3, options);
      return regex5.test(path14.basename(input));
    };
    picomatch2.isMatch = (str2, patterns, options) => picomatch2(patterns, options)(str2);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch2.parse(p, options));
      return parse15(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan(input, options);
    picomatch2.compileRe = (state2, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state2.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append48 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state2.output})${append48}`;
      if (state2 && state2.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex5 = picomatch2.toRegex(source2, options);
      if (returnState === true) {
        regex5.state = state2;
      }
      return regex5;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse15.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse15(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source2, options) => {
      try {
        const opts = options || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants4;
    module.exports = picomatch2;
  }
});

// node_modules/micromatch/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/micromatch/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var braces2 = require_braces();
    var picomatch2 = require_picomatch2();
    var utils = require_utils4();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list3, patterns, options) => {
      patterns = [].concat(patterns);
      list3 = [].concat(list3);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state2) => {
        items.add(state2.output);
        if (options && options.onResult) {
          options.onResult(state2);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch2(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list3) {
          let matched = isMatch(item, true);
          let match5 = negated ? !matched.isMatch : matched.isMatch;
          if (!match5)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch2(pattern, options);
    micromatch.isMatch = (str2, patterns, options) => picomatch2(patterns, options)(str2);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list3, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state2) => {
        if (options.onResult)
          options.onResult(state2);
        items.push(state2.output);
      };
      let matches = new Set(micromatch(list3, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str2, pattern, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str2, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str2) || isEmptyString(pattern)) {
          return false;
        }
        if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str2, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys4 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys4)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list3, patterns, options) => {
      let items = [].concat(list3);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch2(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list3, patterns, options) => {
      let items = [].concat(list3);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch2(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str2, patterns, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      return [].concat(patterns).every((p) => picomatch2(p, options)(str2));
    };
    micromatch.capture = (glob3, input, options) => {
      let posix2 = utils.isWindows(options);
      let regex5 = picomatch2.makeRe(String(glob3), { ...options, capture: true });
      let match5 = regex5.exec(posix2 ? utils.toPosixSlashes(input) : input);
      if (match5) {
        return match5.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch2.makeRe(...args);
    micromatch.scan = (...args) => picomatch2.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str2 of braces2(String(pattern), options)) {
          res.push(picomatch2.parse(str2, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces2(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module.exports = micromatch;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win323) {
        return win323 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
    exports.isRegexChar = (str2) => str2.length === 1 && exports.hasRegexChars(str2);
    exports.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
    exports.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform9 = navigator.platform.toLowerCase();
        return platform9 === "win32" || platform9 === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    exports.removeBackslashes = (str2) => {
      return str2.replace(REGEX_REMOVE_BACKSLASH, (match5) => {
        return match5 === "\\" ? "" : match5;
      });
    };
    exports.escapeLast = (input, char2, lastIdx) => {
      const idx = input.lastIndexOf(char2, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char2, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state2 = {}) => {
      let output8 = input;
      if (output8.startsWith("./")) {
        output8 = output8.slice(2);
        state2.prefix = "./";
      }
      return output8;
    };
    exports.wrapOutput = (input, state2 = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append48 = options.contains ? "" : "$";
      let output8 = `${prepend}(?:${input})${append48}`;
      if (state2.negated === true) {
        output8 = `(?:^(?!${output8}).*$)`;
      }
      return output8;
    };
    exports.basename = (path14, { windows: windows2 } = {}) => {
      const segs = path14.split(windows2 ? /[\\/]/ : "/");
      const last4 = segs[segs.length - 1];
      if (last4 === "") {
        return segs[segs.length - 2];
      }
      return last4;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan3 = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils5();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants3();
    var isPathSeparator = (code3) => {
      return code3 === CHAR_FORWARD_SLASH || code3 === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length9 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index5 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code3;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index5 >= length9;
      const peek2 = () => str2.charCodeAt(index5 + 1);
      const advance = () => {
        prev = code3;
        return str2.charCodeAt(++index5);
      };
      while (index5 < length9) {
        code3 = advance();
        let next2;
        if (code3 === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code3 = advance();
          if (code3 === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code3 === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code3 = advance())) {
            if (code3 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code3 === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code3 === CHAR_DOT && (code3 = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code3 === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code3 === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_FORWARD_SLASH) {
          slashes.push(index5);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index5 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index5 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code3 === CHAR_PLUS || code3 === CHAR_AT || code3 === CHAR_ASTERISK || code3 === CHAR_QUESTION_MARK || code3 === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob = token2.isGlob = true;
            isExtglob = token2.isExtglob = true;
            finished = true;
            if (code3 === CHAR_EXCLAMATION_MARK && index5 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code3 = advance())) {
                if (code3 === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code3 = advance();
                  continue;
                }
                if (code3 === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code3 === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token2.isGlobstar = true;
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_QUESTION_MARK) {
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code3 === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next2 = advance())) {
            if (next2 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code3 === CHAR_EXCLAMATION_MARK && index5 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code3 === CHAR_LEFT_PARENTHESES) {
          isGlob = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code3 = advance())) {
              if (code3 === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code3 = advance();
                continue;
              }
              if (code3 === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str2;
      let prefix4 = "";
      let glob3 = "";
      if (start > 0) {
        prefix4 = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob3 = str2.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob3 = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob3)
          glob3 = utils.removeBackslashes(glob3);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state2 = {
        prefix: prefix4,
        input,
        start,
        base,
        glob: glob3,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state2.maxDepth = 0;
        if (!isPathSeparator(code3)) {
          tokens.push(token2);
        }
        state2.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value4 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix4;
            } else {
              tokens[idx].value = value4;
            }
            depth(tokens[idx]);
            state2.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value4 !== "") {
            parts.push(value4);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value4 = input.slice(prevIndex + 1);
          parts.push(value4);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value4;
            depth(tokens[tokens.length - 1]);
            state2.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state2.slashes = slashes;
        state2.parts = parts;
      }
      return state2;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse4 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants4 = require_constants3();
    var utils = require_utils5();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants4;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value4 = `[${args.join("-")}]`;
      try {
        new RegExp(value4);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value4;
    };
    var syntaxError = (type, char2) => {
      return `Missing ${type}: "${char2}" - use "\\\\${char2}" to match literal characters`;
    };
    var parse15 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants4.globChars(opts.windows);
      const EXTGLOB_CHARS = constants4.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star3 = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state2 = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state2);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value4;
      const eos = () => state2.index === len - 1;
      const peek2 = state2.peek = (n = 1) => input[state2.index + n];
      const advance = state2.advance = () => input[++state2.index] || "";
      const remaining = () => input.slice(state2.index + 1);
      const consume2 = (value5 = "", num = 0) => {
        state2.consumed += value5;
        state2.index += num;
      };
      const append48 = (token2) => {
        state2.output += token2.output != null ? token2.output : token2.value;
        consume2(token2.value);
      };
      const negate4 = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state2.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state2.negated = true;
        state2.start++;
        return true;
      };
      const increment = (type) => {
        state2[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state2[type]--;
        stack.pop();
      };
      const push3 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state2.output = state2.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star3;
            state2.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append48(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value5) => {
        const token2 = { ...EXTGLOB_CHARS[value5], conditions: 1, inner: "" };
        token2.prev = prev;
        token2.parens = state2.parens;
        token2.output = state2.output;
        const output8 = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push3({ type, value: value5, output: state2.output ? "" : ONE_CHAR });
        push3({ type: "paren", extglob: true, value: advance(), output: output8 });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output8 = token2.close + (opts.capture ? ")" : "");
        let rest2;
        if (token2.type === "negate") {
          let extglobStar = star3;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
            output8 = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest2 = remaining()) && /^\.[^\\/.]+$/.test(rest2)) {
            const expression = parse15(rest2, { ...options, fastpaths: false }).output;
            output8 = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state2.negatedExtglob = true;
          }
        }
        push3({ type: "paren", extglob: true, value: value4, output: output8 });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output8 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first2, rest2, index5) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            if (index5 === 0) {
              return qmarkNoDot + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            return QMARK.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest2 ? star3 : "");
            }
            return star3;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output8 = output8.replace(/\\/g, "");
          } else {
            output8 = output8.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output8 === input && opts.contains === true) {
          state2.output = input;
          return state2;
        }
        state2.output = utils.wrapOutput(output8, state2, options);
        return state2;
      }
      while (!eos()) {
        value4 = advance();
        if (value4 === "\0") {
          continue;
        }
        if (value4 === "\\") {
          const next2 = peek2();
          if (next2 === "/" && opts.bash !== true) {
            continue;
          }
          if (next2 === "." || next2 === ";") {
            continue;
          }
          if (!next2) {
            value4 += "\\";
            push3({ type: "text", value: value4 });
            continue;
          }
          const match5 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match5 && match5[0].length > 2) {
            slashes = match5[0].length;
            state2.index += slashes;
            if (slashes % 2 !== 0) {
              value4 += "\\";
            }
          }
          if (opts.unescape === true) {
            value4 = advance();
          } else {
            value4 += advance();
          }
          if (state2.brackets === 0) {
            push3({ type: "text", value: value4 });
            continue;
          }
        }
        if (state2.brackets > 0 && (value4 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value4 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest3 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest3];
                if (posix2) {
                  prev.value = pre + posix2;
                  state2.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value4 === "[" && peek2() !== ":" || value4 === "-" && peek2() === "]") {
            value4 = `\\${value4}`;
          }
          if (value4 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value4 = `\\${value4}`;
          }
          if (opts.posix === true && value4 === "!" && prev.value === "[") {
            value4 = "^";
          }
          prev.value += value4;
          append48({ value: value4 });
          continue;
        }
        if (state2.quotes === 1 && value4 !== '"') {
          value4 = utils.escapeRegex(value4);
          prev.value += value4;
          append48({ value: value4 });
          continue;
        }
        if (value4 === '"') {
          state2.quotes = state2.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push3({ type: "text", value: value4 });
          }
          continue;
        }
        if (value4 === "(") {
          increment("parens");
          push3({ type: "paren", value: value4 });
          continue;
        }
        if (value4 === ")") {
          if (state2.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state2.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push3({ type: "paren", value: value4, output: state2.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value4 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value4 = `\\${value4}`;
          } else {
            increment("brackets");
          }
          push3({ type: "bracket", value: value4 });
          continue;
        }
        if (value4 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push3({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          if (state2.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push3({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value4 = `/${value4}`;
          }
          prev.value += value4;
          append48({ value: value4 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state2.output = state2.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state2.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state2.output += prev.value;
          continue;
        }
        if (value4 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open3 = {
            type: "brace",
            value: value4,
            output: "(",
            outputIndex: state2.output.length,
            tokensIndex: state2.tokens.length
          };
          braces2.push(open3);
          push3(open3);
          continue;
        }
        if (value4 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push3({ type: "text", value: value4, output: value4 });
            continue;
          }
          let output8 = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range3 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range3.unshift(arr[i].value);
              }
            }
            output8 = expandRange(range3, opts);
            state2.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state2.output.slice(0, brace.outputIndex);
            const toks = state2.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value4 = output8 = "\\}";
            state2.output = out;
            for (const t of toks) {
              state2.output += t.output || t.value;
            }
          }
          push3({ type: "brace", value: value4, output: output8 });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value4 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 === ",") {
          let output8 = value4;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output8 = "|";
          }
          push3({ type: "comma", value: value4, output: output8 });
          continue;
        }
        if (value4 === "/") {
          if (prev.type === "dot" && state2.index === state2.start + 1) {
            state2.start = state2.index + 1;
            state2.consumed = "";
            state2.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push3({ type: "slash", value: value4, output: SLASH_LITERAL });
          continue;
        }
        if (value4 === ".") {
          if (state2.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value4;
            prev.value += value4;
            brace.dots = true;
            continue;
          }
          if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push3({ type: "text", value: value4, output: DOT_LITERAL });
            continue;
          }
          push3({ type: "dot", value: value4, output: DOT_LITERAL });
          continue;
        }
        if (value4 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value4);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next2 = peek2();
            let output8 = value4;
            if (prev.value === "(" && !/[!=<:]/.test(next2) || next2 === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output8 = `\\${value4}`;
            }
            push3({ type: "text", value: value4, output: output8 });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push3({ type: "qmark", value: value4, output: QMARK_NO_DOT });
            continue;
          }
          push3({ type: "qmark", value: value4, output: QMARK });
          continue;
        }
        if (value4 === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value4);
              continue;
            }
          }
          if (opts.nonegate !== true && state2.index === 0) {
            negate4();
            continue;
          }
        }
        if (value4 === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value4);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push3({ type: "plus", value: value4, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
            push3({ type: "plus", value: value4 });
            continue;
          }
          push3({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value4 === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push3({ type: "at", extglob: true, value: value4, output: "" });
            continue;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (value4 !== "*") {
          if (value4 === "$" || value4 === "^") {
            value4 = `\\${value4}`;
          }
          const match5 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match5) {
            value4 += match5[0];
            state2.index += match5[0].length;
          }
          push3({ type: "text", value: value4 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value4;
          prev.output = star3;
          state2.backtrack = true;
          state2.globstar = true;
          consume2(value4);
          continue;
        }
        let rest2 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest2)) {
          extglobOpen("star", value4);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume2(value4);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest2[0] && rest2[0] !== "/")) {
            push3({ type: "star", value: value4, output: "" });
            continue;
          }
          const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push3({ type: "star", value: value4, output: "" });
            continue;
          }
          while (rest2.slice(0, 3) === "/**") {
            const after = input[state2.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest2 = rest2.slice(3);
            consume2("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = globstar(opts);
            state2.output = prev.output;
            state2.globstar = true;
            consume2(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value4;
            state2.globstar = true;
            state2.output += prior.output + prev.output;
            consume2(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest2[0] === "/") {
            const end4 = rest2[1] !== void 0 ? "|$" : "";
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end4})`;
            prev.value += value4;
            state2.output += prior.output + prev.output;
            state2.globstar = true;
            consume2(value4 + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest2[0] === "/") {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state2.output = prev.output;
            state2.globstar = true;
            consume2(value4 + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          state2.output = state2.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value4;
          state2.output += prev.output;
          state2.globstar = true;
          consume2(value4);
          continue;
        }
        const token2 = { type: "star", value: value4, output: star3 };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push3(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value4;
          push3(token2);
          continue;
        }
        if (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state2.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state2.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state2.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state2.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push3(token2);
      }
      while (state2.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state2.output = utils.escapeLast(state2.output, "[");
        decrement("brackets");
      }
      while (state2.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state2.output = utils.escapeLast(state2.output, "(");
        decrement("parens");
      }
      while (state2.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state2.output = utils.escapeLast(state2.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push3({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state2.backtrack === true) {
        state2.output = "";
        for (const token2 of state2.tokens) {
          state2.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state2.output += token2.suffix;
          }
        }
      }
      return state2;
    };
    parse15.fastpaths = (input, options) => {
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants4.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state2 = { negated: false, prefix: "" };
      let star3 = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star3;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create3 = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR}${star3}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
          default: {
            const match5 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match5)
              return;
            const source3 = create3(match5[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL + match5[2];
          }
        }
      };
      const output8 = utils.removePrefix(input, state2);
      let source2 = create3(output8);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL}?`;
      }
      return source2;
    };
    module.exports = parse15;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch3 = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var scan = require_scan3();
    var parse15 = require_parse4();
    var utils = require_utils5();
    var constants4 = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob3, options, returnState = false) => {
      if (Array.isArray(glob3)) {
        const fns = glob3.map((input) => picomatch2(input, options, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state3 = isMatch(str2);
            if (state3)
              return state3;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob3) && glob3.tokens && glob3.input;
      if (glob3 === "" || typeof glob3 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = opts.windows;
      const regex5 = isState ? picomatch2.compileRe(glob3, options) : picomatch2.makeRe(glob3, options, false, true);
      const state2 = regex5.state;
      delete regex5.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match5, output: output8 } = picomatch2.test(input, regex5, options, { glob: glob3, posix: posix2 });
        const result = { glob: glob3, state: state2, regex: regex5, posix: posix2, input, output: output8, match: match5, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state2;
      }
      return matcher;
    };
    picomatch2.test = (input, regex5, options, { glob: glob3, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format2 = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match5 = input === glob3;
      let output8 = match5 && format2 ? format2(input) : input;
      if (match5 === false) {
        output8 = format2 ? format2(input) : input;
        match5 = output8 === glob3;
      }
      if (match5 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match5 = picomatch2.matchBase(input, regex5, options, posix2);
        } else {
          match5 = regex5.exec(output8);
        }
      }
      return { isMatch: Boolean(match5), match: match5, output: output8 };
    };
    picomatch2.matchBase = (input, glob3, options) => {
      const regex5 = glob3 instanceof RegExp ? glob3 : picomatch2.makeRe(glob3, options);
      return regex5.test(utils.basename(input));
    };
    picomatch2.isMatch = (str2, patterns, options) => picomatch2(patterns, options)(str2);
    picomatch2.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch2.parse(p, options));
      return parse15(pattern, { ...options, fastpaths: false });
    };
    picomatch2.scan = (input, options) => scan(input, options);
    picomatch2.compileRe = (state2, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state2.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append48 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state2.output})${append48}`;
      if (state2 && state2.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex5 = picomatch2.toRegex(source2, options);
      if (returnState === true) {
        regex5.state = state2;
      }
      return regex5;
    };
    picomatch2.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse15.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse15(input, options);
      }
      return picomatch2.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch2.toRegex = (source2, options) => {
      try {
        const opts = options || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch2.constants = constants4;
    module.exports = picomatch2;
  }
});

// node_modules/picomatch/index.js
var require_picomatch4 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    var pico = require_picomatch3();
    var utils = require_utils5();
    function picomatch2(glob3, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob3, options, returnState);
    }
    Object.assign(picomatch2, pico);
    module.exports = picomatch2;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read7(path14, settings, callback) {
      settings.fs.lstat(path14, (lstatError, lstat5) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat5.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat5);
          return;
        }
        settings.fs.stat(path14, (statError, stat6) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat5);
            return;
          }
          if (settings.markSymbolicLink) {
            stat6.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat6);
        });
      });
    }
    exports.read = read7;
    function callFailureCallback(callback, error5) {
      callback(error5);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read7(path14, settings) {
      const lstat5 = settings.fs.lstatSync(path14);
      if (!lstat5.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat5;
      }
      try {
        const stat6 = settings.fs.statSync(path14);
        if (settings.markSymbolicLink) {
          stat6.isSymbolicLink = () => true;
        }
        return stat6;
      } catch (error5) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat5;
        }
        throw error5;
      }
    }
    exports.read = read7;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs16 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs16.lstat,
      stat: fs16.stat,
      lstatSync: fs16.lstatSync,
      statSync: fs16.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs16 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs16.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync2 = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat6(path14, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path14, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path14, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat6;
    function statSync3(path14, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path14, settings);
    }
    exports.statSync = statSync3;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module) {
    var promise2;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise2 || (promise2 = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports, module) {
    module.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys4;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys4 = Object.keys(tasks);
        results = {};
        pending = keys4.length;
      }
      function done(err) {
        function end4() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end4);
        else
          end4();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys4) {
        keys4.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name5, stats) {
        this.name = name5;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name5, stats) {
      return new DirentFromStats(name5, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs16 = require_fs3();
    exports.fs = fs16;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils6();
    var common = require_common();
    function read7(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir5(directory, settings, callback);
    }
    exports.read = read7;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries3 = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries3);
          return;
        }
        const tasks = entries3.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir5(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name5) => {
          const path14 = common.joinPathSegments(directory, name5, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path14, settings.fsStatSettings, (error5, stats) => {
              if (error5 !== null) {
                done(error5);
                return;
              }
              const entry = {
                name: name5,
                path: path14,
                dirent: utils.fs.createDirentFromStats(name5, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries3) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries3);
        });
      });
    }
    exports.readdir = readdir5;
    function callFailureCallback(callback, error5) {
      callback(error5);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils6();
    var common = require_common();
    function read7(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir5(directory, settings);
    }
    exports.read = read7;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error5) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error5;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir5(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name5) => {
        const entryPath = common.joinPathSegments(directory, name5, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name: name5,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name5, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir5;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs16 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs16.lstat,
      stat: fs16.stat,
      lstatSync: fs16.lstatSync,
      statSync: fs16.statSync,
      readdir: fs16.readdir,
      readdirSync: fs16.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path14 = __require("path");
    var fsStat = require_out();
    var fs16 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs16.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path14.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync2 = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path14, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path14, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path14, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path14, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync2.read(path14, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports, module) {
    "use strict";
    function reusify(Constructor2) {
      var head6 = new Constructor2();
      var tail4 = head6;
      function get6() {
        var current = head6;
        if (current.next) {
          head6 = current.next;
        } else {
          head6 = new Constructor2();
          tail4 = head6;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail4.next = obj;
        tail4 = obj;
      }
      return {
        get: get6,
        release
      };
    }
    module.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports, module) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      if (!(_concurrency >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push: push3,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: false,
        get concurrency() {
          return _concurrency;
        },
        set concurrency(value4) {
          if (!(value4 >= 1)) {
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          }
          _concurrency = value4;
          if (self2.paused)
            return;
          for (; queueHead && _running < _concurrency; ) {
            _running++;
            release();
          }
        },
        running,
        resume: resume2,
        idle,
        length: length9,
        getQueue,
        unshift: unshift2,
        empty: noop2,
        kill: kill3,
        killAndDrain,
        error: error5
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length9() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume2() {
        if (!self2.paused)
          return;
        self2.paused = false;
        if (queueHead === null) {
          _running++;
          release();
          return;
        }
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push3(value4, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value4;
        current.callback = done || noop2;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift2(value4, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value4;
        current.callback = done || noop2;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next2 = queueHead;
        if (next2 && _running <= _concurrency) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next2.next;
            next2.next = null;
            worker.call(context, next2.value, next2.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill3() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop2;
      }
      function error5(handler) {
        errorHandler = handler;
      }
    }
    function noop2() {
    }
    function Task() {
      this.value = null;
      this.callback = noop2;
      this.next = null;
      this.release = noop2;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop2;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, _concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push3;
      queue.unshift = unshift2;
      queue.drained = drained;
      return queue;
      function push3(value4) {
        var p = new Promise(function(resolve3, reject) {
          pushCb(value4, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        p.catch(noop2);
        return p;
      }
      function unshift2(value4) {
        var p = new Promise(function(resolve3, reject) {
          unshiftCb(value4, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        p.catch(noop2);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve3) {
            resolve3();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve3) {
          queue.drain = function() {
            previousDrain();
            resolve3();
          };
        });
        return p;
      }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error5) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error5);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter11, value4) {
      return filter11 === null || filter11(value4);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error5) => {
          if (error5 !== null) {
            this._handleError(error5);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error5, entries3) => {
          if (error5 !== null) {
            done(error5, void 0);
            return;
          }
          for (const entry of entries3) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error5) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error5)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error5);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error5) => {
          callFailureCallback(callback, error5);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error5) {
      callback(error5);
    }
    function callSuccessCallback(callback, entries3) {
      callback(null, entries3);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error5) => {
          this._stream.emit("error", error5);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries3 = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries3) {
            this._handleEntry(entry, base);
          }
        } catch (error5) {
          this._handleError(error5);
        }
      }
      _handleError(error5) {
        if (!common.isFatalError(this._settings, error5)) {
          return;
        }
        throw error5;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path14 = __require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path14.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk2(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk2;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str2) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str2);
      if (b instanceof RegExp)
        b = maybeMatch(b, str2);
      var r = range3(a, b, str2);
      return r && {
        start: r[0],
        end: r[1],
        pre: str2.slice(0, r[0]),
        body: str2.slice(r[0] + a.length, r[1]),
        post: str2.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str2) {
      var m = str2.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range3;
    function range3(a, b, str2) {
      var begs, beg, left3, right2, result;
      var ai = str2.indexOf(a);
      var bi = str2.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left3 = str2.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str2.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left3) {
              left3 = beg;
              right2 = bi;
            }
            bi = str2.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left3, right2];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module) {
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str2) {
      return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
    }
    function escapeBraces(str2) {
      return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str2) {
      return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str2) {
      if (!str2)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str2);
      if (!m)
        return str2.split(",");
      var pre = m.pre;
      var body = m.body;
      var post3 = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post3);
      if (post3.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str2) {
      if (!str2)
        return [];
      if (str2.substr(0, 2) === "{}") {
        str2 = "\\{\\}" + str2.substr(2);
      }
      return expand2(escapeBraces(str2), true).map(unescapeBraces);
    }
    function embrace(str2) {
      return "{" + str2 + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str2, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str2);
      if (!m)
        return [str2];
      var pre = m.pre;
      var post3 = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post3.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post3[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str2 = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str2);
          }
          return [str2];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post3.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width2 = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test2 = lte;
          var reverse4 = y < x;
          if (reverse4) {
            incr *= -1;
            test2 = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test2(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width2 - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post3.length; k++) {
            var expansion = pre + N[j] + post3[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module) {
    module.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module) {
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer5 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer5) {
      if (!Buffer5.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer5[key];
    }
    safer.Buffer.prototype = Buffer5.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value4, encodingOrOffset, length9) {
        if (typeof value4 === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value4);
        }
        if (value4 && typeof value4.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value4);
        }
        return Buffer5(value4, encodingOrOffset, length9);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size8, fill2, encoding) {
        if (typeof size8 !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size8);
        }
        if (size8 < 0 || size8 >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size8 + '" is invalid for option "size"');
        }
        var buf = Buffer5(size8);
        if (!fill2 || fill2.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill2, encoding);
        } else {
          buf.fill(fill2);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader2 = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module) {
    var assert3 = __require("assert");
    var Buffer5 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer5.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek2) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek2)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer5.alloc(0) : "";
      var str2 = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str2 : str2.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values4 = [];
      var value4 = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value4 <<= 7;
        value4 += byte & 127;
        if ((byte & 128) === 0) {
          values4.push(value4);
          value4 = 0;
        }
      }
      value4 = values4.shift();
      values4.unshift(value4 % 40);
      values4.unshift(value4 / 40 >> 0);
      return values4.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert3.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value4 = 0;
      for (var i = 0; i < this.length; i++) {
        value4 <<= 8;
        value4 |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value4 -= 1 << i * 8;
      return value4 >> 0;
    };
    module.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module) {
    var assert3 = __require("assert");
    var Buffer5 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge4(from4, to2) {
      assert3.ok(from4);
      assert3.equal(typeof from4, "object");
      assert3.ok(to2);
      assert3.equal(typeof to2, "object");
      var keys4 = Object.getOwnPropertyNames(from4);
      keys4.forEach(function(key) {
        if (to2[key])
          return;
        var value4 = Object.getOwnPropertyDescriptor(from4, key);
        Object.defineProperty(to2, key, value4);
      });
      return to2;
    }
    function Writer(options) {
      options = merge4(DEFAULT_OPTS, options || {});
      this._buf = Buffer5.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer5.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer5.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert3.ok(start !== void 0);
      assert3.ok(len !== void 0);
      assert3.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert3.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer5.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module) {
    var errors = require_errors2();
    var types2 = require_types();
    var Reader = require_reader2();
    var Writer = require_writer();
    module.exports = {
      Reader,
      Writer
    };
    for (t in types2) {
      if (types2.hasOwnProperty(t))
        module.exports[t] = types2[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module) {
    var Ber = require_ber();
    module.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init4) {
        var i, r = new Float64Array(16);
        if (init4)
          for (i = 0; i < init4.length; i++)
            r[i] = init4[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A2(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A2(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A2(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos2 = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos2;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos2 += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add4(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A2(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A2(g, d, c);
        A2(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add4(q, p);
          add4(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add4(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = __require("crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports, module) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state2 = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state2.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state2.expand0state(sha2salt, 64);
        state2.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state2.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass2, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass2, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/cpu-features/build/Release/cpufeatures.node
var require_cpufeatures = __commonJS({
  "node_modules/cpu-features/build/Release/cpufeatures.node"(exports, module) {
    module.exports = "./cpufeatures-G67VS7TD.node";
  }
});

// node_modules/cpu-features/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/cpu-features/lib/index.js"(exports, module) {
    "use strict";
    var binding = require_cpufeatures();
    module.exports = binding.getCPUInfo;
  }
});

// node_modules/ssh2/lib/protocol/constants.js
var require_constants5 = __commonJS({
  "node_modules/ssh2/lib/protocol/constants.js"(exports, module) {
    "use strict";
    var crypto2 = __require("crypto");
    var cpuInfo;
    try {
      cpuInfo = require_lib3()();
    } catch {
    }
    var { bindingAvailable, CIPHER_INFO, MAC_INFO } = require_crypto();
    var eddsaSupported = (() => {
      if (typeof crypto2.sign === "function" && typeof crypto2.verify === "function") {
        const key = "-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";
        const data = Buffer.from("a");
        let sig;
        let verified;
        try {
          sig = crypto2.sign(null, data, key);
          verified = crypto2.verify(null, data, key, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;
      }
      return false;
    })();
    var curve25519Supported = typeof crypto2.diffieHellman === "function" && typeof crypto2.generateKeyPairSync === "function" && typeof crypto2.createPublicKey === "function";
    var DEFAULT_KEX = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    if (curve25519Supported) {
      DEFAULT_KEX.unshift("curve25519-sha256");
      DEFAULT_KEX.unshift("curve25519-sha256@libssh.org");
    }
    var SUPPORTED_KEX = DEFAULT_KEX.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      // REQUIRED
      "diffie-hellman-group1-sha1"
      // REQUIRED
    ]);
    var DEFAULT_SERVER_HOST_KEY = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      // RFC 8332
      "rsa-sha2-256",
      // RFC 8332
      "ssh-rsa"
    ];
    if (eddsaSupported)
      DEFAULT_SERVER_HOST_KEY.unshift("ssh-ed25519");
    var SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([
      "ssh-dss"
    ]);
    var canUseCipher = (() => {
      const ciphers = crypto2.getCiphers();
      return (name5) => ciphers.includes(CIPHER_INFO[name5].sslName);
    })();
    var DEFAULT_CIPHER = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {
      if (bindingAvailable)
        DEFAULT_CIPHER.unshift("chacha20-poly1305@openssh.com");
      else
        DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    } else if (bindingAvailable && cpuInfo && cpuInfo.arch === "x86") {
      DEFAULT_CIPHER.splice(4, 0, "chacha20-poly1305@openssh.com");
    } else {
      DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    }
    DEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);
    var SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher));
    var canUseMAC = (() => {
      const hashes = crypto2.getHashes();
      return (name5) => hashes.includes(MAC_INFO[name5].sslName);
    })();
    var DEFAULT_MAC = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC);
    var SUPPORTED_MAC = DEFAULT_MAC.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      // first 96 bits of HMAC-SHA256
      "hmac-sha2-512-96",
      // first 96 bits of HMAC-SHA512
      "hmac-ripemd160",
      "hmac-sha1-96",
      // first 96 bits of HMAC-SHA1
      "hmac-md5-96"
      // first 96 bits of HMAC-MD5
    ].filter(canUseMAC));
    var DEFAULT_COMPRESSION = [
      "none",
      "zlib@openssh.com",
      // ZLIB (LZ77) compression, except
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
      // ZLIB (LZ77) compression
    ];
    var SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]);
    var COMPAT = {
      BAD_DHGEX: 1 << 0,
      OLD_EXIT: 1 << 1,
      DYN_RPORT_BUG: 1 << 2,
      BUG_DHGEX_LARGE: 1 << 3,
      IMPLY_RSA_SHA2_SIGALGS: 1 << 4
    };
    module.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // RFC 8308
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
        // Reserved for client protocols (128-191)
        // Local extensions (192-155)
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        // Indicates end of options.
        VINTR: 1,
        // Interrupt character; 255 if none. Similarly for the
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        // The quit character (sends SIGQUIT signal on POSIX
        //  systems).
        VERASE: 3,
        // Erase the character to left of the cursor.
        VKILL: 4,
        // Kill the current input line.
        VEOF: 5,
        // End-of-file character (sends EOF from the
        //  terminal).
        VEOL: 6,
        // End-of-line character in addition to carriage
        //  return and/or linefeed.
        VEOL2: 7,
        // Additional end-of-line character.
        VSTART: 8,
        // Continues paused output (normally control-Q).
        VSTOP: 9,
        // Pauses output (normally control-S).
        VSUSP: 10,
        // Suspends the current program.
        VDSUSP: 11,
        // Another suspend character.
        VREPRINT: 12,
        // Reprints the current input line.
        VWERASE: 13,
        // Erases a word left of cursor.
        VLNEXT: 14,
        // Enter the next character typed literally, even if
        //  it is a special character
        VFLUSH: 15,
        // Character to flush output.
        VSWTCH: 16,
        // Switch to a different shell layer.
        VSTATUS: 17,
        // Prints system status line (load, command, pid,
        //  etc).
        VDISCARD: 18,
        // Toggles the flushing of terminal output.
        IGNPAR: 30,
        // The ignore parity flag.  The parameter SHOULD be 0
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        // Mark parity and framing errors.
        INPCK: 32,
        // Enable checking of parity errors.
        ISTRIP: 33,
        // Strip 8th bit off characters.
        INLCR: 34,
        // Map NL into CR on input.
        IGNCR: 35,
        // Ignore CR on input.
        ICRNL: 36,
        // Map CR to NL on input.
        IUCLC: 37,
        // Translate uppercase characters to lowercase.
        IXON: 38,
        // Enable output flow control.
        IXANY: 39,
        // Any char will restart after stop.
        IXOFF: 40,
        // Enable input flow control.
        IMAXBEL: 41,
        // Ring bell on input queue full.
        ISIG: 50,
        // Enable signals INTR, QUIT, [D]SUSP.
        ICANON: 51,
        // Canonicalize input lines.
        XCASE: 52,
        // Enable input and output of uppercase characters by
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        // Enable echoing.
        ECHOE: 54,
        // Visually erase chars.
        ECHOK: 55,
        // Kill character discards current line.
        ECHONL: 56,
        // Echo NL even if ECHO is off.
        NOFLSH: 57,
        // Don't flush after interrupt.
        TOSTOP: 58,
        // Stop background jobs from output.
        IEXTEN: 59,
        // Enable extensions.
        ECHOCTL: 60,
        // Echo control characters as ^(Char).
        ECHOKE: 61,
        // Visual erase for line kill.
        PENDIN: 62,
        // Retype pending input.
        OPOST: 70,
        // Enable output processing.
        OLCUC: 71,
        // Convert lowercase to uppercase.
        ONLCR: 72,
        // Map NL to CR-NL.
        OCRNL: 73,
        // Translate carriage return to newline (output).
        ONOCR: 74,
        // Translate newline to carriage return-newline
        //  (output).
        ONLRET: 75,
        // Newline performs a carriage return (output).
        CS7: 90,
        // 7 bit mode.
        CS8: 91,
        // 8 bit mode.
        PARENB: 92,
        // Parity enable.
        PARODD: 93,
        // Odd parity, else even.
        TTY_OP_ISPEED: 128,
        // Specifies the input baud rate in bits per second.
        TTY_OP_OSPEED: 129
        // Specifies the output baud rate in bits per second.
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),
      COMPAT,
      COMPAT_CHECKS: [
        ["Cisco-1.25", COMPAT.BAD_DHGEX],
        [/^Cisco-1[.]/, COMPAT.BUG_DHGEX_LARGE],
        [/^[0-9.]+$/, COMPAT.OLD_EXIT],
        // old SSH.com implementations
        [/^OpenSSH_5[.][0-9]+/, COMPAT.DYN_RPORT_BUG],
        [/^OpenSSH_7[.]4/, COMPAT.IMPLY_RSA_SHA2_SIGALGS]
      ],
      // KEX proposal-related
      DEFAULT_KEX,
      SUPPORTED_KEX,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      SUPPORTED_CIPHER,
      DEFAULT_MAC,
      SUPPORTED_MAC,
      DEFAULT_COMPRESSION,
      SUPPORTED_COMPRESSION,
      curve25519Supported,
      eddsaSupported
    };
    module.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module.exports.DISCONNECT_REASON)).reduce((obj, [key, value4]) => ({ ...obj, [value4]: key }), {});
  }
});

// node_modules/ssh2/lib/protocol/utils.js
var require_utils7 = __commonJS({
  "node_modules/ssh2/lib/protocol/utils.js"(exports, module) {
    "use strict";
    var Ber = require_lib2().Ber;
    var DISCONNECT_REASON;
    var FastBuffer = Buffer[Symbol.species];
    var TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
    function readUInt32BE(buf, offset) {
      return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
    }
    function bufferCopy(src, dest, srcStart, srcEnd, destStart) {
      if (!destStart)
        destStart = 0;
      if (srcEnd > src.length)
        srcEnd = src.length;
      let nb = srcEnd - srcStart;
      const destLeft = dest.length - destStart;
      if (nb > destLeft)
        nb = destLeft;
      dest.set(
        new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),
        destStart
      );
      return nb;
    }
    function bufferSlice(buf, start, end4) {
      if (end4 === void 0)
        end4 = buf.length;
      return new FastBuffer(buf.buffer, buf.byteOffset + start, end4 - start);
    }
    function makeBufferParser() {
      let pos2 = 0;
      let buffer;
      const self2 = {
        init: (buf, start) => {
          buffer = buf;
          pos2 = typeof start === "number" ? start : 0;
        },
        pos: () => pos2,
        length: () => buffer ? buffer.length : 0,
        avail: () => buffer && pos2 < buffer.length ? buffer.length - pos2 : 0,
        clear: () => {
          buffer = void 0;
        },
        readUInt32BE: () => {
          if (!buffer || pos2 + 3 >= buffer.length)
            return;
          return buffer[pos2++] * 16777216 + buffer[pos2++] * 65536 + buffer[pos2++] * 256 + buffer[pos2++];
        },
        readUInt64BE: (behavior) => {
          if (!buffer || pos2 + 7 >= buffer.length)
            return;
          switch (behavior) {
            case "always":
              return BigInt(`0x${buffer.hexSlice(pos2, pos2 += 8)}`);
            case "maybe":
              if (buffer[pos2] > 31)
                return BigInt(`0x${buffer.hexSlice(pos2, pos2 += 8)}`);
            default:
              return buffer[pos2++] * 72057594037927940 + buffer[pos2++] * 281474976710656 + buffer[pos2++] * 1099511627776 + buffer[pos2++] * 4294967296 + buffer[pos2++] * 16777216 + buffer[pos2++] * 65536 + buffer[pos2++] * 256 + buffer[pos2++];
          }
        },
        skip: (n) => {
          if (buffer && n > 0)
            pos2 += n;
        },
        skipString: () => {
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          pos2 += len;
          return pos2 <= buffer.length ? len : void 0;
        },
        readByte: () => {
          if (buffer && pos2 < buffer.length)
            return buffer[pos2++];
        },
        readBool: () => {
          if (buffer && pos2 < buffer.length)
            return !!buffer[pos2++];
        },
        readList: () => {
          const list3 = self2.readString(true);
          if (list3 === void 0)
            return;
          return list3 ? list3.split(",") : [];
        },
        readString: (dest, maxLen) => {
          if (typeof dest === "number") {
            maxLen = dest;
            dest = void 0;
          }
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          if (buffer.length - pos2 < len || typeof maxLen === "number" && len > maxLen) {
            return;
          }
          if (dest) {
            if (Buffer.isBuffer(dest))
              return bufferCopy(buffer, dest, pos2, pos2 += len);
            return buffer.utf8Slice(pos2, pos2 += len);
          }
          return bufferSlice(buffer, pos2, pos2 += len);
        },
        readRaw: (len) => {
          if (!buffer)
            return;
          if (typeof len !== "number")
            return bufferSlice(buffer, pos2, pos2 += buffer.length - pos2);
          if (buffer.length - pos2 >= len)
            return bufferSlice(buffer, pos2, pos2 += len);
        }
      };
      return self2;
    }
    function makeError(msg, level, fatal) {
      const err = new Error(msg);
      if (typeof level === "boolean") {
        fatal = level;
        err.level = "protocol";
      } else {
        err.level = level || "protocol";
      }
      err.fatal = !!fatal;
      return err;
    }
    function writeUInt32BE(buf, value4, offset) {
      buf[offset++] = value4 >>> 24;
      buf[offset++] = value4 >>> 16;
      buf[offset++] = value4 >>> 8;
      buf[offset++] = value4;
      return offset;
    }
    var utilBufferParser = makeBufferParser();
    module.exports = {
      bufferCopy,
      bufferSlice,
      FastBuffer,
      bufferFill: (buf, value4, start, end4) => {
        return TypedArrayFill.call(buf, value4, start, end4);
      },
      makeError,
      doFatalError: (protocol, msg, level, reason) => {
        let err;
        if (DISCONNECT_REASON === void 0)
          ({ DISCONNECT_REASON } = require_constants5());
        if (msg instanceof Error) {
          err = msg;
          if (typeof level !== "number")
            reason = DISCONNECT_REASON.PROTOCOL_ERROR;
          else
            reason = level;
        } else {
          err = makeError(msg, level, true);
        }
        if (typeof reason !== "number")
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        protocol.disconnect(reason);
        protocol._destruct();
        protocol._onError(err);
        return Infinity;
      },
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE: (buf, value4, offset) => {
        buf[offset++] = value4;
        buf[offset++] = value4 >>> 8;
        buf[offset++] = value4 >>> 16;
        buf[offset++] = value4 >>> 24;
        return offset;
      },
      makeBufferParser,
      bufferParser: makeBufferParser(),
      readString: (buffer, start, dest, maxLen) => {
        if (typeof dest === "number") {
          maxLen = dest;
          dest = void 0;
        }
        if (start === void 0)
          start = 0;
        const left3 = buffer.length - start;
        if (start < 0 || start >= buffer.length || left3 < 4)
          return;
        const len = readUInt32BE(buffer, start);
        if (left3 < 4 + len || typeof maxLen === "number" && len > maxLen)
          return;
        start += 4;
        const end4 = start + len;
        buffer._pos = end4;
        if (dest) {
          if (Buffer.isBuffer(dest))
            return bufferCopy(buffer, dest, start, end4);
          return buffer.utf8Slice(start, end4);
        }
        return bufferSlice(buffer, start, end4);
      },
      sigSSHToASN1: (sig, type) => {
        switch (type) {
          case "ssh-dss": {
            if (sig.length > 40)
              return sig;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            let r = sig.slice(0, 20);
            let s = sig.slice(20);
            if (r[0] & 128) {
              const rNew = Buffer.allocUnsafe(21);
              rNew[0] = 0;
              r.copy(rNew, 1);
              r = rNew;
            } else if (r[0] === 0 && !(r[1] & 128)) {
              r = r.slice(1);
            }
            if (s[0] & 128) {
              const sNew = Buffer.allocUnsafe(21);
              sNew[0] = 0;
              s.copy(sNew, 1);
              s = sNew;
            } else if (s[0] === 0 && !(s[1] & 128)) {
              s = s.slice(1);
            }
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            utilBufferParser.init(sig, 0);
            const r = utilBufferParser.readString();
            const s = utilBufferParser.readString();
            utilBufferParser.clear();
            if (r === void 0 || s === void 0)
              return;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          default:
            return sig;
        }
      },
      convertSignature: (signature, keyType) => {
        switch (keyType) {
          case "ssh-dss": {
            if (signature.length <= 40)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, true);
            let s = asnReader.readString(Ber.Integer, true);
            let rOffset = 0;
            let sOffset = 0;
            if (r.length < 20) {
              const rNew = Buffer.allocUnsafe(20);
              rNew.set(r, 1);
              r = rNew;
              r[0] = 0;
            }
            if (s.length < 20) {
              const sNew = Buffer.allocUnsafe(20);
              sNew.set(s, 1);
              s = sNew;
              s[0] = 0;
            }
            if (r.length > 20 && r[0] === 0)
              rOffset = 1;
            if (s.length > 20 && s[0] === 0)
              sOffset = 1;
            const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
            bufferCopy(r, newSig, rOffset, r.length, 0);
            bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);
            return newSig;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (signature[0] === 0)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            const r = asnReader.readString(Ber.Integer, true);
            const s = asnReader.readString(Ber.Integer, true);
            if (r === null || s === null)
              return;
            const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
            writeUInt32BE(newSig, r.length, 0);
            newSig.set(r, 4);
            writeUInt32BE(newSig, s.length, 4 + r.length);
            newSig.set(s, 4 + 4 + r.length);
            return newSig;
          }
        }
        return signature;
      },
      sendPacket: (proto, packet, bypass) => {
        if (!bypass && proto._kexinit !== void 0) {
          if (proto._queue === void 0)
            proto._queue = [];
          proto._queue.push(packet);
          proto._debug && proto._debug("Outbound: ... packet queued");
          return false;
        }
        proto._cipher.encrypt(packet);
        return true;
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var require_sshcrypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"(exports, module) {
    module.exports = "./sshcrypto-OVWRNLAR.node";
  }
});

// node_modules/ssh2/lib/protocol/crypto/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/poly1305.js"(exports, module) {
    var createPoly1305 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 !== "undefined" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a;
          r = c;
        });
        var u = {}, w;
        for (w in b)
          b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = "object" === typeof window, y = "function" === typeof importScripts, z = "object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node, B = "", C, D, E, F, G;
        if (z)
          B = y ? __require("path").dirname(B) + "/" : __dirname + "/", C = function(a, c) {
            var d = H(a);
            if (d)
              return c ? d : d.toString();
            F || (F = __require("fs"));
            G || (G = __require("path"));
            a = G.normalize(a);
            return F.readFileSync(a, c ? null : "utf8");
          }, E = function(a) {
            a = C(a, true);
            a.buffer || (a = new Uint8Array(a));
            assert3(a.buffer);
            return a;
          }, D = function(a, c, d) {
            var e = H(a);
            e && c(e);
            F || (F = __require("fs"));
            G || (G = __require("path"));
            a = G.normalize(a);
            F.readFile(a, function(f, l) {
              f ? d(f) : c(l.buffer);
            });
          }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
            return "[Emscripten Module object]";
          };
        else if (x || y)
          y ? B = self.location.href : "undefined" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf("blob:") ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.send(null);
              return c.responseText;
            } catch (f) {
              if (a = H(a)) {
                c = [];
                for (var d = 0; d < a.length; d++) {
                  var e = a[d];
                  255 < e && (ba && assert3(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255);
                  c.push(String.fromCharCode(e));
                }
                return c.join("");
              }
              throw f;
            }
          }, y && (E = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.responseType = "arraybuffer";
              c.send(null);
              return new Uint8Array(c.response);
            } catch (d) {
              if (a = H(a))
                return a;
              throw d;
            }
          }), D = function(a, c, d) {
            var e = new XMLHttpRequest();
            e.open("GET", a, true);
            e.responseType = "arraybuffer";
            e.onload = function() {
              if (200 == e.status || 0 == e.status && e.response)
                c(e.response);
              else {
                var f = H(a);
                f ? c(f.buffer) : d();
              }
            };
            e.onerror = d;
            e.send(null);
          };
        b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u)
          u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        var noExitRuntime = b.noExitRuntime || true;
        "object" !== typeof WebAssembly && K("no native wasm support detected");
        var L, M = false;
        function assert3(a, c) {
          a || K("Assertion failed: " + c);
        }
        function N(a) {
          var c = b["_" + a];
          assert3(c, "Cannot call unknown function " + a + ", make sure it is exported");
          return c;
        }
        function ca(a, c, d, e) {
          var f = { string: function(g) {
            var p = 0;
            if (null !== g && void 0 !== g && 0 !== g) {
              var n = (g.length << 2) + 1;
              p = O(n);
              var k = p, h = P2;
              if (0 < n) {
                n = k + n - 1;
                for (var v = 0; v < g.length; ++v) {
                  var m = g.charCodeAt(v);
                  if (55296 <= m && 57343 >= m) {
                    var oa = g.charCodeAt(++v);
                    m = 65536 + ((m & 1023) << 10) | oa & 1023;
                  }
                  if (127 >= m) {
                    if (k >= n)
                      break;
                    h[k++] = m;
                  } else {
                    if (2047 >= m) {
                      if (k + 1 >= n)
                        break;
                      h[k++] = 192 | m >> 6;
                    } else {
                      if (65535 >= m) {
                        if (k + 2 >= n)
                          break;
                        h[k++] = 224 | m >> 12;
                      } else {
                        if (k + 3 >= n)
                          break;
                        h[k++] = 240 | m >> 18;
                        h[k++] = 128 | m >> 12 & 63;
                      }
                      h[k++] = 128 | m >> 6 & 63;
                    }
                    h[k++] = 128 | m & 63;
                  }
                }
                h[k] = 0;
              }
            }
            return p;
          }, array: function(g) {
            var p = O(g.length);
            Q.set(g, p);
            return p;
          } }, l = N(a), A2 = [];
          a = 0;
          if (e)
            for (var t = 0; t < e.length; t++) {
              var aa = f[d[t]];
              aa ? (0 === a && (a = da()), A2[t] = aa(e[t])) : A2[t] = e[t];
            }
          d = l.apply(null, A2);
          d = function(g) {
            if ("string" === c)
              if (g) {
                for (var p = P2, n = g + NaN, k = g; p[k] && !(k >= n); )
                  ++k;
                if (16 < k - g && p.subarray && ea)
                  g = ea.decode(p.subarray(g, k));
                else {
                  for (n = ""; g < k; ) {
                    var h = p[g++];
                    if (h & 128) {
                      var v = p[g++] & 63;
                      if (192 == (h & 224))
                        n += String.fromCharCode((h & 31) << 6 | v);
                      else {
                        var m = p[g++] & 63;
                        h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;
                        65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                      }
                    } else
                      n += String.fromCharCode(h);
                  }
                  g = n;
                }
              } else
                g = "";
            else
              g = "boolean" === c ? !!g : g;
            return g;
          }(d);
          0 !== a && fa(a);
          return d;
        }
        var ea = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0, ha, Q, P2;
        function ia() {
          var a = L.buffer;
          ha = a;
          b.HEAP8 = Q = new Int8Array(a);
          b.HEAP16 = new Int16Array(a);
          b.HEAP32 = new Int32Array(a);
          b.HEAPU8 = P2 = new Uint8Array(a);
          b.HEAPU16 = new Uint16Array(a);
          b.HEAPU32 = new Uint32Array(a);
          b.HEAPF32 = new Float32Array(a);
          b.HEAPF64 = new Float64Array(a);
        }
        var R2, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        var S = 0, T = null, U = null;
        b.preloadedImages = {};
        b.preloadedAudios = {};
        function K(a) {
          if (b.onAbort)
            b.onAbort(a);
          I(a);
          M = true;
          a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
          r(a);
          throw a;
        }
        var V = "data:application/octet-stream;base64,", W2;
        W2 = "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA==";
        if (!W2.startsWith(V)) {
          var na = W2;
          W2 = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W2;
          try {
            if (a == W2 && J)
              return new Uint8Array(J);
            var c = H(a);
            if (c)
              return c;
            if (E)
              return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        function qa() {
          if (!J && (x || y)) {
            if ("function" === typeof fetch && !W2.startsWith("file://"))
              return fetch(W2, { credentials: "same-origin" }).then(function(a) {
                if (!a.ok)
                  throw "failed to load wasm binary file at '" + W2 + "'";
                return a.arrayBuffer();
              }).catch(function() {
                return pa();
              });
            if (D)
              return new Promise(function(a, c) {
                D(W2, function(d) {
                  a(new Uint8Array(d));
                }, c);
              });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if ("function" == typeof c)
              c(b);
            else {
              var d = c.m;
              "number" === typeof d ? void 0 === c.l ? R2.get(d)() : R2.get(d)(c.l) : d(void 0 === c.l ? null : c.l);
            }
          }
        }
        var ba = false, ra = "function" === typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var A2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | l >> 2;
            var t = (l & 3) << 6 | A2;
            c += String.fromCharCode(e);
            64 !== l && (c += String.fromCharCode(f));
            64 !== A2 && (c += String.fromCharCode(t));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            a = a.slice(V.length);
            if ("boolean" === typeof z && z) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else
              try {
                var d = ra(a), e = new Uint8Array(d.length);
                for (a = 0; a < d.length; ++a)
                  e[a] = d.charCodeAt(a);
                c = e;
              } catch (f) {
                throw Error("Converting base64 string to bytes failed.");
              }
            return c;
          }
        }
        var sa = { a: function(a) {
          var c = P2.length;
          a >>>= 0;
          if (2147483648 < a)
            return false;
          for (var d = 1; 4 >= d; d *= 2) {
            var e = c * (1 + 0.2 / d);
            e = Math.min(e, a + 100663296);
            e = Math.max(a, e);
            0 < e % 65536 && (e += 65536 - e % 65536);
            a: {
              try {
                L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);
                ia();
                var f = 1;
                break a;
              } catch (l) {
              }
              f = void 0;
            }
            if (f)
              return true;
          }
          return false;
        } };
        (function() {
          function a(f) {
            b.asm = f.exports;
            L = b.asm.b;
            ia();
            R2 = b.asm.j;
            ka.unshift(b.asm.c);
            S--;
            b.monitorRunDependencies && b.monitorRunDependencies(S);
            0 == S && (null !== T && (clearInterval(T), T = null), U && (f = U, U = null, f()));
          }
          function c(f) {
            a(f.instance);
          }
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l);
              K(l);
            });
          }
          var e = { a: sa };
          S++;
          b.monitorRunDependencies && b.monitorRunDependencies(S);
          if (b.instantiateWasm)
            try {
              return b.instantiateWasm(
                e,
                a
              );
            } catch (f) {
              return I("Module.instantiateWasm callback failed with error: " + f), false;
            }
          (function() {
            return J || "function" !== typeof WebAssembly.instantiateStreaming || W2.startsWith(V) || W2.startsWith("file://") || "function" !== typeof fetch ? d(c) : fetch(W2, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                I("wasm streaming compile failed: " + l);
                I("falling back to ArrayBuffer instantiation");
                return d(c);
              });
            });
          })().catch(r);
          return {};
        })();
        b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        };
        b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        };
        b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        };
        b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return "number" === l;
          });
          return "string" !== c && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = function ta() {
          Y || Z();
          Y || (U = ta);
        };
        function Z() {
          function a() {
            if (!Y && (Y = true, b.calledRun = true, !M)) {
              X(ka);
              q(b);
              if (b.onRuntimeInitialized)
                b.onRuntimeInitialized();
              if (b.postRun)
                for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                  var c = b.postRun.shift();
                  la.unshift(c);
                }
              X(la);
            }
          }
          if (!(0 < S)) {
            if (b.preRun)
              for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; )
                ma();
            X(ja);
            0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        b.run = Z;
        if (b.preInit)
          for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; )
            b.preInit.pop()();
        Z();
        return createPoly13052.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = createPoly1305;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return createPoly1305;
      });
    else if (typeof exports === "object")
      exports["createPoly1305"] = createPoly1305;
  }
});

// node_modules/ssh2/lib/protocol/crypto.js
var require_crypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto.js"(exports, module) {
    "use strict";
    var {
      createCipheriv,
      createDecipheriv,
      createHmac,
      randomFillSync,
      timingSafeEqual
    } = __require("crypto");
    var { readUInt32BE, writeUInt32BE } = require_utils7();
    var FastBuffer = Buffer[Symbol.species];
    var MAX_SEQNO = 2 ** 32 - 1;
    var EMPTY_BUFFER = Buffer.alloc(0);
    var BUF_INT = Buffer.alloc(4);
    var DISCARD_CACHE = /* @__PURE__ */ new Map();
    var MAX_PACKET_SIZE = 35e3;
    var binding;
    var AESGCMCipher;
    var ChaChaPolyCipher;
    var GenericCipher;
    var AESGCMDecipher;
    var ChaChaPolyDecipher;
    var GenericDecipher;
    try {
      binding = require_sshcrypto();
      ({
        AESGCMCipher,
        ChaChaPolyCipher,
        GenericCipher,
        AESGCMDecipher,
        ChaChaPolyDecipher,
        GenericDecipher
      } = binding);
    } catch {
    }
    var CIPHER_STREAM = 1 << 0;
    var CIPHER_INFO = (() => {
      function info4(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
        return {
          sslName,
          blockLen,
          keyLen,
          ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
          authLen,
          discardLen,
          stream: !!(flags & CIPHER_STREAM)
        };
      }
      return {
        "chacha20-poly1305@openssh.com": info4("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
        "aes128-gcm": info4("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm": info4("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-gcm@openssh.com": info4("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm@openssh.com": info4("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-cbc": info4("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": info4("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": info4("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": info4("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": info4("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": info4("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": info4("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": info4("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": info4("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
        "aes192-ctr": info4("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
        "aes256-ctr": info4("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
        "3des-ctr": info4("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
        "blowfish-ctr": info4("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        "cast128-ctr": info4("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        /* The "arcfour128" algorithm is the RC4 cipher, as described in
               [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
               generated by the cipher MUST be discarded, and the first byte of the
               first encrypted packet MUST be encrypted using the 1537th byte of
               keystream.
        
               -- http://tools.ietf.org/html/rfc4345#section-4 */
        "arcfour": info4("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour128": info4("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour256": info4("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
        "arcfour512": info4("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
      };
    })();
    var MAC_INFO = (() => {
      function info4(sslName, len, actualLen, isETM) {
        return {
          sslName,
          len,
          actualLen,
          isETM
        };
      }
      return {
        "hmac-md5": info4("md5", 16, 16, false),
        "hmac-md5-96": info4("md5", 16, 12, false),
        "hmac-ripemd160": info4("ripemd160", 20, 20, false),
        "hmac-sha1": info4("sha1", 20, 20, false),
        "hmac-sha1-etm@openssh.com": info4("sha1", 20, 20, true),
        "hmac-sha1-96": info4("sha1", 20, 12, false),
        "hmac-sha2-256": info4("sha256", 32, 32, false),
        "hmac-sha2-256-etm@openssh.com": info4("sha256", 32, 32, true),
        "hmac-sha2-256-96": info4("sha256", 32, 12, false),
        "hmac-sha2-512": info4("sha512", 64, 64, false),
        "hmac-sha2-512-etm@openssh.com": info4("sha512", 64, 64, true),
        "hmac-sha2-512-96": info4("sha512", 64, 12, false)
      };
    })();
    var NullCipher = class {
      constructor(seqno, onWrite) {
        this.outSeqno = seqno;
        this._onWrite = onWrite;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var POLY1305_ZEROS = Buffer.alloc(32);
    var POLY1305_OUT_COMPUTE = Buffer.alloc(16);
    var POLY1305_WASM_MODULE;
    var POLY1305_RESULT_MALLOC;
    var poly1305_auth;
    var ChaChaPolyCipherNative = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encKeyMain = enc.cipherKey.slice(0, 32);
        this._encKeyPktLen = enc.cipherKey.slice(32);
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        POLY1305_OUT_COMPUTE[0] = 0;
        writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
        const polyKey = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
        const pktLenEnc = createCipheriv("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
        this._onWrite(pktLenEnc);
        POLY1305_OUT_COMPUTE[0] = 1;
        const payloadEnc = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
        this._onWrite(payloadEnc);
        poly1305_auth(
          POLY1305_RESULT_MALLOC,
          pktLenEnc,
          pktLenEnc.length,
          payloadEnc,
          payloadEnc.length,
          polyKey
        );
        const mac = Buffer.allocUnsafe(16);
        mac.set(
          new Uint8Array(
            POLY1305_WASM_MODULE.HEAPU8.buffer,
            POLY1305_RESULT_MALLOC,
            16
          ),
          0
        );
        this._onWrite(mac);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var ChaChaPolyCipherBinding = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new ChaChaPolyCipher(enc.cipherKey);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* MAC */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherNative = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encSSLName = enc.cipherInfo.sslName;
        this._encKey = enc.cipherKey;
        this._encIV = enc.cipherIV;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);
        cipher.setAutoPadding(false);
        const lenData = packet.slice(0, 4);
        cipher.setAAD(lenData);
        this._onWrite(lenData);
        const encrypted = cipher.update(packet.slice(4));
        this._onWrite(encrypted);
        const final = cipher.final();
        if (final.length)
          this._onWrite(final);
        const tag = cipher.getAuthTag();
        this._onWrite(tag);
        ivIncrement(this._encIV);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherBinding = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new AESGCMCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* authTag */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherNative = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._cipherInstance = createCipheriv(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._macSSLName = enc.macInfo.sslName;
        this._macKey = enc.macKey;
        this._macActualLen = enc.macInfo.actualLen;
        this._macETM = enc.macInfo.isETM;
        this._aadLen = this._macETM ? 4 : 0;
        this._dead = false;
        const discardLen = enc.cipherInfo.discardLen;
        if (discardLen) {
          let discard48 = DISCARD_CACHE.get(discardLen);
          if (discard48 === void 0) {
            discard48 = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard48);
          }
          this._cipherInstance.update(discard48);
        }
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        let mac;
        if (this._macETM) {
          const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);
          const encrypted = this._cipherInstance.update(
            new Uint8Array(
              packet.buffer,
              packet.byteOffset + 4,
              packet.length - 4
            )
          );
          this._onWrite(lenBytes);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(lenBytes);
          mac.update(encrypted);
        } else {
          const encrypted = this._cipherInstance.update(packet);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(packet);
        }
        let digest = mac.digest();
        if (digest.length > this._macActualLen)
          digest = digest.slice(0, this._macActualLen);
        this._onWrite(digest);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherBinding = class {
      constructor(config2) {
        const enc = config2.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._macLen = enc.macInfo.len;
        this._macActualLen = enc.macInfo.actualLen;
        this._aadLen = enc.macInfo.isETM ? 4 : 0;
        this._instance = new GenericCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV,
          enc.macInfo.sslName,
          enc.macKey,
          enc.macInfo.isETM
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen + this._macLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        if (this._macActualLen < this._macLen) {
          packet = new FastBuffer(
            packet.buffer,
            packet.byteOffset,
            packet.length - (this._macLen - this._macActualLen)
          );
        }
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var NullDecipher = class {
      constructor(seqno, onPayload) {
        this.inSeqno = seqno;
        this._onPayload = onPayload;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._packetPos < this._len) {
            const nb = Math.min(this._len - this._packetPos, dataLen - p);
            let chunk;
            if (p !== 0 || nb !== dataLen)
              chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              chunk = data;
            if (nb === this._len) {
              this._packet = chunk;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(chunk, this._packetPos);
            }
            p += nb;
            this._packetPos += nb;
            if (this._packetPos < this._len)
              return;
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherNative = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decKeyMain = dec.decipherKey.slice(0, 32);
        this._decKeyPktLen = dec.decipherKey.slice(32);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._calcMac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            POLY1305_OUT_COMPUTE[0] = 0;
            writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
            const decLenBytes = createDecipheriv("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
            this._len = readUInt32BE(decLenBytes, 0);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          POLY1305_OUT_COMPUTE[0] = 0;
          writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          const polyKey = createCipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
          poly1305_auth(
            POLY1305_RESULT_MALLOC,
            this._lenBuf,
            4,
            this._packet,
            this._packet.length,
            polyKey
          );
          this._calcMac.set(
            new Uint8Array(
              POLY1305_WASM_MODULE.HEAPU8.buffer,
              POLY1305_RESULT_MALLOC,
              16
            ),
            0
          );
          if (!timingSafeEqual(this._calcMac, this._mac))
            throw new Error("Invalid MAC");
          POLY1305_OUT_COMPUTE[0] = 1;
          const packet = createDecipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);
          const payload = new FastBuffer(
            packet.buffer,
            packet.byteOffset + 1,
            packet.length - packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherBinding = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new ChaChaPolyDecipher(dec.decipherKey);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._mac, this.inSeqno);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherNative = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = null;
        this._decipherSSLName = dec.decipherInfo.sslName;
        this._decipherKey = dec.decipherKey;
        this._decipherIV = dec.decipherIV;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error("Bad packet length");
            }
            this._decipherInstance = createDecipheriv(
              this._decipherSSLName,
              this._decipherKey,
              this._decipherIV
            );
            this._decipherInstance.setAutoPadding(false);
            this._decipherInstance.setAAD(intToBytes(this._len));
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let decrypted;
            if (p !== 0 || nb !== dataLen) {
              decrypted = this._decipherInstance.update(
                new Uint8Array(data.buffer, data.byteOffset + p, nb)
              );
            } else {
              decrypted = this._decipherInstance.update(data);
            }
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          {
            this._decipherInstance.setAuthTag(this._tag);
            const decrypted = this._decipherInstance.final();
            if (decrypted.length) {
              if (this._packet)
                this._packet.set(decrypted, this._packetPos);
              else
                this._packet = decrypted;
            }
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          ivIncrement(this._decipherIV);
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherBinding = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new AESGCMDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error(`Bad packet length: ${this._len}`);
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._len, this._tag);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherNative = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = createDecipheriv(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._decipherInstance.setAutoPadding(false);
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen
        );
        this._blockSize = dec.decipherInfo.blockLen;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macSSLName = dec.macInfo.sslName;
        this._macKey = dec.macKey;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
        this._macInstance = null;
        const discardLen = dec.decipherInfo.discardLen;
        if (discardLen) {
          let discard48 = DISCARD_CACHE.get(discardLen);
          if (discard48 === void 0) {
            discard48 = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard48);
          }
          this._decipherInstance.update(discard48);
        }
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let decrypted;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              decrypted = this._decipherInstance.update(this._block);
              this._len = readUInt32BE(decrypted, 0);
              need = 4 + this._len - this._blockSize;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            this._macInstance = createHmac(this._macSSLName, this._macKey);
            writeUInt32BE(BUF_INT, this.inSeqno, 0);
            this._macInstance.update(BUF_INT);
            if (this._macETM) {
              this._macInstance.update(this._block);
            } else {
              this._macInstance.update(new Uint8Array(
                decrypted.buffer,
                decrypted.byteOffset,
                4
              ));
              this._pktLen = decrypted.length - 4;
              this._packetPos = this._pktLen;
              this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(
                new Uint8Array(
                  decrypted.buffer,
                  decrypted.byteOffset + 4,
                  this._packetPos
                ),
                0
              );
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (this._macETM)
              this._macInstance.update(encrypted);
            const decrypted = this._decipherInstance.update(encrypted);
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          if (!this._macETM)
            this._macInstance.update(this._packet);
          let calculated = this._macInstance.digest();
          if (this._macActualLen < calculated.length) {
            calculated = new Uint8Array(
              calculated.buffer,
              calculated.byteOffset,
              this._macActualLen
            );
          }
          if (!timingSafeEquals(calculated, this._mac))
            throw new Error("Invalid MAC");
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherBinding = class {
      constructor(config2) {
        const dec = config2.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new GenericDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV,
          dec.macInfo.sslName,
          dec.macKey,
          dec.macInfo.isETM,
          dec.macInfo.actualLen
        );
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen
        );
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              this._instance.decryptBlock(this._block);
              this._len = readUInt32BE(this._block, 0);
              need = 4 + this._len - this._block.length;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            if (!this._macETM) {
              this._pktLen = this._block.length - 4;
              if (this._pktLen) {
                this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(
                  new Uint8Array(
                    this._block.buffer,
                    this._block.byteOffset + 4,
                    this._pktLen
                  ),
                  0
                );
              }
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          this._instance.decrypt(
            this._packet,
            this.inSeqno,
            this._block,
            this._mac
          );
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    function ivIncrement(iv) {
      ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
    }
    var intToBytes = (() => {
      const ret = Buffer.alloc(4);
      return (n) => {
        ret[0] = n >>> 24;
        ret[1] = n >>> 16;
        ret[2] = n >>> 8;
        ret[3] = n;
        return ret;
      };
    })();
    function timingSafeEquals(a, b) {
      if (a.length !== b.length) {
        timingSafeEqual(a, a);
        return false;
      }
      return timingSafeEqual(a, b);
    }
    function createCipher(config2) {
      if (typeof config2 !== "object" || config2 === null)
        throw new Error("Invalid config");
      if (typeof config2.outbound !== "object" || config2.outbound === null)
        throw new Error("Invalid outbound");
      const outbound = config2.outbound;
      if (typeof outbound.onWrite !== "function")
        throw new Error("Invalid outbound.onWrite");
      if (typeof outbound.cipherInfo !== "object" || outbound.cipherInfo === null)
        throw new Error("Invalid outbound.cipherInfo");
      if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {
        throw new Error("Invalid outbound.cipherKey");
      }
      if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {
        throw new Error("Invalid outbound.cipherIV");
      }
      if (typeof outbound.seqno !== "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid outbound.seqno");
      }
      const forceNative = !!outbound.forceNative;
      switch (outbound.cipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config2) : new AESGCMCipherNative(config2);
        case "chacha20":
          return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config2) : new ChaChaPolyCipherNative(config2);
        default: {
          if (typeof outbound.macInfo !== "object" || outbound.macInfo === null)
            throw new Error("Invalid outbound.macInfo");
          if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {
            throw new Error("Invalid outbound.macKey");
          }
          return GenericCipher && !forceNative ? new GenericCipherBinding(config2) : new GenericCipherNative(config2);
        }
      }
    }
    function createDecipher(config2) {
      if (typeof config2 !== "object" || config2 === null)
        throw new Error("Invalid config");
      if (typeof config2.inbound !== "object" || config2.inbound === null)
        throw new Error("Invalid inbound");
      const inbound = config2.inbound;
      if (typeof inbound.onPayload !== "function")
        throw new Error("Invalid inbound.onPayload");
      if (typeof inbound.decipherInfo !== "object" || inbound.decipherInfo === null) {
        throw new Error("Invalid inbound.decipherInfo");
      }
      if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {
        throw new Error("Invalid inbound.decipherKey");
      }
      if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {
        throw new Error("Invalid inbound.decipherIV");
      }
      if (typeof inbound.seqno !== "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid inbound.seqno");
      }
      const forceNative = !!inbound.forceNative;
      switch (inbound.decipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config2) : new AESGCMDecipherNative(config2);
        case "chacha20":
          return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config2) : new ChaChaPolyDecipherNative(config2);
        default: {
          if (typeof inbound.macInfo !== "object" || inbound.macInfo === null)
            throw new Error("Invalid inbound.macInfo");
          if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {
            throw new Error("Invalid inbound.macKey");
          }
          return GenericDecipher && !forceNative ? new GenericDecipherBinding(config2) : new GenericDecipherNative(config2);
        }
      }
    }
    module.exports = {
      CIPHER_INFO,
      MAC_INFO,
      bindingAvailable: !!binding,
      init: (() => {
        return new Promise(async (resolve3, reject) => {
          try {
            POLY1305_WASM_MODULE = await require_poly1305()();
            POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);
            poly1305_auth = POLY1305_WASM_MODULE.cwrap(
              "poly1305_auth",
              null,
              ["number", "array", "number", "array", "number", "array"]
            );
          } catch (ex) {
            return reject(ex);
          }
          resolve3();
        });
      })(),
      NullCipher,
      createCipher,
      NullDecipher,
      createDecipher
    };
  }
});

// node_modules/ssh2/lib/protocol/keyParser.js
var require_keyParser = __commonJS({
  "node_modules/ssh2/lib/protocol/keyParser.js"(exports, module) {
    "use strict";
    var {
      createDecipheriv,
      createECDH,
      createHash: createHash2,
      createHmac,
      createSign,
      createVerify,
      getCiphers,
      sign: sign_,
      verify: verify_
    } = __require("crypto");
    var supportedOpenSSLCiphers = getCiphers();
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var { eddsaSupported, SUPPORTED_CIPHER } = require_constants5();
    var {
      bufferSlice,
      makeBufferParser,
      readString: readString4,
      readUInt32BE,
      writeUInt32BE
    } = require_utils7();
    var SYM_HASH_ALGO = Symbol("Hash Algorithm");
    var SYM_PRIV_PEM = Symbol("Private key PEM");
    var SYM_PUB_PEM = Symbol("Public key PEM");
    var SYM_PUB_SSH = Symbol("Public key SSH");
    var SYM_DECRYPTED = Symbol("Decrypted Key");
    var CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
    {
      const keys4 = Object.keys(CIPHER_INFO);
      for (let i = 0; i < keys4.length; ++i) {
        const cipherName = CIPHER_INFO[keys4[i]].sslName;
        if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])
          continue;
        CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys4[i]];
      }
    }
    var binaryKeyParser = makeBufferParser();
    function makePEM(type, data) {
      data = data.base64Slice(0, data.length);
      let formatted = data.replace(/.{64}/g, "$&\n");
      if (data.length & 63)
        formatted += "\n";
      return `-----BEGIN ${type} KEY-----
${formatted}-----END ${type} KEY-----`;
    }
    function combineBuffers(buf1, buf2) {
      const result = Buffer.allocUnsafe(buf1.length + buf2.length);
      result.set(buf1, 0);
      result.set(buf2, buf1.length);
      return result;
    }
    function skipFields(buf, nfields) {
      const bufLen = buf.length;
      let pos2 = buf._pos || 0;
      for (let i = 0; i < nfields; ++i) {
        const left3 = bufLen - pos2;
        if (pos2 >= bufLen || left3 < 4)
          return false;
        const len = readUInt32BE(buf, pos2);
        if (left3 < 4 + len)
          return false;
        pos2 += 4 + len;
      }
      buf._pos = pos2;
      return true;
    }
    function genOpenSSLRSAPub(n, e) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.113549.1.1.1");
      asnWriter.writeNull();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.startSequence();
      asnWriter.writeBuffer(n, Ber.Integer);
      asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHRSAPub(n, e) {
      const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-rsa", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, e.length, i);
      publicKey.set(e, i += 4);
      writeUInt32BE(publicKey, n.length, i += e.length);
      publicKey.set(n, i + 4);
      return publicKey;
    }
    var genOpenSSLRSAPriv = /* @__PURE__ */ (() => {
      function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
        const asnWriter = new Ber.Writer();
        asnWriter.startSequence();
        asnWriter.writeInt(0, Ber.Integer);
        asnWriter.writeBuffer(n, Ber.Integer);
        asnWriter.writeBuffer(e, Ber.Integer);
        asnWriter.writeBuffer(d, Ber.Integer);
        asnWriter.writeBuffer(p, Ber.Integer);
        asnWriter.writeBuffer(q, Ber.Integer);
        asnWriter.writeBuffer(dmp1, Ber.Integer);
        asnWriter.writeBuffer(dmq1, Ber.Integer);
        asnWriter.writeBuffer(iqmp, Ber.Integer);
        asnWriter.endSequence();
        return asnWriter.buffer;
      }
      function bigIntFromBuffer(buf) {
        return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
      }
      function bigIntToBuffer(bn) {
        let hex = bn.toString(16);
        if ((hex.length & 1) !== 0) {
          hex = `0${hex}`;
        } else {
          const sigbit = hex.charCodeAt(0);
          if (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) {
            hex = `00${hex}`;
          }
        }
        return Buffer.from(hex, "hex");
      }
      return function genOpenSSLRSAPriv2(n, e, d, iqmp, p, q) {
        const bn_d = bigIntFromBuffer(d);
        const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));
        const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
        return makePEM(
          "RSA PRIVATE",
          genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp)
        );
      };
    })();
    function genOpenSSLDSAPub(p, q, g, y) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10040.4.1");
      asnWriter.startSequence();
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHDSAPub(p, q, g, y) {
      const publicKey = Buffer.allocUnsafe(
        4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length
      );
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-dss", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, p.length, i);
      publicKey.set(p, i += 4);
      writeUInt32BE(publicKey, q.length, i += p.length);
      publicKey.set(q, i += 4);
      writeUInt32BE(publicKey, g.length, i += q.length);
      publicKey.set(g, i += 4);
      writeUInt32BE(publicKey, y.length, i += g.length);
      publicKey.set(y, i + 4);
      return publicKey;
    }
    function genOpenSSLDSAPriv(p, q, g, y, x) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.writeBuffer(x, Ber.Integer);
      asnWriter.endSequence();
      return makePEM("DSA PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLEdPub(pub) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHEdPub(pub) {
      const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);
      writeUInt32BE(publicKey, 11, 0);
      publicKey.utf8Write("ssh-ed25519", 4, 11);
      writeUInt32BE(publicKey, pub.length, 15);
      publicKey.set(pub, 19);
      return publicKey;
    }
    function genOpenSSLEdPriv(priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.OctetString);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPub(oid, Q) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10045.2.1");
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(Q.length);
      asnWriter._buf.set(Q, asnWriter._offset);
      asnWriter._offset += Q.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHECDSAPub(oid, Q) {
      let curveName;
      switch (oid) {
        case "1.2.840.10045.3.1.7":
          curveName = "nistp256";
          break;
        case "1.3.132.0.34":
          curveName = "nistp384";
          break;
        case "1.3.132.0.35":
          curveName = "nistp521";
          break;
        default:
          return;
      }
      const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);
      writeUInt32BE(publicKey, 19, 0);
      publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);
      writeUInt32BE(publicKey, 8, 23);
      publicKey.utf8Write(curveName, 27, 8);
      writeUInt32BE(publicKey, Q.length, 35);
      publicKey.set(Q, 39);
      return publicKey;
    }
    function genOpenSSLECDSAPriv(oid, pub, priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(1, Ber.Integer);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.startSequence(160);
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(161);
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("EC PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPubFromPriv(curveName, priv) {
      const tempECDH = createECDH(curveName);
      tempECDH.setPrivateKey(priv);
      return tempECDH.getPublicKey();
    }
    var BaseKey = {
      sign: (() => {
        if (typeof sign_ === "function") {
          return function sign2(data, algo) {
            const pem = this[SYM_PRIV_PEM];
            if (pem === null)
              return new Error("No private key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return sign_(algo, data, pem);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function sign2(data, algo) {
          const pem = this[SYM_PRIV_PEM];
          if (pem === null)
            return new Error("No private key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const signature = createSign(algo);
          signature.update(data);
          try {
            return signature.sign(pem);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      verify: (() => {
        if (typeof verify_ === "function") {
          return function verify(data, signature, algo) {
            const pem = this[SYM_PUB_PEM];
            if (pem === null)
              return new Error("No public key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return verify_(algo, data, pem, signature);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function verify(data, signature, algo) {
          const pem = this[SYM_PUB_PEM];
          if (pem === null)
            return new Error("No public key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const verifier = createVerify(algo);
          verifier.update(data);
          try {
            return verifier.verify(pem, signature);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      isPrivateKey: function isPrivateKey() {
        return this[SYM_PRIV_PEM] !== null;
      },
      getPrivatePEM: function getPrivatePEM() {
        return this[SYM_PRIV_PEM];
      },
      getPublicPEM: function getPublicPEM() {
        return this[SYM_PUB_PEM];
      },
      getPublicSSH: function getPublicSSH() {
        return this[SYM_PUB_SSH];
      },
      equals: function equals(key) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          return false;
        return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH];
      }
    };
    function OpenSSH_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Private.prototype = BaseKey;
    {
      let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
        const keys4 = [];
        if (data.length < 8)
          return new Error("Malformed OpenSSH private key");
        const check1 = readUInt32BE(data, 0);
        const check2 = readUInt32BE(data, 4);
        if (check1 !== check2) {
          if (decrypted) {
            return new Error(
              "OpenSSH key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("OpenSSH key integrity check failed");
        }
        data._pos = 8;
        let i;
        let oid;
        for (i = 0; i < nkeys; ++i) {
          let algo;
          let privPEM;
          let pubPEM;
          let pubSSH;
          const type = readString4(data, data._pos, true);
          if (type === void 0)
            return new Error("Malformed OpenSSH private key");
          switch (type) {
            case "ssh-rsa": {
              const n = readString4(data, data._pos);
              if (n === void 0)
                return new Error("Malformed OpenSSH private key");
              const e = readString4(data, data._pos);
              if (e === void 0)
                return new Error("Malformed OpenSSH private key");
              const d = readString4(data, data._pos);
              if (d === void 0)
                return new Error("Malformed OpenSSH private key");
              const iqmp = readString4(data, data._pos);
              if (iqmp === void 0)
                return new Error("Malformed OpenSSH private key");
              const p = readString4(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString4(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
              privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);
              algo = "sha1";
              break;
            }
            case "ssh-dss": {
              const p = readString4(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString4(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              const g = readString4(data, data._pos);
              if (g === void 0)
                return new Error("Malformed OpenSSH private key");
              const y = readString4(data, data._pos);
              if (y === void 0)
                return new Error("Malformed OpenSSH private key");
              const x = readString4(data, data._pos);
              if (x === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
              privPEM = genOpenSSLDSAPriv(p, q, g, y, x);
              algo = "sha1";
              break;
            }
            case "ssh-ed25519": {
              if (!eddsaSupported)
                return new Error(`Unsupported OpenSSH private key type: ${type}`);
              const edpub = readString4(data, data._pos);
              if (edpub === void 0 || edpub.length !== 32)
                return new Error("Malformed OpenSSH private key");
              const edpriv = readString4(data, data._pos);
              if (edpriv === void 0 || edpriv.length !== 64)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLEdPub(edpub);
              pubSSH = genOpenSSHEdPub(edpub);
              privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));
              algo = null;
              break;
            }
            case "ecdsa-sha2-nistp256":
              algo = "sha256";
              oid = "1.2.840.10045.3.1.7";
            case "ecdsa-sha2-nistp384":
              if (algo === void 0) {
                algo = "sha384";
                oid = "1.3.132.0.34";
              }
            case "ecdsa-sha2-nistp521": {
              if (algo === void 0) {
                algo = "sha512";
                oid = "1.3.132.0.35";
              }
              if (!skipFields(data, 1))
                return new Error("Malformed OpenSSH private key");
              const ecpub = readString4(data, data._pos);
              if (ecpub === void 0)
                return new Error("Malformed OpenSSH private key");
              const ecpriv = readString4(data, data._pos);
              if (ecpriv === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLECDSAPub(oid, ecpub);
              pubSSH = genOpenSSHECDSAPub(oid, ecpub);
              privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
              break;
            }
            default:
              return new Error(`Unsupported OpenSSH private key type: ${type}`);
          }
          const privComment = readString4(data, data._pos, true);
          if (privComment === void 0)
            return new Error("Malformed OpenSSH private key");
          keys4.push(
            new OpenSSH_Private(
              type,
              privComment,
              privPEM,
              pubPEM,
              pubSSH,
              algo,
              decrypted
            )
          );
        }
        let cnt = 0;
        for (i = data._pos; i < data.length; ++i) {
          if (data[i] !== ++cnt % 255)
            return new Error("Malformed OpenSSH private key");
        }
        return keys4;
      };
      const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
      OpenSSH_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        let ret;
        const data = Buffer.from(m[1], "base64");
        if (data.length < 31)
          return new Error("Malformed OpenSSH private key");
        const magic = data.utf8Slice(0, 15);
        if (magic !== "openssh-key-v1\0")
          return new Error(`Unsupported OpenSSH key magic: ${magic}`);
        const cipherName = readString4(data, 15, true);
        if (cipherName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (cipherName !== "none" && SUPPORTED_CIPHER.indexOf(cipherName) === -1)
          return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
        const kdfName = readString4(data, data._pos, true);
        if (kdfName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfName !== "none") {
          if (cipherName === "none")
            return new Error("Malformed OpenSSH private key");
          if (kdfName !== "bcrypt")
            return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
          if (!passphrase) {
            return new Error(
              "Encrypted private OpenSSH key detected, but no passphrase given"
            );
          }
        } else if (cipherName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        let encInfo;
        let cipherKey;
        let cipherIV;
        if (cipherName !== "none")
          encInfo = CIPHER_INFO[cipherName];
        const kdfOptions = readString4(data, data._pos);
        if (kdfOptions === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfOptions.length) {
          switch (kdfName) {
            case "none":
              return new Error("Malformed OpenSSH private key");
            case "bcrypt": {
              const salt = readString4(kdfOptions, 0);
              if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length)
                return new Error("Malformed OpenSSH private key");
              const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);
              const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
              const r = bcrypt_pbkdf(
                passphrase,
                passphrase.length,
                salt,
                salt.length,
                gen,
                gen.length,
                rounds
              );
              if (r !== 0)
                return new Error("Failed to generate information to decrypt key");
              cipherKey = bufferSlice(gen, 0, encInfo.keyLen);
              cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);
              break;
            }
          }
        } else if (kdfName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        if (data._pos + 3 >= data.length)
          return new Error("Malformed OpenSSH private key");
        const keyCount = readUInt32BE(data, data._pos);
        data._pos += 4;
        if (keyCount > 0) {
          for (let i = 0; i < keyCount; ++i) {
            const pubData = readString4(data, data._pos);
            if (pubData === void 0)
              return new Error("Malformed OpenSSH private key");
            const type = readString4(pubData, 0, true);
            if (type === void 0)
              return new Error("Malformed OpenSSH private key");
          }
          let privBlob = readString4(data, data._pos);
          if (privBlob === void 0)
            return new Error("Malformed OpenSSH private key");
          if (cipherKey !== void 0) {
            if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {
              return new Error("Malformed OpenSSH private key");
            }
            try {
              const options = { authTagLength: encInfo.authLen };
              const decipher = createDecipheriv(
                encInfo.sslName,
                cipherKey,
                cipherIV,
                options
              );
              decipher.setAutoPadding(false);
              if (encInfo.authLen > 0) {
                if (data.length - data._pos < encInfo.authLen)
                  return new Error("Malformed OpenSSH private key");
                decipher.setAuthTag(
                  bufferSlice(data, data._pos, data._pos += encInfo.authLen)
                );
              }
              privBlob = combineBuffers(
                decipher.update(privBlob),
                decipher.final()
              );
            } catch (ex) {
              return ex;
            }
          }
          if (data._pos !== data.length)
            return new Error("Malformed OpenSSH private key");
          ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
        } else {
          ret = [];
        }
        if (ret instanceof Error)
          return ret;
        return ret[0];
      };
    }
    function OpenSSH_Old_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Old_Private.prototype = BaseKey;
    {
      const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
      OpenSSH_Old_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        let privBlob = Buffer.from(m[3], "base64");
        let headers = m[2];
        let decrypted = false;
        if (headers !== void 0) {
          headers = headers.split(/\r\n|\n/g);
          for (let i = 0; i < headers.length; ++i) {
            const header = headers[i];
            let sepIdx = header.indexOf(":");
            if (header.slice(0, sepIdx) === "DEK-Info") {
              const val = header.slice(sepIdx + 2);
              sepIdx = val.indexOf(",");
              if (sepIdx === -1)
                continue;
              const cipherName = val.slice(0, sepIdx).toLowerCase();
              if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const encInfo = CIPHER_INFO_OPENSSL[cipherName];
              if (!encInfo) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
              if (cipherIV.length !== encInfo.ivLen)
                return new Error("Malformed encrypted OpenSSH private key");
              if (!passphrase) {
                return new Error(
                  "Encrypted OpenSSH private key detected, but no passphrase given"
                );
              }
              const ivSlice = bufferSlice(cipherIV, 0, 8);
              let cipherKey = createHash2("md5").update(passphrase).update(ivSlice).digest();
              while (cipherKey.length < encInfo.keyLen) {
                cipherKey = combineBuffers(
                  cipherKey,
                  createHash2("md5").update(cipherKey).update(passphrase).update(ivSlice).digest()
                );
              }
              if (cipherKey.length > encInfo.keyLen)
                cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
              try {
                const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
                decipher.setAutoPadding(false);
                privBlob = combineBuffers(
                  decipher.update(privBlob),
                  decipher.final()
                );
                decrypted = true;
              } catch (ex) {
                return ex;
              }
            }
          }
        }
        let type;
        let privPEM;
        let pubPEM;
        let pubSSH;
        let algo;
        let reader;
        let errMsg = "Malformed OpenSSH private key";
        if (decrypted)
          errMsg += ". Bad passphrase?";
        switch (m[1]) {
          case "RSA":
            type = "ssh-rsa";
            privPEM = makePEM("RSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const n = reader.readString(Ber.Integer, true);
              if (n === null)
                return new Error(errMsg);
              const e = reader.readString(Ber.Integer, true);
              if (e === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "DSA":
            type = "ssh-dss";
            privPEM = makePEM("DSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const p = reader.readString(Ber.Integer, true);
              if (p === null)
                return new Error(errMsg);
              const q = reader.readString(Ber.Integer, true);
              if (q === null)
                return new Error(errMsg);
              const g = reader.readString(Ber.Integer, true);
              if (g === null)
                return new Error(errMsg);
              const y = reader.readString(Ber.Integer, true);
              if (y === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "EC": {
            let ecSSLName;
            let ecPriv;
            let ecOID;
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              ecPriv = reader.readString(Ber.OctetString, true);
              reader.readByte();
              const offset = reader.readLength();
              if (offset !== null) {
                reader._offset = offset;
                ecOID = reader.readOID();
                if (ecOID === null)
                  return new Error(errMsg);
                switch (ecOID) {
                  case "1.2.840.10045.3.1.7":
                    ecSSLName = "prime256v1";
                    type = "ecdsa-sha2-nistp256";
                    algo = "sha256";
                    break;
                  case "1.3.132.0.34":
                    ecSSLName = "secp384r1";
                    type = "ecdsa-sha2-nistp384";
                    algo = "sha384";
                    break;
                  case "1.3.132.0.35":
                    ecSSLName = "secp521r1";
                    type = "ecdsa-sha2-nistp521";
                    algo = "sha512";
                    break;
                  default:
                    return new Error(`Unsupported private key EC OID: ${ecOID}`);
                }
              } else {
                return new Error(errMsg);
              }
            } catch {
              return new Error(errMsg);
            }
            privPEM = makePEM("EC PRIVATE", privBlob);
            const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
            pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);
            pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
            break;
          }
        }
        return new OpenSSH_Old_Private(
          type,
          "",
          privPEM,
          pubPEM,
          pubSSH,
          algo,
          decrypted
        );
      };
    }
    function PPK_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    PPK_Private.prototype = BaseKey;
    {
      const EMPTY_PASSPHRASE = Buffer.alloc(0);
      const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      const PPK_PP1 = Buffer.from([0, 0, 0, 0]);
      const PPK_PP2 = Buffer.from([0, 0, 0, 1]);
      const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
      PPK_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        const cipherName = m[2];
        const encrypted = cipherName !== "none";
        if (encrypted && !passphrase) {
          return new Error(
            "Encrypted PPK private key detected, but no passphrase given"
          );
        }
        let privBlob = Buffer.from(m[5], "base64");
        if (encrypted) {
          const encInfo = CIPHER_INFO[cipherName];
          let cipherKey = combineBuffers(
            createHash2("sha1").update(PPK_PP1).update(passphrase).digest(),
            createHash2("sha1").update(PPK_PP2).update(passphrase).digest()
          );
          if (cipherKey.length > encInfo.keyLen)
            cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
          try {
            const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
            decipher.setAutoPadding(false);
            privBlob = combineBuffers(
              decipher.update(privBlob),
              decipher.final()
            );
          } catch (ex) {
            return ex;
          }
        }
        const type = m[1];
        const comment2 = m[3];
        const pubBlob = Buffer.from(m[4], "base64");
        const mac = m[6];
        const typeLen = type.length;
        const cipherNameLen = cipherName.length;
        const commentLen = Buffer.byteLength(comment2);
        const pubLen = pubBlob.length;
        const privLen = privBlob.length;
        const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);
        let p = 0;
        writeUInt32BE(macData, typeLen, p);
        macData.utf8Write(type, p += 4, typeLen);
        writeUInt32BE(macData, cipherNameLen, p += typeLen);
        macData.utf8Write(cipherName, p += 4, cipherNameLen);
        writeUInt32BE(macData, commentLen, p += cipherNameLen);
        macData.utf8Write(comment2, p += 4, commentLen);
        writeUInt32BE(macData, pubLen, p += commentLen);
        macData.set(pubBlob, p += 4);
        writeUInt32BE(macData, privLen, p += pubLen);
        macData.set(privBlob, p + 4);
        if (!passphrase)
          passphrase = EMPTY_PASSPHRASE;
        const calcMAC = createHmac(
          "sha1",
          createHash2("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()
        ).update(macData).digest("hex");
        if (calcMAC !== mac) {
          if (encrypted) {
            return new Error(
              "PPK private key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("PPK private key integrity check failed");
        }
        let pubPEM;
        let pubSSH;
        let privPEM;
        pubBlob._pos = 0;
        skipFields(pubBlob, 1);
        switch (type) {
          case "ssh-rsa": {
            const e = readString4(pubBlob, pubBlob._pos);
            if (e === void 0)
              return new Error("Malformed PPK public key");
            const n = readString4(pubBlob, pubBlob._pos);
            if (n === void 0)
              return new Error("Malformed PPK public key");
            const d = readString4(privBlob, 0);
            if (d === void 0)
              return new Error("Malformed PPK private key");
            const p2 = readString4(privBlob, privBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK private key");
            const q = readString4(privBlob, privBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK private key");
            const iqmp = readString4(privBlob, privBlob._pos);
            if (iqmp === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
            break;
          }
          case "ssh-dss": {
            const p2 = readString4(pubBlob, pubBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK public key");
            const q = readString4(pubBlob, pubBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK public key");
            const g = readString4(pubBlob, pubBlob._pos);
            if (g === void 0)
              return new Error("Malformed PPK public key");
            const y = readString4(pubBlob, pubBlob._pos);
            if (y === void 0)
              return new Error("Malformed PPK public key");
            const x = readString4(privBlob, 0);
            if (x === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLDSAPub(p2, q, g, y);
            pubSSH = genOpenSSHDSAPub(p2, q, g, y);
            privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
            break;
          }
        }
        return new PPK_Private(
          type,
          comment2,
          privPEM,
          pubPEM,
          pubSSH,
          "sha1",
          encrypted
        );
      };
    }
    function OpenSSH_Public(type, comment2, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    OpenSSH_Public.prototype = BaseKey;
    {
      let regexp;
      if (eddsaSupported)
        regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      else
        regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      OpenSSH_Public.parse = (str2) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        const fullType = m[1];
        const baseType = m[2];
        const data = Buffer.from(m[3], "base64");
        const comment2 = m[4] || "";
        const type = readString4(data, data._pos, true);
        if (type === void 0 || type.indexOf(baseType) !== 0)
          return new Error("Malformed OpenSSH public key");
        return parseDER(data, baseType, comment2, fullType);
      };
    }
    function RFC4716_Public(type, comment2, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    RFC4716_Public.prototype = BaseKey;
    {
      const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;
      const RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/;
      const RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;
      const RE_HEADER_ENDS = /\\\r?\n/g;
      RFC4716_Public.parse = (str2) => {
        let m = regexp.exec(str2);
        if (m === null)
          return null;
        const body = m[1];
        let dataStart = 0;
        let comment2 = "";
        while (m = RE_HEADER.exec(body)) {
          const headerName = m[1];
          const headerValue = m[2].replace(RE_HEADER_ENDS, "");
          if (headerValue.length > 1024) {
            RE_HEADER.lastIndex = 0;
            return new Error("Malformed RFC4716 public key");
          }
          dataStart = RE_HEADER.lastIndex;
          if (headerName.toLowerCase() === "comment") {
            comment2 = headerValue;
            if (comment2.length > 1 && comment2.charCodeAt(0) === 34 && comment2.charCodeAt(comment2.length - 1) === 34) {
              comment2 = comment2.slice(1, -1);
            }
          }
        }
        let data = body.slice(dataStart);
        if (!RE_DATA.test(data))
          return new Error("Malformed RFC4716 public key");
        data = Buffer.from(data, "base64");
        const type = readString4(data, 0, true);
        if (type === void 0)
          return new Error("Malformed RFC4716 public key");
        let pubPEM = null;
        let pubSSH = null;
        switch (type) {
          case "ssh-rsa": {
            const e = readString4(data, data._pos);
            if (e === void 0)
              return new Error("Malformed RFC4716 public key");
            const n = readString4(data, data._pos);
            if (n === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            break;
          }
          case "ssh-dss": {
            const p = readString4(data, data._pos);
            if (p === void 0)
              return new Error("Malformed RFC4716 public key");
            const q = readString4(data, data._pos);
            if (q === void 0)
              return new Error("Malformed RFC4716 public key");
            const g = readString4(data, data._pos);
            if (g === void 0)
              return new Error("Malformed RFC4716 public key");
            const y = readString4(data, data._pos);
            if (y === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLDSAPub(p, q, g, y);
            pubSSH = genOpenSSHDSAPub(p, q, g, y);
            break;
          }
          default:
            return new Error("Malformed RFC4716 public key");
        }
        return new RFC4716_Public(type, comment2, pubPEM, pubSSH, "sha1");
      };
    }
    function parseDER(data, baseType, comment2, fullType) {
      if (!isSupportedKeyType(baseType))
        return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      let algo;
      let oid;
      let pubPEM = null;
      let pubSSH = null;
      switch (baseType) {
        case "ssh-rsa": {
          const e = readString4(data, data._pos || 0);
          if (e === void 0)
            return new Error("Malformed OpenSSH public key");
          const n = readString4(data, data._pos);
          if (n === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
          algo = "sha1";
          break;
        }
        case "ssh-dss": {
          const p = readString4(data, data._pos || 0);
          if (p === void 0)
            return new Error("Malformed OpenSSH public key");
          const q = readString4(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH public key");
          const g = readString4(data, data._pos);
          if (g === void 0)
            return new Error("Malformed OpenSSH public key");
          const y = readString4(data, data._pos);
          if (y === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
          algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          const edpub = readString4(data, data._pos || 0);
          if (edpub === void 0 || edpub.length !== 32)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLEdPub(edpub);
          pubSSH = genOpenSSHEdPub(edpub);
          algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256";
          oid = "1.2.840.10045.3.1.7";
        case "ecdsa-sha2-nistp384":
          if (algo === void 0) {
            algo = "sha384";
            oid = "1.3.132.0.34";
          }
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0) {
            algo = "sha512";
            oid = "1.3.132.0.35";
          }
          if (!skipFields(data, 1))
            return new Error("Malformed OpenSSH public key");
          const ecpub = readString4(data, data._pos || 0);
          if (ecpub === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub);
          pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      }
      return new OpenSSH_Public(fullType, comment2, pubPEM, pubSSH, algo);
    }
    function isSupportedKeyType(type) {
      switch (type) {
        case "ssh-rsa":
        case "ssh-dss":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521":
          return true;
        case "ssh-ed25519":
          if (eddsaSupported)
            return true;
        default:
          return false;
      }
    }
    function isParsedKey(val) {
      if (!val)
        return false;
      return typeof val[SYM_DECRYPTED] === "boolean";
    }
    function parseKey(data, passphrase) {
      if (isParsedKey(data))
        return data;
      let origBuffer;
      if (Buffer.isBuffer(data)) {
        origBuffer = data;
        data = data.utf8Slice(0, data.length).trim();
      } else if (typeof data === "string") {
        data = data.trim();
      } else {
        return new Error("Key data must be a Buffer or string");
      }
      if (passphrase != void 0) {
        if (typeof passphrase === "string")
          passphrase = Buffer.from(passphrase);
        else if (!Buffer.isBuffer(passphrase))
          return new Error("Passphrase must be a string or Buffer when supplied");
      }
      let ret;
      if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = PPK_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Public.parse(data)) !== null)
        return ret;
      if ((ret = RFC4716_Public.parse(data)) !== null)
        return ret;
      if (origBuffer) {
        binaryKeyParser.init(origBuffer, 0);
        const type = binaryKeyParser.readString(true);
        if (type !== void 0) {
          data = binaryKeyParser.readRaw();
          if (data !== void 0) {
            ret = parseDER(data, type, "", type);
            if (ret instanceof Error)
              ret = null;
          }
        }
        binaryKeyParser.clear();
      }
      if (ret)
        return ret;
      return new Error("Unsupported key format");
    }
    module.exports = {
      isParsedKey,
      isSupportedKeyType,
      parseDERKey: (data, type) => parseDER(data, type, "", type),
      parseKey
    };
  }
});

// node_modules/ssh2/lib/agent.js
var require_agent = __commonJS({
  "node_modules/ssh2/lib/agent.js"(exports, module) {
    "use strict";
    var { Socket } = __require("net");
    var { Duplex } = __require("stream");
    var { resolve: resolve3 } = __require("path");
    var { readFile: readFile4 } = __require("fs");
    var { execFile: execFile9, spawn: spawn5 } = __require("child_process");
    var { isParsedKey, parseKey } = require_keyParser();
    var {
      makeBufferParser,
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE
    } = require_utils7();
    function once2(cb) {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        cb(...args);
      };
    }
    function concat5(buf1, buf2) {
      const combined = Buffer.allocUnsafe(buf1.length + buf2.length);
      buf1.copy(combined, 0);
      buf2.copy(combined, buf1.length);
      return combined;
    }
    function noop2() {
    }
    var EMPTY_BUF = Buffer.alloc(0);
    var binaryParser = makeBufferParser();
    var BaseAgent = class {
      getIdentities(cb) {
        cb(new Error("Missing getIdentities() implementation"));
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function")
          cb = options;
        cb(new Error("Missing sign() implementation"));
      }
    };
    var OpenSSHAgent = class extends BaseAgent {
      constructor(socketPath) {
        super();
        this.socketPath = socketPath;
      }
      getStream(cb) {
        cb = once2(cb);
        const sock = new Socket();
        sock.on("connect", () => {
          cb(null, sock);
        });
        sock.on("close", onFail).on("end", onFail).on("error", onFail);
        sock.connect(this.socketPath);
        function onFail() {
          try {
            sock.destroy();
          } catch {
          }
          cb(new Error("Failed to connect to agent"));
        }
      }
      getIdentities(cb) {
        cb = once2(cb);
        this.getStream((err, stream3) => {
          function onFail(err2) {
            if (stream3) {
              try {
                stream3.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to retrieve identities from agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream3).pipe(protocol);
          stream3.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.getIdentities((err2, keys4) => {
            if (err2)
              return onFail(err2);
            try {
              stream3.destroy();
            } catch {
            }
            cb(null, keys4);
          });
        });
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = void 0;
        } else if (typeof options !== "object" || options === null) {
          options = void 0;
        }
        cb = once2(cb);
        this.getStream((err, stream3) => {
          function onFail(err2) {
            if (stream3) {
              try {
                stream3.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to sign data with agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream3).pipe(protocol);
          stream3.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.sign(pubKey, data, options, (err2, sig) => {
            if (err2)
              return onFail(err2);
            try {
              stream3.destroy();
            } catch {
            }
            cb(null, sig);
          });
        });
      }
    };
    var PageantAgent = (() => {
      const RET_ERR_BADARGS = 10;
      const RET_ERR_UNAVAILABLE = 11;
      const RET_ERR_NOMAP = 12;
      const RET_ERR_BINSTDIN = 13;
      const RET_ERR_BINSTDOUT = 14;
      const RET_ERR_BADLEN = 15;
      const EXEPATH = resolve3(__dirname, "..", "util/pagent.exe");
      const ERROR2 = {
        [RET_ERR_BADARGS]: new Error("Invalid pagent.exe arguments"),
        [RET_ERR_UNAVAILABLE]: new Error("Pageant is not running"),
        [RET_ERR_NOMAP]: new Error("pagent.exe could not create an mmap"),
        [RET_ERR_BINSTDIN]: new Error("pagent.exe could not set mode for stdin"),
        [RET_ERR_BINSTDOUT]: new Error("pagent.exe could not set mode for stdout"),
        [RET_ERR_BADLEN]: new Error("pagent.exe did not get expected input payload")
      };
      function destroy2(stream3) {
        stream3.buffer = null;
        if (stream3.proc) {
          stream3.proc.kill();
          stream3.proc = void 0;
        }
      }
      class PageantSocket extends Duplex {
        constructor() {
          super();
          this.proc = void 0;
          this.buffer = null;
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this.buffer === null) {
            this.buffer = data;
          } else {
            const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
            this.buffer.copy(newBuffer, 0);
            data.copy(newBuffer, this.buffer.length);
            this.buffer = newBuffer;
          }
          if (this.buffer.length < 4)
            return cb();
          const len = readUInt32BE(this.buffer, 0);
          if (this.buffer.length - 4 < len)
            return cb();
          data = this.buffer.slice(0, 4 + len);
          if (this.buffer.length > 4 + len)
            return cb(new Error("Unexpected multiple agent requests"));
          this.buffer = null;
          let error5;
          const proc2 = this.proc = spawn5(EXEPATH, [data.length]);
          proc2.stdout.on("data", (data2) => {
            this.push(data2);
          });
          proc2.on("error", (err) => {
            error5 = err;
            cb(error5);
          });
          proc2.on("close", (code3) => {
            this.proc = void 0;
            if (!error5) {
              if (error5 = ERROR2[code3])
                return cb(error5);
              cb();
            }
          });
          proc2.stdin.end(data);
        }
        _final(cb) {
          destroy2(this);
          cb();
        }
        _destroy(err, cb) {
          destroy2(this);
          cb();
        }
      }
      return class PageantAgent extends OpenSSHAgent {
        getStream(cb) {
          cb(null, new PageantSocket());
        }
      };
    })();
    var CygwinAgent = /* @__PURE__ */ (() => {
      const RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
      return class CygwinAgent extends OpenSSHAgent {
        getStream(cb) {
          cb = once2(cb);
          let socketPath = this.socketPath;
          let triedCygpath = false;
          readFile4(socketPath, function readCygsocket(err, data) {
            if (err) {
              if (triedCygpath)
                return cb(new Error("Invalid cygwin unix socket path"));
              execFile9("cygpath", ["-w", socketPath], (err2, stdout2, stderr2) => {
                if (err2 || stdout2.length === 0)
                  return cb(new Error("Invalid cygwin unix socket path"));
                triedCygpath = true;
                socketPath = stdout2.toString().replace(/[\r\n]/g, "");
                readFile4(socketPath, readCygsocket);
              });
              return;
            }
            const m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
            if (!m)
              return cb(new Error("Malformed cygwin unix socket file"));
            let state2;
            let bc = 0;
            let isRetrying = false;
            const inBuf = [];
            let sock;
            let credsBuf = Buffer.alloc(12);
            const port = parseInt(m[1], 10);
            const secret = m[2].replace(/-/g, "");
            const secretBuf = Buffer.allocUnsafe(16);
            for (let i = 0, j = 0; j < 32; ++i, j += 2)
              secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
            for (let i = 0; i < 16; i += 4)
              writeUInt32LE(secretBuf, readUInt32BE(secretBuf, i), i);
            tryConnect();
            function _onconnect() {
              bc = 0;
              state2 = "secret";
              sock.write(secretBuf);
            }
            function _ondata(data2) {
              bc += data2.length;
              if (state2 === "secret") {
                if (bc === 16) {
                  bc = 0;
                  state2 = "creds";
                  sock.write(credsBuf);
                }
                return;
              }
              if (state2 === "creds") {
                if (!isRetrying)
                  inBuf.push(data2);
                if (bc === 12) {
                  sock.removeListener("connect", _onconnect);
                  sock.removeListener("data", _ondata);
                  sock.removeListener("error", onFail);
                  sock.removeListener("end", onFail);
                  sock.removeListener("close", onFail);
                  if (isRetrying)
                    return cb(null, sock);
                  isRetrying = true;
                  credsBuf = Buffer.concat(inBuf);
                  writeUInt32LE(credsBuf, process.pid, 0);
                  sock.on("error", () => {
                  });
                  sock.destroy();
                  tryConnect();
                }
              }
            }
            function onFail() {
              cb(new Error("Problem negotiating cygwin unix socket security"));
            }
            function tryConnect() {
              sock = new Socket();
              sock.on("connect", _onconnect);
              sock.on("data", _ondata);
              sock.on("error", onFail);
              sock.on("end", onFail);
              sock.on("close", onFail);
              sock.connect(port);
            }
          });
        }
      };
    })();
    var WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
    function createAgent(path14) {
      if (process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path14)) {
        return path14 === "pageant" ? new PageantAgent() : new CygwinAgent(path14);
      }
      return new OpenSSHAgent(path14);
    }
    var AgentProtocol = (() => {
      const SSH_AGENTC_REQUEST_IDENTITIES = 11;
      const SSH_AGENTC_SIGN_REQUEST = 13;
      const SSH_AGENT_FAILURE = 5;
      const SSH_AGENT_IDENTITIES_ANSWER = 12;
      const SSH_AGENT_SIGN_RESPONSE = 14;
      const SSH_AGENT_RSA_SHA2_256 = 1 << 1;
      const SSH_AGENT_RSA_SHA2_512 = 1 << 2;
      const ROLE_CLIENT = 0;
      const ROLE_SERVER = 1;
      function processResponses(protocol) {
        let ret;
        while (protocol[SYM_REQS].length) {
          const nextResponse = protocol[SYM_REQS][0][SYM_RESP];
          if (nextResponse === void 0)
            break;
          protocol[SYM_REQS].shift();
          ret = protocol.push(nextResponse);
        }
        return ret;
      }
      const SYM_TYPE = Symbol("Inbound Request Type");
      const SYM_RESP = Symbol("Inbound Request Response");
      const SYM_CTX = Symbol("Inbound Request Context");
      class AgentInboundRequest {
        constructor(type, ctx) {
          this[SYM_TYPE] = type;
          this[SYM_RESP] = void 0;
          this[SYM_CTX] = ctx;
        }
        hasResponded() {
          return this[SYM_RESP] !== void 0;
        }
        getType() {
          return this[SYM_TYPE];
        }
        getContext() {
          return this[SYM_CTX];
        }
      }
      function respond(protocol, req, data) {
        req[SYM_RESP] = data;
        return processResponses(protocol);
      }
      function cleanup(protocol) {
        protocol[SYM_BUFFER] = null;
        if (protocol[SYM_MODE] === ROLE_CLIENT) {
          const reqs = protocol[SYM_REQS];
          if (reqs && reqs.length) {
            protocol[SYM_REQS] = [];
            for (const req of reqs)
              req.cb(new Error("No reply from server"));
          }
        }
        try {
          protocol.end();
        } catch {
        }
        setImmediate(() => {
          if (!protocol[SYM_ENDED])
            protocol.emit("end");
          if (!protocol[SYM_CLOSED])
            protocol.emit("close");
        });
      }
      function onClose() {
        this[SYM_CLOSED] = true;
      }
      function onEnd() {
        this[SYM_ENDED] = true;
      }
      const SYM_REQS = Symbol("Requests");
      const SYM_MODE = Symbol("Agent Protocol Role");
      const SYM_BUFFER = Symbol("Agent Protocol Buffer");
      const SYM_MSGLEN = Symbol("Agent Protocol Current Message Length");
      const SYM_CLOSED = Symbol("Agent Protocol Closed");
      const SYM_ENDED = Symbol("Agent Protocol Ended");
      return class AgentProtocol extends Duplex {
        /*
            Notes:
              - `constraint` type consists of:
                   byte                    constraint_type
                   byte[]                  constraint_data
                where `constraint_type` is one of:
                  * SSH_AGENT_CONSTRAIN_LIFETIME
                    - `constraint_data` consists of:
                         uint32                  seconds
                  * SSH_AGENT_CONSTRAIN_CONFIRM
                    - `constraint_data` N/A
                  * SSH_AGENT_CONSTRAIN_EXTENSION
                    - `constraint_data` consists of:
                         string                  extension name
                         byte[]                  extension-specific details
        */
        constructor(isClient) {
          super({ autoDestroy: true, emitClose: false });
          this[SYM_MODE] = isClient ? ROLE_CLIENT : ROLE_SERVER;
          this[SYM_REQS] = [];
          this[SYM_BUFFER] = null;
          this[SYM_MSGLEN] = -1;
          this.once("end", onEnd);
          this.once("close", onClose);
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this[SYM_BUFFER] === null)
            this[SYM_BUFFER] = data;
          else
            this[SYM_BUFFER] = concat5(this[SYM_BUFFER], data);
          let buffer = this[SYM_BUFFER];
          let bufferLen = buffer.length;
          let p = 0;
          while (p < bufferLen) {
            if (bufferLen < 5)
              break;
            if (this[SYM_MSGLEN] === -1)
              this[SYM_MSGLEN] = readUInt32BE(buffer, p);
            if (bufferLen < 4 + this[SYM_MSGLEN])
              break;
            const msgType = buffer[p += 4];
            ++p;
            if (this[SYM_MODE] === ROLE_CLIENT) {
              if (this[SYM_REQS].length === 0)
                return cb(new Error("Received unexpected message from server"));
              const req = this[SYM_REQS].shift();
              switch (msgType) {
                case SSH_AGENT_FAILURE:
                  req.cb(new Error("Agent responded with failure"));
                  break;
                case SSH_AGENT_IDENTITIES_ANSWER: {
                  if (req.type !== SSH_AGENTC_REQUEST_IDENTITIES)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  const numKeys = binaryParser.readUInt32BE();
                  if (numKeys === void 0) {
                    binaryParser.clear();
                    return cb(new Error("Malformed agent response"));
                  }
                  const keys4 = [];
                  for (let i = 0; i < numKeys; ++i) {
                    let pubKey = binaryParser.readString();
                    if (pubKey === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    const comment2 = binaryParser.readString(true);
                    if (comment2 === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    pubKey = parseKey(pubKey);
                    if (pubKey instanceof Error)
                      continue;
                    pubKey.comment = pubKey.comment || comment2;
                    keys4.push(pubKey);
                  }
                  p = binaryParser.pos();
                  binaryParser.clear();
                  req.cb(null, keys4);
                  break;
                }
                case SSH_AGENT_SIGN_RESPONSE: {
                  if (req.type !== SSH_AGENTC_SIGN_REQUEST)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let signature = binaryParser.readString();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed agent response"));
                  binaryParser.init(signature, 0);
                  binaryParser.readString(true);
                  signature = binaryParser.readString();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed OpenSSH signature format"));
                  req.cb(null, signature);
                  break;
                }
                default:
                  return cb(
                    new Error("Agent responded with unsupported message type")
                  );
              }
            } else {
              switch (msgType) {
                case SSH_AGENTC_REQUEST_IDENTITIES: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.emit("identities", req);
                  break;
                }
                case SSH_AGENTC_SIGN_REQUEST: {
                  binaryParser.init(buffer, p);
                  let pubKey = binaryParser.readString();
                  const data2 = binaryParser.readString();
                  const flagsVal = binaryParser.readUInt32BE();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (flagsVal === void 0) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  pubKey = parseKey(pubKey);
                  if (pubKey instanceof Error) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  const flags = {
                    hash: void 0
                  };
                  let ctx;
                  if (pubKey.type === "ssh-rsa") {
                    if (flagsVal & SSH_AGENT_RSA_SHA2_256) {
                      ctx = "rsa-sha2-256";
                      flags.hash = "sha256";
                    } else if (flagsVal & SSH_AGENT_RSA_SHA2_512) {
                      ctx = "rsa-sha2-512";
                      flags.hash = "sha512";
                    }
                  }
                  if (ctx === void 0)
                    ctx = pubKey.type;
                  const req = new AgentInboundRequest(msgType, ctx);
                  this[SYM_REQS].push(req);
                  this.emit("sign", req, pubKey, data2, flags);
                  break;
                }
                default: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.failureReply(req);
                }
              }
            }
            this[SYM_MSGLEN] = -1;
            if (p === bufferLen) {
              this[SYM_BUFFER] = null;
              break;
            } else {
              this[SYM_BUFFER] = buffer = buffer.slice(p);
              bufferLen = buffer.length;
              p = 0;
            }
          }
          cb();
        }
        _destroy(err, cb) {
          cleanup(this);
          cb();
        }
        _final(cb) {
          cleanup(this);
          cb();
        }
        // Client->Server messages =================================================
        sign(pubKey, data, options, cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          if (typeof options === "function") {
            cb = options;
            options = void 0;
          } else if (typeof options !== "object" || options === null) {
            options = void 0;
          }
          let flags = 0;
          pubKey = parseKey(pubKey);
          if (pubKey instanceof Error)
            throw new Error("Invalid public key argument");
          if (pubKey.type === "ssh-rsa" && options) {
            switch (options.hash) {
              case "sha256":
                flags = SSH_AGENT_RSA_SHA2_256;
                break;
              case "sha512":
                flags = SSH_AGENT_RSA_SHA2_512;
                break;
            }
          }
          pubKey = pubKey.getPublicSSH();
          const type = SSH_AGENTC_SIGN_REQUEST;
          const keyLen = pubKey.length;
          const dataLen = data.length;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + 4 + keyLen + 4 + dataLen + 4);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          writeUInt32BE(buf, keyLen, ++p);
          pubKey.copy(buf, p += 4);
          writeUInt32BE(buf, dataLen, p += keyLen);
          data.copy(buf, p += 4);
          writeUInt32BE(buf, flags, p += dataLen);
          if (typeof cb !== "function")
            cb = noop2;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        getIdentities(cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          const type = SSH_AGENTC_REQUEST_IDENTITIES;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          if (typeof cb !== "function")
            cb = noop2;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        // Server->Client messages =================================================
        failureReply(req) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_FAILURE;
          return respond(this, req, buf);
        }
        getIdentitiesReply(req, keys4) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_REQUEST_IDENTITIES)
            throw new Error("Invalid response to request");
          if (!Array.isArray(keys4))
            throw new Error("Keys argument must be an array");
          let totalKeysLen = 4;
          const newKeys = [];
          for (let i = 0; i < keys4.length; ++i) {
            const entry = keys4[i];
            if (typeof entry !== "object" || entry === null)
              throw new Error(`Invalid key entry: ${entry}`);
            let pubKey;
            let comment2;
            if (isParsedKey(entry)) {
              pubKey = entry;
            } else if (isParsedKey(entry.pubKey)) {
              pubKey = entry.pubKey;
            } else {
              if (typeof entry.pubKey !== "object" || entry.pubKey === null)
                continue;
              ({ pubKey, comment: comment2 } = entry.pubKey);
              pubKey = parseKey(pubKey);
              if (pubKey instanceof Error)
                continue;
            }
            comment2 = pubKey.comment || comment2;
            pubKey = pubKey.getPublicSSH();
            totalKeysLen += 4 + pubKey.length;
            if (comment2 && typeof comment2 === "string")
              comment2 = Buffer.from(comment2);
            else if (!Buffer.isBuffer(comment2))
              comment2 = EMPTY_BUF;
            totalKeysLen += 4 + comment2.length;
            newKeys.push({ pubKey, comment: comment2 });
          }
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + totalKeysLen);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_IDENTITIES_ANSWER;
          writeUInt32BE(buf, newKeys.length, ++p);
          p += 4;
          for (let i = 0; i < newKeys.length; ++i) {
            const { pubKey, comment: comment2 } = newKeys[i];
            writeUInt32BE(buf, pubKey.length, p);
            pubKey.copy(buf, p += 4);
            writeUInt32BE(buf, comment2.length, p += pubKey.length);
            p += 4;
            if (comment2.length) {
              comment2.copy(buf, p);
              p += comment2.length;
            }
          }
          return respond(this, req, buf);
        }
        signReply(req, signature) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_SIGN_REQUEST)
            throw new Error("Invalid response to request");
          if (!Buffer.isBuffer(signature))
            throw new Error("Signature argument must be a Buffer");
          if (signature.length === 0)
            throw new Error("Signature argument must be non-empty");
          let p = 0;
          const sigFormat = req.getContext();
          const sigFormatLen = Buffer.byteLength(sigFormat);
          const buf = Buffer.allocUnsafe(
            4 + 1 + 4 + 4 + sigFormatLen + 4 + signature.length
          );
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_SIGN_RESPONSE;
          writeUInt32BE(buf, 4 + sigFormatLen + 4 + signature.length, ++p);
          writeUInt32BE(buf, sigFormatLen, p += 4);
          buf.utf8Write(sigFormat, p += 4, sigFormatLen);
          writeUInt32BE(buf, signature.length, p += sigFormatLen);
          signature.copy(buf, p += 4);
          return respond(this, req, buf);
        }
      };
    })();
    var SYM_AGENT = Symbol("Agent");
    var SYM_AGENT_KEYS = Symbol("Agent Keys");
    var SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index");
    var SYM_AGENT_CBS = Symbol("Agent Init Callbacks");
    var AgentContext = class {
      constructor(agent) {
        if (typeof agent === "string")
          agent = createAgent(agent);
        else if (!isAgent(agent))
          throw new Error("Invalid agent argument");
        this[SYM_AGENT] = agent;
        this[SYM_AGENT_KEYS] = null;
        this[SYM_AGENT_KEYS_IDX] = -1;
        this[SYM_AGENT_CBS] = null;
      }
      init(cb) {
        if (typeof cb !== "function")
          cb = noop2;
        if (this[SYM_AGENT_KEYS] === null) {
          if (this[SYM_AGENT_CBS] === null) {
            this[SYM_AGENT_CBS] = [cb];
            const doCbs = (...args) => {
              process.nextTick(() => {
                const cbs = this[SYM_AGENT_CBS];
                this[SYM_AGENT_CBS] = null;
                for (const cb2 of cbs)
                  cb2(...args);
              });
            };
            this[SYM_AGENT].getIdentities(once2((err, keys4) => {
              if (err)
                return doCbs(err);
              if (!Array.isArray(keys4)) {
                return doCbs(new Error(
                  "Agent implementation failed to provide keys"
                ));
              }
              const newKeys = [];
              for (let key of keys4) {
                key = parseKey(key);
                if (key instanceof Error) {
                  continue;
                }
                newKeys.push(key);
              }
              this[SYM_AGENT_KEYS] = newKeys;
              this[SYM_AGENT_KEYS_IDX] = -1;
              doCbs();
            }));
          } else {
            this[SYM_AGENT_CBS].push(cb);
          }
        } else {
          process.nextTick(cb);
        }
      }
      nextKey() {
        if (this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return false;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      currentKey() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return null;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      pos() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return -1;
        }
        return this[SYM_AGENT_KEYS_IDX];
      }
      reset() {
        this[SYM_AGENT_KEYS_IDX] = -1;
      }
      sign(...args) {
        this[SYM_AGENT].sign(...args);
      }
    };
    function isAgent(val) {
      return val instanceof BaseAgent;
    }
    module.exports = {
      AgentContext,
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      isAgent,
      OpenSSHAgent,
      PageantAgent
    };
  }
});

// node_modules/ssh2/lib/protocol/zlib.js
var require_zlib = __commonJS({
  "node_modules/ssh2/lib/protocol/zlib.js"(exports, module) {
    "use strict";
    var { kMaxLength } = __require("buffer");
    var {
      createInflate,
      constants: {
        DEFLATE,
        INFLATE,
        Z_DEFAULT_CHUNK,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_MEMLEVEL,
        Z_DEFAULT_STRATEGY,
        Z_DEFAULT_WINDOWBITS,
        Z_PARTIAL_FLUSH
      }
    } = __require("zlib");
    var ZlibHandle = createInflate()._handle.constructor;
    function processCallback() {
      throw new Error("Should not get here");
    }
    function zlibOnError(message3, errno, code3) {
      const self2 = this._owner;
      const error5 = new Error(message3);
      error5.errno = errno;
      error5.code = code3;
      self2._err = error5;
    }
    function _close2(engine) {
      if (!engine._handle)
        return;
      engine._handle.close();
      engine._handle = null;
    }
    var Zlib2 = class {
      constructor(mode2) {
        const windowBits = Z_DEFAULT_WINDOWBITS;
        const level = Z_DEFAULT_COMPRESSION;
        const memLevel = Z_DEFAULT_MEMLEVEL;
        const strategy = Z_DEFAULT_STRATEGY;
        const dictionary = void 0;
        this._err = void 0;
        this._writeState = new Uint32Array(2);
        this._chunkSize = Z_DEFAULT_CHUNK;
        this._maxOutputLength = kMaxLength;
        this._outBuffer = Buffer.allocUnsafe(this._chunkSize);
        this._outOffset = 0;
        this._handle = new ZlibHandle(mode2);
        this._handle._owner = this;
        this._handle.onerror = zlibOnError;
        this._handle.init(
          windowBits,
          level,
          memLevel,
          strategy,
          this._writeState,
          processCallback,
          dictionary
        );
      }
      writeSync(chunk, retChunks) {
        const handle = this._handle;
        if (!handle)
          throw new Error("Invalid Zlib instance");
        let availInBefore = chunk.length;
        let availOutBefore = this._chunkSize - this._outOffset;
        let inOff = 0;
        let availOutAfter;
        let availInAfter;
        let buffers;
        let nread = 0;
        const state2 = this._writeState;
        let buffer = this._outBuffer;
        let offset = this._outOffset;
        const chunkSize = this._chunkSize;
        while (true) {
          handle.writeSync(
            Z_PARTIAL_FLUSH,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            buffer,
            // out
            offset,
            // out_off
            availOutBefore
          );
          if (this._err)
            throw this._err;
          availOutAfter = state2[0];
          availInAfter = state2[1];
          const inDelta = availInBefore - availInAfter;
          const have = availOutBefore - availOutAfter;
          if (have > 0) {
            const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);
            offset += have;
            if (!buffers)
              buffers = out;
            else if (buffers.push === void 0)
              buffers = [buffers, out];
            else
              buffers.push(out);
            nread += out.byteLength;
            if (nread > this._maxOutputLength) {
              _close2(this);
              throw new Error(
                `Output length exceeded maximum of ${this._maxOutputLength}`
              );
            }
          } else if (have !== 0) {
            throw new Error("have should not go down");
          }
          if (availOutAfter === 0 || offset >= chunkSize) {
            availOutBefore = chunkSize;
            offset = 0;
            buffer = Buffer.allocUnsafe(chunkSize);
          }
          if (availOutAfter === 0) {
            inOff += inDelta;
            availInBefore = availInAfter;
          } else {
            break;
          }
        }
        this._outBuffer = buffer;
        this._outOffset = offset;
        if (nread === 0)
          buffers = Buffer.alloc(0);
        if (retChunks) {
          buffers.totalLen = nread;
          return buffers;
        }
        if (buffers.push === void 0)
          return buffers;
        const output8 = Buffer.allocUnsafe(nread);
        for (let i = 0, p = 0; i < buffers.length; ++i) {
          const buf = buffers[i];
          output8.set(buf, p);
          p += buf.length;
        }
        return output8;
      }
    };
    var ZlibPacketWriter = class {
      constructor(protocol) {
        this.allocStart = 0;
        this.allocStartKEX = 0;
        this._protocol = protocol;
        this._zlib = new Zlib2(DEFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close2(this._zlib);
      }
      alloc(payloadSize, force2) {
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(payload, force2) {
        if (this._protocol._kexinit === void 0 || force2) {
          const output8 = this._zlib.writeSync(payload, true);
          const packet = this._protocol._cipher.allocPacket(output8.totalLen);
          if (output8.push === void 0) {
            packet.set(output8, 5);
          } else {
            for (let i = 0, p = 5; i < output8.length; ++i) {
              const chunk = output8[i];
              packet.set(chunk, p);
              p += chunk.length;
            }
          }
          return packet;
        }
        return payload;
      }
    };
    var PacketWriter = class {
      constructor(protocol) {
        this.allocStart = 5;
        this.allocStartKEX = 5;
        this._protocol = protocol;
      }
      cleanup() {
      }
      alloc(payloadSize, force2) {
        if (this._protocol._kexinit === void 0 || force2)
          return this._protocol._cipher.allocPacket(payloadSize);
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(packet, force2) {
        return packet;
      }
    };
    var ZlibPacketReader = class {
      constructor() {
        this._zlib = new Zlib2(INFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close2(this._zlib);
      }
      read(data) {
        return this._zlib.writeSync(data, false);
      }
    };
    var PacketReader = class {
      cleanup() {
      }
      read(data) {
        return data;
      }
    };
    module.exports = {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.misc.js
var require_handlers_misc = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.misc.js"(exports, module) {
    "use strict";
    var {
      bufferSlice,
      bufferParser,
      doFatalError,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var {
      CHANNEL_OPEN_FAILURE,
      COMPAT,
      MESSAGE,
      TERMINAL_MODE
    } = require_constants5();
    var {
      parseKey
    } = require_keyParser();
    var TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value4]) => ({ ...obj, [key]: value4 }), {});
    module.exports = {
      // Transport layer protocol ==================================================
      [MESSAGE.DISCONNECT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const reason = bufferParser.readUInt32BE();
        const desc = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DISCONNECT packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: Received DISCONNECT (${reason}, "${desc}")`
        );
        const handler = self2._handlers.DISCONNECT;
        handler && handler(self2, reason, desc);
      },
      [MESSAGE.IGNORE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received IGNORE");
      },
      [MESSAGE.UNIMPLEMENTED]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const seqno = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (seqno === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed UNIMPLEMENTED packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
      },
      [MESSAGE.DEBUG]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const display = bufferParser.readBool();
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DEBUG packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received DEBUG");
        const handler = self2._handlers.DEBUG;
        handler && handler(self2, display, msg);
      },
      [MESSAGE.SERVICE_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name5 = bufferParser.readString(true);
        bufferParser.clear();
        if (name5 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name5})`);
        const handler = self2._handlers.SERVICE_REQUEST;
        handler && handler(self2, name5);
      },
      [MESSAGE.SERVICE_ACCEPT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name5 = bufferParser.readString(true);
        bufferParser.clear();
        if (name5 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_ACCEPT packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name5})`);
        const handler = self2._handlers.SERVICE_ACCEPT;
        handler && handler(self2, name5);
      },
      [MESSAGE.EXT_INFO]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const numExts = bufferParser.readUInt32BE();
        let exts;
        if (numExts !== void 0) {
          exts = [];
          for (let i = 0; i < numExts; ++i) {
            const name5 = bufferParser.readString(true);
            const data = bufferParser.readString();
            if (data !== void 0) {
              switch (name5) {
                case "server-sig-algs": {
                  const algs = data.latin1Slice(0, data.length).split(",");
                  exts.push({ name: name5, algs });
                  continue;
                }
                default:
                  continue;
              }
            }
            exts = void 0;
            break;
          }
        }
        bufferParser.clear();
        if (exts === void 0)
          return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
        self2._debug && self2._debug("Inbound: Received EXT_INFO");
        const handler = self2._handlers.EXT_INFO;
        handler && handler(self2, exts);
      },
      // User auth protocol -- generic =============================================
      [MESSAGE.USERAUTH_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const user = bufferParser.readString(true);
        const service = bufferParser.readString(true);
        const method = bufferParser.readString(true);
        let methodData;
        let methodDesc;
        switch (method) {
          case "none":
            methodData = null;
            break;
          case "password": {
            const isChange = bufferParser.readBool();
            if (isChange !== void 0) {
              methodData = bufferParser.readString(true);
              if (methodData !== void 0 && isChange) {
                const newPassword = bufferParser.readString(true);
                if (newPassword !== void 0)
                  methodData = { oldPassword: methodData, newPassword };
                else
                  methodData = void 0;
              }
            }
            break;
          }
          case "publickey": {
            const hasSig = bufferParser.readBool();
            if (hasSig !== void 0) {
              const keyAlgo = bufferParser.readString(true);
              let realKeyAlgo = keyAlgo;
              const key = bufferParser.readString();
              let hashAlgo;
              switch (keyAlgo) {
                case "rsa-sha2-256":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha256";
                  break;
                case "rsa-sha2-512":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha512";
                  break;
              }
              if (hasSig) {
                const blobEnd = bufferParser.pos();
                let signature = bufferParser.readString();
                if (signature !== void 0) {
                  if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                    signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
                  }
                  signature = sigSSHToASN1(signature, realKeyAlgo);
                  if (signature) {
                    const sessionID = self2._kex.sessionID;
                    const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                    writeUInt32BE(blob, sessionID.length, 0);
                    blob.set(sessionID, 4);
                    blob.set(
                      new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                      4 + sessionID.length
                    );
                    methodData = {
                      keyAlgo: realKeyAlgo,
                      key,
                      signature,
                      blob,
                      hashAlgo
                    };
                  }
                }
              } else {
                methodData = { keyAlgo: realKeyAlgo, key, hashAlgo };
                methodDesc = "publickey -- check";
              }
            }
            break;
          }
          case "hostbased": {
            const keyAlgo = bufferParser.readString(true);
            let realKeyAlgo = keyAlgo;
            const key = bufferParser.readString();
            const localHostname = bufferParser.readString(true);
            const localUsername = bufferParser.readString(true);
            let hashAlgo;
            switch (keyAlgo) {
              case "rsa-sha2-256":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha512";
                break;
            }
            const blobEnd = bufferParser.pos();
            let signature = bufferParser.readString();
            if (signature !== void 0) {
              if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
              }
              signature = sigSSHToASN1(signature, realKeyAlgo);
              if (signature !== void 0) {
                const sessionID = self2._kex.sessionID;
                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                writeUInt32BE(blob, sessionID.length, 0);
                blob.set(sessionID, 4);
                blob.set(
                  new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                  4 + sessionID.length
                );
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key,
                  signature,
                  blob,
                  localHostname,
                  localUsername,
                  hashAlgo
                };
              }
            }
            break;
          }
          case "keyboard-interactive":
            bufferParser.skipString();
            methodData = bufferParser.readList();
            break;
          default:
            if (method !== void 0)
              methodData = bufferParser.readRaw();
        }
        bufferParser.clear();
        if (methodData === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_REQUEST packet"
          );
        }
        if (methodDesc === void 0)
          methodDesc = method;
        self2._authsQueue.push(method);
        self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
        const handler = self2._handlers.USERAUTH_REQUEST;
        handler && handler(self2, user, service, method, methodData);
      },
      [MESSAGE.USERAUTH_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const authMethods = bufferParser.readList();
        const partialSuccess = bufferParser.readBool();
        bufferParser.clear();
        if (partialSuccess === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_FAILURE;
        handler && handler(self2, authMethods, partialSuccess);
      },
      [MESSAGE.USERAUTH_SUCCESS]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS");
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_SUCCESS;
        handler && handler(self2);
      },
      [MESSAGE.USERAUTH_BANNER]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_BANNER packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
        const handler = self2._handlers.USERAUTH_BANNER;
        handler && handler(self2, msg);
      },
      // User auth protocol -- method-specific =====================================
      60: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
          return;
        }
        switch (self2._authsQueue[0]) {
          case "password": {
            bufferParser.init(payload, 1);
            const prompt = bufferParser.readString(true);
            const lang = bufferParser.readString();
            bufferParser.clear();
            if (lang === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
            const handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
            handler && handler(self2, prompt);
            break;
          }
          case "publickey": {
            bufferParser.init(payload, 1);
            const keyAlgo = bufferParser.readString(true);
            const key = bufferParser.readString();
            bufferParser.clear();
            if (key === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PK_OK packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK");
            self2._authsQueue.shift();
            const handler = self2._handlers.USERAUTH_PK_OK;
            handler && handler(self2, keyAlgo, key);
            break;
          }
          case "keyboard-interactive": {
            bufferParser.init(payload, 1);
            const name5 = bufferParser.readString(true);
            const instructions = bufferParser.readString(true);
            bufferParser.readString();
            const numPrompts = bufferParser.readUInt32BE();
            let prompts;
            if (numPrompts !== void 0) {
              prompts = new Array(numPrompts);
              let i;
              for (i = 0; i < numPrompts; ++i) {
                const prompt = bufferParser.readString(true);
                const echo = bufferParser.readBool();
                if (echo === void 0)
                  break;
                prompts[i] = { prompt, echo };
              }
              if (i !== numPrompts)
                prompts = void 0;
            }
            bufferParser.clear();
            if (prompts === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_INFO_REQUEST packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
            const handler = self2._handlers.USERAUTH_INFO_REQUEST;
            handler && handler(self2, name5, instructions, prompts);
            break;
          }
          default:
            self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
        }
      },
      61: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
          return;
        }
        if (self2._authsQueue[0] !== "keyboard-interactive") {
          return doFatalError(
            self2,
            "Inbound: Received unexpected payload type 61"
          );
        }
        bufferParser.init(payload, 1);
        const numResponses = bufferParser.readUInt32BE();
        let responses;
        if (numResponses !== void 0) {
          responses = new Array(numResponses);
          let i;
          for (i = 0; i < numResponses; ++i) {
            const response = bufferParser.readString(true);
            if (response === void 0)
              break;
            responses[i] = response;
          }
          if (i !== numResponses)
            responses = void 0;
        }
        bufferParser.clear();
        if (responses === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_INFO_RESPONSE packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
        const handler = self2._handlers.USERAUTH_INFO_RESPONSE;
        handler && handler(self2, responses);
      },
      // Connection protocol -- generic ============================================
      [MESSAGE.GLOBAL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name5 = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (name5) {
            case "tcpip-forward":
            case "cancel-tcpip-forward": {
              const bindAddr = bufferParser.readString(true);
              const bindPort = bufferParser.readUInt32BE();
              if (bindPort !== void 0)
                data = { bindAddr, bindPort };
              break;
            }
            case "streamlocal-forward@openssh.com":
            case "cancel-streamlocal-forward@openssh.com": {
              const socketPath = bufferParser.readString(true);
              if (socketPath !== void 0)
                data = { socketPath };
              break;
            }
            case "no-more-sessions@openssh.com":
              data = null;
              break;
            case "hostkeys-00@openssh.com": {
              data = [];
              while (bufferParser.avail() > 0) {
                const keyRaw = bufferParser.readString();
                if (keyRaw === void 0) {
                  data = void 0;
                  break;
                }
                const key = parseKey(keyRaw);
                if (!(key instanceof Error))
                  data.push(key);
              }
              break;
            }
            default:
              data = bufferParser.readRaw();
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed GLOBAL_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name5})`);
        const handler = self2._handlers.GLOBAL_REQUEST;
        if (handler)
          handler(self2, name5, wantReply, data);
        else
          self2.requestFailure();
      },
      [MESSAGE.REQUEST_SUCCESS]: (self2, payload) => {
        const data = payload.length > 1 ? bufferSlice(payload, 1) : null;
        self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
        const handler = self2._handlers.REQUEST_SUCCESS;
        handler && handler(self2, data);
      },
      [MESSAGE.REQUEST_FAILURE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
        const handler = self2._handlers.REQUEST_FAILURE;
        handler && handler(self2);
      },
      // Connection protocol -- channel-related ====================================
      [MESSAGE.CHANNEL_OPEN]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const type = bufferParser.readString(true);
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        let channelInfo;
        switch (type) {
          case "forwarded-tcpip":
          case "direct-tcpip": {
            const destIP = bufferParser.readString(true);
            const destPort = bufferParser.readUInt32BE();
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { destIP, destPort, srcIP, srcPort }
              };
            }
            break;
          }
          case "forwarded-streamlocal@openssh.com":
          case "direct-streamlocal@openssh.com": {
            const socketPath = bufferParser.readString(true);
            if (socketPath !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { socketPath }
              };
            }
            break;
          }
          case "x11": {
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { srcIP, srcPort }
              };
            }
            break;
          }
          default:
            channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: {}
            };
        }
        bufferParser.clear();
        if (channelInfo === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);
        const handler = self2._handlers.CHANNEL_OPEN;
        if (handler) {
          handler(self2, channelInfo);
        } else {
          self2.channelOpenFail(
            channelInfo.sender,
            CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,
            "",
            ""
          );
        }
      },
      [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        const data = bufferParser.avail() ? bufferParser.readRaw() : void 0;
        bufferParser.clear();
        if (packetSize === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`
        );
        const handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
        if (handler)
          handler(self2, { recipient, sender, window: window2, packetSize, data });
      },
      [MESSAGE.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const reason = bufferParser.readUInt32BE();
        const description = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_OPEN_FAILURE;
        handler && handler(self2, recipient, reason, description);
      },
      [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const bytesToAdd = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (bytesToAdd === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`
        );
        const handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
        handler && handler(self2, recipient, bytesToAdd);
      },
      [MESSAGE.CHANNEL_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_DATA packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
        const handler = self2._handlers.CHANNEL_DATA;
        handler && handler(self2, recipient, data);
      },
      [MESSAGE.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EXTENDED_DATA packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`
        );
        const handler = self2._handlers.CHANNEL_EXTENDED_DATA;
        handler && handler(self2, recipient, data, type);
      },
      [MESSAGE.CHANNEL_EOF]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EOF packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_EOF;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_CLOSE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_CLOSE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_CLOSE;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (type) {
            case "exit-status":
              data = bufferParser.readUInt32BE();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "exit-signal": {
              let signal;
              let coreDumped;
              if (self2._compatFlags & COMPAT.OLD_EXIT) {
                const num = bufferParser.readUInt32BE();
                switch (num) {
                  case 1:
                    signal = "HUP";
                    break;
                  case 2:
                    signal = "INT";
                    break;
                  case 3:
                    signal = "QUIT";
                    break;
                  case 6:
                    signal = "ABRT";
                    break;
                  case 9:
                    signal = "KILL";
                    break;
                  case 14:
                    signal = "ALRM";
                    break;
                  case 15:
                    signal = "TERM";
                    break;
                  default:
                    if (num !== void 0) {
                      signal = `UNKNOWN (${num})`;
                    }
                }
                coreDumped = false;
              } else {
                signal = bufferParser.readString(true);
                coreDumped = bufferParser.readBool();
                if (coreDumped === void 0)
                  signal = void 0;
              }
              const errorMessage = bufferParser.readString(true);
              if (bufferParser.skipString() !== void 0)
                data = { signal, coreDumped, errorMessage };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`
              );
              break;
            }
            case "pty-req": {
              const term = bufferParser.readString(true);
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width2 = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              const modesBinary = bufferParser.readString();
              if (modesBinary !== void 0) {
                bufferParser.init(modesBinary, 1);
                let modes = {};
                while (bufferParser.avail()) {
                  const opcode = bufferParser.readByte();
                  if (opcode === TERMINAL_MODE.TTY_OP_END)
                    break;
                  const name5 = TERMINAL_MODE_BY_VALUE[opcode];
                  const value4 = bufferParser.readUInt32BE();
                  if (opcode === void 0 || name5 === void 0 || value4 === void 0) {
                    modes = void 0;
                    break;
                  }
                  modes[name5] = value4;
                }
                if (modes !== void 0)
                  data = { term, cols, rows, width: width2, height, modes };
              }
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "window-change": {
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width2 = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              if (height !== void 0)
                data = { cols, rows, width: width2, height };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "x11-req": {
              const single = bufferParser.readBool();
              const protocol = bufferParser.readString(true);
              const cookie = bufferParser.readString();
              const screen = bufferParser.readUInt32BE();
              if (screen !== void 0)
                data = { single, protocol, cookie, screen };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "env": {
              const name5 = bufferParser.readString(true);
              const value4 = bufferParser.readString(true);
              if (value4 !== void 0)
                data = { name: name5, value: value4 };
              if (self2._debug) {
                self2._debug(
                  `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${name5}=${value4})`
                );
              }
              break;
            }
            case "shell":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            case "exec":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "subsystem":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "signal":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "xon-xoff":
              data = bufferParser.readBool();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "auth-agent-req@openssh.com":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            default:
              data = bufferParser.avail() ? bufferParser.readRaw() : null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_REQUEST packet"
          );
        }
        const handler = self2._handlers.CHANNEL_REQUEST;
        handler && handler(self2, recipient, type, wantReply, data);
      },
      [MESSAGE.CHANNEL_SUCCESS]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_SUCCESS packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_SUCCESS;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_FAILURE;
        handler && handler(self2, recipient);
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.js
var require_handlers = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.js"(exports, module) {
    "use strict";
    var MESSAGE_HANDLERS = new Array(256);
    [
      require_kex().HANDLERS,
      require_handlers_misc()
    ].forEach((handlers) => {
      for (let [type, handler] of Object.entries(handlers)) {
        type = +type;
        if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length)
          MESSAGE_HANDLERS[type] = handler;
      }
    });
    module.exports = MESSAGE_HANDLERS;
  }
});

// node_modules/ssh2/lib/protocol/kex.js
var require_kex = __commonJS({
  "node_modules/ssh2/lib/protocol/kex.js"(exports, module) {
    "use strict";
    var {
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash: createHash2,
      createPublicKey,
      diffieHellman,
      generateKeyPairSync,
      randomFillSync
    } = __require("crypto");
    var { Ber } = require_lib2();
    var {
      COMPAT,
      curve25519Supported,
      DEFAULT_KEX,
      DEFAULT_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      DEFAULT_MAC,
      DEFAULT_COMPRESSION,
      DISCONNECT_REASON,
      MESSAGE
    } = require_constants5();
    var {
      CIPHER_INFO,
      createCipher,
      createDecipher,
      MAC_INFO
    } = require_crypto();
    var { parseDERKey } = require_keyParser();
    var {
      bufferFill,
      bufferParser,
      convertSignature,
      doFatalError,
      FastBuffer,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MESSAGE_HANDLERS;
    var GEX_MIN_BITS = 2048;
    var GEX_MAX_BITS = 8192;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function kexinit(self2) {
      let payload;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        const entry = self2._offer.lists.kex;
        let kex = entry.array;
        let found = false;
        for (let i = 0; i < kex.length; ++i) {
          if (kex[i].includes("group-exchange")) {
            if (!found) {
              found = true;
              kex = kex.slice();
            }
            kex.splice(i--, 1);
          }
        }
        if (found) {
          let len = 1 + 16 + self2._offer.totalSize + 1 + 4;
          const newKexBuf = Buffer.from(kex.join(","));
          len -= entry.buffer.length - newKexBuf.length;
          const all5 = self2._offer.lists.all;
          const rest2 = new Uint8Array(
            all5.buffer,
            all5.byteOffset + 4 + entry.buffer.length,
            all5.length - (4 + entry.buffer.length)
          );
          payload = Buffer.allocUnsafe(len);
          writeUInt32BE(payload, newKexBuf.length, 17);
          payload.set(newKexBuf, 17 + 4);
          payload.set(rest2, 17 + 4 + newKexBuf.length);
        }
      }
      if (payload === void 0) {
        payload = Buffer.allocUnsafe(1 + 16 + self2._offer.totalSize + 1 + 4);
        self2._offer.copyAllTo(payload, 17);
      }
      self2._debug && self2._debug("Outbound: Sending KEXINIT");
      payload[0] = MESSAGE.KEXINIT;
      randomFillSync(payload, 1, 16);
      bufferFill(payload, 0, payload.length - 5);
      self2._kexinit = payload;
      self2._packetRW.write.allocStart = 0;
      {
        const p = self2._packetRW.write.allocStartKEX;
        const packet = self2._packetRW.write.alloc(payload.length, true);
        packet.set(payload, p);
        self2._cipher.encrypt(self2._packetRW.write.finalize(packet, true));
      }
    }
    function handleKexInit(self2, payload) {
      const init4 = {
        kex: void 0,
        serverHostKey: void 0,
        cs: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        },
        sc: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        }
      };
      bufferParser.init(payload, 17);
      if ((init4.kex = bufferParser.readList()) === void 0 || (init4.serverHostKey = bufferParser.readList()) === void 0 || (init4.cs.cipher = bufferParser.readList()) === void 0 || (init4.sc.cipher = bufferParser.readList()) === void 0 || (init4.cs.mac = bufferParser.readList()) === void 0 || (init4.sc.mac = bufferParser.readList()) === void 0 || (init4.cs.compress = bufferParser.readList()) === void 0 || (init4.sc.compress = bufferParser.readList()) === void 0 || (init4.cs.lang = bufferParser.readList()) === void 0 || (init4.sc.lang = bufferParser.readList()) === void 0) {
        bufferParser.clear();
        return doFatalError(
          self2,
          "Received malformed KEXINIT",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      const pos2 = bufferParser.pos();
      const firstFollows = pos2 < payload.length && payload[pos2] === 1;
      bufferParser.clear();
      const local4 = self2._offer;
      const remote = init4;
      let localKex = local4.lists.kex.array;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let found = false;
        for (let i2 = 0; i2 < localKex.length; ++i2) {
          if (localKex[i2].indexOf("group-exchange") !== -1) {
            if (!found) {
              found = true;
              localKex = localKex.slice();
            }
            localKex.splice(i2--, 1);
          }
        }
      }
      let clientList;
      let serverList;
      let i;
      const debug2 = self2._debug;
      debug2 && debug2("Inbound: Handshake in progress");
      debug2 && debug2(`Handshake: (local) KEX method: ${localKex}`);
      debug2 && debug2(`Handshake: (remote) KEX method: ${remote.kex}`);
      let remoteExtInfoEnabled;
      if (self2._server) {
        serverList = localKex;
        clientList = remote.kex;
        remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1;
      } else {
        serverList = remote.kex;
        clientList = localKex;
        remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1;
      }
      if (self2._strictMode === void 0) {
        if (self2._server) {
          self2._strictMode = clientList.indexOf("kex-strict-c-v00@openssh.com") !== -1;
        } else {
          self2._strictMode = serverList.indexOf("kex-strict-s-v00@openssh.com") !== -1;
        }
        if (self2._strictMode) {
          debug2 && debug2("Handshake: strict KEX mode enabled");
          if (self2._decipher.inSeqno !== 1) {
            if (debug2)
              debug2("Handshake: KEXINIT not first packet in strict KEX mode");
            return doFatalError(
              self2,
              "Handshake failed: KEXINIT not first packet in strict KEX mode",
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
        }
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: no matching key exchange algorithm");
        return doFatalError(
          self2,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.kex = clientList[i];
      debug2 && debug2(`Handshake: KEX algorithm: ${clientList[i]}`);
      if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {
        self2._skipNextInboundPacket = true;
      }
      const localSrvHostKey = local4.lists.serverHostKey.array;
      debug2 && debug2(`Handshake: (local) Host key format: ${localSrvHostKey}`);
      debug2 && debug2(
        `Handshake: (remote) Host key format: ${remote.serverHostKey}`
      );
      if (self2._server) {
        serverList = localSrvHostKey;
        clientList = remote.serverHostKey;
      } else {
        serverList = remote.serverHostKey;
        clientList = localSrvHostKey;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching host key format");
        return doFatalError(
          self2,
          "Handshake failed: no matching host key format",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.serverHostKey = clientList[i];
      debug2 && debug2(`Handshake: Host key format: ${clientList[i]}`);
      const localCSCipher = local4.lists.cs.cipher.array;
      debug2 && debug2(`Handshake: (local) C->S cipher: ${localCSCipher}`);
      debug2 && debug2(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);
      if (self2._server) {
        serverList = localCSCipher;
        clientList = remote.cs.cipher;
      } else {
        serverList = remote.cs.cipher;
        clientList = localCSCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching C->S cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.cs.cipher = clientList[i];
      debug2 && debug2(`Handshake: C->S Cipher: ${clientList[i]}`);
      const localSCCipher = local4.lists.sc.cipher.array;
      debug2 && debug2(`Handshake: (local) S->C cipher: ${localSCCipher}`);
      debug2 && debug2(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);
      if (self2._server) {
        serverList = localSCCipher;
        clientList = remote.sc.cipher;
      } else {
        serverList = remote.sc.cipher;
        clientList = localSCCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching S->C cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.sc.cipher = clientList[i];
      debug2 && debug2(`Handshake: S->C cipher: ${clientList[i]}`);
      const localCSMAC = local4.lists.cs.mac.array;
      debug2 && debug2(`Handshake: (local) C->S MAC: ${localCSMAC}`);
      debug2 && debug2(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);
      if (CIPHER_INFO[init4.cs.cipher].authLen > 0) {
        init4.cs.mac = "";
        debug2 && debug2("Handshake: C->S MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localCSMAC;
          clientList = remote.cs.mac;
        } else {
          serverList = remote.cs.mac;
          clientList = localCSMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug2 && debug2("Handshake: No matching C->S MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init4.cs.mac = clientList[i];
        debug2 && debug2(`Handshake: C->S MAC: ${clientList[i]}`);
      }
      const localSCMAC = local4.lists.sc.mac.array;
      debug2 && debug2(`Handshake: (local) S->C MAC: ${localSCMAC}`);
      debug2 && debug2(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);
      if (CIPHER_INFO[init4.sc.cipher].authLen > 0) {
        init4.sc.mac = "";
        debug2 && debug2("Handshake: S->C MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localSCMAC;
          clientList = remote.sc.mac;
        } else {
          serverList = remote.sc.mac;
          clientList = localSCMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug2 && debug2("Handshake: No matching S->C MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init4.sc.mac = clientList[i];
        debug2 && debug2(`Handshake: S->C MAC: ${clientList[i]}`);
      }
      const localCSCompress = local4.lists.cs.compress.array;
      debug2 && debug2(`Handshake: (local) C->S compression: ${localCSCompress}`);
      debug2 && debug2(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);
      if (self2._server) {
        serverList = localCSCompress;
        clientList = remote.cs.compress;
      } else {
        serverList = remote.cs.compress;
        clientList = localCSCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching C->S compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.cs.compress = clientList[i];
      debug2 && debug2(`Handshake: C->S compression: ${clientList[i]}`);
      const localSCCompress = local4.lists.sc.compress.array;
      debug2 && debug2(`Handshake: (local) S->C compression: ${localSCCompress}`);
      debug2 && debug2(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);
      if (self2._server) {
        serverList = localSCCompress;
        clientList = remote.sc.compress;
      } else {
        serverList = remote.sc.compress;
        clientList = localSCCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching S->C compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.sc.compress = clientList[i];
      debug2 && debug2(`Handshake: S->C compression: ${clientList[i]}`);
      init4.cs.lang = "";
      init4.sc.lang = "";
      if (self2._kex) {
        if (!self2._kexinit) {
          kexinit(self2);
        }
        self2._decipher._onPayload = onKEXPayload.bind(self2, { firstPacket: false });
      }
      self2._kex = createKeyExchange(init4, self2, payload);
      self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;
      self2._kex.start();
    }
    var createKeyExchange = /* @__PURE__ */ (() => {
      function convertToMpint(buf) {
        let idx = 0;
        let length9 = buf.length;
        while (buf[idx] === 0) {
          ++idx;
          --length9;
        }
        let newBuf;
        if (buf[idx] & 128) {
          newBuf = Buffer.allocUnsafe(1 + length9);
          newBuf[0] = 0;
          buf.copy(newBuf, 1, idx);
          buf = newBuf;
        } else if (length9 !== buf.length) {
          newBuf = Buffer.allocUnsafe(length9);
          buf.copy(newBuf, 0, idx);
          buf = newBuf;
        }
        return buf;
      }
      class KeyExchange {
        constructor(negotiated, protocol, remoteKexinit) {
          this._protocol = protocol;
          this.sessionID = protocol._kex ? protocol._kex.sessionID : void 0;
          this.negotiated = negotiated;
          this.remoteExtInfoEnabled = false;
          this._step = 1;
          this._public = null;
          this._dh = null;
          this._sentNEWKEYS = false;
          this._receivedNEWKEYS = false;
          this._finished = false;
          this._hostVerified = false;
          this._kexinit = protocol._kexinit;
          this._remoteKexinit = remoteKexinit;
          this._identRaw = protocol._identRaw;
          this._remoteIdentRaw = protocol._remoteIdentRaw;
          this._hostKey = void 0;
          this._dhData = void 0;
          this._sig = void 0;
        }
        finish(scOnly) {
          if (this._finished)
            return false;
          this._finished = true;
          const isServer = this._protocol._server;
          const negotiated = this.negotiated;
          const pubKey = this.convertPublicKey(this._dhData);
          let secret = this.computeSecret(this._dhData);
          if (secret instanceof Error) {
            secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;
            secret.level = "handshake";
            return doFatalError(
              this._protocol,
              secret,
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          const hash4 = createHash2(this.hashName);
          hashString3(hash4, isServer ? this._remoteIdentRaw : this._identRaw);
          hashString3(hash4, isServer ? this._identRaw : this._remoteIdentRaw);
          hashString3(hash4, isServer ? this._remoteKexinit : this._kexinit);
          hashString3(hash4, isServer ? this._kexinit : this._remoteKexinit);
          const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
          hashString3(hash4, serverPublicHostKey);
          if (this.type === "groupex") {
            const params2 = this.getDHParams();
            const num = Buffer.allocUnsafe(4);
            writeUInt32BE(num, this._minBits, 0);
            hash4.update(num);
            writeUInt32BE(num, this._prefBits, 0);
            hash4.update(num);
            writeUInt32BE(num, this._maxBits, 0);
            hash4.update(num);
            hashString3(hash4, params2.prime);
            hashString3(hash4, params2.generator);
          }
          hashString3(hash4, isServer ? pubKey : this.getPublicKey());
          const serverPublicKey = isServer ? this.getPublicKey() : pubKey;
          hashString3(hash4, serverPublicKey);
          hashString3(hash4, secret);
          const exchangeHash = hash4.digest();
          if (!isServer) {
            bufferParser.init(this._sig, 0);
            const sigType = bufferParser.readString(true);
            if (!sigType) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (sigType !== negotiated.serverHostKey) {
              return doFatalError(
                this._protocol,
                `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let sigValue = bufferParser.readString();
            bufferParser.clear();
            if (sigValue === void 0) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {
              return doFatalError(
                this._protocol,
                "Malformed signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let parsedHostKey;
            {
              bufferParser.init(this._hostKey, 0);
              const name5 = bufferParser.readString(true);
              const hostKey = this._hostKey.slice(bufferParser.pos());
              bufferParser.clear();
              parsedHostKey = parseDERKey(hostKey, name5);
              if (parsedHostKey instanceof Error) {
                parsedHostKey.level = "handshake";
                return doFatalError(
                  this._protocol,
                  parsedHostKey,
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
            }
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Verifying signature ...");
            const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
            if (verified !== true) {
              if (verified instanceof Error) {
                this._protocol._debug && this._protocol._debug(
                  `Signature verification failed: ${verified.stack}`
                );
              } else {
                this._protocol._debug && this._protocol._debug(
                  "Signature verification failed"
                );
              }
              return doFatalError(
                this._protocol,
                "Handshake failed: signature verification failed",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug("Verified signature");
          } else {
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug(
              "Generating signature ..."
            );
            let signature = this._hostKey.sign(exchangeHash, hashAlgo);
            if (signature instanceof Error) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            signature = convertSignature(signature, this._hostKey.type);
            if (signature === false) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            const sigType = this.negotiated.serverHostKey;
            const sigTypeLen = Buffer.byteLength(sigType);
            const sigLen = 4 + sigTypeLen + 4 + signature.length;
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen,
              true
            );
            packet[p] = MESSAGE.KEXDH_REPLY;
            writeUInt32BE(packet, serverPublicHostKey.length, ++p);
            packet.set(serverPublicHostKey, p += 4);
            writeUInt32BE(
              packet,
              serverPublicKey.length,
              p += serverPublicHostKey.length
            );
            packet.set(serverPublicKey, p += 4);
            writeUInt32BE(packet, sigLen, p += serverPublicKey.length);
            writeUInt32BE(packet, sigTypeLen, p += 4);
            packet.utf8Write(sigType, p += 4, sigTypeLen);
            writeUInt32BE(packet, signature.length, p += sigTypeLen);
            packet.set(signature, p += 4);
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_REPLY";
                  break;
                case "groupex":
                  type = "KEXDH_GEX_REPLY";
                  break;
                default:
                  type = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
          if (isServer || !scOnly)
            trySendNEWKEYS(this);
          let hsCipherConfig;
          let hsWrite;
          const completeHandshake = (partial) => {
            if (hsCipherConfig) {
              trySendNEWKEYS(this);
              hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno;
              this._protocol._cipher.free();
              this._protocol._cipher = createCipher(hsCipherConfig);
              this._protocol._packetRW.write = hsWrite;
              hsCipherConfig = void 0;
              hsWrite = void 0;
              this._protocol._onHandshakeComplete(negotiated);
              return false;
            }
            if (!this.sessionID)
              this.sessionID = exchangeHash;
            {
              const newSecret = Buffer.allocUnsafe(4 + secret.length);
              writeUInt32BE(newSecret, secret.length, 0);
              newSecret.set(secret, 4);
              secret = newSecret;
            }
            const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];
            const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];
            const csIV = generateKEXVal(
              csCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "A"
            );
            const scIV = generateKEXVal(
              scCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "B"
            );
            const csKey = generateKEXVal(
              csCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "C"
            );
            const scKey = generateKEXVal(
              scCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "D"
            );
            let csMacInfo;
            let csMacKey;
            if (!csCipherInfo.authLen) {
              csMacInfo = MAC_INFO[negotiated.cs.mac];
              csMacKey = generateKEXVal(
                csMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "E"
              );
            }
            let scMacInfo;
            let scMacKey;
            if (!scCipherInfo.authLen) {
              scMacInfo = MAC_INFO[negotiated.sc.mac];
              scMacKey = generateKEXVal(
                scMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "F"
              );
            }
            const config2 = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: !isServer ? scCipherInfo : csCipherInfo,
                decipherIV: !isServer ? scIV : csIV,
                decipherKey: !isServer ? scKey : csKey,
                macInfo: !isServer ? scMacInfo : csMacInfo,
                macKey: !isServer ? scMacKey : csMacKey
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: isServer ? scCipherInfo : csCipherInfo,
                cipherIV: isServer ? scIV : csIV,
                cipherKey: isServer ? scKey : csKey,
                macInfo: isServer ? scMacInfo : csMacInfo,
                macKey: isServer ? scMacKey : csMacKey
              }
            };
            this._protocol._decipher.free();
            hsCipherConfig = config2;
            this._protocol._decipher = createDecipher(config2);
            const rw = {
              read: void 0,
              write: void 0
            };
            switch (negotiated.cs.compress) {
              case "zlib":
                if (isServer)
                  rw.read = new ZlibPacketReader();
                else
                  rw.write = new ZlibPacketWriter(this._protocol);
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.read = new ZlibPacketReader();
                  else
                    rw.write = new ZlibPacketWriter(this._protocol);
                  break;
                }
              default:
                if (isServer)
                  rw.read = new PacketReader();
                else
                  rw.write = new PacketWriter(this._protocol);
            }
            switch (negotiated.sc.compress) {
              case "zlib":
                if (isServer)
                  rw.write = new ZlibPacketWriter(this._protocol);
                else
                  rw.read = new ZlibPacketReader();
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.write = new ZlibPacketWriter(this._protocol);
                  else
                    rw.read = new ZlibPacketReader();
                  break;
                }
              default:
                if (isServer)
                  rw.write = new PacketWriter(this._protocol);
                else
                  rw.read = new PacketReader();
            }
            this._protocol._packetRW.read.cleanup();
            this._protocol._packetRW.write.cleanup();
            this._protocol._packetRW.read = rw.read;
            hsWrite = rw.write;
            this._public = null;
            this._dh = null;
            this._kexinit = this._protocol._kexinit = void 0;
            this._remoteKexinit = void 0;
            this._identRaw = void 0;
            this._remoteIdentRaw = void 0;
            this._hostKey = void 0;
            this._dhData = void 0;
            this._sig = void 0;
            if (!partial)
              return completeHandshake();
            return false;
          };
          if (isServer || scOnly)
            this.finish = completeHandshake;
          if (!isServer)
            return completeHandshake(scOnly);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_INIT";
                  break;
                default:
                  type = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + pubKey.length,
              true
            );
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._public;
          if (key)
            return this.convertPublicKey(key);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key[idx] & 128) {
            newKey = Buffer.allocUnsafe(1 + len);
            newKey[0] = 0;
            key.copy(newKey, 1, idx);
            return newKey;
          }
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            return convertToMpint(this._dh.computeSecret(otherPublicKey));
          } catch (ex) {
            return ex;
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Init"
                );
                bufferParser.init(payload, 1);
                const dhData = bufferParser.readString();
                bufferParser.clear();
                if (dhData === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._dhData = dhData;
                let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
                if (Array.isArray(hostKey))
                  hostKey = hostKey[0];
                this._hostKey = hostKey;
                this.finish();
              } else {
                if (type !== MESSAGE.KEXDH_REPLY) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Reply"
                );
                bufferParser.init(payload, 1);
                let hostPubKey;
                let dhData;
                let sig;
                if ((hostPubKey = bufferParser.readString()) === void 0 || (dhData = bufferParser.readString()) === void 0 || (sig = bufferParser.readString()) === void 0) {
                  bufferParser.clear();
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_REPLY",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                bufferParser.clear();
                bufferParser.init(hostPubKey, 0);
                const hostPubKeyType = bufferParser.readString(true);
                bufferParser.clear();
                if (hostPubKeyType === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                if (hostPubKeyType !== this.negotiated.serverHostKey) {
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (hostPubKeyType === "ssh-rsa")
                        break;
                    default:
                      return doFatalError(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                  }
                }
                this._hostKey = hostPubKey;
                this._dhData = dhData;
                this._sig = sig;
                let checked = false;
                let ret;
                if (this._protocol._hostVerifier === void 0) {
                  ret = true;
                  this._protocol._debug && this._protocol._debug(
                    "Host accepted by default (no verification)"
                  );
                } else {
                  ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                    if (checked)
                      return;
                    checked = true;
                    if (permitted === false) {
                      this._protocol._debug && this._protocol._debug(
                        "Host denied (verification failed)"
                      );
                      return doFatalError(
                        this._protocol,
                        "Host denied (verification failed)",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                    }
                    this._protocol._debug && this._protocol._debug(
                      "Host accepted (verified)"
                    );
                    this._hostVerified = true;
                    if (this._receivedNEWKEYS)
                      this.finish();
                    else
                      trySendNEWKEYS(this);
                  });
                }
                if (ret === void 0) {
                  ++this._step;
                  return;
                }
                checked = true;
                if (ret === false) {
                  this._protocol._debug && this._protocol._debug(
                    "Host denied (verification failed)"
                  );
                  return doFatalError(
                    this._protocol,
                    "Host denied (verification failed)",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Host accepted (verified)"
                );
                this._hostVerified = true;
                trySendNEWKEYS(this);
              }
              ++this._step;
              break;
            case 2:
              if (type !== MESSAGE.NEWKEYS) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Inbound: NEWKEYS"
              );
              this._receivedNEWKEYS = true;
              if (this._protocol._strictMode)
                this._protocol._decipher.inSeqno = 0;
              ++this._step;
              return this.finish(!this._protocol._server && !this._hostVerified);
            default:
              return doFatalError(
                this._protocol,
                `Received unexpected packet ${type} after NEWKEYS`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
          }
        }
      }
      class Curve25519Exchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "25519";
          this.hashName = hashName;
          this._keys = null;
        }
        generateKeys() {
          if (!this._keys)
            this._keys = generateKeyPairSync("x25519");
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._keys.publicKey.export({ type: "spki", format: "der" });
          return key.slice(-32);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key.length === 32)
            return key;
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.startSequence();
            asnWriter.writeOID("1.3.101.110");
            asnWriter.endSequence();
            asnWriter.startSequence(Ber.BitString);
            asnWriter.writeByte(0);
            asnWriter._ensure(otherPublicKey.length);
            otherPublicKey.copy(
              asnWriter._buf,
              asnWriter._offset,
              0,
              otherPublicKey.length
            );
            asnWriter._offset += otherPublicKey.length;
            asnWriter.endSequence();
            asnWriter.endSequence();
            return convertToMpint(diffieHellman({
              privateKey: this._keys.privateKey,
              publicKey: createPublicKey({
                key: asnWriter.buffer,
                type: "spki",
                format: "der"
              })
            }));
          } catch (ex) {
            return ex;
          }
        }
      }
      class ECDHExchange extends KeyExchange {
        constructor(curveName, hashName, ...args) {
          super(...args);
          this.type = "ecdh";
          this.curveName = curveName;
          this.hashName = hashName;
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createECDH(this.curveName);
            this._public = this._dh.generateKeys();
          }
        }
      }
      class DHGroupExchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "groupex";
          this.hashName = hashName;
          this._prime = null;
          this._generator = null;
          this._minBits = GEX_MIN_BITS;
          this._prefBits = dhEstimate(this.negotiated);
          if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)
            this._prefBits = Math.min(this._prefBits, 4096);
          this._maxBits = GEX_MAX_BITS;
        }
        start() {
          if (this._protocol._server)
            return;
          this._protocol._debug && this._protocol._debug(
            "Outbound: Sending KEXDH_GEX_REQUEST"
          );
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(
            1 + 4 + 4 + 4,
            true
          );
          packet[p] = MESSAGE.KEXDH_GEX_REQUEST;
          writeUInt32BE(packet, this._minBits, ++p);
          writeUInt32BE(packet, this._prefBits, p += 4);
          writeUInt32BE(packet, this._maxBits, p += 4);
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
        generateKeys() {
          if (!this._dh && this._prime && this._generator) {
            this._dh = createDiffieHellman(this._prime, this._generator);
            this._public = this._dh.generateKeys();
          }
        }
        setDHParams(prime, generator) {
          if (!Buffer.isBuffer(prime))
            throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(generator))
            throw new Error("Invalid generator value");
          this._prime = prime;
          this._generator = generator;
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_REQUEST) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              if (type !== MESSAGE.KEXDH_GEX_GROUP) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Group"
              );
              bufferParser.init(payload, 1);
              let prime;
              let gen;
              if ((prime = bufferParser.readString()) === void 0 || (gen = bufferParser.readString()) === void 0) {
                bufferParser.clear();
                return doFatalError(
                  this._protocol,
                  "Received malformed KEXDH_GEX_GROUP",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              bufferParser.clear();
              this.setDHParams(prime, gen);
              this.generateKeys();
              const pubkey = this.getPublicKey();
              this._protocol._debug && this._protocol._debug(
                "Outbound: Sending KEXDH_GEX_INIT"
              );
              let p = this._protocol._packetRW.write.allocStartKEX;
              const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);
              packet[p] = MESSAGE.KEXDH_GEX_INIT;
              writeUInt32BE(packet, pubkey.length, ++p);
              packet.set(pubkey, p += 4);
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(packet, true)
              );
              ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH GEX Init"
                );
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Reply"
              );
              this._step = 1;
              payload[0] = MESSAGE.KEXDH_REPLY;
              this.parse = KeyExchange.prototype.parse;
              this.parse(payload);
          }
        }
      }
      class DHExchange extends KeyExchange {
        constructor(groupName, hashName, ...args) {
          super(...args);
          this.type = "group";
          this.groupName = groupName;
          this.hashName = hashName;
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug && this._protocol._debug(
              "Outbound: Sending KEXDH_INIT"
            );
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createDiffieHellmanGroup(this.groupName);
            this._public = this._dh.generateKeys();
          }
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
      }
      return (negotiated, ...args) => {
        if (typeof negotiated !== "object" || negotiated === null)
          throw new Error("Invalid negotiated argument");
        const kexType = negotiated.kex;
        if (typeof kexType === "string") {
          args = [negotiated, ...args];
          switch (kexType) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!curve25519Supported)
                break;
              return new Curve25519Exchange("sha256", ...args);
            case "ecdh-sha2-nistp256":
              return new ECDHExchange("prime256v1", "sha256", ...args);
            case "ecdh-sha2-nistp384":
              return new ECDHExchange("secp384r1", "sha384", ...args);
            case "ecdh-sha2-nistp521":
              return new ECDHExchange("secp521r1", "sha512", ...args);
            case "diffie-hellman-group1-sha1":
              return new DHExchange("modp2", "sha1", ...args);
            case "diffie-hellman-group14-sha1":
              return new DHExchange("modp14", "sha1", ...args);
            case "diffie-hellman-group14-sha256":
              return new DHExchange("modp14", "sha256", ...args);
            case "diffie-hellman-group15-sha512":
              return new DHExchange("modp15", "sha512", ...args);
            case "diffie-hellman-group16-sha512":
              return new DHExchange("modp16", "sha512", ...args);
            case "diffie-hellman-group17-sha512":
              return new DHExchange("modp17", "sha512", ...args);
            case "diffie-hellman-group18-sha512":
              return new DHExchange("modp18", "sha512", ...args);
            case "diffie-hellman-group-exchange-sha1":
              return new DHGroupExchange("sha1", ...args);
            case "diffie-hellman-group-exchange-sha256":
              return new DHGroupExchange("sha256", ...args);
          }
          throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
        }
        throw new Error(`Invalid key exchange type: ${kexType}`);
      };
    })();
    var KexInit = /* @__PURE__ */ (() => {
      const KEX_PROPERTY_NAMES = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"]
      ];
      return class KexInit {
        constructor(obj) {
          if (typeof obj !== "object" || obj === null)
            throw new TypeError("Argument must be an object");
          const lists = {
            kex: void 0,
            serverHostKey: void 0,
            cs: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            sc: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            all: void 0
          };
          let totalSize = 0;
          for (const prop4 of KEX_PROPERTY_NAMES) {
            let base;
            let val;
            let desc;
            let key;
            if (typeof prop4 === "string") {
              base = lists;
              val = obj[prop4];
              desc = key = prop4;
            } else {
              const parent = prop4[0];
              base = lists[parent];
              key = prop4[1];
              val = obj[parent][key];
              desc = `${parent}.${key}`;
            }
            const entry = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(val)) {
              entry.array = ("" + val).split(",");
              entry.buffer = val;
              totalSize += 4 + val.length;
            } else {
              if (typeof val === "string")
                val = val.split(",");
              if (Array.isArray(val)) {
                entry.array = val;
                entry.buffer = Buffer.from(val.join(","));
              } else {
                throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
              }
              totalSize += 4 + entry.buffer.length;
            }
            base[key] = entry;
          }
          const all5 = Buffer.allocUnsafe(totalSize);
          lists.all = all5;
          let allPos = 0;
          for (const prop4 of KEX_PROPERTY_NAMES) {
            let data;
            if (typeof prop4 === "string")
              data = lists[prop4].buffer;
            else
              data = lists[prop4[0]][prop4[1]].buffer;
            allPos = writeUInt32BE(all5, data.length, allPos);
            all5.set(data, allPos);
            allPos += data.length;
          }
          this.totalSize = totalSize;
          this.lists = lists;
        }
        copyAllTo(buf, offset) {
          const src = this.lists.all;
          if (typeof offset !== "number")
            throw new TypeError(`Invalid offset value: ${typeof offset}`);
          if (buf.length - offset < src.length)
            throw new Error("Insufficient space to copy list");
          buf.set(src, offset);
          return src.length;
        }
      };
    })();
    var hashString3 = (() => {
      const LEN = Buffer.allocUnsafe(4);
      return (hash4, buf) => {
        writeUInt32BE(LEN, buf.length, 0);
        hash4.update(LEN);
        hash4.update(buf);
      };
    })();
    function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char2) {
      let ret;
      if (len) {
        let digest = createHash2(hashName).update(secret).update(exchangeHash).update(char2).update(sessionID).digest();
        while (digest.length < len) {
          const chunk = createHash2(hashName).update(secret).update(exchangeHash).update(digest).digest();
          const extended = Buffer.allocUnsafe(digest.length + chunk.length);
          extended.set(digest, 0);
          extended.set(chunk, digest.length);
          digest = extended;
        }
        if (digest.length === len)
          ret = digest;
        else
          ret = new FastBuffer(digest.buffer, digest.byteOffset, len);
      } else {
        ret = EMPTY_BUFFER;
      }
      return ret;
    }
    function onKEXPayload(state2, payload) {
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      if (this._skipNextInboundPacket) {
        this._skipNextInboundPacket = false;
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (!this._strictMode) {
        switch (type) {
          case MESSAGE.IGNORE:
          case MESSAGE.UNIMPLEMENTED:
          case MESSAGE.DEBUG:
            if (!MESSAGE_HANDLERS)
              MESSAGE_HANDLERS = require_handlers();
            return MESSAGE_HANDLERS[type](this, payload);
        }
      }
      switch (type) {
        case MESSAGE.DISCONNECT:
          if (!MESSAGE_HANDLERS)
            MESSAGE_HANDLERS = require_handlers();
          return MESSAGE_HANDLERS[type](this, payload);
        case MESSAGE.KEXINIT:
          if (!state2.firstPacket) {
            return doFatalError(
              this,
              "Received extra KEXINIT during handshake",
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          state2.firstPacket = false;
          return handleKexInit(this, payload);
        default:
          if (type < 20 || type > 49) {
            return doFatalError(
              this,
              `Received unexpected packet type ${type}`,
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
      }
      return this._kex.parse(payload);
    }
    function dhEstimate(neg) {
      const csCipher = CIPHER_INFO[neg.cs.cipher];
      const scCipher = CIPHER_INFO[neg.sc.cipher];
      const bits = Math.max(
        0,
        csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen,
        csCipher.blockLen,
        csCipher.ivLen,
        scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen,
        scCipher.blockLen,
        scCipher.ivLen
      ) * 8;
      if (bits <= 112)
        return 2048;
      if (bits <= 128)
        return 3072;
      if (bits <= 192)
        return 7680;
      return 8192;
    }
    function trySendNEWKEYS(kex) {
      if (!kex._sentNEWKEYS) {
        kex._protocol._debug && kex._protocol._debug(
          "Outbound: Sending NEWKEYS"
        );
        const p = kex._protocol._packetRW.write.allocStartKEX;
        const packet = kex._protocol._packetRW.write.alloc(1, true);
        packet[p] = MESSAGE.NEWKEYS;
        kex._protocol._cipher.encrypt(
          kex._protocol._packetRW.write.finalize(packet, true)
        );
        kex._sentNEWKEYS = true;
        if (kex._protocol._strictMode)
          kex._protocol._cipher.outSeqno = 0;
      }
    }
    module.exports = {
      KexInit,
      kexinit,
      onKEXPayload,
      DEFAULT_KEXINIT_CLIENT: new KexInit({
        kex: DEFAULT_KEX.concat(["ext-info-c", "kex-strict-c-v00@openssh.com"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      DEFAULT_KEXINIT_SERVER: new KexInit({
        kex: DEFAULT_KEX.concat(["kex-strict-s-v00@openssh.com"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      HANDLERS: {
        [MESSAGE.KEXINIT]: handleKexInit
      }
    };
  }
});

// node_modules/ssh2/package.json
var require_package = __commonJS({
  "node_modules/ssh2/package.json"(exports, module) {
    module.exports = {
      name: "ssh2",
      version: "1.15.0",
      author: "Brian White <mscdex@mscdex.net>",
      description: "SSH2 client and server modules written in pure JavaScript for node.js",
      main: "./lib/index.js",
      engines: {
        node: ">=10.16.0"
      },
      dependencies: {
        asn1: "^0.2.6",
        "bcrypt-pbkdf": "^1.0.2"
      },
      devDependencies: {
        "@mscdex/eslint-config": "^1.1.0",
        eslint: "^7.32.0"
      },
      optionalDependencies: {
        "cpu-features": "~0.0.9",
        nan: "^2.18.0"
      },
      scripts: {
        install: "node install.js",
        rebuild: "node install.js",
        test: "node test/test.js",
        lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
        "lint:fix": "npm run lint -- --fix"
      },
      keywords: [
        "ssh",
        "ssh2",
        "sftp",
        "secure",
        "shell",
        "exec",
        "remote",
        "client"
      ],
      licenses: [
        {
          type: "MIT",
          url: "http://github.com/mscdex/ssh2/raw/master/LICENSE"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/mscdex/ssh2.git"
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/ssh2/lib/protocol/Protocol.js"(exports, module) {
    "use strict";
    var { inspect: inspect2 } = __require("util");
    var { bindingAvailable, NullCipher, NullDecipher } = require_crypto();
    var {
      COMPAT_CHECKS,
      DISCONNECT_REASON,
      eddsaSupported,
      MESSAGE,
      SIGNALS,
      TERMINAL_MODE
    } = require_constants5();
    var {
      DEFAULT_KEXINIT_CLIENT,
      DEFAULT_KEXINIT_SERVER,
      KexInit,
      kexinit,
      onKEXPayload
    } = require_kex();
    var {
      parseKey
    } = require_keyParser();
    var MESSAGE_HANDLERS = require_handlers();
    var {
      bufferCopy,
      bufferFill,
      bufferSlice,
      convertSignature,
      sendPacket,
      writeUInt32BE
    } = require_utils7();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MODULE_VER = require_package().version;
    var VALID_DISCONNECT_REASONS = new Map(
      Object.values(DISCONNECT_REASON).map((n) => [n, 1])
    );
    var IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);
    var IDENT = Buffer.from(`${IDENT_RAW}\r
`);
    var MAX_LINE_LEN = 8192;
    var MAX_LINES = 1024;
    var PING_PAYLOAD = Buffer.from([
      MESSAGE.GLOBAL_REQUEST,
      // "keepalive@openssh.com"
      0,
      0,
      0,
      21,
      107,
      101,
      101,
      112,
      97,
      108,
      105,
      118,
      101,
      64,
      111,
      112,
      101,
      110,
      115,
      115,
      104,
      46,
      99,
      111,
      109,
      // Request a reply
      1
    ]);
    var NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);
    function noop2() {
    }
    var Protocol = class {
      constructor(config2) {
        const onWrite = config2.onWrite;
        if (typeof onWrite !== "function")
          throw new Error("Missing onWrite function");
        this._onWrite = (data) => {
          onWrite(data);
        };
        const onError = config2.onError;
        if (typeof onError !== "function")
          throw new Error("Missing onError function");
        this._onError = (err) => {
          onError(err);
        };
        const debug2 = config2.debug;
        this._debug = typeof debug2 === "function" ? (msg) => {
          debug2(msg);
        } : void 0;
        const onHeader = config2.onHeader;
        this._onHeader = typeof onHeader === "function" ? (...args) => {
          onHeader(...args);
        } : noop2;
        const onPacket = config2.onPacket;
        this._onPacket = typeof onPacket === "function" ? () => {
          onPacket();
        } : noop2;
        let onHandshakeComplete = config2.onHandshakeComplete;
        if (typeof onHandshakeComplete !== "function")
          onHandshakeComplete = noop2;
        let firstHandshake;
        this._onHandshakeComplete = (...args) => {
          this._debug && this._debug("Handshake completed");
          if (firstHandshake === void 0)
            firstHandshake = true;
          else
            firstHandshake = false;
          const oldQueue = this._queue;
          if (oldQueue) {
            this._queue = void 0;
            this._debug && this._debug(
              `Draining outbound queue (${oldQueue.length}) ...`
            );
            for (let i = 0; i < oldQueue.length; ++i) {
              const data = oldQueue[i];
              let finalized = this._packetRW.write.finalize(data);
              if (finalized === data) {
                const packet = this._cipher.allocPacket(data.length);
                packet.set(data, 5);
                finalized = packet;
              }
              sendPacket(this, finalized);
            }
            this._debug && this._debug("... finished draining outbound queue");
          }
          if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled)
            sendExtInfo(this);
          onHandshakeComplete(...args);
        };
        this._queue = void 0;
        const messageHandlers = config2.messageHandlers;
        if (typeof messageHandlers === "object" && messageHandlers !== null)
          this._handlers = messageHandlers;
        else
          this._handlers = {};
        this._onPayload = onPayload.bind(this);
        this._server = !!config2.server;
        this._banner = void 0;
        let greeting;
        if (this._server) {
          if (typeof config2.hostKeys !== "object" || config2.hostKeys === null)
            throw new Error("Missing server host key(s)");
          this._hostKeys = config2.hostKeys;
          if (typeof config2.greeting === "string" && config2.greeting.length) {
            greeting = config2.greeting.slice(-2) === "\r\n" ? config2.greeting : `${config2.greeting}\r
`;
          }
          if (typeof config2.banner === "string" && config2.banner.length) {
            this._banner = config2.banner.slice(-2) === "\r\n" ? config2.banner : `${config2.banner}\r
`;
          }
        } else {
          this._hostKeys = void 0;
        }
        let offer = config2.offer;
        if (typeof offer !== "object" || offer === null) {
          offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;
        } else if (offer.constructor !== KexInit) {
          if (this._server) {
            offer.kex = offer.kex.concat(["kex-strict-s-v00@openssh.com"]);
          } else {
            offer.kex = offer.kex.concat([
              "ext-info-c",
              "kex-strict-c-v00@openssh.com"
            ]);
          }
          offer = new KexInit(offer);
        }
        this._kex = void 0;
        this._strictMode = void 0;
        this._kexinit = void 0;
        this._offer = offer;
        this._cipher = new NullCipher(0, this._onWrite);
        this._decipher = void 0;
        this._skipNextInboundPacket = false;
        this._packetRW = {
          read: new PacketReader(),
          write: new PacketWriter(this)
        };
        this._hostVerifier = !this._server && typeof config2.hostVerifier === "function" ? config2.hostVerifier : void 0;
        this._parse = parseHeader;
        this._buffer = void 0;
        this._authsQueue = [];
        this._authenticated = false;
        this._remoteIdentRaw = void 0;
        let sentIdent;
        if (typeof config2.ident === "string") {
          this._identRaw = Buffer.from(`SSH-2.0-${config2.ident}`);
          sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);
          sentIdent.set(this._identRaw, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else if (Buffer.isBuffer(config2.ident)) {
          const fullIdent = Buffer.allocUnsafe(8 + config2.ident.length);
          fullIdent.latin1Write("SSH-2.0-", 0, 8);
          fullIdent.set(config2.ident, 8);
          this._identRaw = fullIdent;
          sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);
          sentIdent.set(fullIdent, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else {
          this._identRaw = IDENT_RAW;
          sentIdent = IDENT;
        }
        this._compatFlags = 0;
        if (this._debug) {
          if (bindingAvailable)
            this._debug("Custom crypto binding available");
          else
            this._debug("Custom crypto binding not available");
        }
        this._debug && this._debug(
          `Local ident: ${inspect2(this._identRaw.toString())}`
        );
        this.start = () => {
          this.start = void 0;
          if (greeting)
            this._onWrite(greeting);
          this._onWrite(sentIdent);
        };
      }
      _destruct(reason) {
        this._packetRW.read.cleanup();
        this._packetRW.write.cleanup();
        this._cipher && this._cipher.free();
        this._decipher && this._decipher.free();
        if (typeof reason !== "string" || reason.length === 0)
          reason = "fatal error";
        this.parse = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._onWrite = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._destruct = void 0;
      }
      cleanup() {
        this._destruct && this._destruct();
      }
      parse(chunk, i, len) {
        while (i < len)
          i = this._parse(chunk, i, len);
      }
      // Protocol message API
      // ===========================================================================
      // Common/Shared =============================================================
      // ===========================================================================
      // Global
      // ------
      disconnect(reason) {
        const pktLen = 1 + 4 + 4 + 4;
        let p = this._packetRW.write.allocStartKEX;
        const packet = this._packetRW.write.alloc(pktLen, true);
        const end4 = p + pktLen;
        if (!VALID_DISCONNECT_REASONS.has(reason))
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        packet[p] = MESSAGE.DISCONNECT;
        writeUInt32BE(packet, reason, ++p);
        packet.fill(0, p += 4, end4);
        this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);
        sendPacket(this, this._packetRW.write.finalize(packet, true), true);
      }
      ping() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
        packet.set(PING_PAYLOAD, p);
        this._debug && this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      rekey() {
        if (this._kexinit === void 0) {
          this._debug && this._debug("Outbound: Initiated explicit rekey");
          this._queue = [];
          kexinit(this);
        } else {
          this._debug && this._debug("Outbound: Ignoring rekey during handshake");
        }
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      requestSuccess(data) {
        let p = this._packetRW.write.allocStart;
        let packet;
        if (Buffer.isBuffer(data)) {
          packet = this._packetRW.write.alloc(1 + data.length);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
          packet.set(data, ++p);
        } else {
          packet = this._packetRW.write.alloc(1);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
        }
        this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      requestFailure() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.REQUEST_FAILURE;
        this._debug && this._debug("Outbound: Sending REQUEST_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelSuccess(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_SUCCESS;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelFailure(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_FAILURE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelEOF(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_EOF;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelClose(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_CLOSE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelWindowAdjust(chan, amount) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, amount, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelData(chan, data) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelExtData(chan, data, type) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, type, p += 4);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenConfirm(remote, local4, initWindow, maxPacket) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, local4, p += 4);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local4})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenFail(remote, reason, desc) {
        if (typeof desc !== "string")
          desc = "";
        const descLen = Buffer.byteLength(desc);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, reason, p += 4);
        writeUInt32BE(packet, descLen, p += 4);
        p += 4;
        if (descLen) {
          packet.utf8Write(desc, p, descLen);
          p += descLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      service(name5) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name5);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + nameLen);
        packet[p] = MESSAGE.SERVICE_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name5, p += 4, nameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name5})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      // -------------------------------
      authPassword(username, password, newPassword) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        const passLen = Buffer.byteLength(password);
        const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0)
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 8, p += 14);
        packet.utf8Write("password", p += 4, 8);
        packet[p += 8] = newPassword ? 1 : 0;
        writeUInt32BE(packet, passLen, ++p);
        if (Buffer.isBuffer(password))
          bufferCopy(password, packet, 0, passLen, p += 4);
        else
          packet.utf8Write(password, p += 4, passLen);
        if (newPassword) {
          writeUInt32BE(packet, newPassLen, p += passLen);
          if (Buffer.isBuffer(newPassword))
            bufferCopy(newPassword, packet, 0, newPassLen, p += 4);
          else
            packet.utf8Write(newPassword, p += 4, newPassLen);
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (changed password)"
          );
        } else {
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (password)"
          );
        }
        this._authsQueue.push("password");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPK(username, pubKey, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;
        let packet;
        let p;
        if (cbSign) {
          packet = Buffer.allocUnsafe(payloadLen);
          p = 0;
          writeUInt32BE(packet, sesLen, p);
          packet.set(sessionID, p += 4);
          p += sesLen;
        } else {
          packet = this._packetRW.write.alloc(payloadLen);
          p = this._packetRW.write.allocStart;
        }
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 9, p += 14);
        packet.utf8Write("publickey", p += 4, 9);
        packet[p += 9] = cbSign ? 1 : 0;
        writeUInt32BE(packet, algoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(packet, pubKeyLen, p += algoLen);
        packet.set(pubKey, p += 4);
        if (!cbSign) {
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
          return;
        }
        cbSign(packet, (signature) => {
          signature = convertSignature(signature, keyType);
          if (signature === false)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          p = this._packetRW.write.allocStart;
          packet = this._packetRW.write.alloc(
            1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen
          );
          packet[p] = MESSAGE.USERAUTH_REQUEST;
          writeUInt32BE(packet, userLen, ++p);
          packet.utf8Write(username, p += 4, userLen);
          writeUInt32BE(packet, 14, p += userLen);
          packet.utf8Write("ssh-connection", p += 4, 14);
          writeUInt32BE(packet, 9, p += 14);
          packet.utf8Write("publickey", p += 4, 9);
          packet[p += 9] = 1;
          writeUInt32BE(packet, algoLen, ++p);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, pubKeyLen, p += algoLen);
          packet.set(pubKey, p += 4);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const hostnameLen = Buffer.byteLength(hostname);
        const userlocalLen = Buffer.byteLength(userlocal);
        const data = Buffer.allocUnsafe(
          4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen
        );
        let p = 0;
        writeUInt32BE(data, sesLen, p);
        data.set(sessionID, p += 4);
        data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(data, userLen, ++p);
        data.utf8Write(username, p += 4, userLen);
        writeUInt32BE(data, 14, p += userLen);
        data.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(data, 9, p += 14);
        data.utf8Write("hostbased", p += 4, 9);
        writeUInt32BE(data, algoLen, p += 9);
        data.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(data, pubKeyLen, p += algoLen);
        data.set(pubKey, p += 4);
        writeUInt32BE(data, hostnameLen, p += pubKeyLen);
        data.utf8Write(hostname, p += 4, hostnameLen);
        writeUInt32BE(data, userlocalLen, p += hostnameLen);
        data.utf8Write(userlocal, p += 4, userlocalLen);
        cbSign(data, (signature) => {
          signature = convertSignature(signature, keyType);
          if (!signature)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          const reqDataLen = data.length - sesLen - 4;
          p = this._packetRW.write.allocStart;
          const packet = this._packetRW.write.alloc(
            reqDataLen + 4 + 4 + algoLen + 4 + sigLen
          );
          bufferCopy(data, packet, 4 + sesLen, data.length, p);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("hostbased");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (hostbased)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authKeyboard(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 20, p += 14);
        packet.utf8Write("keyboard-interactive", p += 4, 20);
        writeUInt32BE(packet, 0, p += 20);
        writeUInt32BE(packet, 0, p += 4);
        this._authsQueue.push("keyboard-interactive");
        this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authNone(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 4, p += 14);
        packet.utf8Write("none", p += 4, 4);
        this._authsQueue.push("none");
        this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoRes(responses) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let responsesTotalLen = 0;
        let responseLens;
        if (responses) {
          responseLens = new Array(responses.length);
          for (let i = 0; i < responses.length; ++i) {
            const len = Buffer.byteLength(responses[i]);
            responseLens[i] = len;
            responsesTotalLen += 4 + len;
          }
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);
        packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;
        if (responses) {
          writeUInt32BE(packet, responses.length, ++p);
          p += 4;
          for (let i = 0; i < responses.length; ++i) {
            const len = responseLens[i];
            writeUInt32BE(packet, len, p);
            p += 4;
            if (len) {
              packet.utf8Write(responses[i], p, len);
              p += len;
            }
          }
        } else {
          writeUInt32BE(packet, 0, ++p);
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      tcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 13, ++p);
        packet.utf8Write("tcpip-forward", p += 4, 13);
        packet[p += 13] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      cancelTcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 20, ++p);
        packet.utf8Write("cancel-tcpip-forward", p += 4, 20);
        packet[p += 20] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_streamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 31 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 31, ++p);
        packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31);
        packet[p += 31] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_cancelStreamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 38 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 38, ++p);
        packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38);
        packet[p += 38] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      directTcpip(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const srcLen = Buffer.byteLength(cfg.srcIP);
        const dstLen = Buffer.byteLength(cfg.dstIP);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 12, ++p);
        packet.utf8Write("direct-tcpip", p += 4, 12);
        writeUInt32BE(packet, chan, p += 12);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, dstLen, p += 4);
        packet.utf8Write(cfg.dstIP, p += 4, dstLen);
        writeUInt32BE(packet, cfg.dstPort, p += dstLen);
        writeUInt32BE(packet, srcLen, p += 4);
        packet.utf8Write(cfg.srcIP, p += 4, srcLen);
        writeUInt32BE(packet, cfg.srcPort, p += srcLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 30, ++p);
        packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30);
        writeUInt32BE(packet, chan, p += 30);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        bufferFill(packet, 0, p += pathLen, p + 8);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_noMoreSessions(wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 28, ++p);
        packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28);
        packet[p += 28] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      session(chan, initWindow, maxPacket) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 7, ++p);
        packet.utf8Write("session", p += 4, 7);
        writeUInt32BE(packet, chan, p += 7);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      windowChange(chan, rows, cols, height, width2) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 13, p += 4);
        packet.utf8Write("window-change", p += 4, 13);
        packet[p += 13] = 0;
        writeUInt32BE(packet, cols, ++p);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width2, p += 4);
        writeUInt32BE(packet, height, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      pty(chan, rows, cols, height, width2, term, modes, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        if (!term || !term.length)
          term = "vt100";
        if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === "object" && modes !== null) {
          modes = modesToBytes(modes);
        }
        if (!modes || !modes.length)
          modes = NO_TERMINAL_MODES_BUFFER;
        const termLen = term.length;
        const modesLen = modes.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("pty-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, termLen, ++p);
        packet.utf8Write(term, p += 4, termLen);
        writeUInt32BE(packet, cols, p += termLen);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width2, p += 4);
        writeUInt32BE(packet, height, p += 4);
        writeUInt32BE(packet, modesLen, p += 4);
        p += 4;
        if (Array.isArray(modes)) {
          for (let i = 0; i < modesLen; ++i)
            packet[p++] = modes[i];
        } else if (Buffer.isBuffer(modes)) {
          packet.set(modes, p);
        }
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      shell(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 5, p += 4);
        packet.utf8Write("shell", p += 4, 5);
        packet[p += 5] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exec(chan, cmd, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const isBuf = Buffer.isBuffer(cmd);
        const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 4, p += 4);
        packet.utf8Write("exec", p += 4, 4);
        packet[p += 4] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, cmdLen, ++p);
        if (isBuf)
          packet.set(cmd, p += 4);
        else
          packet.utf8Write(cmd, p += 4, cmdLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      signal(chan, signal) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const origSignal = signal;
        signal = signal.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const signalLen = signal.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 6 + 1 + 4 + signalLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 6, p += 4);
        packet.utf8Write("signal", p += 4, 6);
        packet[p += 6] = 0;
        writeUInt32BE(packet, signalLen, ++p);
        packet.utf8Write(signal, p += 4, signalLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      env(chan, key, val, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const keyLen = Buffer.byteLength(key);
        const isBuf = Buffer.isBuffer(val);
        const valLen = isBuf ? val.length : Buffer.byteLength(val);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 3, p += 4);
        packet.utf8Write("env", p += 4, 3);
        packet[p += 3] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, keyLen, ++p);
        packet.utf8Write(key, p += 4, keyLen);
        writeUInt32BE(packet, valLen, p += keyLen);
        if (isBuf)
          packet.set(val, p += 4);
        else
          packet.utf8Write(val, p += 4, valLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11Forward(chan, cfg, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const protocol = cfg.protocol;
        const cookie = cfg.cookie;
        const isBufProto = Buffer.isBuffer(protocol);
        const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);
        const isBufCookie = Buffer.isBuffer(cookie);
        const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("x11-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        packet[++p] = cfg.single ? 1 : 0;
        writeUInt32BE(packet, protoLen, ++p);
        if (isBufProto)
          packet.set(protocol, p += 4);
        else
          packet.utf8Write(protocol, p += 4, protoLen);
        writeUInt32BE(packet, cookieLen, p += protoLen);
        if (isBufCookie)
          packet.set(cookie, p += 4);
        else
          packet.latin1Write(cookie, p += 4, cookieLen);
        writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      subsystem(chan, name5, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name5);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 9, p += 4);
        packet.utf8Write("subsystem", p += 4, 9);
        packet[p += 9] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name5, p += 4, nameLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name5})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_agentForward(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 26, p += 4);
        packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26);
        packet[p += 26] = wantReply === void 0 || wantReply === true ? 1 : 0;
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_hostKeysProve(keys4) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let keysTotal = 0;
        const publicKeys = [];
        for (const key of keys4) {
          const publicKey = key.getPublicSSH();
          keysTotal += 4 + publicKey.length;
          publicKeys.push(publicKey);
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 29, ++p);
        packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
        packet[p += 29] = 1;
        ++p;
        for (const buf of publicKeys) {
          writeUInt32BE(packet, buf.length, p);
          bufferCopy(buf, packet, 0, buf.length, p += 4);
          p += buf.length;
        }
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      serviceAccept(svcName) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const svcNameLen = Buffer.byteLength(svcName);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);
        packet[p] = MESSAGE.SERVICE_ACCEPT;
        writeUInt32BE(packet, svcNameLen, ++p);
        packet.utf8Write(svcName, p += 4, svcNameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._server && this._banner && svcName === "ssh-userauth") {
          const banner = this._banner;
          this._banner = void 0;
          const bannerLen = Buffer.byteLength(banner);
          p = this._packetRW.write.allocStart;
          const packet2 = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);
          packet2[p] = MESSAGE.USERAUTH_BANNER;
          writeUInt32BE(packet2, bannerLen, ++p);
          packet2.utf8Write(banner, p += 4, bannerLen);
          writeUInt32BE(packet2, 0, p += bannerLen);
          this._debug && this._debug("Outbound: Sending USERAUTH_BANNER");
          sendPacket(this, this._packetRW.write.finalize(packet2));
        }
      }
      // 'ssh-connection' service-specific
      forwardedTcpip(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const boundAddrLen = Buffer.byteLength(cfg.boundAddr);
        const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 15, ++p);
        packet.utf8Write("forwarded-tcpip", p += 4, 15);
        writeUInt32BE(packet, chan, p += 15);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, boundAddrLen, p += 4);
        packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);
        writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);
        writeUInt32BE(packet, remoteAddrLen, p += 4);
        packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);
        writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const addrLen = Buffer.byteLength(cfg.originAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 3, ++p);
        packet.utf8Write("x11", p += 4, 3);
        writeUInt32BE(packet, chan, p += 3);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, addrLen, p += 4);
        packet.utf8Write(cfg.originAddr, p += 4, addrLen);
        writeUInt32BE(packet, cfg.originPort, p += addrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_authAgent(chan, initWindow, maxPacket) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 22, ++p);
        packet.utf8Write("auth-agent@openssh.com", p += 4, 22);
        writeUInt32BE(packet, chan, p += 22);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 33, ++p);
        packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33);
        writeUInt32BE(packet, chan, p += 33);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        writeUInt32BE(packet, 0, p += pathLen);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitStatus(chan, status2) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-status", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, status2, ++p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status2})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitSignal(chan, name5, coreDumped, msg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const origSignal = name5;
        if (typeof origSignal !== "string" || !origSignal)
          throw new Error(`Invalid signal: ${origSignal}`);
        let signal = name5.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const nameLen = Buffer.byteLength(signal);
        const msgLen = msg ? Buffer.byteLength(msg) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-signal", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(signal, p += 4, nameLen);
        packet[p += nameLen] = coreDumped ? 1 : 0;
        writeUInt32BE(packet, msgLen, ++p);
        p += 4;
        if (msgLen) {
          packet.utf8Write(msg, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name5})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      authFailure(authMethods, isPartial) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        let methods;
        if (typeof authMethods === "boolean") {
          isPartial = authMethods;
          authMethods = void 0;
        }
        if (authMethods) {
          methods = [];
          for (let i = 0; i < authMethods.length; ++i) {
            if (authMethods[i].toLowerCase() === "none")
              continue;
            methods.push(authMethods[i]);
          }
          methods = methods.join(",");
        } else {
          methods = "";
        }
        const methodsLen = methods.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);
        packet[p] = MESSAGE.USERAUTH_FAILURE;
        writeUInt32BE(packet, methodsLen, ++p);
        packet.utf8Write(methods, p += 4, methodsLen);
        packet[p += methodsLen] = isPartial === true ? 1 : 0;
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authSuccess() {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.USERAUTH_SUCCESS;
        this._authsQueue.shift();
        this._authenticated = true;
        this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
      }
      authPKOK(keyAlgo, key) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
          throw new Error('"publickey" auth not in progress');
        const keyAlgoLen = Buffer.byteLength(keyAlgo);
        const keyLen = key.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);
        packet[p] = MESSAGE.USERAUTH_PK_OK;
        writeUInt32BE(packet, keyAlgoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);
        writeUInt32BE(packet, keyLen, p += keyAlgoLen);
        packet.set(key, p += 4);
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPasswdChg(prompt) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const promptLen = Buffer.byteLength(prompt);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);
        packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;
        writeUInt32BE(packet, promptLen, ++p);
        packet.utf8Write(prompt, p += 4, promptLen);
        writeUInt32BE(packet, 0, p += promptLen);
        this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoReq(name5, instructions, prompts) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let promptsLen = 0;
        const nameLen = name5 ? Buffer.byteLength(name5) : 0;
        const instrLen = instructions ? Buffer.byteLength(instructions) : 0;
        for (let i = 0; i < prompts.length; ++i)
          promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen
        );
        packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        p += 4;
        if (name5) {
          packet.utf8Write(name5, p, nameLen);
          p += nameLen;
        }
        writeUInt32BE(packet, instrLen, p);
        p += 4;
        if (instructions) {
          packet.utf8Write(instructions, p, instrLen);
          p += instrLen;
        }
        writeUInt32BE(packet, 0, p);
        writeUInt32BE(packet, prompts.length, p += 4);
        p += 4;
        for (let i = 0; i < prompts.length; ++i) {
          const prompt = prompts[i];
          const promptLen = Buffer.byteLength(prompt.prompt);
          writeUInt32BE(packet, promptLen, p);
          p += 4;
          if (promptLen) {
            packet.utf8Write(prompt.prompt, p, promptLen);
            p += promptLen;
          }
          packet[p++] = prompt.echo ? 1 : 0;
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
    };
    var RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
    function parseHeader(chunk, p, len) {
      let data;
      let chunkOffset;
      if (this._buffer) {
        data = Buffer.allocUnsafe(this._buffer.length + (len - p));
        data.set(this._buffer, 0);
        if (p === 0) {
          data.set(chunk, this._buffer.length);
        } else {
          data.set(
            new Uint8Array(
              chunk.buffer,
              chunk.byteOffset + p,
              len - p
            ),
            this._buffer.length
          );
        }
        chunkOffset = this._buffer.length;
        p = 0;
      } else {
        data = chunk;
        chunkOffset = 0;
      }
      const op = p;
      let start = p;
      let end4 = p;
      let needNL = false;
      let lineLen = 0;
      let lines8 = 0;
      for (; p < data.length; ++p) {
        const ch = data[p];
        if (ch === 13) {
          needNL = true;
          continue;
        }
        if (ch === 10) {
          if (end4 > start && end4 - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
            const full = data.latin1Slice(op, end4 + 1);
            const identRaw = start === op ? full : full.slice(start - op);
            const m = RE_IDENT.exec(identRaw);
            if (!m)
              throw new Error("Invalid identification string");
            const header = {
              greeting: start === op ? "" : full.slice(0, start - op),
              identRaw,
              versions: {
                protocol: m[1],
                software: m[2]
              },
              comments: m[3]
            };
            this._remoteIdentRaw = Buffer.from(identRaw);
            this._debug && this._debug(`Remote ident: ${inspect2(identRaw)}`);
            this._compatFlags = getCompatFlags(header);
            this._buffer = void 0;
            this._decipher = new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));
            this._parse = parsePacket;
            this._onHeader(header);
            if (!this._destruct) {
              return len;
            }
            kexinit(this);
            return p + 1 - chunkOffset;
          }
          if (this._server)
            throw new Error("Greetings from clients not permitted");
          if (++lines8 > MAX_LINES)
            throw new Error("Max greeting lines exceeded");
          needNL = false;
          start = p + 1;
          lineLen = 0;
        } else if (needNL) {
          throw new Error("Invalid header: expected newline");
        } else if (++lineLen >= MAX_LINE_LEN) {
          throw new Error("Header line too long");
        }
        end4 = p;
      }
      if (!this._buffer)
        this._buffer = bufferSlice(data, op);
      return p - chunkOffset;
    }
    function parsePacket(chunk, p, len) {
      return this._decipher.decrypt(chunk, p, len);
    }
    function onPayload(payload) {
      this._onPacket();
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {
        this._authenticated = true;
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
      }
      const handler = MESSAGE_HANDLERS[type];
      if (handler === void 0) {
        this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);
        return;
      }
      return handler(this, payload);
    }
    function getCompatFlags(header) {
      const software = header.versions.software;
      let flags = 0;
      for (const rule of COMPAT_CHECKS) {
        if (typeof rule[0] === "string") {
          if (software === rule[0])
            flags |= rule[1];
        } else if (rule[0].test(software)) {
          flags |= rule[1];
        }
      }
      return flags;
    }
    function modesToBytes(modes) {
      const keys4 = Object.keys(modes);
      const bytes = Buffer.allocUnsafe(5 * keys4.length + 1);
      let b = 0;
      for (let i = 0; i < keys4.length; ++i) {
        const key = keys4[i];
        if (key === "TTY_OP_END")
          continue;
        const opcode = TERMINAL_MODE[key];
        if (opcode === void 0)
          continue;
        const val = modes[key];
        if (typeof val === "number" && isFinite(val)) {
          bytes[b++] = opcode;
          bytes[b++] = val >>> 24;
          bytes[b++] = val >>> 16;
          bytes[b++] = val >>> 8;
          bytes[b++] = val;
        }
      }
      bytes[b++] = TERMINAL_MODE.TTY_OP_END;
      if (b < bytes.length)
        return bufferSlice(bytes, 0, b);
      return bytes;
    }
    function sendExtInfo(proto) {
      let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
      if (eddsaSupported)
        serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;
      const algsLen = Buffer.byteLength(serverSigAlgs);
      let p = proto._packetRW.write.allocStart;
      const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);
      packet[p] = MESSAGE.EXT_INFO;
      writeUInt32BE(packet, 1, ++p);
      writeUInt32BE(packet, 15, p += 4);
      packet.utf8Write("server-sig-algs", p += 4, 15);
      writeUInt32BE(packet, algsLen, p += 15);
      packet.utf8Write(serverSigAlgs, p += 4, algsLen);
      proto._debug && proto._debug("Outbound: Sending EXT_INFO");
      sendPacket(proto, proto._packetRW.write.finalize(packet));
    }
    module.exports = Protocol;
  }
});

// node_modules/ssh2/lib/protocol/node-fs-compat.js
var require_node_fs_compat = __commonJS({
  "node_modules/ssh2/lib/protocol/node-fs-compat.js"(exports) {
    "use strict";
    var assert3 = __require("assert");
    var { inspect: inspect2 } = __require("util");
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3)
        res = `_${val.slice(i - 3, i)}${res}`;
      return `${val.slice(0, i)}${res}`;
    }
    function oneOf5(expected, thing) {
      assert3(typeof thing === "string", "`thing` has to be of type string");
      if (Array.isArray(expected)) {
        const len = expected.length;
        assert3(len > 0, "At least one expected value needs to be specified");
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        }
        return `of ${thing} ${expected[0]}`;
      }
      return `of ${thing} ${String(expected)}`;
    }
    exports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
      constructor(message3) {
        super();
        Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
        const suffix2 = "This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.\nPlease open an issue with this stack trace at https://github.com/mscdex/ssh2/issues\n";
        this.message = message3 === void 0 ? suffix2 : `${message3}
${suffix2}`;
      }
    };
    var MAX_32BIT_INT = 2 ** 32;
    var MAX_32BIT_BIGINT = (() => {
      try {
        return new Function("return 2n ** 32n")();
      } catch {
      }
    })();
    exports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
      constructor(str2, range3, input, replaceDefaultBoolean) {
        super();
        Error.captureStackTrace(this, ERR_OUT_OF_RANGE);
        assert3(range3, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str2 : `The value of "${str2}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)
            received = addNumericalSeparator(received);
          received += "n";
        } else {
          received = inspect2(input);
        }
        msg += ` It must be ${range3}. Received ${received}`;
        this.message = msg;
      }
    };
    var ERR_INVALID_ARG_TYPE = class _ERR_INVALID_ARG_TYPE extends TypeError {
      constructor(name5, expected, actual) {
        super();
        Error.captureStackTrace(this, _ERR_INVALID_ARG_TYPE);
        assert3(typeof name5 === "string", `'name' must be a string`);
        let determiner;
        if (typeof expected === "string" && expected.startsWith("not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        let msg;
        if (name5.endsWith(" argument")) {
          msg = `The ${name5} ${determiner} ${oneOf5(expected, "type")}`;
        } else {
          const type = name5.includes(".") ? "property" : "argument";
          msg = `The "${name5}" ${type} ${determiner} ${oneOf5(expected, "type")}`;
        }
        msg += `. Received type ${typeof actual}`;
        this.message = msg;
      }
    };
    exports.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    exports.validateNumber = function validateNumber(value4, name5) {
      if (typeof value4 !== "number")
        throw new ERR_INVALID_ARG_TYPE(name5, "number", value4);
    };
  }
});

// node_modules/ssh2/lib/protocol/SFTP.js
var require_SFTP = __commonJS({
  "node_modules/ssh2/lib/protocol/SFTP.js"(exports, module) {
    "use strict";
    var EventEmitter3 = __require("events");
    var fs16 = __require("fs");
    var { constants: constants4 } = fs16;
    var {
      Readable: ReadableStream,
      Writable: WritableStream
    } = __require("stream");
    var { inherits, isDate } = __require("util");
    var FastBuffer = Buffer[Symbol.species];
    var {
      bufferCopy,
      bufferSlice,
      makeBufferParser,
      writeUInt32BE
    } = require_utils7();
    var ATTR = {
      SIZE: 1,
      UIDGID: 2,
      PERMISSIONS: 4,
      ACMODTIME: 8,
      EXTENDED: 2147483648
    };
    var ATTRS_BUF = Buffer.alloc(28);
    var STATUS_CODE = {
      OK: 0,
      EOF: 1,
      NO_SUCH_FILE: 2,
      PERMISSION_DENIED: 3,
      FAILURE: 4,
      BAD_MESSAGE: 5,
      NO_CONNECTION: 6,
      CONNECTION_LOST: 7,
      OP_UNSUPPORTED: 8
    };
    var VALID_STATUS_CODES = new Map(
      Object.values(STATUS_CODE).map((n) => [n, 1])
    );
    var STATUS_CODE_STR = {
      [STATUS_CODE.OK]: "No error",
      [STATUS_CODE.EOF]: "End of file",
      [STATUS_CODE.NO_SUCH_FILE]: "No such file or directory",
      [STATUS_CODE.PERMISSION_DENIED]: "Permission denied",
      [STATUS_CODE.FAILURE]: "Failure",
      [STATUS_CODE.BAD_MESSAGE]: "Bad message",
      [STATUS_CODE.NO_CONNECTION]: "No connection",
      [STATUS_CODE.CONNECTION_LOST]: "Connection lost",
      [STATUS_CODE.OP_UNSUPPORTED]: "Operation unsupported"
    };
    var REQUEST = {
      INIT: 1,
      OPEN: 3,
      CLOSE: 4,
      READ: 5,
      WRITE: 6,
      LSTAT: 7,
      FSTAT: 8,
      SETSTAT: 9,
      FSETSTAT: 10,
      OPENDIR: 11,
      READDIR: 12,
      REMOVE: 13,
      MKDIR: 14,
      RMDIR: 15,
      REALPATH: 16,
      STAT: 17,
      RENAME: 18,
      READLINK: 19,
      SYMLINK: 20,
      EXTENDED: 200
    };
    var RESPONSE = {
      VERSION: 2,
      STATUS: 101,
      HANDLE: 102,
      DATA: 103,
      NAME: 104,
      ATTRS: 105,
      EXTENDED: 201
    };
    var OPEN_MODE = {
      READ: 1,
      WRITE: 2,
      APPEND: 4,
      CREAT: 8,
      TRUNC: 16,
      EXCL: 32
    };
    var PKT_RW_OVERHEAD = 2 * 1024;
    var MAX_REQID = 2 ** 32 - 1;
    var CLIENT_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      REQUEST.INIT,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var SERVER_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      RESPONSE.VERSION,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;
    var OPENSSH_MAX_PKT_LEN = 256 * 1024;
    var bufferParser = makeBufferParser();
    var fakeStderr = {
      readable: false,
      writable: false,
      push: (data) => {
      },
      once: () => {
      },
      on: () => {
      },
      emit: () => {
      },
      end: () => {
      }
    };
    function noop2() {
    }
    var SFTP = class extends EventEmitter3 {
      constructor(client, chanInfo, cfg) {
        super();
        if (typeof cfg !== "object" || !cfg)
          cfg = {};
        const remoteIdentRaw = client._protocol._remoteIdentRaw;
        this.server = !!cfg.server;
        this._debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);
        this._version = -1;
        this._extensions = {};
        this._biOpt = cfg.biOpt;
        this._pktLenBytes = 0;
        this._pktLen = 0;
        this._pktPos = 0;
        this._pktType = 0;
        this._pktData = void 0;
        this._writeReqid = -1;
        this._requests = {};
        this._maxInPktLen = OPENSSH_MAX_PKT_LEN;
        this._maxOutPktLen = 34e3;
        this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this.maxOpenHandles = void 0;
        this._client = client;
        this._protocol = client._protocol;
        this._callbacks = [];
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this._waitWindow = false;
        this._chunkcb = void 0;
        this._buffer = [];
        this.type = chanInfo.type;
        this.subtype = void 0;
        this.incoming = chanInfo.incoming;
        this.outgoing = chanInfo.outgoing;
        this.stderr = fakeStderr;
        this.readable = true;
      }
      // This handles incoming data to parse
      push(data) {
        if (data === null) {
          cleanupRequests(this);
          if (!this.readable)
            return;
          this.readable = false;
          this.emit("end");
          return;
        }
        let p = 0;
        while (p < data.length) {
          if (this._pktLenBytes < 4) {
            let nb = Math.min(4 - this._pktLenBytes, data.length - p);
            this._pktLenBytes += nb;
            while (nb--)
              this._pktLen = (this._pktLen << 8) + data[p++];
            if (this._pktLenBytes < 4)
              return;
            if (this._pktLen === 0)
              return doFatalSFTPError(this, "Invalid packet length");
            if (this._pktLen > this._maxInPktLen) {
              const max8 = this._maxInPktLen;
              return doFatalSFTPError(
                this,
                `Packet length ${this._pktLen} exceeds max length of ${max8}`
              );
            }
            if (p >= data.length)
              return;
          }
          if (this._pktPos < this._pktLen) {
            const nb = Math.min(this._pktLen - this._pktPos, data.length - p);
            if (p !== 0 || nb !== data.length) {
              if (nb === this._pktLen) {
                this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);
              } else {
                if (!this._pkt)
                  this._pkt = Buffer.allocUnsafe(this._pktLen);
                this._pkt.set(
                  new Uint8Array(data.buffer, data.byteOffset + p, nb),
                  this._pktPos
                );
              }
            } else if (nb === this._pktLen) {
              this._pkt = data;
            } else {
              if (!this._pkt)
                this._pkt = Buffer.allocUnsafe(this._pktLen);
              this._pkt.set(data, this._pktPos);
            }
            p += nb;
            this._pktPos += nb;
            if (this._pktPos < this._pktLen)
              return;
          }
          const type = this._pkt[0];
          const payload = this._pkt;
          this._pktLen = 0;
          this._pktLenBytes = 0;
          this._pkt = void 0;
          this._pktPos = 0;
          const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];
          if (!handler)
            return doFatalSFTPError(this, `Unknown packet type ${type}`);
          if (this._version === -1) {
            if (this.server) {
              if (type !== REQUEST.INIT)
                return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);
            } else if (type !== RESPONSE.VERSION) {
              return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);
            }
          }
          if (handler(this, payload) === false)
            return;
        }
      }
      end() {
        this.destroy();
      }
      destroy() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._protocol.channelClose(this.outgoing.id);
        }
      }
      _init() {
        this._init = noop2;
        if (!this.server)
          sendOrBuffer(this, CLIENT_VERSION_BUFFER);
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      createReadStream(path14, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new ReadStream2(this, path14, options);
      }
      createWriteStream(path14, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new WriteStream2(this, path14, options);
      }
      open(path14, flags_, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        const flags = typeof flags_ === "number" ? flags_ : stringToFlags(flags_);
        if (flags === null)
          throw new Error(`Unknown flags string: ${flags_}`);
        let attrsFlags = 0;
        let attrsLen = 0;
        if (typeof attrs === "string" || typeof attrs === "number")
          attrs = { mode: attrs };
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          attrsFlags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPEN;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        writeUInt32BE(buf, attrsFlags, p += 4);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`
        );
      }
      close(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.CLOSE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`
        );
      }
      read(handle, buf, off, len, position2, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off >= buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position2 === null)
          throw new Error("null position currently unsupported");
        read_(this, handle, buf, off, len, position2, cb);
      }
      readData(handle, buf, off, len, position2, cb) {
        this.read(handle, buf, off, len, position2, cb);
      }
      write(handle, buf, off, len, position2, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off > buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position2 === null)
          throw new Error("null position currently unsupported");
        if (!len) {
          cb && process.nextTick(cb, void 0, 0);
          return;
        }
        const maxDataLen = this._maxWriteLen;
        const overflow = Math.max(len - maxDataLen, 0);
        const origPosition = position2;
        if (overflow)
          len = maxDataLen;
        const handleLen = handle.length;
        let p = 9;
        const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);
        writeUInt32BE(out, out.length - 4, 0);
        out[4] = REQUEST.WRITE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(out, reqid, 5);
        writeUInt32BE(out, handleLen, p);
        out.set(handle, p += 4);
        p += handleLen;
        for (let i = 7; i >= 0; --i) {
          out[p + i] = position2 & 255;
          position2 /= 256;
        }
        writeUInt32BE(out, len, p += 8);
        bufferCopy(buf, out, off, off + len, p += 4);
        this._requests[reqid] = {
          cb: (err) => {
            if (err) {
              if (typeof cb === "function")
                cb(err);
            } else if (overflow) {
              this.write(
                handle,
                buf,
                off + len,
                overflow,
                origPosition + len,
                cb
              );
            } else if (typeof cb === "function") {
              cb(void 0, off + len);
            }
          }
        };
        const isSent = sendOrBuffer(this, out);
        if (this._debug) {
          const how = isSent ? "Sent" : "Buffered";
          this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
        }
      }
      writeData(handle, buf, off, len, position2, cb) {
        this.write(handle, buf, off, len, position2, cb);
      }
      fastGet(remotePath, localPath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(this, fs16, remotePath, localPath, opts, cb);
      }
      fastPut(localPath, remotePath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(fs16, this, localPath, remotePath, opts, cb);
      }
      readFile(path14, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, flag: "r" };
        else if (!options)
          options = { encoding: null, flag: "r" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        const encoding = options.encoding;
        if (encoding && !Buffer.isEncoding(encoding))
          throw new Error(`Unknown encoding: ${encoding}`);
        let size8;
        let buffer;
        let buffers;
        let pos2 = 0;
        let handle;
        let bytesRead = 0;
        const flag2 = options.flag || "r";
        const read7 = () => {
          if (size8 === 0) {
            buffer = Buffer.allocUnsafe(8192);
            this.read(handle, buffer, 0, 8192, bytesRead, afterRead);
          } else {
            this.read(handle, buffer, pos2, size8 - pos2, bytesRead, afterRead);
          }
        };
        const afterRead = (er, nbytes) => {
          let eof5;
          if (er) {
            eof5 = er.code === STATUS_CODE.EOF;
            if (!eof5) {
              return this.close(handle, () => {
                return callback && callback(er);
              });
            }
          } else {
            eof5 = false;
          }
          if (eof5 || size8 === 0 && nbytes === 0)
            return close2();
          bytesRead += nbytes;
          pos2 += nbytes;
          if (size8 !== 0) {
            if (pos2 === size8)
              close2();
            else
              read7();
          } else {
            buffers.push(bufferSlice(buffer, 0, nbytes));
            read7();
          }
        };
        afterRead._wantEOFError = true;
        const close2 = () => {
          this.close(handle, (er) => {
            if (size8 === 0) {
              buffer = Buffer.concat(buffers, pos2);
            } else if (pos2 < size8) {
              buffer = bufferSlice(buffer, 0, pos2);
            }
            if (encoding)
              buffer = buffer.toString(encoding);
            return callback && callback(er, buffer);
          });
        };
        this.open(path14, flag2, 438, (er, handle_) => {
          if (er)
            return callback && callback(er);
          handle = handle_;
          const tryStat = (er2, st) => {
            if (er2) {
              this.stat(path14, (er_, st_) => {
                if (er_) {
                  return this.close(handle, () => {
                    callback && callback(er2);
                  });
                }
                tryStat(null, st_);
              });
              return;
            }
            size8 = st.size || 0;
            if (size8 === 0) {
              buffers = [];
              return read7();
            }
            buffer = Buffer.allocUnsafe(size8);
            read7();
          };
          this.fstat(handle, tryStat);
        });
      }
      writeFile(path14, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "w" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "w" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (options.encoding && !Buffer.isEncoding(options.encoding))
          throw new Error(`Unknown encoding: ${options.encoding}`);
        const flag2 = options.flag || "w";
        this.open(path14, flag2, options.mode, (openErr, handle) => {
          if (openErr) {
            callback && callback(openErr);
          } else {
            const buffer = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8");
            const position2 = /a/.test(flag2) ? null : 0;
            if (position2 === null) {
              const tryStat = (er, st) => {
                if (er) {
                  this.stat(path14, (er_, st_) => {
                    if (er_) {
                      return this.close(handle, () => {
                        callback && callback(er);
                      });
                    }
                    tryStat(null, st_);
                  });
                  return;
                }
                writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);
              };
              this.fstat(handle, tryStat);
              return;
            }
            writeAll(this, handle, buffer, 0, buffer.length, position2, callback);
          }
        });
      }
      appendFile(path14, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "a" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "a" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (!options.flag)
          options = Object.assign({ flag: "a" }, options);
        this.writeFile(path14, data, options, callback);
      }
      exists(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.stat(path14, (err) => {
          cb && cb(err ? false : true);
        });
      }
      unlink(filename, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const fnameLen = Buffer.byteLength(filename);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REMOVE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, fnameLen, p);
        buf.utf8Write(filename, p += 4, fnameLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`
        );
      }
      rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RENAME;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, oldLen, p);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`
        );
      }
      mkdir(path14, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.MKDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`
        );
      }
      rmdir(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RMDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`
        );
      }
      readdir(where, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (typeof opts !== "object" || opts === null)
          opts = {};
        const doFilter = opts && opts.full ? false : true;
        if (!Buffer.isBuffer(where) && typeof where !== "string")
          throw new Error("missing directory handle or path");
        if (typeof where === "string") {
          const entries3 = [];
          let e = 0;
          const reread = (err, handle) => {
            if (err)
              return cb(err);
            this.readdir(handle, opts, (err2, list3) => {
              const eof5 = err2 && err2.code === STATUS_CODE.EOF;
              if (err2 && !eof5)
                return this.close(handle, () => cb(err2));
              if (eof5) {
                return this.close(handle, (err3) => {
                  if (err3)
                    return cb(err3);
                  cb(void 0, entries3);
                });
              }
              for (let i = 0; i < list3.length; ++i, ++e)
                entries3[e] = list3[i];
              reread(void 0, handle);
            });
          };
          return this.opendir(where, reread);
        }
        const handleLen = where.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(where, p += 4);
        this._requests[reqid] = {
          cb: doFilter ? (err, list3) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            for (let i = list3.length - 1; i >= 0; --i) {
              if (list3[i].filename === "." || list3[i].filename === "..")
                list3.splice(i, 1);
            }
            cb(void 0, list3);
          } : cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`
        );
      }
      fstat(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`
        );
      }
      stat(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.STAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`
        );
      }
      lstat(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.LSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`
        );
      }
      opendir(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPENDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`
        );
      }
      setstat(path14, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`
        );
      }
      fsetstat(handle, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        writeUInt32BE(buf, flags, p += handleLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`
        );
      }
      futimes(handle, atime, mtime, cb) {
        return this.fsetstat(handle, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      utimes(path14, atime, mtime, cb) {
        return this.setstat(path14, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      fchown(handle, uid2, gid2, cb) {
        return this.fsetstat(handle, {
          uid: uid2,
          gid: gid2
        }, cb);
      }
      chown(path14, uid2, gid2, cb) {
        return this.setstat(path14, {
          uid: uid2,
          gid: gid2
        }, cb);
      }
      fchmod(handle, mode2, cb) {
        return this.fsetstat(handle, {
          mode: mode2
        }, cb);
      }
      chmod(path14, mode2, cb) {
        return this.setstat(path14, {
          mode: mode2
        }, cb);
      }
      readlink(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing link info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`
        );
      }
      symlink(targetPath, linkPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const linkLen = Buffer.byteLength(linkPath);
        const targetLen = Buffer.byteLength(targetPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SYMLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        if (this._isOpenSSH) {
          writeUInt32BE(buf, targetLen, p);
          buf.utf8Write(targetPath, p += 4, targetLen);
          writeUInt32BE(buf, linkLen, p += targetLen);
          buf.utf8Write(linkPath, p += 4, linkLen);
        } else {
          writeUInt32BE(buf, linkLen, p);
          buf.utf8Write(linkPath, p += 4, linkLen);
          writeUInt32BE(buf, targetLen, p += linkLen);
          buf.utf8Write(targetPath, p += 4, targetLen);
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`
        );
      }
      realpath(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REALPATH;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing path info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`
        );
      }
      // extended requests
      ext_openssh_rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["posix-rename@openssh.com"];
        if (!ext2 || ext2 !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 24, p);
        buf.utf8Write("posix-rename@openssh.com", p += 4, 24);
        writeUInt32BE(buf, oldLen, p += 24);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
        }
      }
      ext_openssh_statvfs(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["statvfs@openssh.com"];
        if (!ext2 || ext2 !== "2")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 19, p);
        buf.utf8Write("statvfs@openssh.com", p += 4, 19);
        writeUInt32BE(buf, pathLen, p += 19);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = { extended: "statvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
        }
      }
      ext_openssh_fstatvfs(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["fstatvfs@openssh.com"];
        if (!ext2 || ext2 !== "2")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("fstatvfs@openssh.com", p += 4, 20);
        writeUInt32BE(buf, handleLen, p += 20);
        buf.set(handle, p += 4);
        this._requests[reqid] = { extended: "fstatvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
        }
      }
      ext_openssh_hardlink(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["hardlink@openssh.com"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("hardlink@openssh.com", p += 4, 20);
        writeUInt32BE(buf, oldLen, p += 20);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
        }
      }
      ext_openssh_fsync(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["fsync@openssh.com"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 17, p);
        buf.utf8Write("fsync@openssh.com", p += 4, 17);
        writeUInt32BE(buf, handleLen, p += 17);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`
        );
      }
      ext_openssh_lsetstat(path14, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["lsetstat@openssh.com"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("lsetstat@openssh.com", p += 4, 20);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path14, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status2 = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status2} lsetstat@openssh.com`);
        }
      }
      ext_openssh_expandPath(path14, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["expand-path@openssh.com"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path14);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 23, p);
        buf.utf8Write("expand-path@openssh.com", p += 4, 23);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path14, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing expanded path"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status2 = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status2} expand-path@openssh.com`);
        }
      }
      ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["copy-data"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(srcHandle))
          throw new Error("Source handle is not a Buffer");
        if (!Buffer.isBuffer(dstHandle))
          throw new Error("Destination handle is not a Buffer");
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 9, p);
        p += 4;
        buf.utf8Write("copy-data", p, 9);
        p += 9;
        writeUInt32BE(buf, srcHandle.length, p);
        p += 4;
        buf.set(srcHandle, p);
        p += srcHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = srcOffset & 255;
          srcOffset /= 256;
        }
        p += 8;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = len & 255;
          len /= 256;
        }
        p += 8;
        writeUInt32BE(buf, dstHandle.length, p);
        p += 4;
        buf.set(dstHandle, p);
        p += dstHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = dstOffset & 255;
          dstOffset /= 256;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status2 = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status2} copy-data`);
        }
      }
      ext_home_dir(username, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["home-directory"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        if (typeof username !== "string")
          throw new TypeError("username is not a string");
        let p = 0;
        const usernameLen = Buffer.byteLength(username);
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 14 + 4 + usernameLen
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 14, p);
        p += 4;
        buf.utf8Write("home-directory", p, 14);
        p += 14;
        writeUInt32BE(buf, usernameLen, p);
        p += 4;
        buf.utf8Write(username, p, usernameLen);
        p += usernameLen;
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing home directory"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status2 = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status2} home-directory`);
        }
      }
      ext_users_groups(uids, gids, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext2 = this._extensions["users-groups-by-id@openssh.com"];
        if (ext2 !== "1")
          throw new Error("Server does not support this extended request");
        if (!Array.isArray(uids))
          throw new TypeError("uids is not an array");
        for (const val of uids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("uid values must all be 32-bit unsigned integers");
        }
        if (!Array.isArray(gids))
          throw new TypeError("gids is not an array");
        for (const val of gids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("gid values must all be 32-bit unsigned integers");
        }
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 30, p);
        p += 4;
        buf.utf8Write("users-groups-by-id@openssh.com", p, 30);
        p += 30;
        writeUInt32BE(buf, 4 * uids.length, p);
        p += 4;
        for (const val of uids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        writeUInt32BE(buf, 4 * gids.length, p);
        p += 4;
        for (const val of gids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        this._requests[reqid] = { extended: "users-groups-by-id@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status2 = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status2} users-groups-by-id@openssh.com`);
        }
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      handle(reqid, handle) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        if (handleLen > 256)
          throw new Error("handle too large (> 256 bytes)");
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.HANDLE;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        if (handleLen)
          buf.set(handle, p += 4);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`
        );
      }
      status(reqid, code3, message3) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!VALID_STATUS_CODES.has(code3))
          throw new Error(`Bad status code: ${code3}`);
        message3 || (message3 = "");
        const msgLen = Buffer.byteLength(message3);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.STATUS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, code3, p);
        writeUInt32BE(buf, msgLen, p += 4);
        p += 4;
        if (msgLen) {
          buf.utf8Write(message3, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(buf, 0, p);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`
        );
      }
      data(reqid, data, encoding) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        const isBuffer = Buffer.isBuffer(data);
        if (!isBuffer && typeof data !== "string")
          throw new Error("data is not a Buffer or string");
        let isUTF8;
        if (!isBuffer && !encoding) {
          encoding = void 0;
          isUTF8 = true;
        }
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.DATA;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, dataLen, p);
        if (dataLen) {
          if (isBuffer)
            buf.set(data, p += 4);
          else if (isUTF8)
            buf.utf8Write(data, p += 4, dataLen);
          else
            buf.write(data, p += 4, dataLen, encoding);
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`
        );
      }
      name(reqid, names) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Array.isArray(names)) {
          if (typeof names !== "object" || names === null)
            throw new Error("names is not an object or array");
          names = [names];
        }
        const count = names.length;
        let namesLen = 0;
        let nameAttrs;
        const attrs = [];
        for (let i = 0; i < count; ++i) {
          const name5 = names[i];
          const filename = !name5 || !name5.filename || typeof name5.filename !== "string" ? "" : name5.filename;
          namesLen += 4 + Buffer.byteLength(filename);
          const longname = !name5 || !name5.longname || typeof name5.longname !== "string" ? "" : name5.longname;
          namesLen += 4 + Buffer.byteLength(longname);
          if (typeof name5.attrs === "object" && name5.attrs !== null) {
            nameAttrs = attrsToBytes(name5.attrs);
            namesLen += 4 + nameAttrs.nb;
            if (nameAttrs.nb) {
              let bytes;
              if (nameAttrs.nb === ATTRS_BUF.length) {
                bytes = new Uint8Array(ATTRS_BUF);
              } else {
                bytes = new Uint8Array(nameAttrs.nb);
                bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);
              }
              nameAttrs.bytes = bytes;
            }
            attrs.push(nameAttrs);
          } else {
            namesLen += 4;
            attrs.push(null);
          }
        }
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.NAME;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, count, p);
        p += 4;
        for (let i = 0; i < count; ++i) {
          const name5 = names[i];
          {
            const filename = !name5 || !name5.filename || typeof name5.filename !== "string" ? "" : name5.filename;
            const len = Buffer.byteLength(filename);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(filename, p, len);
              p += len;
            }
          }
          {
            const longname = !name5 || !name5.longname || typeof name5.longname !== "string" ? "" : name5.longname;
            const len = Buffer.byteLength(longname);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(longname, p, len);
              p += len;
            }
          }
          const attr = attrs[i];
          if (attr) {
            writeUInt32BE(buf, attr.flags, p);
            p += 4;
            if (attr.flags && attr.bytes) {
              buf.set(attr.bytes, p);
              p += attr.nb;
            }
          } else {
            writeUInt32BE(buf, 0, p);
            p += 4;
          }
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`
        );
      }
      attrs(reqid, attrs) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (typeof attrs !== "object" || attrs === null)
          throw new Error("attrs is not an object");
        attrs = attrsToBytes(attrs);
        const flags = attrs.flags;
        const attrsLen = attrs.nb;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.ATTRS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, flags, p);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`
        );
      }
    };
    function tryCreateBuffer(size8) {
      try {
        return Buffer.allocUnsafe(size8);
      } catch (ex) {
        return ex;
      }
    }
    function read_(self2, handle, buf, off, len, position2, cb, req_) {
      const maxDataLen = self2._maxReadLen;
      const overflow = Math.max(len - maxDataLen, 0);
      if (overflow)
        len = maxDataLen;
      const handleLen = handle.length;
      let p = 9;
      let pos2 = position2;
      const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);
      writeUInt32BE(out, out.length - 4, 0);
      out[4] = REQUEST.READ;
      const reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(out, reqid, 5);
      writeUInt32BE(out, handleLen, p);
      out.set(handle, p += 4);
      p += handleLen;
      for (let i = 7; i >= 0; --i) {
        out[p + i] = pos2 & 255;
        pos2 /= 256;
      }
      writeUInt32BE(out, len, p += 8);
      if (typeof cb !== "function")
        cb = noop2;
      const req = req_ || {
        nb: 0,
        position: position2,
        off,
        origOff: off,
        len: void 0,
        overflow: void 0,
        cb: (err, data, nb) => {
          const len2 = req.len;
          const overflow2 = req.overflow;
          if (err) {
            if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)
              return cb(err);
          } else if (nb > len2) {
            return cb(new Error("Received more data than requested"));
          } else if (nb === len2 && overflow2) {
            req.nb += nb;
            req.position += nb;
            req.off += nb;
            read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
            return;
          }
          nb = nb || 0;
          if (req.origOff === 0 && buf.length === req.nb)
            data = buf;
          else
            data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);
          cb(void 0, req.nb + nb, data, req.position);
        },
        buffer: void 0
      };
      req.len = len;
      req.overflow = overflow;
      req.buffer = bufferSlice(buf, off, off + len);
      self2._requests[reqid] = req;
      const isBuffered = sendOrBuffer(self2, out);
      self2._debug && self2._debug(
        `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`
      );
    }
    function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
      let concurrency = 64;
      let chunkSize = 32768;
      let onstep;
      let mode2;
      let fileSize;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.concurrency === "number" && opts.concurrency > 0 && !isNaN(opts.concurrency)) {
          concurrency = opts.concurrency;
        }
        if (typeof opts.chunkSize === "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {
          chunkSize = opts.chunkSize;
        }
        if (typeof opts.fileSize === "number" && opts.fileSize > 0 && !isNaN(opts.fileSize)) {
          fileSize = opts.fileSize;
        }
        if (typeof opts.step === "function")
          onstep = opts.step;
        if (typeof opts.mode === "string" || typeof opts.mode === "number")
          mode2 = modeNum(opts.mode);
      }
      let fsize;
      let pdst = 0;
      let total = 0;
      let hadError = false;
      let srcHandle;
      let dstHandle;
      let readbuf;
      let bufsize = chunkSize * concurrency;
      function onerror(err) {
        if (hadError)
          return;
        hadError = true;
        let left3 = 0;
        let cbfinal;
        if (srcHandle || dstHandle) {
          cbfinal = () => {
            if (--left3 === 0)
              cb(err);
          };
          if (srcHandle && (src === fs16 || src.outgoing.state === "open"))
            ++left3;
          if (dstHandle && (dst === fs16 || dst.outgoing.state === "open"))
            ++left3;
          if (srcHandle && (src === fs16 || src.outgoing.state === "open"))
            src.close(srcHandle, cbfinal);
          if (dstHandle && (dst === fs16 || dst.outgoing.state === "open"))
            dst.close(dstHandle, cbfinal);
        } else {
          cb(err);
        }
      }
      src.open(srcPath, "r", (err, sourceHandle) => {
        if (err)
          return onerror(err);
        srcHandle = sourceHandle;
        if (fileSize === void 0)
          src.fstat(srcHandle, tryStat);
        else
          tryStat(null, { size: fileSize });
        function tryStat(err2, attrs) {
          if (err2) {
            if (src !== fs16) {
              src.stat(srcPath, (err_, attrs_) => {
                if (err_)
                  return onerror(err2);
                tryStat(null, attrs_);
              });
              return;
            }
            return onerror(err2);
          }
          fsize = attrs.size;
          dst.open(dstPath, "w", (err3, destHandle) => {
            if (err3)
              return onerror(err3);
            dstHandle = destHandle;
            if (fsize <= 0)
              return onerror();
            while (bufsize > fsize) {
              if (concurrency === 1) {
                bufsize = fsize;
                break;
              }
              bufsize -= chunkSize;
              --concurrency;
            }
            readbuf = tryCreateBuffer(bufsize);
            if (readbuf instanceof Error)
              return onerror(readbuf);
            if (mode2 !== void 0) {
              dst.fchmod(dstHandle, mode2, function tryAgain(err4) {
                if (err4) {
                  dst.chmod(dstPath, mode2, (err_) => tryAgain());
                  return;
                }
                startReads();
              });
            } else {
              startReads();
            }
            function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
              if (err4)
                return onerror(err4);
              datapos = datapos || 0;
              dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
              function writeCb(err5) {
                if (err5)
                  return onerror(err5);
                total += nb;
                onstep && onstep(total, nb, fsize);
                if (nb < origChunkLen)
                  return singleRead(datapos, dstpos + nb, origChunkLen - nb);
                if (total === fsize) {
                  dst.close(dstHandle, (err6) => {
                    dstHandle = void 0;
                    if (err6)
                      return onerror(err6);
                    src.close(srcHandle, (err7) => {
                      srcHandle = void 0;
                      if (err7)
                        return onerror(err7);
                      cb();
                    });
                  });
                  return;
                }
                if (pdst >= fsize)
                  return;
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(datapos, pdst, chunk);
                pdst += chunk;
              }
            }
            function makeCb(psrc, pdst2, chunk) {
              return (err4, nb, data) => {
                onread(err4, nb, data, pdst2, psrc, chunk);
              };
            }
            function singleRead(psrc, pdst2, chunk) {
              src.read(
                srcHandle,
                readbuf,
                psrc,
                chunk,
                pdst2,
                makeCb(psrc, pdst2, chunk)
              );
            }
            function startReads() {
              let reads = 0;
              let psrc = 0;
              while (pdst < fsize && reads < concurrency) {
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(psrc, pdst, chunk);
                psrc += chunk;
                pdst += chunk;
                ++reads;
              }
            }
          });
        }
      });
    }
    function writeAll(sftp, handle, buffer, offset, length9, position2, callback_) {
      const callback = typeof callback_ === "function" ? callback_ : void 0;
      sftp.write(
        handle,
        buffer,
        offset,
        length9,
        position2,
        (writeErr, written) => {
          if (writeErr) {
            return sftp.close(handle, () => {
              callback && callback(writeErr);
            });
          }
          if (written === length9) {
            sftp.close(handle, callback);
          } else {
            offset += written;
            length9 -= written;
            position2 += written;
            writeAll(sftp, handle, buffer, offset, length9, position2, callback);
          }
        }
      );
    }
    var Stats = class {
      constructor(initial) {
        this.mode = initial && initial.mode;
        this.uid = initial && initial.uid;
        this.gid = initial && initial.gid;
        this.size = initial && initial.size;
        this.atime = initial && initial.atime;
        this.mtime = initial && initial.mtime;
        this.extended = initial && initial.extended;
      }
      isDirectory() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFDIR;
      }
      isFile() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFREG;
      }
      isBlockDevice() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFBLK;
      }
      isCharacterDevice() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFCHR;
      }
      isSymbolicLink() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFLNK;
      }
      isFIFO() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFIFO;
      }
      isSocket() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFSOCK;
      }
    };
    function attrsToBytes(attrs) {
      let flags = 0;
      let nb = 0;
      if (typeof attrs === "object" && attrs !== null) {
        if (typeof attrs.size === "number") {
          flags |= ATTR.SIZE;
          const val = attrs.size;
          ATTRS_BUF[nb++] = val / 72057594037927940;
          ATTRS_BUF[nb++] = val / 281474976710656;
          ATTRS_BUF[nb++] = val / 1099511627776;
          ATTRS_BUF[nb++] = val / 4294967296;
          ATTRS_BUF[nb++] = val / 16777216;
          ATTRS_BUF[nb++] = val / 65536;
          ATTRS_BUF[nb++] = val / 256;
          ATTRS_BUF[nb++] = val;
        }
        if (typeof attrs.uid === "number" && typeof attrs.gid === "number") {
          flags |= ATTR.UIDGID;
          const uid2 = attrs.uid;
          const gid2 = attrs.gid;
          ATTRS_BUF[nb++] = uid2 >>> 24;
          ATTRS_BUF[nb++] = uid2 >>> 16;
          ATTRS_BUF[nb++] = uid2 >>> 8;
          ATTRS_BUF[nb++] = uid2;
          ATTRS_BUF[nb++] = gid2 >>> 24;
          ATTRS_BUF[nb++] = gid2 >>> 16;
          ATTRS_BUF[nb++] = gid2 >>> 8;
          ATTRS_BUF[nb++] = gid2;
        }
        if (typeof attrs.mode === "number" || typeof attrs.mode === "string") {
          const mode2 = modeNum(attrs.mode);
          flags |= ATTR.PERMISSIONS;
          ATTRS_BUF[nb++] = mode2 >>> 24;
          ATTRS_BUF[nb++] = mode2 >>> 16;
          ATTRS_BUF[nb++] = mode2 >>> 8;
          ATTRS_BUF[nb++] = mode2;
        }
        if ((typeof attrs.atime === "number" || isDate(attrs.atime)) && (typeof attrs.mtime === "number" || isDate(attrs.mtime))) {
          const atime = toUnixTimestamp(attrs.atime);
          const mtime = toUnixTimestamp(attrs.mtime);
          flags |= ATTR.ACMODTIME;
          ATTRS_BUF[nb++] = atime >>> 24;
          ATTRS_BUF[nb++] = atime >>> 16;
          ATTRS_BUF[nb++] = atime >>> 8;
          ATTRS_BUF[nb++] = atime;
          ATTRS_BUF[nb++] = mtime >>> 24;
          ATTRS_BUF[nb++] = mtime >>> 16;
          ATTRS_BUF[nb++] = mtime >>> 8;
          ATTRS_BUF[nb++] = mtime;
        }
      }
      return { flags, nb };
    }
    function toUnixTimestamp(time3) {
      if (typeof time3 === "number" && time3 === time3)
        return time3;
      if (isDate(time3))
        return parseInt(time3.getTime() / 1e3, 10);
      throw new Error(`Cannot parse time: ${time3}`);
    }
    function modeNum(mode2) {
      if (typeof mode2 === "number" && mode2 === mode2)
        return mode2;
      if (typeof mode2 === "string")
        return modeNum(parseInt(mode2, 8));
      throw new Error(`Cannot parse mode: ${mode2}`);
    }
    var stringFlagMap = {
      "r": OPEN_MODE.READ,
      "r+": OPEN_MODE.READ | OPEN_MODE.WRITE,
      "w": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "wx": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "w+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "wx+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "ax": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "ax+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL
    };
    function stringToFlags(str2) {
      const flags = stringFlagMap[str2];
      return flags !== void 0 ? flags : null;
    }
    var flagsToString = (() => {
      const stringFlagMapKeys = Object.keys(stringFlagMap);
      return (flags) => {
        for (let i = 0; i < stringFlagMapKeys.length; ++i) {
          const key = stringFlagMapKeys[i];
          if (stringFlagMap[key] === flags)
            return key;
        }
        return null;
      };
    })();
    function readAttrs(biOpt) {
      const flags = bufferParser.readUInt32BE();
      if (flags === void 0)
        return;
      const attrs = new Stats();
      if (flags & ATTR.SIZE) {
        const size8 = bufferParser.readUInt64BE(biOpt);
        if (size8 === void 0)
          return;
        attrs.size = size8;
      }
      if (flags & ATTR.UIDGID) {
        const uid2 = bufferParser.readUInt32BE();
        const gid2 = bufferParser.readUInt32BE();
        if (gid2 === void 0)
          return;
        attrs.uid = uid2;
        attrs.gid = gid2;
      }
      if (flags & ATTR.PERMISSIONS) {
        const mode2 = bufferParser.readUInt32BE();
        if (mode2 === void 0)
          return;
        attrs.mode = mode2;
      }
      if (flags & ATTR.ACMODTIME) {
        const atime = bufferParser.readUInt32BE();
        const mtime = bufferParser.readUInt32BE();
        if (mtime === void 0)
          return;
        attrs.atime = atime;
        attrs.mtime = mtime;
      }
      if (flags & ATTR.EXTENDED) {
        const count = bufferParser.readUInt32BE();
        if (count === void 0)
          return;
        const extended = {};
        for (let i = 0; i < count; ++i) {
          const type = bufferParser.readString(true);
          const data = bufferParser.readString();
          if (data === void 0)
            return;
          extended[type] = data;
        }
        attrs.extended = extended;
      }
      return attrs;
    }
    function sendOrBuffer(sftp, payload) {
      const ret = tryWritePayload(sftp, payload);
      if (ret !== void 0) {
        sftp._buffer.push(ret);
        return false;
      }
      return true;
    }
    function tryWritePayload(sftp, payload) {
      const outgoing = sftp.outgoing;
      if (outgoing.state !== "open")
        return;
      if (outgoing.window === 0) {
        sftp._waitWindow = true;
        sftp._chunkcb = drainBuffer;
        return payload;
      }
      let ret;
      const len = payload.length;
      let p = 0;
      while (len - p > 0 && outgoing.window > 0) {
        const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
        outgoing.window -= actualLen;
        if (outgoing.window === 0) {
          sftp._waitWindow = true;
          sftp._chunkcb = drainBuffer;
        }
        if (p === 0 && actualLen === len) {
          sftp._protocol.channelData(sftp.outgoing.id, payload);
        } else {
          sftp._protocol.channelData(
            sftp.outgoing.id,
            bufferSlice(payload, p, p + actualLen)
          );
        }
        p += actualLen;
      }
      if (len - p > 0) {
        if (p > 0)
          ret = bufferSlice(payload, p, len);
        else
          ret = payload;
      }
      return ret;
    }
    function drainBuffer() {
      this._chunkcb = void 0;
      const buffer = this._buffer;
      let i = 0;
      while (i < buffer.length) {
        const payload = buffer[i];
        const ret = tryWritePayload(this, payload);
        if (ret !== void 0) {
          if (ret !== payload)
            buffer[i] = ret;
          if (i > 0)
            this._buffer = buffer.slice(i);
          return;
        }
        ++i;
      }
      if (i > 0)
        this._buffer = [];
    }
    function doFatalSFTPError(sftp, msg, noDebug) {
      const err = new Error(msg);
      err.level = "sftp-protocol";
      if (!noDebug && sftp._debug)
        sftp._debug(`SFTP: Inbound: ${msg}`);
      sftp.emit("error", err);
      sftp.destroy();
      cleanupRequests(sftp);
      return false;
    }
    function cleanupRequests(sftp) {
      const keys4 = Object.keys(sftp._requests);
      if (keys4.length === 0)
        return;
      const reqs = sftp._requests;
      sftp._requests = {};
      const err = new Error("No response from server");
      for (let i = 0; i < keys4.length; ++i) {
        const req = reqs[keys4[i]];
        if (typeof req.cb === "function")
          req.cb(err);
      }
    }
    function requestLimits(sftp, cb) {
      let p = 9;
      const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
      writeUInt32BE(buf, buf.length - 4, 0);
      buf[4] = REQUEST.EXTENDED;
      const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(buf, reqid, 5);
      writeUInt32BE(buf, 18, p);
      buf.utf8Write("limits@openssh.com", p += 4, 18);
      sftp._requests[reqid] = { extended: "limits@openssh.com", cb };
      const isBuffered = sendOrBuffer(sftp, buf);
      if (sftp._debug) {
        const which = isBuffered ? "Buffered" : "Sending";
        sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
      }
    }
    var CLIENT_HANDLERS = {
      [RESPONSE.VERSION]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate VERSION packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version4 = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version4 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version4 === void 0)
          return doFatalSFTPError(sftp, "Malformed VERSION packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received VERSION (v${version4}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received VERSION (v${version4})`);
          }
        }
        sftp._version = version4;
        sftp._extensions = extensions;
        if (extensions["limits@openssh.com"] === "1") {
          return requestLimits(sftp, (err, limits) => {
            if (!err) {
              if (limits.maxPktLen > 0)
                sftp._maxOutPktLen = limits.maxPktLen;
              if (limits.maxReadLen > 0)
                sftp._maxReadLen = limits.maxReadLen;
              if (limits.maxWriteLen > 0)
                sftp._maxWriteLen = limits.maxWriteLen;
              sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;
            }
            sftp.emit("ready");
          });
        }
        sftp.emit("ready");
      },
      [RESPONSE.STATUS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const errorCode = bufferParser.readUInt32BE();
        const errorMsg = bufferParser.readString(true);
        bufferParser.clear();
        if (sftp._debug) {
          const jsonMsg = JSON.stringify(errorMsg);
          sftp._debug(
            `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`
          );
        }
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function") {
          if (errorCode === STATUS_CODE.OK) {
            req.cb();
            return;
          }
          const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
          err.code = errorCode;
          req.cb(err);
        }
      },
      [RESPONSE.HANDLE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0) {
          if (reqID !== void 0)
            delete sftp._requests[reqID];
          return doFatalSFTPError(sftp, "Malformed HANDLE packet");
        }
        sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function")
          req.cb(void 0, handle);
      },
      [RESPONSE.DATA]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        if (req && typeof req.cb === "function") {
          if (req.buffer) {
            const nb = bufferParser.readString(req.buffer);
            bufferParser.clear();
            if (nb !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
              );
              req.cb(void 0, req.buffer, nb);
              return;
            }
          } else {
            const data = bufferParser.readString();
            bufferParser.clear();
            if (data !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`
              );
              req.cb(void 0, data);
              return;
            }
          }
        } else {
          const nb = bufferParser.skipString();
          bufferParser.clear();
          if (nb !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
            );
            return;
          }
        }
        return doFatalSFTPError(sftp, "Malformed DATA packet");
      },
      [RESPONSE.NAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const count = bufferParser.readUInt32BE();
        if (count !== void 0) {
          let names = [];
          for (let i = 0; i < count; ++i) {
            const filename = bufferParser.readString(true);
            const longname = bufferParser.readString(true);
            const attrs = readAttrs(sftp._biOpt);
            if (attrs === void 0) {
              names = void 0;
              break;
            }
            names.push({ filename, longname, attrs });
          }
          if (names !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`
            );
            bufferParser.clear();
            if (req && typeof req.cb === "function")
              req.cb(void 0, names);
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed NAME packet");
      },
      [RESPONSE.ATTRS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs !== void 0) {
          sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);
          if (req && typeof req.cb === "function")
            req.cb(void 0, attrs);
          return;
        }
        return doFatalSFTPError(sftp, "Malformed ATTRS packet");
      },
      [RESPONSE.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        if (reqID !== void 0) {
          const req = sftp._requests[reqID];
          if (req) {
            delete sftp._requests[reqID];
            switch (req.extended) {
              case "statvfs@openssh.com":
              case "fstatvfs@openssh.com": {
                const biOpt = sftp._biOpt;
                const stats = {
                  f_bsize: bufferParser.readUInt64BE(biOpt),
                  f_frsize: bufferParser.readUInt64BE(biOpt),
                  f_blocks: bufferParser.readUInt64BE(biOpt),
                  f_bfree: bufferParser.readUInt64BE(biOpt),
                  f_bavail: bufferParser.readUInt64BE(biOpt),
                  f_files: bufferParser.readUInt64BE(biOpt),
                  f_ffree: bufferParser.readUInt64BE(biOpt),
                  f_favail: bufferParser.readUInt64BE(biOpt),
                  f_sid: bufferParser.readUInt64BE(biOpt),
                  f_flag: bufferParser.readUInt64BE(biOpt),
                  f_namemax: bufferParser.readUInt64BE(biOpt)
                };
                if (stats.f_namemax === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, stats);
                return;
              }
              case "limits@openssh.com": {
                const limits = {
                  maxPktLen: bufferParser.readUInt64BE(),
                  maxReadLen: bufferParser.readUInt64BE(),
                  maxWriteLen: bufferParser.readUInt64BE(),
                  maxOpenHandles: bufferParser.readUInt64BE()
                };
                if (limits.maxOpenHandles === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, limits);
                return;
              }
              case "users-groups-by-id@openssh.com": {
                const usernameCount = bufferParser.readUInt32BE();
                if (usernameCount === void 0)
                  break;
                const usernames = new Array(usernameCount);
                for (let i = 0; i < usernames.length; ++i)
                  usernames[i] = bufferParser.readString(true);
                const groupnameCount = bufferParser.readUInt32BE();
                if (groupnameCount === void 0)
                  break;
                const groupnames = new Array(groupnameCount);
                for (let i = 0; i < groupnames.length; ++i)
                  groupnames[i] = bufferParser.readString(true);
                if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0) {
                  break;
                }
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, usernames, groupnames);
                return;
              }
              default:
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
                );
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb();
                return;
            }
          } else {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
            );
            bufferParser.clear();
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
      }
    };
    var SERVER_HANDLERS = {
      [REQUEST.INIT]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate INIT packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version4 = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version4 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version4 === void 0)
          return doFatalSFTPError(sftp, "Malformed INIT packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received INIT (v${version4}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received INIT (v${version4})`);
          }
        }
        sendOrBuffer(sftp, SERVER_VERSION_BUFFER);
        sftp._version = version4;
        sftp._extensions = extensions;
        sftp.emit("ready");
      },
      [REQUEST.OPEN]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const filename = bufferParser.readString(true);
        const pflags = bufferParser.readUInt32BE();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed OPEN packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);
        if (!sftp.emit("OPEN", reqID, filename, pflags, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.CLOSE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed CLOSE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);
        if (!sftp.emit("CLOSE", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READ]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const len = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (len === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READ packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);
        if (!sftp.emit("READ", reqID, handle, offset, len)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.WRITE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed WRITE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);
        if (!sftp.emit("WRITE", reqID, handle, offset, data)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.LSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed LSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);
        if (!sftp.emit("LSTAT", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);
        if (!sftp.emit("FSTAT", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);
        if (!sftp.emit("SETSTAT", reqID, path14, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received FSETSTAT (id:${reqID})`
        );
        if (!sftp.emit("FSETSTAT", reqID, handle, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.OPENDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);
        if (!sftp.emit("OPENDIR", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);
        if (!sftp.emit("READDIR", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REMOVE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed REMOVE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);
        if (!sftp.emit("REMOVE", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.MKDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed MKDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);
        if (!sftp.emit("MKDIR", reqID, path14, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RMDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed RMDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);
        if (!sftp.emit("RMDIR", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REALPATH]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed REALPATH packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received REALPATH (id:${reqID})`
        );
        if (!sftp.emit("REALPATH", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.STAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed STAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);
        if (!sftp.emit("STAT", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RENAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const oldPath = bufferParser.readString(true);
        const newPath = bufferParser.readString(true);
        bufferParser.clear();
        if (newPath === void 0)
          return doFatalSFTPError(sftp, "Malformed RENAME packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);
        if (!sftp.emit("RENAME", reqID, oldPath, newPath)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path14 = bufferParser.readString(true);
        bufferParser.clear();
        if (path14 === void 0)
          return doFatalSFTPError(sftp, "Malformed READLINK packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received READLINK (id:${reqID})`
        );
        if (!sftp.emit("READLINK", reqID, path14)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SYMLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const linkPath = bufferParser.readString(true);
        const targetPath = bufferParser.readString(true);
        bufferParser.clear();
        if (targetPath === void 0)
          return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
        let handled;
        if (sftp._isOpenSSH) {
          handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath);
        } else {
          handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath);
        }
        if (!handled) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const extName = bufferParser.readString(true);
        if (extName === void 0) {
          bufferParser.clear();
          return doFatalSFTPError(sftp, "Malformed EXTENDED packet");
        }
        let extData;
        if (bufferParser.avail())
          extData = bufferParser.readRaw();
        bufferParser.clear();
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received EXTENDED (id:${reqID})`
        );
        if (!sftp.emit("EXTENDED", reqID, extName, extData)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      }
    };
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_OUT_OF_RANGE,
      validateNumber
    } = require_node_fs_compat();
    var kMinPoolSpace = 128;
    var pool;
    var poolFragments = [];
    function allocNewPool(poolSize2) {
      if (poolFragments.length > 0)
        pool = poolFragments.pop();
      else
        pool = Buffer.allocUnsafe(poolSize2);
      pool.used = 0;
    }
    function checkPosition(pos2, name5) {
      if (!Number.isSafeInteger(pos2)) {
        validateNumber(pos2, name5);
        if (!Number.isInteger(pos2))
          throw new ERR_OUT_OF_RANGE(name5, "an integer", pos2);
        throw new ERR_OUT_OF_RANGE(name5, ">= 0 and <= 2 ** 53 - 1", pos2);
      }
      if (pos2 < 0)
        throw new ERR_OUT_OF_RANGE(name5, ">= 0 and <= 2 ** 53 - 1", pos2);
    }
    function roundUpToMultipleOf8(n) {
      return n + 7 & ~7;
    }
    function ReadStream2(sftp, path14, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      options.emitClose = false;
      options.autoDestroy = false;
      ReadableStream.call(this, options);
      this.path = path14;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesRead = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (this.end !== Infinity) {
        checkPosition(this.end, "end");
        if (this.start !== void 0 && this.start > this.end) {
          throw new ERR_OUT_OF_RANGE(
            "start",
            `<= "end" (here: ${this.end})`,
            this.start
          );
        }
      }
      this.on("end", function() {
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(ReadStream2, ReadableStream);
    ReadStream2.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        this.emit("open", handle);
        this.emit("ready");
        this.read();
      });
    };
    ReadStream2.prototype._read = function(n) {
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", () => this._read(n));
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
      }
      const thisPool = pool;
      let toRead = Math.min(pool.length - pool.used, n);
      const start = pool.used;
      if (this.end !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      this.sftp.read(
        this.handle,
        pool,
        pool.used,
        toRead,
        this.pos,
        (er, bytesRead) => {
          if (er) {
            this.emit("error", er);
            if (this.autoClose)
              this.destroy();
            return;
          }
          let b = null;
          if (start + toRead === thisPool.used && thisPool === pool) {
            thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
          } else {
            const alignedEnd = start + toRead & ~7;
            const alignedStart = roundUpToMultipleOf8(start + bytesRead);
            if (alignedEnd - alignedStart >= kMinPoolSpace)
              poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
          }
          if (bytesRead > 0) {
            this.bytesRead += bytesRead;
            b = thisPool.slice(start, start + bytesRead);
          }
          this.pos += bytesRead;
          this.push(b);
        }
      );
      pool.used = roundUpToMultipleOf8(pool.used + toRead);
    };
    ReadStream2.prototype._destroy = function(err, cb) {
      if (this._opening && !Buffer.isBuffer(this.handle)) {
        this.once("open", closeStream.bind(null, this, cb, err));
        return;
      }
      closeStream(this, cb, err);
      this.handle = null;
      this._opening = false;
    };
    function closeStream(stream3, cb, err) {
      if (!stream3.handle)
        return onclose();
      stream3.sftp.close(stream3.handle, onclose);
      function onclose(er) {
        er = er || err;
        cb(er);
        stream3.isClosed = true;
        if (!er)
          stream3.emit("close");
      }
    }
    ReadStream2.prototype.close = function(cb) {
      this.destroy(null, cb);
    };
    Object.defineProperty(ReadStream2.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    function WriteStream2(sftp, path14, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      options.emitClose = false;
      options.autoDestroy = false;
      WritableStream.call(this, options);
      this.path = path14;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesWritten = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      this.on("finish", function() {
        if (this._writableState.finalCalled)
          return;
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(WriteStream2, WritableStream);
    WriteStream2.prototype._final = function(cb) {
      if (this.autoClose)
        this.destroy();
      cb();
    };
    WriteStream2.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        const tryAgain = (err) => {
          if (err) {
            this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
            return;
          }
          if (this.flags[0] === "a") {
            const tryStat = (err2, st) => {
              if (err2) {
                this.sftp.stat(this.path, (err_, st_) => {
                  if (err_) {
                    this.destroy();
                    this.emit("error", err2);
                    return;
                  }
                  tryStat(null, st_);
                });
                return;
              }
              this.pos = st.size;
              this.emit("open", handle);
              this.emit("ready");
            };
            this.sftp.fstat(handle, tryStat);
            return;
          }
          this.emit("open", handle);
          this.emit("ready");
        };
        this.sftp.fchmod(handle, this.mode, tryAgain);
      });
    };
    WriteStream2.prototype._write = function(data, encoding, cb) {
      if (!Buffer.isBuffer(data)) {
        const err = new ERR_INVALID_ARG_TYPE("data", "Buffer", data);
        return this.emit("error", err);
      }
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      this.sftp.write(
        this.handle,
        data,
        0,
        data.length,
        this.pos,
        (er, bytes) => {
          if (er) {
            if (this.autoClose)
              this.destroy();
            return cb(er);
          }
          this.bytesWritten += bytes;
          cb();
        }
      );
      this.pos += data.length;
    };
    WriteStream2.prototype._writev = function(data, cb) {
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      const sftp = this.sftp;
      const handle = this.handle;
      let writesLeft = data.length;
      const onwrite = (er, bytes) => {
        if (er) {
          this.destroy();
          return cb(er);
        }
        this.bytesWritten += bytes;
        if (--writesLeft === 0)
          cb();
      };
      for (let i = 0; i < data.length; ++i) {
        const chunk = data[i].chunk;
        sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);
        this.pos += chunk.length;
      }
    };
    if (typeof WritableStream.prototype.destroy !== "function")
      WriteStream2.prototype.destroy = ReadStream2.prototype.destroy;
    WriteStream2.prototype._destroy = ReadStream2.prototype._destroy;
    WriteStream2.prototype.close = function(cb) {
      if (cb) {
        if (this.isClosed) {
          process.nextTick(cb);
          return;
        }
        this.on("close", cb);
      }
      if (!this.autoClose)
        this.on("finish", this.destroy.bind(this));
      this.end();
    };
    WriteStream2.prototype.destroySoon = WriteStream2.prototype.end;
    Object.defineProperty(WriteStream2.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    module.exports = {
      flagsToString,
      OPEN_MODE,
      SFTP,
      Stats,
      STATUS_CODE,
      stringToFlags
    };
  }
});

// node_modules/ssh2/lib/Channel.js
var require_Channel = __commonJS({
  "node_modules/ssh2/lib/Channel.js"(exports, module) {
    "use strict";
    var {
      Duplex: DuplexStream,
      Readable: ReadableStream,
      Writable: WritableStream
    } = __require("stream");
    var {
      CHANNEL_EXTENDED_DATATYPE: { STDERR }
    } = require_constants5();
    var { bufferSlice } = require_utils7();
    var PACKET_SIZE = 32 * 1024;
    var MAX_WINDOW = 2 * 1024 * 1024;
    var WINDOW_THRESHOLD = MAX_WINDOW / 2;
    var ClientStderr = class extends ReadableStream {
      constructor(channel, streamOpts) {
        super(streamOpts);
        this._channel = channel;
      }
      _read(n) {
        if (this._channel._waitChanDrain) {
          this._channel._waitChanDrain = false;
          if (this._channel.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this._channel);
        }
      }
    };
    var ServerStderr = class extends WritableStream {
      constructor(channel) {
        super({ highWaterMark: MAX_WINDOW });
        this._channel = channel;
      }
      _write(data, encoding, cb) {
        const channel = this._channel;
        const protocol = channel._client._protocol;
        const outgoing = channel.outgoing;
        const packetSize = outgoing.packetSize;
        const id2 = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelExtData(id2, data, STDERR);
          else
            protocol.channelExtData(id2, bufferSlice(data, p, p + sliceLen), STDERR);
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            channel._waitWindow = true;
          if (p > 0)
            channel._chunkErr = bufferSlice(data, p, len);
          else
            channel._chunkErr = data;
          channel._chunkcbErr = cb;
          return;
        }
        cb();
      }
    };
    var Channel = class extends DuplexStream {
      constructor(client, info4, opts) {
        const streamOpts = {
          highWaterMark: MAX_WINDOW,
          allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,
          emitClose: false
        };
        super(streamOpts);
        this.allowHalfOpen = streamOpts.allowHalfOpen;
        const server = !!(opts && opts.server);
        this.server = server;
        this.type = info4.type;
        this.subtype = void 0;
        this.incoming = info4.incoming;
        this.outgoing = info4.outgoing;
        this._callbacks = [];
        this._client = client;
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this.stdin = this.stdout = this;
        if (server)
          this.stderr = new ServerStderr(this);
        else
          this.stderr = new ClientStderr(this, streamOpts);
        this._waitWindow = false;
        this._waitChanDrain = false;
        this._chunk = void 0;
        this._chunkcb = void 0;
        this._chunkErr = void 0;
        this._chunkcbErr = void 0;
        this.on("finish", onFinish).on("prefinish", onFinish);
        this.on("end", onEnd).on("close", onEnd);
      }
      _read(n) {
        if (this._waitChanDrain) {
          this._waitChanDrain = false;
          if (this.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this);
        }
      }
      _write(data, encoding, cb) {
        const protocol = this._client._protocol;
        const outgoing = this.outgoing;
        const packetSize = outgoing.packetSize;
        const id2 = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelData(id2, data);
          else
            protocol.channelData(id2, bufferSlice(data, p, p + sliceLen));
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            this._waitWindow = true;
          if (p > 0)
            this._chunk = bufferSlice(data, p, len);
          else
            this._chunk = data;
          this._chunkcb = cb;
          return;
        }
        cb();
      }
      eof() {
        if (this.outgoing.state === "open") {
          this.outgoing.state = "eof";
          this._client._protocol.channelEOF(this.outgoing.id);
        }
      }
      close() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._client._protocol.channelClose(this.outgoing.id);
        }
      }
      destroy() {
        this.end();
        this.close();
        return this;
      }
      // Session type-specific methods =============================================
      setWindow(rows, cols, height, width2) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open") {
          this._client._protocol.windowChange(
            this.outgoing.id,
            rows,
            cols,
            height,
            width2
          );
        }
      }
      signal(signalName) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          this._client._protocol.signal(this.outgoing.id, signalName);
        }
      }
      exit(statusOrSignal, coreDumped, msg) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          if (typeof statusOrSignal === "number") {
            this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);
          } else {
            this._client._protocol.exitSignal(
              this.outgoing.id,
              statusOrSignal,
              coreDumped,
              msg
            );
          }
        }
      }
    };
    function onFinish() {
      this.eof();
      if (this.server || !this.allowHalfOpen)
        this.close();
      this.writable = false;
    }
    function onEnd() {
      this.readable = false;
    }
    function windowAdjust(self2) {
      if (self2.outgoing.state === "closed")
        return;
      const amt = MAX_WINDOW - self2.incoming.window;
      if (amt <= 0)
        return;
      self2.incoming.window += amt;
      self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt);
    }
    module.exports = {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    };
  }
});

// node_modules/ssh2/lib/utils.js
var require_utils8 = __commonJS({
  "node_modules/ssh2/lib/utils.js"(exports, module) {
    "use strict";
    var { SFTP } = require_SFTP();
    var MAX_CHANNEL = 2 ** 32 - 1;
    function onChannelOpenFailure(self2, recipient, info4, cb) {
      self2._chanMgr.remove(recipient);
      if (typeof cb !== "function")
        return;
      let err;
      if (info4 instanceof Error) {
        err = info4;
      } else if (typeof info4 === "object" && info4 !== null) {
        err = new Error(`(SSH) Channel open failure: ${info4.description}`);
        err.reason = info4.reason;
      } else {
        err = new Error(
          "(SSH) Channel open failure: server closed channel unexpectedly"
        );
        err.reason = "";
      }
      cb(err);
    }
    function onCHANNEL_CLOSE(self2, recipient, channel, err, dead) {
      if (typeof channel === "function") {
        onChannelOpenFailure(self2, recipient, err, channel);
        return;
      }
      if (typeof channel !== "object" || channel === null)
        return;
      if (channel.incoming && channel.incoming.state === "closed")
        return;
      self2._chanMgr.remove(recipient);
      if (channel.server && channel.constructor.name === "Session")
        return;
      channel.incoming.state = "closed";
      if (channel.readable)
        channel.push(null);
      if (channel.server) {
        if (channel.stderr.writable)
          channel.stderr.end();
      } else if (channel.stderr.readable) {
        channel.stderr.push(null);
      }
      if (channel.constructor !== SFTP && (channel.outgoing.state === "open" || channel.outgoing.state === "eof") && !dead) {
        channel.close();
      }
      if (channel.outgoing.state === "closing")
        channel.outgoing.state = "closed";
      const readState = channel._readableState;
      const writeState = channel._writableState;
      if (writeState && !writeState.ending && !writeState.finished && !dead)
        channel.end();
      const chanCallbacks = channel._callbacks;
      channel._callbacks = [];
      for (let i = 0; i < chanCallbacks.length; ++i)
        chanCallbacks[i](true);
      if (channel.server) {
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          channel.emit("close");
        } else {
          channel.once("end", () => channel.emit("close"));
        }
      } else {
        let doClose;
        switch (channel.type) {
          case "direct-streamlocal@openssh.com":
          case "direct-tcpip":
            doClose = () => channel.emit("close");
            break;
          default: {
            const exit2 = channel._exit;
            doClose = () => {
              if (exit2.code === null)
                channel.emit("close", exit2.code, exit2.signal, exit2.dump, exit2.desc);
              else
                channel.emit("close", exit2.code);
            };
          }
        }
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          doClose();
        } else {
          channel.once("end", doClose);
        }
        const errReadState = channel.stderr._readableState;
        if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {
          channel.stderr.emit("close");
        } else {
          channel.stderr.once("end", () => channel.stderr.emit("close"));
        }
      }
    }
    var ChannelManager = class {
      constructor(client) {
        this._client = client;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
      }
      add(val) {
        let id2;
        if (this._cur < MAX_CHANNEL) {
          id2 = ++this._cur;
        } else if (this._count === 0) {
          this._cur = 0;
          id2 = 0;
        } else {
          const channels = this._channels;
          for (let i = 0; i < MAX_CHANNEL; ++i) {
            if (channels[i] === void 0) {
              id2 = i;
              break;
            }
          }
        }
        if (id2 === void 0)
          return -1;
        this._channels[id2] = val || true;
        ++this._count;
        return id2;
      }
      update(id2, val) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        if (val && this._channels[id2])
          this._channels[id2] = val;
      }
      get(id2) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        return this._channels[id2];
      }
      remove(id2) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        if (this._channels[id2]) {
          delete this._channels[id2];
          if (this._count)
            --this._count;
        }
      }
      cleanup(err) {
        const channels = this._channels;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
        const chanIDs = Object.keys(channels);
        const client = this._client;
        for (let i = 0; i < chanIDs.length; ++i) {
          const id2 = +chanIDs[i];
          const channel = channels[id2];
          onCHANNEL_CLOSE(client, id2, channel._channel || channel, err, true);
        }
      }
    };
    var isRegExp = /* @__PURE__ */ (() => {
      const toString9 = Object.prototype.toString;
      return (val) => toString9.call(val) === "[object RegExp]";
    })();
    function generateAlgorithmList(algoList, defaultList, supportedList) {
      if (Array.isArray(algoList) && algoList.length > 0) {
        for (let i = 0; i < algoList.length; ++i) {
          if (supportedList.indexOf(algoList[i]) === -1)
            throw new Error(`Unsupported algorithm: ${algoList[i]}`);
        }
        return algoList;
      }
      if (typeof algoList === "object" && algoList !== null) {
        const keys4 = Object.keys(algoList);
        let list3 = defaultList;
        for (let i = 0; i < keys4.length; ++i) {
          const key = keys4[i];
          let val = algoList[key];
          switch (key) {
            case "append":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const append48 = val[j];
                  if (typeof append48 === "string") {
                    if (!append48 || list3.indexOf(append48) !== -1)
                      continue;
                    if (supportedList.indexOf(append48) === -1)
                      throw new Error(`Unsupported algorithm: ${append48}`);
                    if (list3 === defaultList)
                      list3 = list3.slice();
                    list3.push(append48);
                  } else if (isRegExp(append48)) {
                    for (let k = 0; k < supportedList.length; ++k) {
                      const algo = supportedList[k];
                      if (append48.test(algo)) {
                        if (list3.indexOf(algo) !== -1)
                          continue;
                        if (list3 === defaultList)
                          list3 = list3.slice();
                        list3.push(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "prepend":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = val.length; j >= 0; --j) {
                  const prepend = val[j];
                  if (typeof prepend === "string") {
                    if (!prepend || list3.indexOf(prepend) !== -1)
                      continue;
                    if (supportedList.indexOf(prepend) === -1)
                      throw new Error(`Unsupported algorithm: ${prepend}`);
                    if (list3 === defaultList)
                      list3 = list3.slice();
                    list3.unshift(prepend);
                  } else if (isRegExp(prepend)) {
                    for (let k = supportedList.length; k >= 0; --k) {
                      const algo = supportedList[k];
                      if (prepend.test(algo)) {
                        if (list3.indexOf(algo) !== -1)
                          continue;
                        if (list3 === defaultList)
                          list3 = list3.slice();
                        list3.unshift(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "remove":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const search2 = val[j];
                  if (typeof search2 === "string") {
                    if (!search2)
                      continue;
                    const idx = list3.indexOf(search2);
                    if (idx === -1)
                      continue;
                    if (list3 === defaultList)
                      list3 = list3.slice();
                    list3.splice(idx, 1);
                  } else if (isRegExp(search2)) {
                    for (let k = 0; k < list3.length; ++k) {
                      if (search2.test(list3[k])) {
                        if (list3 === defaultList)
                          list3 = list3.slice();
                        list3.splice(k, 1);
                        --k;
                      }
                    }
                  }
                }
              }
              break;
          }
        }
        return list3;
      }
      return defaultList;
    }
    module.exports = {
      ChannelManager,
      generateAlgorithmList,
      onChannelOpenFailure,
      onCHANNEL_CLOSE,
      isWritable: (stream3) => {
        return stream3 && stream3.writable && stream3._readableState && stream3._readableState.ended === false;
      }
    };
  }
});

// node_modules/ssh2/lib/client.js
var require_client = __commonJS({
  "node_modules/ssh2/lib/client.js"(exports, module) {
    "use strict";
    var {
      createHash: createHash2,
      getHashes,
      randomFillSync
    } = __require("crypto");
    var { Socket } = __require("net");
    var { lookup: dnsLookup } = __require("dns");
    var EventEmitter3 = __require("events");
    var HASHES = getHashes();
    var {
      COMPAT,
      CHANNEL_EXTENDED_DATATYPE: { STDERR },
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants5();
    var { init: cryptoInit } = require_crypto();
    var Protocol = require_Protocol();
    var { parseKey } = require_keyParser();
    var { SFTP } = require_SFTP();
    var {
      bufferCopy,
      makeBufferParser,
      makeError,
      readUInt32BE,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var { AgentContext, createAgent, isAgent } = require_agent();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable: isWritable2,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils8();
    var bufferParser = makeBufferParser();
    var sigParser = makeBufferParser();
    var RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;
    var noop2 = (err) => {
    };
    var Client = class extends EventEmitter3 {
      constructor() {
        super();
        this.config = {
          host: void 0,
          port: void 0,
          localAddress: void 0,
          localPort: void 0,
          forceIPv4: void 0,
          forceIPv6: void 0,
          keepaliveCountMax: void 0,
          keepaliveInterval: void 0,
          readyTimeout: void 0,
          ident: void 0,
          username: void 0,
          password: void 0,
          privateKey: void 0,
          tryKeyboard: void 0,
          agent: void 0,
          allowAgentFwd: void 0,
          authHandler: void 0,
          hostHashAlgo: void 0,
          hostHashCb: void 0,
          strictVendor: void 0,
          debug: void 0
        };
        this._agent = void 0;
        this._readyTimeout = void 0;
        this._chanMgr = void 0;
        this._callbacks = void 0;
        this._forwarding = void 0;
        this._forwardingUnix = void 0;
        this._acceptX11 = void 0;
        this._agentFwdEnabled = void 0;
        this._remoteVer = void 0;
        this._protocol = void 0;
        this._sock = void 0;
        this._resetKA = void 0;
      }
      connect(cfg) {
        if (this._sock && isWritable2(this._sock)) {
          this.once("close", () => {
            this.connect(cfg);
          });
          this.end();
          return this;
        }
        this.config.host = cfg.hostname || cfg.host || "localhost";
        this.config.port = cfg.port || 22;
        this.config.localAddress = typeof cfg.localAddress === "string" ? cfg.localAddress : void 0;
        this.config.localPort = typeof cfg.localPort === "string" || typeof cfg.localPort === "number" ? cfg.localPort : void 0;
        this.config.forceIPv4 = cfg.forceIPv4 || false;
        this.config.forceIPv6 = cfg.forceIPv6 || false;
        this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;
        this.config.keepaliveInterval = typeof cfg.keepaliveInterval === "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;
        this.config.readyTimeout = typeof cfg.readyTimeout === "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4;
        this.config.ident = typeof cfg.ident === "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
        const algorithms = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: []
          },
          sc: void 0
        };
        let allOfferDefaults = true;
        if (typeof cfg.algorithms === "object" && cfg.algorithms !== null) {
          algorithms.kex = generateAlgorithmList(
            cfg.algorithms.kex,
            DEFAULT_KEX,
            SUPPORTED_KEX
          );
          if (algorithms.kex !== DEFAULT_KEX)
            allOfferDefaults = false;
          algorithms.serverHostKey = generateAlgorithmList(
            cfg.algorithms.serverHostKey,
            DEFAULT_SERVER_HOST_KEY,
            SUPPORTED_SERVER_HOST_KEY
          );
          if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)
            allOfferDefaults = false;
          algorithms.cs.cipher = generateAlgorithmList(
            cfg.algorithms.cipher,
            DEFAULT_CIPHER,
            SUPPORTED_CIPHER
          );
          if (algorithms.cs.cipher !== DEFAULT_CIPHER)
            allOfferDefaults = false;
          algorithms.cs.mac = generateAlgorithmList(
            cfg.algorithms.hmac,
            DEFAULT_MAC,
            SUPPORTED_MAC
          );
          if (algorithms.cs.mac !== DEFAULT_MAC)
            allOfferDefaults = false;
          algorithms.cs.compress = generateAlgorithmList(
            cfg.algorithms.compress,
            DEFAULT_COMPRESSION,
            SUPPORTED_COMPRESSION
          );
          if (algorithms.cs.compress !== DEFAULT_COMPRESSION)
            allOfferDefaults = false;
          if (!allOfferDefaults)
            algorithms.sc = algorithms.cs;
        }
        if (typeof cfg.username === "string")
          this.config.username = cfg.username;
        else if (typeof cfg.user === "string")
          this.config.username = cfg.user;
        else
          throw new Error("Invalid username");
        this.config.password = typeof cfg.password === "string" ? cfg.password : void 0;
        this.config.privateKey = typeof cfg.privateKey === "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0;
        this.config.localHostname = typeof cfg.localHostname === "string" ? cfg.localHostname : void 0;
        this.config.localUsername = typeof cfg.localUsername === "string" ? cfg.localUsername : void 0;
        this.config.tryKeyboard = cfg.tryKeyboard === true;
        if (typeof cfg.agent === "string" && cfg.agent.length)
          this.config.agent = createAgent(cfg.agent);
        else if (isAgent(cfg.agent))
          this.config.agent = cfg.agent;
        else
          this.config.agent = void 0;
        this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== void 0;
        let authHandler = this.config.authHandler = typeof cfg.authHandler === "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
        this.config.strictVendor = typeof cfg.strictVendor === "boolean" ? cfg.strictVendor : true;
        const debug2 = this.config.debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        if (cfg.agentForward === true && !this.config.allowAgentFwd) {
          throw new Error(
            "You must set a valid agent path to allow agent forwarding"
          );
        }
        let callbacks = this._callbacks = [];
        this._chanMgr = new ChannelManager(this);
        this._forwarding = {};
        this._forwardingUnix = {};
        this._acceptX11 = 0;
        this._agentFwdEnabled = false;
        this._agent = this.config.agent ? this.config.agent : void 0;
        this._remoteVer = void 0;
        let privateKey;
        if (this.config.privateKey) {
          privateKey = parseKey(this.config.privateKey, cfg.passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null) {
            throw new Error(
              "privateKey value does not contain a (valid) private key"
            );
          }
        }
        let hostVerifier;
        if (typeof cfg.hostVerifier === "function") {
          const hashCb = cfg.hostVerifier;
          let hasher;
          if (HASHES.indexOf(cfg.hostHash) !== -1) {
            hasher = createHash2(cfg.hostHash);
          }
          hostVerifier = (key, verify) => {
            if (hasher) {
              hasher.update(key);
              key = hasher.digest("hex");
            }
            const ret = hashCb(key, verify);
            if (ret !== void 0)
              verify(ret);
          };
        }
        const sock = this._sock = cfg.sock || new Socket();
        let ready = false;
        let sawHeader = false;
        if (this._protocol)
          this._protocol.cleanup();
        const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
          debug2(`Debug output from server: ${JSON.stringify(msg)}`);
        };
        let serverSigAlgs;
        const proto = this._protocol = new Protocol({
          ident: this.config.ident,
          offer: allOfferDefaults ? void 0 : algorithms,
          onWrite: (data) => {
            if (isWritable2(sock))
              sock.write(data);
          },
          onError: (err) => {
            if (err.level === "handshake")
              clearTimeout(this._readyTimeout);
            if (!proto._destruct)
              sock.removeAllListeners("data");
            this.emit("error", err);
            try {
              sock.end();
            } catch {
            }
          },
          onHeader: (header) => {
            sawHeader = true;
            this._remoteVer = header.versions.software;
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            this.emit("handshake", negotiated);
            if (!ready) {
              ready = true;
              proto.service("ssh-userauth");
            }
          },
          debug: debug2,
          hostVerifier,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              sock.end();
            },
            SERVICE_ACCEPT: (p, name5) => {
              if (name5 === "ssh-userauth")
                tryNextAuth();
            },
            EXT_INFO: (p, exts) => {
              if (serverSigAlgs === void 0) {
                for (const ext2 of exts) {
                  if (ext2.name === "server-sig-algs") {
                    serverSigAlgs = ext2.algs;
                    return;
                  }
                }
                serverSigAlgs = null;
              }
            },
            USERAUTH_BANNER: (p, msg) => {
              this.emit("banner", msg);
            },
            USERAUTH_SUCCESS: (p) => {
              resetKA();
              clearTimeout(this._readyTimeout);
              this.emit("ready");
            },
            USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {
              if (curAuth.keyAlgos) {
                const oldKeyAlgo = curAuth.keyAlgos[0][0];
                if (debug2)
                  debug2(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);
                curAuth.keyAlgos.shift();
                if (curAuth.keyAlgos.length) {
                  const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  switch (curAuth.type) {
                    case "agent":
                      proto.authPK(
                        curAuth.username,
                        curAuth.agentCtx.currentKey(),
                        keyAlgo
                      );
                      return;
                    case "publickey":
                      proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                      return;
                    case "hostbased":
                      proto.authHostbased(
                        curAuth.username,
                        curAuth.key,
                        curAuth.localHostname,
                        curAuth.localUsername,
                        keyAlgo,
                        (buf, cb) => {
                          const signature = curAuth.key.sign(buf, hashAlgo);
                          if (signature instanceof Error) {
                            signature.message = `Error while signing with key: ${signature.message}`;
                            signature.level = "client-authentication";
                            this.emit("error", signature);
                            return tryNextAuth();
                          }
                          cb(signature);
                        }
                      );
                      return;
                  }
                } else {
                  curAuth.keyAlgos = void 0;
                }
              }
              if (curAuth.type === "agent") {
                const pos2 = curAuth.agentCtx.pos();
                debug2 && debug2(`Client: Agent key #${pos2 + 1} failed`);
                return tryNextAgentKey();
              }
              debug2 && debug2(`Client: ${curAuth.type} auth failed`);
              curPartial = partialSuccess;
              curAuthsLeft = authMethods;
              tryNextAuth();
            },
            USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {
              if (curAuth.type === "password") {
                this.emit("change password", prompt, (newPassword) => {
                  proto.authPassword(
                    this.config.username,
                    this.config.password,
                    newPassword
                  );
                });
              }
            },
            USERAUTH_PK_OK: (p) => {
              let keyAlgo;
              let hashAlgo;
              if (curAuth.keyAlgos)
                [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              if (curAuth.type === "agent") {
                const key = curAuth.agentCtx.currentKey();
                proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {
                  const opts = { hash: hashAlgo };
                  curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {
                    if (err) {
                      err.level = "agent";
                      this.emit("error", err);
                    } else {
                      return cb(signed);
                    }
                    tryNextAgentKey();
                  });
                });
              } else if (curAuth.type === "publickey") {
                proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
                  const signature = curAuth.key.sign(buf, hashAlgo);
                  if (signature instanceof Error) {
                    signature.message = `Error signing data with key: ${signature.message}`;
                    signature.level = "client-authentication";
                    this.emit("error", signature);
                    return tryNextAuth();
                  }
                  cb(signature);
                });
              }
            },
            USERAUTH_INFO_REQUEST: (p, name5, instructions, prompts) => {
              if (curAuth.type === "keyboard-interactive") {
                const nprompts = Array.isArray(prompts) ? prompts.length : 0;
                if (nprompts === 0) {
                  debug2 && debug2(
                    "Client: Sending automatic USERAUTH_INFO_RESPONSE"
                  );
                  proto.authInfoRes();
                  return;
                }
                curAuth.prompt(
                  name5,
                  instructions,
                  "",
                  prompts,
                  (answers) => {
                    proto.authInfoRes(answers);
                  }
                );
              }
            },
            REQUEST_SUCCESS: (p, data) => {
              if (callbacks.length)
                callbacks.shift()(false, data);
            },
            REQUEST_FAILURE: (p) => {
              if (callbacks.length)
                callbacks.shift()(true);
            },
            GLOBAL_REQUEST: (p, name5, wantReply, data) => {
              switch (name5) {
                case "hostkeys-00@openssh.com":
                  hostKeysProve(this, data, (err, keys4) => {
                    if (err)
                      return;
                    this.emit("hostkeys", keys4);
                  });
                  if (wantReply)
                    proto.requestSuccess();
                  break;
                default:
                  if (wantReply)
                    proto.requestFailure();
              }
            },
            CHANNEL_OPEN: (p, info4) => {
              onCHANNEL_OPEN(this, info4);
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info4) => {
              const channel = this._chanMgr.get(info4.recipient);
              if (typeof channel !== "function")
                return;
              const isSFTP = channel.type === "sftp";
              const type = isSFTP ? "session" : channel.type;
              const chanInfo = {
                type,
                incoming: {
                  id: info4.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info4.sender,
                  window: info4.window,
                  packetSize: info4.packetSize,
                  state: "open"
                }
              };
              const instance = isSFTP ? new SFTP(this, chanInfo, { debug: debug2 }) : new Channel(this, chanInfo);
              this._chanMgr.update(info4.recipient, instance);
              channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function")
                return;
              const info4 = { reason, description };
              onChannelOpenFailure(this, recipient, info4, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
              if (type !== STDERR)
                return;
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (!channel.stderr.push(data)) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(
                    channel._chunkErr,
                    null,
                    channel._chunkcbErr
                  );
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              this._resetKA();
              if (channel._callbacks.length)
                channel._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              this._resetKA();
              if (channel._callbacks.length)
                channel._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              const exit2 = channel._exit;
              if (exit2.code !== void 0)
                return;
              switch (type) {
                case "exit-status":
                  channel.emit("exit", exit2.code = data);
                  return;
                case "exit-signal":
                  channel.emit(
                    "exit",
                    exit2.code = null,
                    exit2.signal = `SIG${data.signal}`,
                    exit2.dump = data.coreDumped,
                    exit2.desc = data.errorMessage
                  );
                  return;
              }
              if (wantReply)
                p.channelFailure(channel.outgoing.id);
            },
            CHANNEL_EOF: (p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.incoming.state !== "open")
                return;
              channel.incoming.state = "eof";
              if (channel.readable)
                channel.push(null);
              if (channel.stderr.readable)
                channel.stderr.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));
            }
          }
        });
        sock.pause();
        const kainterval = this.config.keepaliveInterval;
        const kacountmax = this.config.keepaliveCountMax;
        let kacount = 0;
        let katimer;
        const sendKA = () => {
          if (++kacount > kacountmax) {
            clearInterval(katimer);
            if (sock.readable) {
              const err = new Error("Keepalive timeout");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }
            return;
          }
          if (isWritable2(sock)) {
            callbacks.push(resetKA);
            proto.ping();
          } else {
            clearInterval(katimer);
          }
        };
        function resetKA() {
          if (kainterval > 0) {
            kacount = 0;
            clearInterval(katimer);
            if (isWritable2(sock))
              katimer = setInterval(sendKA, kainterval);
          }
        }
        this._resetKA = resetKA;
        const onDone = /* @__PURE__ */ (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            if (wasConnected && !sawHeader) {
              const err = makeError("Connection lost before handshake", "protocol", true);
              this.emit("error", err);
            }
          };
        })();
        const onConnect = /* @__PURE__ */ (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            wasConnected = true;
            debug2 && debug2("Socket connected");
            this.emit("connect");
            cryptoInit.then(() => {
              proto.start();
              sock.on("data", (data) => {
                try {
                  proto.parse(data, 0, data.length);
                } catch (ex) {
                  this.emit("error", ex);
                  try {
                    if (isWritable2(sock))
                      sock.end();
                  } catch {
                  }
                }
              });
              if (sock.stderr && typeof sock.stderr.resume === "function")
                sock.stderr.resume();
              sock.resume();
            }).catch((err) => {
              this.emit("error", err);
              try {
                if (isWritable2(sock))
                  sock.end();
              } catch {
              }
            });
          };
        })();
        let wasConnected = false;
        sock.on("connect", onConnect).on("timeout", () => {
          this.emit("timeout");
        }).on("error", (err) => {
          debug2 && debug2(`Socket error: ${err.message}`);
          clearTimeout(this._readyTimeout);
          err.level = "client-socket";
          this.emit("error", err);
        }).on("end", () => {
          debug2 && debug2("Socket ended");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("end");
        }).on("close", () => {
          debug2 && debug2("Socket closed");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("close");
          const callbacks_ = callbacks;
          callbacks = this._callbacks = [];
          const err = new Error("No response from server");
          for (let i = 0; i < callbacks_.length; ++i)
            callbacks_[i](err);
          this._chanMgr.cleanup(err);
        });
        let curAuth;
        let curPartial = null;
        let curAuthsLeft = null;
        const authsAllowed = ["none"];
        if (this.config.password !== void 0)
          authsAllowed.push("password");
        if (privateKey !== void 0)
          authsAllowed.push("publickey");
        if (this._agent !== void 0)
          authsAllowed.push("agent");
        if (this.config.tryKeyboard)
          authsAllowed.push("keyboard-interactive");
        if (privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0) {
          authsAllowed.push("hostbased");
        }
        if (Array.isArray(authHandler))
          authHandler = makeSimpleAuthHandler(authHandler);
        else if (typeof authHandler !== "function")
          authHandler = makeSimpleAuthHandler(authsAllowed);
        let hasSentAuth = false;
        const doNextAuth = (nextAuth) => {
          if (hasSentAuth)
            return;
          hasSentAuth = true;
          if (nextAuth === false) {
            const err = new Error("All configured authentication methods failed");
            err.level = "client-authentication";
            this.emit("error", err);
            this.end();
            return;
          }
          if (typeof nextAuth === "string") {
            const type = nextAuth;
            if (authsAllowed.indexOf(type) === -1)
              return skipAuth(`Authentication method not allowed: ${type}`);
            const username = this.config.username;
            switch (type) {
              case "password":
                nextAuth = { type, username, password: this.config.password };
                break;
              case "publickey":
                nextAuth = { type, username, key: privateKey };
                break;
              case "hostbased":
                nextAuth = {
                  type,
                  username,
                  key: privateKey,
                  localHostname: this.config.localHostname,
                  localUsername: this.config.localUsername
                };
                break;
              case "agent":
                nextAuth = {
                  type,
                  username,
                  agentCtx: new AgentContext(this._agent)
                };
                break;
              case "keyboard-interactive":
                nextAuth = {
                  type,
                  username,
                  prompt: (...args) => this.emit("keyboard-interactive", ...args)
                };
                break;
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          } else if (typeof nextAuth !== "object" || nextAuth === null) {
            return skipAuth(
              `Skipping invalid authentication attempt: ${nextAuth}`
            );
          } else {
            const username = nextAuth.username;
            if (typeof username !== "string") {
              return skipAuth(
                `Skipping invalid authentication attempt: ${nextAuth}`
              );
            }
            const type = nextAuth.type;
            switch (type) {
              case "password": {
                const { password } = nextAuth;
                if (typeof password !== "string" && !Buffer.isBuffer(password))
                  return skipAuth("Skipping invalid password auth attempt");
                nextAuth = { type, username, password };
                break;
              }
              case "publickey": {
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error)
                  return skipAuth("Skipping invalid key auth attempt");
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key };
                break;
              }
              case "hostbased": {
                const { localHostname, localUsername } = nextAuth;
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error || typeof localHostname !== "string" || typeof localUsername !== "string") {
                  return skipAuth("Skipping invalid hostbased auth attempt");
                }
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key, localHostname, localUsername };
                break;
              }
              case "agent": {
                let agent = nextAuth.agent;
                if (typeof agent === "string" && agent.length) {
                  agent = createAgent(agent);
                } else if (!isAgent(agent)) {
                  return skipAuth(
                    `Skipping invalid agent: ${nextAuth.agent}`
                  );
                }
                nextAuth = { type, username, agentCtx: new AgentContext(agent) };
                break;
              }
              case "keyboard-interactive": {
                const { prompt } = nextAuth;
                if (typeof prompt !== "function") {
                  return skipAuth(
                    "Skipping invalid keyboard-interactive auth attempt"
                  );
                }
                nextAuth = { type, username, prompt };
                break;
              }
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          }
          curAuth = nextAuth;
          try {
            const username = curAuth.username;
            switch (curAuth.type) {
              case "password":
                proto.authPassword(username, curAuth.password);
                break;
              case "publickey": {
                let keyAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    keyAlgo = curAuth.keyAlgos[0][0];
                  } else {
                    return skipAuth(
                      "Skipping key authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authPK(username, curAuth.key, keyAlgo);
                break;
              }
              case "hostbased": {
                let keyAlgo;
                let hashAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  } else {
                    return skipAuth(
                      "Skipping hostbased authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authHostbased(
                  username,
                  curAuth.key,
                  curAuth.localHostname,
                  curAuth.localUsername,
                  keyAlgo,
                  (buf, cb) => {
                    const signature = curAuth.key.sign(buf, hashAlgo);
                    if (signature instanceof Error) {
                      signature.message = `Error while signing with key: ${signature.message}`;
                      signature.level = "client-authentication";
                      this.emit("error", signature);
                      return tryNextAuth();
                    }
                    cb(signature);
                  }
                );
                break;
              }
              case "agent":
                curAuth.agentCtx.init((err) => {
                  if (err) {
                    err.level = "agent";
                    this.emit("error", err);
                    return tryNextAuth();
                  }
                  tryNextAgentKey();
                });
                break;
              case "keyboard-interactive":
                proto.authKeyboard(username);
                break;
              case "none":
                proto.authNone(username);
                break;
            }
          } finally {
            hasSentAuth = false;
          }
        };
        function skipAuth(msg) {
          debug2 && debug2(msg);
          process.nextTick(tryNextAuth);
        }
        function tryNextAuth() {
          hasSentAuth = false;
          const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
          if (hasSentAuth || auth === void 0)
            return;
          doNextAuth(auth);
        }
        const tryNextAgentKey = () => {
          if (curAuth.type === "agent") {
            const key = curAuth.agentCtx.nextKey();
            if (key === false) {
              debug2 && debug2("Agent: No more keys left to try");
              debug2 && debug2("Client: agent auth failed");
              tryNextAuth();
            } else {
              const pos2 = curAuth.agentCtx.pos();
              let keyAlgo;
              curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);
              if (curAuth.keyAlgos) {
                if (curAuth.keyAlgos.length) {
                  keyAlgo = curAuth.keyAlgos[0][0];
                } else {
                  debug2 && debug2(
                    `Agent: Skipping key #${pos2 + 1} (no mutual hash algorithm)`
                  );
                  tryNextAgentKey();
                  return;
                }
              }
              debug2 && debug2(`Agent: Trying key #${pos2 + 1}`);
              proto.authPK(curAuth.username, key, keyAlgo);
            }
          }
        };
        const startTimeout = () => {
          if (this.config.readyTimeout > 0) {
            this._readyTimeout = setTimeout(() => {
              const err = new Error("Timed out while waiting for handshake");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }, this.config.readyTimeout);
          }
        };
        if (!cfg.sock) {
          let host = this.config.host;
          const forceIPv4 = this.config.forceIPv4;
          const forceIPv6 = this.config.forceIPv6;
          debug2 && debug2(`Client: Trying ${host} on port ${this.config.port} ...`);
          const doConnect = () => {
            startTimeout();
            sock.connect({
              host,
              port: this.config.port,
              localAddress: this.config.localAddress,
              localPort: this.config.localPort
            });
            sock.setMaxListeners(0);
            sock.setTimeout(typeof cfg.timeout === "number" ? cfg.timeout : 0);
          };
          if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {
            doConnect();
          } else {
            dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
              if (err) {
                const type = forceIPv4 ? "IPv4" : "IPv6";
                const error5 = new Error(
                  `Error while looking up ${type} address for '${host}': ${err}`
                );
                clearTimeout(this._readyTimeout);
                error5.level = "client-dns";
                this.emit("error", error5);
                this.emit("close");
                return;
              }
              host = address;
              doConnect();
            });
          }
        } else {
          startTimeout();
          if (typeof sock.connecting === "boolean") {
            if (!sock.connecting) {
              onConnect();
            }
          } else {
            onConnect();
          }
        }
        return this;
      }
      end() {
        if (this._sock && isWritable2(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      destroy() {
        this._sock && isWritable2(this._sock) && this._sock.destroy();
        return this;
      }
      exec(cmd, opts, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        const extraOpts = { allowHalfOpen: opts.allowHalfOpen !== false };
        openChannel(this, "session", extraOpts, (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.pty === "object" && opts.pty !== null || opts.pty === true) {
              todo.push(() => reqPty(chan, opts.pty, reqCb));
            }
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqExec(chan, cmd, opts, cb));
          todo.shift()();
        });
        return this;
      }
      shell(wndopts, opts, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        if (typeof wndopts === "function") {
          cb = wndopts;
          wndopts = opts = void 0;
        } else if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0)) {
          opts = wndopts;
          wndopts = void 0;
        }
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (wndopts !== false)
            todo.push(() => reqPty(chan, wndopts, reqCb));
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqShell(chan, cb));
          todo.shift()();
        });
        return this;
      }
      subsys(name5, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(chan, name5, (err2, stream3) => {
            if (err2) {
              cb(err2);
              return;
            }
            cb(void 0, stream3);
          });
        });
        return this;
      }
      forwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err, data) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
              return;
            }
            let realPort = bindPort;
            if (bindPort === 0 && data && data.length >= 4) {
              realPort = readUInt32BE(data, 0);
              if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))
                bindPort = realPort;
            }
            this._forwarding[`${bindAddr}:${bindPort}`] = realPort;
            cb(void 0, realPort);
          });
        }
        this._protocol.tcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      unforwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
              return;
            }
            delete this._forwarding[`${bindAddr}:${bindPort}`];
            cb();
          });
        }
        this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const cfg = {
          srcIP,
          srcPort,
          dstIP,
          dstPort
        };
        if (typeof cb !== "function")
          cb = noop2;
        openChannel(this, "direct-tcpip", cfg, cb);
        return this;
      }
      openssh_noMoreSessions(cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error("Unable to disable future sessions"));
                return;
              }
              cb();
            });
          }
          this._protocol.openssh_noMoreSessions(wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));
                return;
              }
              this._forwardingUnix[socketPath] = true;
              cb();
            });
          }
          this._protocol.openssh_streamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_unforwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));
                return;
              }
              delete this._forwardingUnix[socketPath];
              cb();
            });
          }
          this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        if (typeof cb !== "function")
          cb = noop2;
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          openChannel(this, "direct-streamlocal@openssh.com", { socketPath }, cb);
          return this;
        }
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      sftp(cb) {
        if (!this._sock || !isWritable2(this._sock))
          throw new Error("Not connected");
        openChannel(this, "sftp", (err, sftp) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(sftp, "sftp", (err2, sftp_) => {
            if (err2) {
              cb(err2);
              return;
            }
            function removeListeners() {
              sftp.removeListener("ready", onReady);
              sftp.removeListener("error", onError);
              sftp.removeListener("exit", onExit2);
              sftp.removeListener("close", onExit2);
            }
            function onReady() {
              removeListeners();
              cb(void 0, sftp);
            }
            function onError(err3) {
              removeListeners();
              cb(err3);
            }
            function onExit2(code3, signal) {
              removeListeners();
              let msg;
              if (typeof code3 === "number")
                msg = `Received exit code ${code3} while establishing SFTP session`;
              else if (signal !== void 0)
                msg = `Received signal ${signal} while establishing SFTP session`;
              else
                msg = "Received unexpected SFTP session termination";
              const err3 = new Error(msg);
              err3.code = code3;
              err3.signal = signal;
              cb(err3);
            }
            sftp.on("ready", onReady).on("error", onError).on("exit", onExit2).on("close", onExit2);
            sftp._init();
          });
        });
        return this;
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream3) => {
        cb(err, stream3);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "session":
        case "sftp":
          self2._protocol.session(localChan, initWindow, maxPacket);
          break;
        case "direct-tcpip":
          self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "direct-streamlocal@openssh.com":
          self2._protocol.openssh_directStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function reqX11(chan, screen, cb) {
      const cfg = {
        single: false,
        protocol: "MIT-MAGIC-COOKIE-1",
        cookie: void 0,
        screen: 0
      };
      if (typeof screen === "function") {
        cb = screen;
      } else if (typeof screen === "object" && screen !== null) {
        if (typeof screen.single === "boolean")
          cfg.single = screen.single;
        if (typeof screen.screen === "number")
          cfg.screen = screen.screen;
        if (typeof screen.protocol === "string")
          cfg.protocol = screen.protocol;
        if (typeof screen.cookie === "string")
          cfg.cookie = screen.cookie;
        else if (Buffer.isBuffer(screen.cookie))
          cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);
      }
      if (cfg.cookie === void 0)
        cfg.cookie = randomCookie();
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request X11"));
            return;
          }
          chan._hasX11 = true;
          ++chan._client._acceptX11;
          chan.once("close", () => {
            if (chan._client._acceptX11)
              --chan._client._acceptX11;
          });
          cb();
        });
      }
      chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
    }
    function reqPty(chan, opts, cb) {
      let rows = 24;
      let cols = 80;
      let width2 = 640;
      let height = 480;
      let term = "vt100";
      let modes = null;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.rows === "number")
          rows = opts.rows;
        if (typeof opts.cols === "number")
          cols = opts.cols;
        if (typeof opts.width === "number")
          width2 = opts.width;
        if (typeof opts.height === "number")
          height = opts.height;
        if (typeof opts.term === "string")
          term = opts.term;
        if (typeof opts.modes === "object")
          modes = opts.modes;
      }
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request a pseudo-terminal"));
            return;
          }
          cb();
        });
      }
      chan._client._protocol.pty(
        chan.outgoing.id,
        rows,
        cols,
        height,
        width2,
        term,
        modes,
        wantReply
      );
    }
    function reqAgentFwd(chan, cb) {
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      if (chan._client._agentFwdEnabled) {
        wantReply && cb(false);
        return;
      }
      chan._client._agentFwdEnabled = true;
      chan._callbacks.push((had_err) => {
        if (had_err) {
          chan._client._agentFwdEnabled = false;
          if (wantReply) {
            cb(had_err !== true ? had_err : new Error("Unable to request agent forwarding"));
          }
          return;
        }
        if (wantReply)
          cb();
      });
      chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);
    }
    function reqShell(chan, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to open shell"));
          return;
        }
        chan.subtype = "shell";
        cb(void 0, chan);
      });
      chan._client._protocol.shell(chan.outgoing.id, true);
    }
    function reqExec(chan, cmd, opts, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to exec"));
          return;
        }
        chan.subtype = "exec";
        chan.allowHalfOpen = opts.allowHalfOpen !== false;
        cb(void 0, chan);
      });
      chan._client._protocol.exec(chan.outgoing.id, cmd, true);
    }
    function reqEnv(chan, env3) {
      if (chan.outgoing.state !== "open")
        return;
      const keys4 = Object.keys(env3 || {});
      for (let i = 0; i < keys4.length; ++i) {
        const key = keys4[i];
        const val = env3[key];
        chan._client._protocol.env(chan.outgoing.id, key, val, false);
      }
    }
    function reqSubsystem(chan, name5, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name5}`));
          return;
        }
        chan.subtype = "subsystem";
        cb(void 0, chan);
      });
      chan._client._protocol.subsystem(chan.outgoing.id, name5, true);
    }
    function onCHANNEL_OPEN(self2, info4) {
      let localChan = -1;
      let reason;
      const accept = () => {
        const chanInfo = {
          type: info4.type,
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info4.sender,
            window: info4.window,
            packetSize: info4.packetSize,
            state: "open"
          }
        };
        const stream3 = new Channel(self2, chanInfo);
        self2._chanMgr.update(localChan, stream3);
        self2._protocol.channelOpenConfirm(
          info4.sender,
          localChan,
          MAX_WINDOW,
          PACKET_SIZE
        );
        return stream3;
      };
      const reject = () => {
        if (reason === void 0) {
          if (localChan === -1)
            reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          else
            reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
        }
        if (localChan !== -1)
          self2._chanMgr.remove(localChan);
        self2._protocol.channelOpenFail(info4.sender, reason, "");
      };
      const reserveChannel = () => {
        localChan = self2._chanMgr.add();
        if (localChan === -1) {
          reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          if (self2.config.debug) {
            self2.config.debug(
              "Client: Automatic rejection of incoming channel open: no channels available"
            );
          }
        }
        return localChan !== -1;
      };
      const data = info4.data;
      switch (info4.type) {
        case "forwarded-tcpip": {
          const val = self2._forwarding[`${data.destIP}:${data.destPort}`];
          if (val !== void 0 && reserveChannel()) {
            if (data.destPort === 0)
              data.destPort = val;
            self2.emit("tcp connection", data, accept, reject);
            return;
          }
          break;
        }
        case "forwarded-streamlocal@openssh.com":
          if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
            self2.emit("unix connection", data, accept, reject);
            return;
          }
          break;
        case "auth-agent@openssh.com":
          if (self2._agentFwdEnabled && typeof self2._agent.getStream === "function" && reserveChannel()) {
            self2._agent.getStream((err, stream3) => {
              if (err)
                return reject();
              const upstream = accept();
              upstream.pipe(stream3).pipe(upstream);
            });
            return;
          }
          break;
        case "x11":
          if (self2._acceptX11 !== 0 && reserveChannel()) {
            self2.emit("x11", data, accept, reject);
            return;
          }
          break;
        default:
          reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
          if (self2.config.debug) {
            self2.config.debug(
              `Client: Automatic rejection of unsupported incoming channel open type: ${info4.type}`
            );
          }
      }
      if (reason === void 0) {
        reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
        if (self2.config.debug) {
          self2.config.debug(
            "Client: Automatic rejection of unexpected incoming channel open for: " + info4.type
          );
        }
      }
      reject();
    }
    var randomCookie = (() => {
      const buffer = Buffer.allocUnsafe(16);
      return () => {
        randomFillSync(buffer, 0, 16);
        return buffer.hexSlice(0, 16);
      };
    })();
    function makeSimpleAuthHandler(authList) {
      if (!Array.isArray(authList))
        throw new Error("authList must be an array");
      let a = 0;
      return (authsLeft, partialSuccess, cb) => {
        if (a === authList.length)
          return false;
        return authList[a++];
      };
    }
    function hostKeysProve(client, keys_, cb) {
      if (!client._sock || !isWritable2(client._sock))
        return;
      if (typeof cb !== "function")
        cb = noop2;
      if (!Array.isArray(keys_))
        throw new TypeError("Invalid keys argument type");
      const keys4 = [];
      for (const key of keys_) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          throw parsed;
        keys4.push(parsed);
      }
      if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {
        client._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Server failed to prove supplied keys"));
            return;
          }
          const ret = [];
          let keyIdx = 0;
          bufferParser.init(data, 0);
          while (bufferParser.avail()) {
            if (keyIdx === keys4.length)
              break;
            const key = keys4[keyIdx++];
            const keyPublic = key.getPublicSSH();
            const sigEntry = bufferParser.readString();
            sigParser.init(sigEntry, 0);
            const type = sigParser.readString(true);
            let value4 = sigParser.readString();
            let algo;
            if (type !== key.type) {
              if (key.type === "ssh-rsa") {
                switch (type) {
                  case "rsa-sha2-256":
                    algo = "sha256";
                    break;
                  case "rsa-sha2-512":
                    algo = "sha512";
                    break;
                  default:
                    continue;
                }
              } else {
                continue;
              }
            }
            const sessionID = client._protocol._kex.sessionID;
            const verifyData = Buffer.allocUnsafe(
              4 + 29 + 4 + sessionID.length + 4 + keyPublic.length
            );
            let p = 0;
            writeUInt32BE(verifyData, 29, p);
            verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
            writeUInt32BE(verifyData, sessionID.length, p += 29);
            bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);
            writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);
            bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);
            if (!(value4 = sigSSHToASN1(value4, type)))
              continue;
            if (key.verify(verifyData, value4, algo) === true)
              ret.push(key);
          }
          sigParser.clear();
          bufferParser.clear();
          cb(null, ret);
        });
        client._protocol.openssh_hostKeysProve(keys4);
        return;
      }
      process.nextTick(
        cb,
        new Error(
          "strictVendor enabled and server is not OpenSSH or compatible version"
        )
      );
    }
    function getKeyAlgos(client, key, serverSigAlgs) {
      switch (key.type) {
        case "ssh-rsa":
          if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {
            if (!Array.isArray(serverSigAlgs))
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512"];
            else
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512", ...serverSigAlgs];
          }
          if (Array.isArray(serverSigAlgs)) {
            if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1)
              return [["rsa-sha2-256", "sha256"]];
            if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1)
              return [["rsa-sha2-512", "sha512"]];
            if (serverSigAlgs.indexOf("ssh-rsa") === -1)
              return [];
          }
          return [["ssh-rsa", "sha1"]];
      }
    }
    module.exports = Client;
  }
});

// node_modules/ssh2/lib/http-agents.js
var require_http_agents = __commonJS({
  "node_modules/ssh2/lib/http-agents.js"(exports) {
    "use strict";
    var { Agent: HttpAgent } = __require("http");
    var { Agent: HttpsAgent } = __require("https");
    var { connect: tlsConnect } = __require("tls");
    var Client;
    for (const ctor of [HttpAgent, HttpsAgent]) {
      class SSHAgent extends ctor {
        constructor(connectCfg, agentOptions) {
          super(agentOptions);
          this._connectCfg = connectCfg;
          this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
        }
        createConnection(options, cb) {
          const srcIP = options && options.localAddress || this._defaultSrcIP;
          const srcPort = options && options.localPort || 0;
          const dstIP = options.host;
          const dstPort = options.port;
          if (Client === void 0)
            Client = require_client();
          const client = new Client();
          let triedForward = false;
          client.on("ready", () => {
            client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream3) => {
              triedForward = true;
              if (err) {
                client.end();
                return cb(err);
              }
              stream3.once("close", () => client.end());
              cb(null, decorateStream(stream3, ctor, options));
            });
          }).on("error", cb).on("close", () => {
            if (!triedForward)
              cb(new Error("Unexpected connection close"));
          }).connect(this._connectCfg);
        }
      }
      exports[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
    }
    function noop2() {
    }
    function decorateStream(stream3, ctor, options) {
      if (ctor === HttpAgent) {
        stream3.setKeepAlive = noop2;
        stream3.setNoDelay = noop2;
        stream3.setTimeout = noop2;
        stream3.ref = noop2;
        stream3.unref = noop2;
        stream3.destroySoon = stream3.destroy;
        return stream3;
      }
      options.socket = stream3;
      const wrapped2 = tlsConnect(options);
      const onClose = /* @__PURE__ */ (() => {
        let called = false;
        return () => {
          if (called)
            return;
          called = true;
          if (stream3.isPaused())
            stream3.resume();
        };
      })();
      wrapped2.on("end", onClose).on("close", onClose);
      return wrapped2;
    }
  }
});

// node_modules/ssh2/lib/server.js
var require_server = __commonJS({
  "node_modules/ssh2/lib/server.js"(exports, module) {
    "use strict";
    var { Server: netServer } = __require("net");
    var EventEmitter3 = __require("events");
    var { listenerCount: listenerCount2 } = EventEmitter3;
    var {
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants5();
    var { init: cryptoInit } = require_crypto();
    var { KexInit } = require_kex();
    var { parseKey } = require_keyParser();
    var Protocol = require_Protocol();
    var { SFTP } = require_SFTP();
    var { writeUInt32BE } = require_utils7();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable: isWritable2,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils8();
    var MAX_PENDING_AUTHS = 10;
    var AuthContext = class extends EventEmitter3 {
      constructor(protocol, username, service, method, cb) {
        super();
        this.username = this.user = username;
        this.service = service;
        this.method = method;
        this._initialResponse = false;
        this._finalResponse = false;
        this._multistep = false;
        this._cbfinal = (allowed, methodsLeft, isPartial) => {
          if (!this._finalResponse) {
            this._finalResponse = true;
            cb(this, allowed, methodsLeft, isPartial);
          }
        };
        this._protocol = protocol;
      }
      accept() {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(true);
      }
      reject(methodsLeft, isPartial) {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(false, methodsLeft, isPartial);
      }
    };
    var KeyboardAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, submethods, cb) {
        super(protocol, username, service, method, cb);
        this._multistep = true;
        this._cb = void 0;
        this._onInfoResponse = (responses) => {
          const callback = this._cb;
          if (callback) {
            this._cb = void 0;
            callback(responses);
          }
        };
        this.submethods = submethods;
        this.on("abort", () => {
          this._cb && this._cb(new Error("Authentication request aborted"));
        });
      }
      prompt(prompts, title2, instructions, cb) {
        if (!Array.isArray(prompts))
          prompts = [prompts];
        if (typeof title2 === "function") {
          cb = title2;
          title2 = instructions = void 0;
        } else if (typeof instructions === "function") {
          cb = instructions;
          instructions = void 0;
        } else if (typeof cb !== "function") {
          cb = void 0;
        }
        for (let i = 0; i < prompts.length; ++i) {
          if (typeof prompts[i] === "string") {
            prompts[i] = {
              prompt: prompts[i],
              echo: true
            };
          }
        }
        this._cb = cb;
        this._initialResponse = true;
        this._protocol.authInfoReq(title2, instructions, prompts);
      }
    };
    var PKAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
      }
      accept() {
        if (!this.signature) {
          this._initialResponse = true;
          this._protocol.authPKOK(this.key.algo, this.key.data);
        } else {
          AuthContext.prototype.accept.call(this);
        }
      }
    };
    var HostbasedAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
        this.localHostname = pkInfo.localHostname;
        this.localUsername = pkInfo.localUsername;
      }
    };
    var PwdAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, password, cb) {
        super(protocol, username, service, method, cb);
        this.password = password;
        this._changeCb = void 0;
      }
      requestChange(prompt, cb) {
        if (this._changeCb)
          throw new Error("Change request already in progress");
        if (typeof prompt !== "string")
          throw new Error("prompt argument must be a string");
        if (typeof cb !== "function")
          throw new Error("Callback argument must be a function");
        this._changeCb = cb;
        this._protocol.authPasswdChg(prompt);
      }
    };
    var Session = class extends EventEmitter3 {
      constructor(client, info4, localChan) {
        super();
        this.type = "session";
        this.subtype = void 0;
        this.server = true;
        this._ending = false;
        this._channel = void 0;
        this._chanInfo = {
          type: "session",
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info4.sender,
            window: info4.window,
            packetSize: info4.packetSize,
            state: "open"
          }
        };
      }
    };
    var Server = class extends EventEmitter3 {
      constructor(cfg, listener) {
        super();
        if (typeof cfg !== "object" || cfg === null)
          throw new Error("Missing configuration object");
        const hostKeys = /* @__PURE__ */ Object.create(null);
        const hostKeyAlgoOrder = [];
        const hostKeys_ = cfg.hostKeys;
        if (!Array.isArray(hostKeys_))
          throw new Error("hostKeys must be an array");
        const cfgAlgos = typeof cfg.algorithms === "object" && cfg.algorithms !== null ? cfg.algorithms : {};
        const hostKeyAlgos = generateAlgorithmList(
          cfgAlgos.serverHostKey,
          DEFAULT_SERVER_HOST_KEY,
          SUPPORTED_SERVER_HOST_KEY
        );
        for (let i = 0; i < hostKeys_.length; ++i) {
          let privateKey;
          if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === "string")
            privateKey = parseKey(hostKeys_[i]);
          else
            privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null)
            throw new Error("privateKey value contains an invalid private key");
          if (hostKeyAlgoOrder.includes(privateKey.type))
            continue;
          if (privateKey.type === "ssh-rsa") {
            let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa");
            const sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256");
            const sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
            if (sha1Pos === -1) {
              sha1Pos = Infinity;
            }
            [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos2) => {
              if (pos2 === -1)
                return;
              let type;
              switch (pos2) {
                case sha1Pos:
                  type = "ssh-rsa";
                  break;
                case sha256Pos:
                  type = "rsa-sha2-256";
                  break;
                case sha512Pos:
                  type = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              hostKeys[type] = privateKey;
              hostKeyAlgoOrder.push(type);
            });
          } else {
            hostKeys[privateKey.type] = privateKey;
            hostKeyAlgoOrder.push(privateKey.type);
          }
        }
        const algorithms = {
          kex: generateAlgorithmList(
            cfgAlgos.kex,
            DEFAULT_KEX,
            SUPPORTED_KEX
          ).concat(["kex-strict-s-v00@openssh.com"]),
          serverHostKey: hostKeyAlgoOrder,
          cs: {
            cipher: generateAlgorithmList(
              cfgAlgos.cipher,
              DEFAULT_CIPHER,
              SUPPORTED_CIPHER
            ),
            mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
            compress: generateAlgorithmList(
              cfgAlgos.compress,
              DEFAULT_COMPRESSION,
              SUPPORTED_COMPRESSION
            ),
            lang: []
          },
          sc: void 0
        };
        algorithms.sc = algorithms.cs;
        if (typeof listener === "function")
          this.on("connection", listener);
        const origDebug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        const ident = cfg.ident ? Buffer.from(cfg.ident) : void 0;
        const offer = new KexInit(algorithms);
        this._srv = new netServer((socket) => {
          if (this._connections >= this.maxConnections) {
            socket.destroy();
            return;
          }
          ++this._connections;
          socket.once("close", () => {
            --this._connections;
          });
          let debug2;
          if (origDebug) {
            const debugPrefix = `[${process.hrtime().join(".")}] `;
            debug2 = (msg) => {
              origDebug(`${debugPrefix}${msg}`);
            };
          }
          new Client(socket, hostKeys, ident, offer, debug2, this, cfg);
        }).on("error", (err) => {
          this.emit("error", err);
        }).on("listening", () => {
          this.emit("listening");
        }).on("close", () => {
          this.emit("close");
        });
        this._connections = 0;
        this.maxConnections = Infinity;
      }
      injectSocket(socket) {
        this._srv.emit("connection", socket);
      }
      listen(...args) {
        this._srv.listen(...args);
        return this;
      }
      address() {
        return this._srv.address();
      }
      getConnections(cb) {
        this._srv.getConnections(cb);
        return this;
      }
      close(cb) {
        this._srv.close(cb);
        return this;
      }
      ref() {
        this._srv.ref();
        return this;
      }
      unref() {
        this._srv.unref();
        return this;
      }
    };
    Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
    Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
    var Client = class extends EventEmitter3 {
      constructor(socket, hostKeys, ident, offer, debug2, server, srvCfg) {
        super();
        let exchanges = 0;
        let acceptedAuthSvc = false;
        let pendingAuths = [];
        let authCtx;
        let kaTimer;
        let onPacket;
        const unsentGlobalRequestsReplies = [];
        this._sock = socket;
        this._chanMgr = new ChannelManager(this);
        this._debug = debug2;
        this.noMoreSessions = false;
        this.authenticated = false;
        function onClientPreHeaderError(err) {
        }
        this.on("error", onClientPreHeaderError);
        const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
          debug2(`Debug output from client: ${JSON.stringify(msg)}`);
        };
        const kaIntvl = typeof srvCfg.keepaliveInterval === "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;
        const kaCountMax = typeof srvCfg.keepaliveCountMax === "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;
        let kaCurCount = 0;
        if (kaIntvl !== -1 && kaCountMax !== -1) {
          this.once("ready", () => {
            const onClose = () => {
              clearInterval(kaTimer);
            };
            this.on("close", onClose).on("end", onClose);
            kaTimer = setInterval(() => {
              if (++kaCurCount > kaCountMax) {
                clearInterval(kaTimer);
                const err = new Error("Keepalive timeout");
                err.level = "client-timeout";
                this.emit("error", err);
                this.end();
              } else {
                proto.ping();
              }
            }, kaIntvl);
          });
          onPacket = () => {
            kaTimer && kaTimer.refresh();
            kaCurCount = 0;
          };
        }
        const proto = this._protocol = new Protocol({
          server: true,
          hostKeys,
          ident,
          offer,
          onPacket,
          greeting: srvCfg.greeting,
          banner: srvCfg.banner,
          onWrite: (data) => {
            if (isWritable2(socket))
              socket.write(data);
          },
          onError: (err) => {
            if (!proto._destruct)
              socket.removeAllListeners("data");
            this.emit("error", err);
            try {
              socket.end();
            } catch {
            }
          },
          onHeader: (header) => {
            this.removeListener("error", onClientPreHeaderError);
            const info4 = {
              ip: socket.remoteAddress,
              family: socket.remoteFamily,
              port: socket.remotePort,
              header
            };
            if (!server.emit("connection", this, info4)) {
              proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);
              socket.end();
              return;
            }
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            if (++exchanges > 1)
              this.emit("rekey");
            this.emit("handshake", negotiated);
          },
          debug: debug2,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              socket.end();
            },
            CHANNEL_OPEN: (p, info4) => {
              if (info4.type === "session" && this.noMoreSessions || !this.authenticated) {
                const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                return proto.channelOpenFail(info4.sender, reasonCode);
              }
              let localChan = -1;
              let reason;
              let replied = false;
              let accept;
              const reject = () => {
                if (replied)
                  return;
                replied = true;
                if (reason === void 0) {
                  if (localChan === -1)
                    reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  else
                    reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
                }
                if (localChan !== -1)
                  this._chanMgr.remove(localChan);
                proto.channelOpenFail(info4.sender, reason, "");
              };
              const reserveChannel = () => {
                localChan = this._chanMgr.add();
                if (localChan === -1) {
                  reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  if (debug2) {
                    debug2("Automatic rejection of incoming channel open: no channels available");
                  }
                }
                return localChan !== -1;
              };
              const data = info4.data;
              switch (info4.type) {
                case "session":
                  if (listenerCount2(this, "session") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const instance = new Session(this, info4, localChan);
                      this._chanMgr.update(localChan, instance);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return instance;
                    };
                    this.emit("session", accept, reject);
                    return;
                  }
                  break;
                case "direct-tcpip":
                  if (listenerCount2(this, "tcpip") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info4.sender,
                          window: info4.window,
                          packetSize: info4.packetSize,
                          state: "open"
                        }
                      };
                      const stream3 = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream3);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream3;
                    };
                    this.emit("tcpip", accept, reject, data);
                    return;
                  }
                  break;
                case "direct-streamlocal@openssh.com":
                  if (listenerCount2(this, "openssh.streamlocal") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info4.sender,
                          window: info4.window,
                          packetSize: info4.packetSize,
                          state: "open"
                        }
                      };
                      const stream3 = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream3);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream3;
                    };
                    this.emit("openssh.streamlocal", accept, reject, data);
                    return;
                  }
                  break;
                default:
                  reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
                  if (debug2) {
                    debug2(`Automatic rejection of unsupported incoming channel open type: ${info4.type}`);
                  }
              }
              if (reason === void 0) {
                reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                if (debug2) {
                  debug2(`Automatic rejection of unexpected incoming channel open for: ${info4.type}`);
                }
              }
              reject();
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info4) => {
              const channel = this._chanMgr.get(info4.recipient);
              if (typeof channel !== "function")
                return;
              const chanInfo = {
                type: channel.type,
                incoming: {
                  id: info4.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info4.sender,
                  window: info4.window,
                  packetSize: info4.packetSize,
                  state: "open"
                }
              };
              const instance = new Channel(this, chanInfo, { server: true });
              this._chanMgr.update(info4.recipient, instance);
              channel(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function")
                return;
              const info4 = { reason, description };
              onChannelOpenFailure(this, recipient, info4, channel);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel.incoming.window === 0)
                return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(
                    channel._chunkErr,
                    null,
                    channel._chunkcbErr
                  );
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel._callbacks.length)
                channel._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel._callbacks.length)
                channel._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const session = this._chanMgr.get(recipient);
              if (typeof session !== "object" || session === null)
                return;
              let replied = false;
              let accept;
              let reject;
              if (session.constructor !== Session) {
                if (wantReply)
                  proto.channelFailure(session.outgoing.id);
                return;
              }
              if (wantReply) {
                if (type !== "shell" && type !== "exec" && type !== "subsystem") {
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  };
                }
                reject = () => {
                  if (replied || session._ending || session._channel)
                    return;
                  replied = true;
                  proto.channelFailure(session._chanInfo.outgoing.id);
                };
              }
              if (session._ending) {
                reject && reject();
                return;
              }
              switch (type) {
                case "env":
                  if (listenerCount2(session, "env")) {
                    session.emit("env", accept, reject, {
                      key: data.name,
                      val: data.value
                    });
                    return;
                  }
                  break;
                case "pty-req":
                  if (listenerCount2(session, "pty")) {
                    session.emit("pty", accept, reject, data);
                    return;
                  }
                  break;
                case "window-change":
                  if (listenerCount2(session, "window-change"))
                    session.emit("window-change", accept, reject, data);
                  else
                    reject && reject();
                  break;
                case "x11-req":
                  if (listenerCount2(session, "x11")) {
                    session.emit("x11", accept, reject, data);
                    return;
                  }
                  break;
                case "signal":
                  if (listenerCount2(session, "signal")) {
                    session.emit("signal", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                case "auth-agent-req@openssh.com":
                  if (listenerCount2(session, "auth-agent")) {
                    session.emit("auth-agent", accept, reject);
                    return;
                  }
                  break;
                case "shell":
                  if (listenerCount2(session, "shell")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    };
                    session.emit("shell", accept, reject);
                    return;
                  }
                  break;
                case "exec":
                  if (listenerCount2(session, "exec")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    };
                    session.emit("exec", accept, reject, {
                      command: data
                    });
                    return;
                  }
                  break;
                case "subsystem": {
                  let useSFTP = data === "sftp";
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    if (wantReply)
                      proto.channelSuccess(session._chanInfo.outgoing.id);
                    let instance;
                    if (useSFTP) {
                      instance = new SFTP(this, session._chanInfo, {
                        server: true,
                        debug: debug2
                      });
                    } else {
                      instance = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      instance.subtype = session.subtype = `${type}:${data}`;
                    }
                    session._channel = instance;
                    return instance;
                  };
                  if (data === "sftp") {
                    if (listenerCount2(session, "sftp")) {
                      session.emit("sftp", accept, reject);
                      return;
                    }
                    useSFTP = false;
                  }
                  if (listenerCount2(session, "subsystem")) {
                    session.emit("subsystem", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                }
              }
              debug2 && debug2(
                `Automatic rejection of incoming channel request: ${type}`
              );
              reject && reject();
            },
            CHANNEL_EOF: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                if (!channel._ending) {
                  channel._ending = true;
                  channel.emit("eof");
                  channel.emit("end");
                }
                channel = channel._channel;
                if (!channel)
                  return;
              }
              if (channel.incoming.state !== "open")
                return;
              channel.incoming.state = "eof";
              if (channel.readable)
                channel.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null)
                return;
              if (channel.constructor === Session) {
                channel._ending = true;
                channel.emit("close");
                channel = channel._channel;
                if (!channel)
                  return;
              }
              onCHANNEL_CLOSE(this, recipient, channel);
            },
            // Begin service/auth-related ==========================================
            SERVICE_REQUEST: (p, service) => {
              if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              acceptedAuthSvc = true;
              proto.serviceAccept(service);
            },
            USERAUTH_REQUEST: (p, username, service, method, methodData) => {
              if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
                proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);
                socket.end();
                return;
              } else if (service !== "ssh-connection") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              let ctx;
              switch (method) {
                case "keyboard-interactive":
                  ctx = new KeyboardAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "publickey":
                  ctx = new PKAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "hostbased":
                  ctx = new HostbasedAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "password":
                  if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                    const cb = authCtx._changeCb;
                    authCtx._changeCb = void 0;
                    cb(methodData.newPassword);
                    return;
                  }
                  ctx = new PwdAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "none":
                  ctx = new AuthContext(
                    proto,
                    username,
                    service,
                    method,
                    onAuthDecide
                  );
                  break;
              }
              if (authCtx) {
                if (!authCtx._initialResponse) {
                  return pendingAuths.push(ctx);
                } else if (authCtx._multistep && !authCtx._finalResponse) {
                  authCtx._cleanup && authCtx._cleanup();
                  authCtx.emit("abort");
                }
              }
              authCtx = ctx;
              if (listenerCount2(this, "authentication"))
                this.emit("authentication", authCtx);
              else
                authCtx.reject();
            },
            USERAUTH_INFO_RESPONSE: (p, responses) => {
              if (authCtx && authCtx instanceof KeyboardAuthContext)
                authCtx._onInfoResponse(responses);
            },
            // End service/auth-related ============================================
            GLOBAL_REQUEST: (p, name5, wantReply, data) => {
              const reply = {
                type: null,
                buf: null
              };
              function setReply(type, buf) {
                reply.type = type;
                reply.buf = buf;
                sendReplies();
              }
              if (wantReply)
                unsentGlobalRequestsReplies.push(reply);
              if ((name5 === "tcpip-forward" || name5 === "cancel-tcpip-forward" || name5 === "no-more-sessions@openssh.com" || name5 === "streamlocal-forward@openssh.com" || name5 === "cancel-streamlocal-forward@openssh.com") && listenerCount2(this, "request") && this.authenticated) {
                let accept;
                let reject;
                if (wantReply) {
                  let replied = false;
                  accept = (chosenPort) => {
                    if (replied)
                      return;
                    replied = true;
                    let bufPort;
                    if (name5 === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort === "number") {
                      bufPort = Buffer.allocUnsafe(4);
                      writeUInt32BE(bufPort, chosenPort, 0);
                    }
                    setReply("SUCCESS", bufPort);
                  };
                  reject = () => {
                    if (replied)
                      return;
                    replied = true;
                    setReply("FAILURE");
                  };
                }
                if (name5 === "no-more-sessions@openssh.com") {
                  this.noMoreSessions = true;
                  accept && accept();
                  return;
                }
                this.emit("request", accept, reject, name5, data);
              } else if (wantReply) {
                setReply("FAILURE");
              }
            }
          }
        });
        socket.pause();
        cryptoInit.then(() => {
          proto.start();
          socket.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                if (isWritable2(socket))
                  socket.end();
              } catch {
              }
            }
          });
          socket.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            if (isWritable2(socket))
              socket.end();
          } catch {
          }
        });
        socket.on("error", (err) => {
          err.level = "socket";
          this.emit("error", err);
        }).once("end", () => {
          debug2 && debug2("Socket ended");
          proto.cleanup();
          this.emit("end");
        }).once("close", () => {
          debug2 && debug2("Socket closed");
          proto.cleanup();
          this.emit("close");
          const err = new Error("No response from server");
          this._chanMgr.cleanup(err);
        });
        const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {
          if (authCtx === ctx && !this.authenticated) {
            if (allowed) {
              authCtx = void 0;
              this.authenticated = true;
              proto.authSuccess();
              pendingAuths = [];
              this.emit("ready");
            } else {
              proto.authFailure(methodsLeft, isPartial);
              if (pendingAuths.length) {
                authCtx = pendingAuths.pop();
                if (listenerCount2(this, "authentication"))
                  this.emit("authentication", authCtx);
                else
                  authCtx.reject();
              }
            }
          }
        };
        function sendReplies() {
          while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {
            const reply = unsentGlobalRequestsReplies.shift();
            if (reply.type === "SUCCESS")
              proto.requestSuccess(reply.buf);
            if (reply.type === "FAILURE")
              proto.requestFailure();
          }
        }
      }
      end() {
        if (this._sock && isWritable2(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      x11(originAddr, originPort, cb) {
        const opts = { originAddr, originPort };
        openChannel(this, "x11", opts, cb);
        return this;
      }
      forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
        const opts = { boundAddr, boundPort, remoteAddr, remotePort };
        openChannel(this, "forwarded-tcpip", opts, cb);
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        const opts = { socketPath };
        openChannel(this, "forwarded-streamlocal@openssh.com", opts, cb);
        return this;
      }
      rekey(cb) {
        let error5;
        try {
          this._protocol.rekey();
        } catch (ex) {
          error5 = ex;
        }
        if (typeof cb === "function") {
          if (error5)
            process.nextTick(cb, error5);
          else
            this.once("rekey", cb);
        }
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream3) => {
        cb(err, stream3);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "forwarded-tcpip":
          self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "x11":
          self2._protocol.x11(localChan, initWindow, maxPacket, opts);
          break;
        case "forwarded-streamlocal@openssh.com":
          self2._protocol.openssh_forwardedStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    module.exports = Server;
    module.exports.IncomingClient = Client;
  }
});

// node_modules/ssh2/lib/keygen.js
var require_keygen = __commonJS({
  "node_modules/ssh2/lib/keygen.js"(exports, module) {
    "use strict";
    var {
      createCipheriv,
      generateKeyPair: generateKeyPair_,
      generateKeyPairSync: generateKeyPairSync_,
      getCurves,
      randomBytes: randomBytes2
    } = __require("crypto");
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var SALT_LEN = 16;
    var DEFAULT_ROUNDS = 16;
    var curves = getCurves();
    var ciphers = new Map(Object.entries(CIPHER_INFO));
    function makeArgs(type, opts) {
      if (typeof type !== "string")
        throw new TypeError("Key type must be a string");
      const publicKeyEncoding = { type: "spki", format: "der" };
      const privateKeyEncoding = { type: "pkcs8", format: "der" };
      switch (type.toLowerCase()) {
        case "rsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for RSA key");
          const modulusLength = opts.bits;
          if (!Number.isInteger(modulusLength))
            throw new TypeError("RSA bits must be an integer");
          if (modulusLength <= 0 || modulusLength > 16384)
            throw new RangeError("RSA bits must be non-zero and <= 16384");
          return ["rsa", { modulusLength, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ecdsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for ECDSA key");
          if (!Number.isInteger(opts.bits))
            throw new TypeError("ECDSA bits must be an integer");
          let namedCurve;
          switch (opts.bits) {
            case 256:
              namedCurve = "prime256v1";
              break;
            case 384:
              namedCurve = "secp384r1";
              break;
            case 521:
              namedCurve = "secp521r1";
              break;
            default:
              throw new Error("ECDSA bits must be 256, 384, or 521");
          }
          if (!curves.includes(namedCurve))
            throw new Error("Unsupported ECDSA bits value");
          return ["ec", { namedCurve, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ed25519":
          return ["ed25519", { publicKeyEncoding, privateKeyEncoding }];
        default:
          throw new Error(`Unsupported key type: ${type}`);
      }
    }
    function parseDERs(keyType, pub, priv) {
      switch (keyType) {
        case "rsa": {
          let reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.113549.1.1.1")
            throw new Error("Bad RSA private OID");
          if (reader.readByte() !== Ber.Null)
            throw new Error("Malformed RSA private key (expected null)");
          if (reader.readByte() !== 0) {
            throw new Error(
              "Malformed RSA private key (expected zero-length null)"
            );
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          const n = reader.readString(Ber.Integer, true);
          const e = reader.readString(Ber.Integer, true);
          const d = reader.readString(Ber.Integer, true);
          const p = reader.readString(Ber.Integer, true);
          const q = reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          const iqmp = reader.readString(Ber.Integer, true);
          const keyName = Buffer.from("ssh-rsa");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length
          );
          let pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0);
          privBuf.set(keyName, pos2 += 4);
          privBuf.writeUInt32BE(n.length, pos2 += keyName.length);
          privBuf.set(n, pos2 += 4);
          privBuf.writeUInt32BE(e.length, pos2 += n.length);
          privBuf.set(e, pos2 += 4);
          privBuf.writeUInt32BE(d.length, pos2 += e.length);
          privBuf.set(d, pos2 += 4);
          privBuf.writeUInt32BE(iqmp.length, pos2 += d.length);
          privBuf.set(iqmp, pos2 += 4);
          privBuf.writeUInt32BE(p.length, pos2 += iqmp.length);
          privBuf.set(p, pos2 += 4);
          privBuf.writeUInt32BE(q.length, pos2 += p.length);
          privBuf.set(q, pos2 += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + e.length + 4 + n.length
          );
          pos2 = 0;
          pubBuf.writeUInt32BE(keyName.length, pos2 += 0);
          pubBuf.set(keyName, pos2 += 4);
          pubBuf.writeUInt32BE(e.length, pos2 += keyName.length);
          pubBuf.set(e, pos2 += 4);
          pubBuf.writeUInt32BE(n.length, pos2 += e.length);
          pubBuf.set(n, pos2 += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ec": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA public OID");
          reader.readOID();
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ECDSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA private OID");
          const curveOID = reader.readOID();
          let sshCurveName;
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              sshCurveName = "nistp256";
              break;
            case "1.3.132.0.34":
              sshCurveName = "nistp384";
              break;
            case "1.3.132.0.35":
              sshCurveName = "nistp521";
              break;
            default:
              throw new Error("Unsupported curve in ECDSA private key");
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 1)
            throw new Error("Unsupported version in ECDSA private key");
          const privBin = Buffer.concat([
            Buffer.from([0]),
            reader.readString(Ber.OctetString, true)
          ]);
          const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
          sshCurveName = Buffer.from(sshCurveName);
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length
          );
          let pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0);
          privBuf.set(keyName, pos2 += 4);
          privBuf.writeUInt32BE(sshCurveName.length, pos2 += keyName.length);
          privBuf.set(sshCurveName, pos2 += 4);
          privBuf.writeUInt32BE(pubBin.length, pos2 += sshCurveName.length);
          privBuf.set(pubBin, pos2 += 4);
          privBuf.writeUInt32BE(privBin.length, pos2 += pubBin.length);
          privBuf.set(privBin, pos2 += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length
          );
          pos2 = 0;
          pubBuf.writeUInt32BE(keyName.length, pos2 += 0);
          pubBuf.set(keyName, pos2 += 4);
          pubBuf.writeUInt32BE(sshCurveName.length, pos2 += keyName.length);
          pubBuf.set(sshCurveName, pos2 += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos2 += sshCurveName.length);
          pubBuf.set(pubBin, pos2 += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ed25519": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 public OID");
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ED25519 private key");
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 private OID");
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          const privBin = reader.readString(Ber.OctetString, true);
          const keyName = Buffer.from("ssh-ed25519");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length)
          );
          let pos2 = 0;
          privBuf.writeUInt32BE(keyName.length, pos2 += 0);
          privBuf.set(keyName, pos2 += 4);
          privBuf.writeUInt32BE(pubBin.length, pos2 += keyName.length);
          privBuf.set(pubBin, pos2 += 4);
          privBuf.writeUInt32BE(
            privBin.length + pubBin.length,
            pos2 += pubBin.length
          );
          privBuf.set(privBin, pos2 += 4);
          privBuf.set(pubBin, pos2 += privBin.length);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length
          );
          pos2 = 0;
          pubBuf.writeUInt32BE(keyName.length, pos2 += 0);
          pubBuf.set(keyName, pos2 += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos2 += keyName.length);
          pubBuf.set(pubBin, pos2 += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
      }
    }
    function convertKeys(keyType, pub, priv, opts) {
      let format2 = "new";
      let encrypted;
      let comment2 = "";
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.comment === "string" && opts.comment)
          comment2 = opts.comment;
        if (typeof opts.format === "string" && opts.format)
          format2 = opts.format;
        if (opts.passphrase) {
          let passphrase;
          if (typeof opts.passphrase === "string")
            passphrase = Buffer.from(opts.passphrase);
          else if (Buffer.isBuffer(opts.passphrase))
            passphrase = opts.passphrase;
          else
            throw new Error("Invalid passphrase");
          if (opts.cipher === void 0)
            throw new Error("Missing cipher name");
          const cipher = ciphers.get(opts.cipher);
          if (cipher === void 0)
            throw new Error("Invalid cipher name");
          if (format2 === "new") {
            let rounds = DEFAULT_ROUNDS;
            if (opts.rounds !== void 0) {
              if (!Number.isInteger(opts.rounds))
                throw new TypeError("rounds must be an integer");
              if (opts.rounds > 0)
                rounds = opts.rounds;
            }
            const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);
            const salt = randomBytes2(SALT_LEN);
            const r = bcrypt_pbkdf(
              passphrase,
              passphrase.length,
              salt,
              salt.length,
              gen,
              gen.length,
              rounds
            );
            if (r !== 0)
              return new Error("Failed to generate information to encrypt key");
            const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
            {
              let pos2 = 0;
              kdfOptions.writeUInt32BE(salt.length, pos2 += 0);
              kdfOptions.set(salt, pos2 += 4);
              kdfOptions.writeUInt32BE(rounds, pos2 += salt.length);
            }
            encrypted = {
              cipher,
              cipherName: opts.cipher,
              kdfName: "bcrypt",
              kdfOptions,
              key: gen.slice(0, cipher.keyLen),
              iv: gen.slice(cipher.keyLen)
            };
          }
        }
      }
      switch (format2) {
        case "new": {
          let privateB64 = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
          let publicB64;
          const cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none");
          const kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none");
          const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);
          const blockLen = encrypted ? encrypted.cipher.blockLen : 8;
          const parsed = parseDERs(keyType, pub, priv);
          const checkInt = randomBytes2(4);
          const commentBin = Buffer.from(comment2);
          const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;
          let padding = [];
          for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i)
            padding.push(i & 255);
          padding = Buffer.from(padding);
          let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);
          let extra;
          {
            let pos2 = 0;
            privBlob.set(checkInt, pos2 += 0);
            privBlob.set(checkInt, pos2 += 4);
            privBlob.set(parsed.priv, pos2 += 4);
            privBlob.writeUInt32BE(commentBin.length, pos2 += parsed.priv.length);
            privBlob.set(commentBin, pos2 += 4);
            privBlob.set(padding, pos2 += commentBin.length);
          }
          if (encrypted) {
            const options = { authTagLength: encrypted.cipher.authLen };
            const cipher = createCipheriv(
              encrypted.cipher.sslName,
              encrypted.key,
              encrypted.iv,
              options
            );
            cipher.setAutoPadding(false);
            privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]);
            if (encrypted.cipher.authLen > 0)
              extra = cipher.getAuthTag();
            else
              extra = Buffer.alloc(0);
            encrypted.key.fill(0);
            encrypted.iv.fill(0);
          } else {
            extra = Buffer.alloc(0);
          }
          const magicBytes = Buffer.from("openssh-key-v1\0");
          const privBin = Buffer.allocUnsafe(
            magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length
          );
          {
            let pos2 = 0;
            privBin.set(magicBytes, pos2 += 0);
            privBin.writeUInt32BE(cipherName.length, pos2 += magicBytes.length);
            privBin.set(cipherName, pos2 += 4);
            privBin.writeUInt32BE(kdfName.length, pos2 += cipherName.length);
            privBin.set(kdfName, pos2 += 4);
            privBin.writeUInt32BE(kdfOptions.length, pos2 += kdfName.length);
            privBin.set(kdfOptions, pos2 += 4);
            privBin.writeUInt32BE(1, pos2 += kdfOptions.length);
            privBin.writeUInt32BE(parsed.pub.length, pos2 += 4);
            privBin.set(parsed.pub, pos2 += 4);
            privBin.writeUInt32BE(privBlob.length, pos2 += parsed.pub.length);
            privBin.set(privBlob, pos2 += 4);
            privBin.set(extra, pos2 += privBlob.length);
          }
          {
            const b64 = privBin.base64Slice(0, privBin.length);
            let formatted = b64.replace(/.{64}/g, "$&\n");
            if (b64.length & 63)
              formatted += "\n";
            privateB64 += formatted;
          }
          {
            const b64 = parsed.pub.base64Slice(0, parsed.pub.length);
            publicB64 = `${parsed.sshName} ${b64}${comment2 ? ` ${comment2}` : ""}`;
          }
          privateB64 += "-----END OPENSSH PRIVATE KEY-----\n";
          return {
            private: privateB64,
            public: publicB64
          };
        }
        default:
          throw new Error("Invalid output key format");
      }
    }
    function noop2() {
    }
    module.exports = {
      generateKeyPair: (keyType, opts, cb) => {
        if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (typeof cb !== "function")
          cb = noop2;
        const args = makeArgs(keyType, opts);
        generateKeyPair_(...args, (err, pub, priv) => {
          if (err)
            return cb(err);
          let ret;
          try {
            ret = convertKeys(args[0], pub, priv, opts);
          } catch (ex) {
            return cb(ex);
          }
          cb(null, ret);
        });
      },
      generateKeyPairSync: (keyType, opts) => {
        const args = makeArgs(keyType, opts);
        const { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
        return convertKeys(args[0], pub, priv, opts);
      }
    };
  }
});

// node_modules/ssh2/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ssh2/lib/index.js"(exports, module) {
    "use strict";
    var {
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      OpenSSHAgent,
      PageantAgent
    } = require_agent();
    var {
      SSHTTPAgent: HTTPAgent,
      SSHTTPSAgent: HTTPSAgent
    } = require_http_agents();
    var { parseKey } = require_keyParser();
    var {
      flagsToString,
      OPEN_MODE,
      STATUS_CODE,
      stringToFlags
    } = require_SFTP();
    module.exports = {
      AgentProtocol,
      BaseAgent,
      createAgent,
      Client: require_client(),
      CygwinAgent,
      HTTPAgent,
      HTTPSAgent,
      OpenSSHAgent,
      PageantAgent,
      Server: require_server(),
      utils: {
        parseKey,
        ...require_keygen(),
        sftp: {
          flagsToString,
          OPEN_MODE,
          STATUS_CODE,
          stringToFlags
        }
      }
    };
  }
});

// node_modules/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag2, argv2 = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix4 = flag2.startsWith("-") ? "" : flag2.length === 1 ? "-" : "--";
  const position2 = argv2.indexOf(prefix4 + flag2);
  const terminatorPosition = argv2.indexOf("--");
  return position2 !== -1 && (terminatorPosition === -1 || position2 < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min8 = forceColor || 0;
  if (env.TERM === "dumb") {
    return min8;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min8;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version4 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version4 >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min8;
}
function createSupportsColor(stream3, options = {}) {
  const level = _supportsColor(stream3, {
    streamIsTTY: stream3 && stream3.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// output/Main/foreign.js
var supportsColor2 = () => {
  if ("NO_COLOR" in process.env) {
    return false;
  }
  ;
  if (supports_color_default.stderr) {
    return true;
  } else {
    return false;
  }
  ;
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};
var compose = function(dict) {
  return dict.compose;
};
var composeFlipped = function(dictSemigroupoid) {
  var compose1 = compose(dictSemigroupoid);
  return function(f) {
    return function(g) {
      return compose1(g)(f);
    };
  };
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var on = function(f) {
  return function(g) {
    return function(x) {
      return function(y) {
        return f(g(x))(g(y));
      };
    };
  };
};
var flip = function(f) {
  return function(b) {
    return function(a) {
      return f(a)(b);
    };
  };
};
var $$const = function(a) {
  return function(v) {
    return a;
  };
};
var applyN = function(f) {
  var go = function($copy_n) {
    return function($copy_acc) {
      var $tco_var_n = $copy_n;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(n, acc) {
        if (n <= 0) {
          $tco_done = true;
          return acc;
        }
        ;
        if (otherwise) {
          $tco_var_n = n - 1 | 0;
          $copy_acc = f(acc);
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Function (line 107, column 3 - line 109, column 37): " + [n.constructor.name, acc.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_n, $copy_acc);
      }
      ;
      return $tco_result;
    };
  };
  return go;
};
var applyFlipped = function(x) {
  return function(f) {
    return f(x);
  };
};
var apply = function(f) {
  return function(x) {
    return f(x);
  };
};

// output/Data.Unit/foreign.js
var unit = void 0;

// output/Type.Proxy/index.js
var $$Proxy = /* @__PURE__ */ function() {
  function $$Proxy2() {
  }
  ;
  $$Proxy2.value = new $$Proxy2();
  return $$Proxy2;
}();

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var mapFlipped = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(fa) {
    return function(f) {
      return map154(f)(fa);
    };
  };
};
var $$void = function(dictFunctor) {
  return map(dictFunctor)($$const(unit));
};
var voidLeft = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(f) {
    return function(x) {
      return map154($$const(x))(f);
    };
  };
};
var voidRight = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(x) {
    return map154($$const(x));
  };
};
var functorFn = {
  map: /* @__PURE__ */ compose(semigroupoidFn)
};
var functorArray = {
  map: arrayMap
};

// output/Data.Semigroup/foreign.js
var concatString = function(s1) {
  return function(s2) {
    return s1 + s2;
  };
};
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0)
      return ys;
    if (ys.length === 0)
      return xs;
    return xs.concat(ys);
  };
};

// output/Data.Symbol/index.js
var reflectSymbol = function(dict) {
  return dict.reflectSymbol;
};

// output/Record.Unsafe/foreign.js
var unsafeHas = function(label) {
  return function(rec) {
    return {}.hasOwnProperty.call(rec, label);
  };
};
var unsafeGet = function(label) {
  return function(rec) {
    return rec[label];
  };
};
var unsafeSet = function(label) {
  return function(value4) {
    return function(rec) {
      var copy = {};
      for (var key in rec) {
        if ({}.hasOwnProperty.call(rec, key)) {
          copy[key] = rec[key];
        }
      }
      copy[label] = value4;
      return copy;
    };
  };
};
var unsafeDelete = function(label) {
  return function(rec) {
    var copy = {};
    for (var key in rec) {
      if (key !== label && {}.hasOwnProperty.call(rec, key)) {
        copy[key] = rec[key];
      }
    }
    return copy;
  };
};

// output/Data.Semigroup/index.js
var semigroupUnit = {
  append: function(v) {
    return function(v1) {
      return unit;
    };
  }
};
var semigroupString = {
  append: concatString
};
var semigroupRecordNil = {
  appendRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  }
};
var semigroupArray = {
  append: concatArray
};
var appendRecord = function(dict) {
  return dict.appendRecord;
};
var semigroupRecord = function() {
  return function(dictSemigroupRecord) {
    return {
      append: appendRecord(dictSemigroupRecord)($$Proxy.value)
    };
  };
};
var append = function(dict) {
  return dict.append;
};
var semigroupFn = function(dictSemigroup) {
  var append127 = append(dictSemigroup);
  return {
    append: function(f) {
      return function(g) {
        return function(x) {
          return append127(f(x))(g(x));
        };
      };
    }
  };
};
var semigroupRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictSemigroupRecord) {
      var appendRecord1 = appendRecord(dictSemigroupRecord);
      return function(dictSemigroup) {
        var append127 = append(dictSemigroup);
        return {
          appendRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail4 = appendRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert22 = unsafeSet(key);
                var get6 = unsafeGet(key);
                return insert22(append127(get6(ra))(get6(rb)))(tail4);
              };
            };
          }
        };
      };
    };
  };
};

// output/Control.Alt/index.js
var altArray = {
  alt: /* @__PURE__ */ append(semigroupArray),
  Functor0: function() {
    return functorArray;
  }
};
var alt = function(dict) {
  return dict.alt;
};

// output/Control.Apply/foreign.js
var arrayApply = function(fs16) {
  return function(xs) {
    var l = fs16.length;
    var k = xs.length;
    var result = new Array(l * k);
    var n = 0;
    for (var i = 0; i < l; i++) {
      var f = fs16[i];
      for (var j = 0; j < k; j++) {
        result[n++] = f(xs[j]);
      }
    }
    return result;
  };
};

// output/Control.Apply/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var applyFn = {
  apply: function(f) {
    return function(g) {
      return function(x) {
        return f(x)(g(x));
      };
    };
  },
  Functor0: function() {
    return functorFn;
  }
};
var applyArray = {
  apply: arrayApply,
  Functor0: function() {
    return functorArray;
  }
};
var apply2 = function(dict) {
  return dict.apply;
};
var applyFirst = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map154 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply111(map154($$const)(a))(b);
    };
  };
};
var applySecond = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map154 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply111(map154($$const(identity2))(a))(b);
    };
  };
};
var lift2 = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map154 = map(dictApply.Functor0());
  return function(f) {
    return function(a) {
      return function(b) {
        return apply111(map154(f)(a))(b);
      };
    };
  };
};

// output/Control.Applicative/index.js
var pure = function(dict) {
  return dict.pure;
};
var unless = function(dictApplicative) {
  var pure129 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (!v) {
        return v1;
      }
      ;
      if (v) {
        return pure129(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var when = function(dictApplicative) {
  var pure129 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return pure129(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var liftA1 = function(dictApplicative) {
  var apply30 = apply2(dictApplicative.Apply0());
  var pure129 = pure(dictApplicative);
  return function(f) {
    return function(a) {
      return apply30(pure129(f))(a);
    };
  };
};
var applicativeFn = {
  pure: function(x) {
    return function(v) {
      return x;
    };
  },
  Apply0: function() {
    return applyFn;
  }
};
var applicativeArray = {
  pure: function(x) {
    return [x];
  },
  Apply0: function() {
    return applyArray;
  }
};

// output/Control.Plus/index.js
var plusArray = {
  empty: [],
  Alt0: function() {
    return altArray;
  }
};
var empty = function(dict) {
  return dict.empty;
};

// output/Control.Alternative/index.js
var guard = function(dictAlternative) {
  var pure98 = pure(dictAlternative.Applicative0());
  var empty14 = empty(dictAlternative.Plus1());
  return function(v) {
    if (v) {
      return pure98(unit);
    }
    ;
    if (!v) {
      return empty14;
    }
    ;
    throw new Error("Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): " + [v.constructor.name]);
  };
};
var alternativeArray = {
  Applicative0: function() {
    return applicativeArray;
  },
  Plus1: function() {
    return plusArray;
  }
};

// output/Control.Bind/foreign.js
var arrayBind = function(arr) {
  return function(f) {
    var result = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      Array.prototype.push.apply(result, f(arr[i]));
    }
    return result;
  };
};

// output/Control.Bind/index.js
var identity3 = /* @__PURE__ */ identity(categoryFn);
var discard = function(dict) {
  return dict.discard;
};
var bindFn = {
  bind: function(m) {
    return function(f) {
      return function(x) {
        return f(m(x))(x);
      };
    };
  },
  Apply0: function() {
    return applyFn;
  }
};
var bindArray = {
  bind: arrayBind,
  Apply0: function() {
    return applyArray;
  }
};
var bind = function(dict) {
  return dict.bind;
};
var bindFlipped = function(dictBind) {
  return flip(bind(dictBind));
};
var composeKleisliFlipped = function(dictBind) {
  var bindFlipped14 = bindFlipped(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bindFlipped14(f)(g(a));
      };
    };
  };
};
var composeKleisli = function(dictBind) {
  var bind128 = bind(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bind128(f(a))(g);
      };
    };
  };
};
var discardUnit = {
  discard: function(dictBind) {
    return bind(dictBind);
  }
};
var ifM = function(dictBind) {
  var bind128 = bind(dictBind);
  return function(cond) {
    return function(t) {
      return function(f) {
        return bind128(cond)(function(cond$prime) {
          if (cond$prime) {
            return t;
          }
          ;
          return f;
        });
      };
    };
  };
};
var join = function(dictBind) {
  var bind128 = bind(dictBind);
  return function(m) {
    return bind128(m)(identity3);
  };
};

// output/Control.Monad/index.js
var whenM = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var when21 = when(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind82(mb)(function(b) {
        return when21(b)(m);
      });
    };
  };
};
var unlessM = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var unless10 = unless(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind82(mb)(function(b) {
        return unless10(b)(m);
      });
    };
  };
};
var liftM1 = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var pure98 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind82(a)(function(a$prime) {
        return pure98(f(a$prime));
      });
    };
  };
};
var ap = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var pure98 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind82(f)(function(f$prime) {
        return bind82(a)(function(a$prime) {
          return pure98(f$prime(a$prime));
        });
      });
    };
  };
};

// output/Control.Monad.Reader.Class/index.js
var local = function(dict) {
  return dict.local;
};
var ask = function(dict) {
  return dict.ask;
};

// output/Data.Bounded/foreign.js
var topInt = 2147483647;
var bottomInt = -2147483648;
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq46) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq46 : gt;
        };
      };
    };
  };
};
var ordIntImpl = unsafeCompareImpl;
var ordNumberImpl = unsafeCompareImpl;
var ordStringImpl = unsafeCompareImpl;
var ordCharImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqBooleanImpl = refEq;
var eqIntImpl = refEq;
var eqNumberImpl = refEq;
var eqCharImpl = refEq;
var eqStringImpl = refEq;
var eqArrayImpl = function(f) {
  return function(xs) {
    return function(ys) {
      if (xs.length !== ys.length)
        return false;
      for (var i = 0; i < xs.length; i++) {
        if (!f(xs[i])(ys[i]))
          return false;
      }
      return true;
    };
  };
};

// output/Data.Eq/index.js
var eqUnit = {
  eq: function(v) {
    return function(v1) {
      return true;
    };
  }
};
var eqString = {
  eq: eqStringImpl
};
var eqRowNil = {
  eqRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return true;
      };
    };
  }
};
var eqRecord = function(dict) {
  return dict.eqRecord;
};
var eqRec = function() {
  return function(dictEqRecord) {
    return {
      eq: eqRecord(dictEqRecord)($$Proxy.value)
    };
  };
};
var eqNumber = {
  eq: eqNumberImpl
};
var eqInt = {
  eq: eqIntImpl
};
var eqChar = {
  eq: eqCharImpl
};
var eqBoolean = {
  eq: eqBooleanImpl
};
var eq1 = function(dict) {
  return dict.eq1;
};
var eq = function(dict) {
  return dict.eq;
};
var eq2 = /* @__PURE__ */ eq(eqBoolean);
var eqArray = function(dictEq) {
  return {
    eq: eqArrayImpl(eq(dictEq))
  };
};
var eqRowCons = function(dictEqRecord) {
  var eqRecord1 = eqRecord(dictEqRecord);
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return function(dictEq) {
        var eq310 = eq(dictEq);
        return {
          eqRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail4 = eqRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var get6 = unsafeGet(key);
                return eq310(get6(ra))(get6(rb)) && tail4;
              };
            };
          }
        };
      };
    };
  };
};
var notEq = function(dictEq) {
  var eq310 = eq(dictEq);
  return function(x) {
    return function(y) {
      return eq2(eq310(x)(y))(false);
    };
  };
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
}();
var GT = /* @__PURE__ */ function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
}();
var EQ = /* @__PURE__ */ function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
}();
var semigroupOrdering = {
  append: function(v) {
    return function(v1) {
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      if (v instanceof EQ) {
        return v1;
      }
      ;
      throw new Error("Failed pattern match at Data.Ordering (line 21, column 1 - line 24, column 18): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var eqOrdering = {
  eq: function(v) {
    return function(v1) {
      if (v instanceof LT && v1 instanceof LT) {
        return true;
      }
      ;
      if (v instanceof GT && v1 instanceof GT) {
        return true;
      }
      ;
      if (v instanceof EQ && v1 instanceof EQ) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};
var numSub = function(n1) {
  return function(n2) {
    return n1 - n2;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};
var numAdd = function(n1) {
  return function(n2) {
    return n1 + n2;
  };
};
var numMul = function(n1) {
  return function(n2) {
    return n1 * n2;
  };
};

// output/Data.Semiring/index.js
var zero = function(dict) {
  return dict.zero;
};
var semiringNumber = {
  add: numAdd,
  zero: 0,
  mul: numMul,
  one: 1
};
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};
var one = function(dict) {
  return dict.one;
};
var mul = function(dict) {
  return dict.mul;
};
var add = function(dict) {
  return dict.add;
};

// output/Data.Ring/index.js
var sub = function(dict) {
  return dict.sub;
};
var ringNumber = {
  sub: numSub,
  Semiring0: function() {
    return semiringNumber;
  }
};
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};
var negate = function(dictRing) {
  var sub1 = sub(dictRing);
  var zero4 = zero(dictRing.Semiring0());
  return function(a) {
    return sub1(zero4)(a);
  };
};

// output/Data.Ord/index.js
var eqRec2 = /* @__PURE__ */ eqRec();
var notEq2 = /* @__PURE__ */ notEq(eqOrdering);
var ordString = /* @__PURE__ */ function() {
  return {
    compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqString;
    }
  };
}();
var ordRecordNil = {
  compareRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return EQ.value;
      };
    };
  },
  EqRecord0: function() {
    return eqRowNil;
  }
};
var ordNumber = /* @__PURE__ */ function() {
  return {
    compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqNumber;
    }
  };
}();
var ordInt = /* @__PURE__ */ function() {
  return {
    compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqInt;
    }
  };
}();
var ordChar = /* @__PURE__ */ function() {
  return {
    compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqChar;
    }
  };
}();
var compareRecord = function(dict) {
  return dict.compareRecord;
};
var ordRecord = function() {
  return function(dictOrdRecord) {
    var eqRec12 = eqRec2(dictOrdRecord.EqRecord0());
    return {
      compare: compareRecord(dictOrdRecord)($$Proxy.value),
      Eq0: function() {
        return eqRec12;
      }
    };
  };
};
var compare1 = function(dict) {
  return dict.compare1;
};
var compare = function(dict) {
  return dict.compare;
};
var comparing = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(f) {
    return function(x) {
      return function(y) {
        return compare33(f(x))(f(y));
      };
    };
  };
};
var greaterThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof GT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var greaterThanOrEq = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return false;
      }
      ;
      return true;
    };
  };
};
var lessThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var lessThanOrEq = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof GT) {
        return false;
      }
      ;
      return true;
    };
  };
};
var max = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return y;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return x;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): " + [v.constructor.name]);
    };
  };
};
var min = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return x;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return y;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v.constructor.name]);
    };
  };
};
var ordRecordCons = function(dictOrdRecord) {
  var compareRecord1 = compareRecord(dictOrdRecord);
  var eqRowCons4 = eqRowCons(dictOrdRecord.EqRecord0())();
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      var eqRowCons1 = eqRowCons4(dictIsSymbol);
      return function(dictOrd) {
        var compare33 = compare(dictOrd);
        var eqRowCons22 = eqRowCons1(dictOrd.Eq0());
        return {
          compareRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var key = reflectSymbol2($$Proxy.value);
                var left3 = compare33(unsafeGet(key)(ra))(unsafeGet(key)(rb));
                var $95 = notEq2(left3)(EQ.value);
                if ($95) {
                  return left3;
                }
                ;
                return compareRecord1($$Proxy.value)(ra)(rb);
              };
            };
          },
          EqRecord0: function() {
            return eqRowCons22;
          }
        };
      };
    };
  };
};
var between = function(dictOrd) {
  var lessThan12 = lessThan(dictOrd);
  var greaterThan1 = greaterThan(dictOrd);
  return function(low) {
    return function(hi) {
      return function(x) {
        if (lessThan12(x)(low)) {
          return false;
        }
        ;
        if (greaterThan1(x)(hi)) {
          return false;
        }
        ;
        return true;
      };
    };
  };
};
var abs = function(dictOrd) {
  var greaterThanOrEq12 = greaterThanOrEq(dictOrd);
  return function(dictRing) {
    var zero4 = zero(dictRing.Semiring0());
    var negate1 = negate(dictRing);
    return function(x) {
      var $99 = greaterThanOrEq12(x)(zero4);
      if ($99) {
        return x;
      }
      ;
      return negate1(x);
    };
  };
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedInt = {
  top: topInt,
  bottom: bottomInt,
  Ord0: function() {
    return ordInt;
  }
};
var boundedChar = {
  top: topChar,
  bottom: bottomChar,
  Ord0: function() {
    return ordChar;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Show/foreign.js
var showIntImpl = function(n) {
  return n.toString();
};
var showNumberImpl = function(n) {
  var str2 = n.toString();
  return isNaN(str2 + ".0") ? str2 : str2 + ".0";
};
var showCharImpl = function(c) {
  var code3 = c.charCodeAt(0);
  if (code3 < 32 || code3 === 127) {
    switch (c) {
      case "\x07":
        return "'\\a'";
      case "\b":
        return "'\\b'";
      case "\f":
        return "'\\f'";
      case "\n":
        return "'\\n'";
      case "\r":
        return "'\\r'";
      case "	":
        return "'\\t'";
      case "\v":
        return "'\\v'";
    }
    return "'\\" + code3.toString(10) + "'";
  }
  return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
};
var showStringImpl = function(s) {
  var l = s.length;
  return '"' + s.replace(
    /[\0-\x1F\x7F"\\]/g,
    // eslint-disable-line no-control-regex
    function(c, i) {
      switch (c) {
        case '"':
        case "\\":
          return "\\" + c;
        case "\x07":
          return "\\a";
        case "\b":
          return "\\b";
        case "\f":
          return "\\f";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "	":
          return "\\t";
        case "\v":
          return "\\v";
      }
      var k = i + 1;
      var empty14 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
      return "\\" + c.charCodeAt(0).toString(10) + empty14;
    }
  ) + '"';
};
var showArrayImpl = function(f) {
  return function(xs) {
    var ss = [];
    for (var i = 0, l = xs.length; i < l; i++) {
      ss[i] = f(xs[i]);
    }
    return "[" + ss.join(",") + "]";
  };
};

// output/Data.Show/index.js
var showString = {
  show: showStringImpl
};
var showRecordFields = function(dict) {
  return dict.showRecordFields;
};
var showRecord = function() {
  return function() {
    return function(dictShowRecordFields) {
      var showRecordFields1 = showRecordFields(dictShowRecordFields);
      return {
        show: function(record4) {
          return "{" + (showRecordFields1($$Proxy.value)(record4) + "}");
        }
      };
    };
  };
};
var showNumber = {
  show: showNumberImpl
};
var showInt = {
  show: showIntImpl
};
var showChar = {
  show: showCharImpl
};
var showBoolean = {
  show: function(v) {
    if (v) {
      return "true";
    }
    ;
    if (!v) {
      return "false";
    }
    ;
    throw new Error("Failed pattern match at Data.Show (line 29, column 1 - line 31, column 23): " + [v.constructor.name]);
  }
};
var show = function(dict) {
  return dict.show;
};
var showArray = function(dictShow) {
  return {
    show: showArrayImpl(show(dictShow))
  };
};
var showRecordFieldsCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function(dictShowRecordFields) {
    var showRecordFields1 = showRecordFields(dictShowRecordFields);
    return function(dictShow) {
      var show122 = show(dictShow);
      return {
        showRecordFields: function(v) {
          return function(record4) {
            var tail4 = showRecordFields1($$Proxy.value)(record4);
            var key = reflectSymbol2($$Proxy.value);
            var focus = unsafeGet(key)(record4);
            return " " + (key + (": " + (show122(focus) + ("," + tail4))));
          };
        }
      };
    };
  };
};
var showRecordFieldsConsNil = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function(dictShow) {
    var show122 = show(dictShow);
    return {
      showRecordFields: function(v) {
        return function(record4) {
          var key = reflectSymbol2($$Proxy.value);
          var focus = unsafeGet(key)(record4);
          return " " + (key + (": " + (show122(focus) + " ")));
        };
      }
    };
  };
};

// output/Data.Generic.Rep/index.js
var Inl = /* @__PURE__ */ function() {
  function Inl2(value0) {
    this.value0 = value0;
  }
  ;
  Inl2.create = function(value0) {
    return new Inl2(value0);
  };
  return Inl2;
}();
var Inr = /* @__PURE__ */ function() {
  function Inr2(value0) {
    this.value0 = value0;
  }
  ;
  Inr2.create = function(value0) {
    return new Inr2(value0);
  };
  return Inr2;
}();
var Product = /* @__PURE__ */ function() {
  function Product3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Product3.create = function(value0) {
    return function(value12) {
      return new Product3(value0, value12);
    };
  };
  return Product3;
}();
var NoArguments = /* @__PURE__ */ function() {
  function NoArguments2() {
  }
  ;
  NoArguments2.value = new NoArguments2();
  return NoArguments2;
}();
var Constructor = function(x) {
  return x;
};
var Argument = function(x) {
  return x;
};
var to = function(dict) {
  return dict.to;
};
var from = function(dict) {
  return dict.from;
};

// output/Data.Maybe/index.js
var identity4 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
}();
var Just = /* @__PURE__ */ function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
}();
var showMaybe = function(dictShow) {
  var show57 = show(dictShow);
  return {
    show: function(v) {
      if (v instanceof Just) {
        return "(Just " + (show57(v.value0) + ")");
      }
      ;
      if (v instanceof Nothing) {
        return "Nothing";
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 223, column 1 - line 225, column 28): " + [v.constructor.name]);
    }
  };
};
var semigroupMaybe = function(dictSemigroup) {
  var append127 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return v1;
        }
        ;
        if (v1 instanceof Nothing) {
          return v;
        }
        ;
        if (v instanceof Just && v1 instanceof Just) {
          return new Just(append127(v.value0)(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 182, column 1 - line 185, column 43): " + [v.constructor.name, v1.constructor.name]);
      };
    }
  };
};
var optional = function(dictAlt) {
  var alt40 = alt(dictAlt);
  var map154 = map(dictAlt.Functor0());
  return function(dictApplicative) {
    var pure98 = pure(dictApplicative);
    return function(a) {
      return alt40(map154(Just.create)(a))(pure98(Nothing.value));
    };
  };
};
var monoidMaybe = function(dictSemigroup) {
  var semigroupMaybe1 = semigroupMaybe(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupMaybe1;
    }
  };
};
var maybe$prime = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v(unit);
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));
var functorMaybe = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      ;
      return Nothing.value;
    };
  }
};
var map2 = /* @__PURE__ */ map(functorMaybe);
var fromMaybe$prime = function(a) {
  return maybe$prime(a)(identity4);
};
var fromMaybe = function(a) {
  return maybe(a)(identity4);
};
var fromJust = function() {
  return function(v) {
    if (v instanceof Just) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
  };
};
var eqMaybe = function(dictEq) {
  var eq46 = eq(dictEq);
  return {
    eq: function(x) {
      return function(y) {
        if (x instanceof Nothing && y instanceof Nothing) {
          return true;
        }
        ;
        if (x instanceof Just && y instanceof Just) {
          return eq46(x.value0)(y.value0);
        }
        ;
        return false;
      };
    }
  };
};
var applyMaybe = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return map2(v.value0)(v1);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var bindMaybe = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v1(v.value0);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyMaybe;
  }
};
var applicativeMaybe = /* @__PURE__ */ function() {
  return {
    pure: Just.create,
    Apply0: function() {
      return applyMaybe;
    }
  };
}();
var altMaybe = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Nothing) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var plusMaybe = /* @__PURE__ */ function() {
  return {
    empty: Nothing.value,
    Alt0: function() {
      return altMaybe;
    }
  };
}();
var alternativeMaybe = {
  Applicative0: function() {
    return applicativeMaybe;
  },
  Plus1: function() {
    return plusMaybe;
  }
};

// output/Data.Either/index.js
var Left = /* @__PURE__ */ function() {
  function Left2(value0) {
    this.value0 = value0;
  }
  ;
  Left2.create = function(value0) {
    return new Left2(value0);
  };
  return Left2;
}();
var Right = /* @__PURE__ */ function() {
  function Right2(value0) {
    this.value0 = value0;
  }
  ;
  Right2.create = function(value0) {
    return new Right2(value0);
  };
  return Right2;
}();
var note = function(a) {
  return maybe(new Left(a))(Right.create);
};
var functorEither = {
  map: function(f) {
    return function(m) {
      if (m instanceof Left) {
        return new Left(m.value0);
      }
      ;
      if (m instanceof Right) {
        return new Right(f(m.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map3 = /* @__PURE__ */ map(functorEither);
var fromRight$prime = function(v) {
  return function(v1) {
    if (v1 instanceof Right) {
      return v1.value0;
    }
    ;
    return v(unit);
  };
};
var eqEither = function(dictEq) {
  var eq46 = eq(dictEq);
  return function(dictEq1) {
    var eq116 = eq(dictEq1);
    return {
      eq: function(x) {
        return function(y) {
          if (x instanceof Left && y instanceof Left) {
            return eq46(x.value0)(y.value0);
          }
          ;
          if (x instanceof Right && y instanceof Right) {
            return eq116(x.value0)(y.value0);
          }
          ;
          return false;
        };
      }
    };
  };
};
var either = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Left) {
        return v(v2.value0);
      }
      ;
      if (v2 instanceof Right) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var hush = /* @__PURE__ */ function() {
  return either($$const(Nothing.value))(Just.create);
}();
var isLeft = /* @__PURE__ */ either(/* @__PURE__ */ $$const(true))(/* @__PURE__ */ $$const(false));
var applyEither = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return new Left(v.value0);
      }
      ;
      if (v instanceof Right) {
        return map3(v.value0)(v1);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorEither;
  }
};
var bindEither = {
  bind: /* @__PURE__ */ either(function(e) {
    return function(v) {
      return new Left(e);
    };
  })(function(a) {
    return function(f) {
      return f(a);
    };
  }),
  Apply0: function() {
    return applyEither;
  }
};
var applicativeEither = /* @__PURE__ */ function() {
  return {
    pure: Right.create,
    Apply0: function() {
      return applyEither;
    }
  };
}();
var monadEither = {
  Applicative0: function() {
    return applicativeEither;
  },
  Bind1: function() {
    return bindEither;
  }
};
var altEither = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorEither;
  }
};

// output/Effect/foreign.js
var pureE = function(a) {
  return function() {
    return a;
  };
};
var bindE = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0)
      return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0)
      return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};
var div = function(dict) {
  return dict.div;
};

// output/Data.Monoid/index.js
var semigroupRecord2 = /* @__PURE__ */ semigroupRecord();
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var div2 = /* @__PURE__ */ div(euclideanRingInt);
var monoidUnit = {
  mempty: unit,
  Semigroup0: function() {
    return semigroupUnit;
  }
};
var monoidString = {
  mempty: "",
  Semigroup0: function() {
    return semigroupString;
  }
};
var monoidRecordNil = {
  memptyRecord: function(v) {
    return {};
  },
  SemigroupRecord0: function() {
    return semigroupRecordNil;
  }
};
var monoidArray = {
  mempty: [],
  Semigroup0: function() {
    return semigroupArray;
  }
};
var memptyRecord = function(dict) {
  return dict.memptyRecord;
};
var monoidRecord = function() {
  return function(dictMonoidRecord) {
    var semigroupRecord1 = semigroupRecord2(dictMonoidRecord.SemigroupRecord0());
    return {
      mempty: memptyRecord(dictMonoidRecord)($$Proxy.value),
      Semigroup0: function() {
        return semigroupRecord1;
      }
    };
  };
};
var mempty = function(dict) {
  return dict.mempty;
};
var monoidFn = function(dictMonoid) {
  var mempty113 = mempty(dictMonoid);
  var semigroupFn2 = semigroupFn(dictMonoid.Semigroup0());
  return {
    mempty: function(v) {
      return mempty113;
    },
    Semigroup0: function() {
      return semigroupFn2;
    }
  };
};
var monoidRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  var semigroupRecordCons3 = semigroupRecordCons(dictIsSymbol)();
  return function(dictMonoid) {
    var mempty113 = mempty(dictMonoid);
    var Semigroup0 = dictMonoid.Semigroup0();
    return function() {
      return function(dictMonoidRecord) {
        var memptyRecord1 = memptyRecord(dictMonoidRecord);
        var semigroupRecordCons12 = semigroupRecordCons3(dictMonoidRecord.SemigroupRecord0())(Semigroup0);
        return {
          memptyRecord: function(v) {
            var tail4 = memptyRecord1($$Proxy.value);
            var key = reflectSymbol2($$Proxy.value);
            var insert22 = unsafeSet(key);
            return insert22(mempty113)(tail4);
          },
          SemigroupRecord0: function() {
            return semigroupRecordCons12;
          }
        };
      };
    };
  };
};
var power = function(dictMonoid) {
  var mempty113 = mempty(dictMonoid);
  var append48 = append(dictMonoid.Semigroup0());
  return function(x) {
    var go = function(p) {
      if (p <= 0) {
        return mempty113;
      }
      ;
      if (p === 1) {
        return x;
      }
      ;
      if (mod2(p)(2) === 0) {
        var x$prime = go(div2(p)(2));
        return append48(x$prime)(x$prime);
      }
      ;
      if (otherwise) {
        var x$prime = go(div2(p)(2));
        return append48(x$prime)(append48(x$prime)(x));
      }
      ;
      throw new Error("Failed pattern match at Data.Monoid (line 88, column 3 - line 88, column 17): " + [p.constructor.name]);
    };
    return go;
  };
};
var guard2 = function(dictMonoid) {
  var mempty113 = mempty(dictMonoid);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return mempty113;
      }
      ;
      throw new Error("Failed pattern match at Data.Monoid (line 96, column 1 - line 96, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};

// output/Effect/index.js
var $runtime_lazy = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var monadEffect = {
  Applicative0: function() {
    return applicativeEffect;
  },
  Bind1: function() {
    return bindEffect;
  }
};
var bindEffect = {
  bind: bindE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var applicativeEffect = {
  pure: pureE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
  return {
    map: liftA1(applicativeEffect)
  };
});
var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
  return {
    apply: ap(monadEffect),
    Functor0: function() {
      return $lazy_functorEffect(0);
    }
  };
});
var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);
var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);
var lift22 = /* @__PURE__ */ lift2(applyEffect);
var semigroupEffect = function(dictSemigroup) {
  return {
    append: lift22(append(dictSemigroup))
  };
};
var monoidEffect = function(dictMonoid) {
  var semigroupEffect1 = semigroupEffect(dictMonoid.Semigroup0());
  return {
    mempty: pureE(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupEffect1;
    }
  };
};

// output/Effect.Exception/foreign.js
function showErrorImpl(err) {
  return err.stack || err.toString();
}
function error(msg) {
  return new Error(msg);
}
function message(e) {
  return e.message;
}
function throwException(e) {
  return function() {
    throw e;
  };
}
function catchException(c) {
  return function(t) {
    return function() {
      try {
        return t();
      } catch (e) {
        if (e instanceof Error || Object.prototype.toString.call(e) === "[object Error]") {
          return c(e)();
        } else {
          return c(new Error(e.toString()))();
        }
      }
    };
  };
}

// output/Effect.Exception/index.js
var pure2 = /* @__PURE__ */ pure(applicativeEffect);
var map4 = /* @__PURE__ */ map(functorEffect);
var $$try = function(action) {
  return catchException(function($3) {
    return pure2(Left.create($3));
  })(map4(Right.create)(action));
};
var $$throw = function($4) {
  return throwException(error($4));
};
var showError = {
  show: showErrorImpl
};

// output/Control.Monad.Error.Class/index.js
var throwError = function(dict) {
  return dict.throwError;
};
var monadThrowEffect = {
  throwError: throwException,
  Monad0: function() {
    return monadEffect;
  }
};
var monadErrorEffect = {
  catchError: /* @__PURE__ */ flip(catchException),
  MonadThrow0: function() {
    return monadThrowEffect;
  }
};
var liftEither = function(dictMonadThrow) {
  return either(throwError(dictMonadThrow))(pure(dictMonadThrow.Monad0().Applicative0()));
};
var catchError = function(dict) {
  return dict.catchError;
};
var $$try2 = function(dictMonadError) {
  var catchError1 = catchError(dictMonadError);
  var Monad0 = dictMonadError.MonadThrow0().Monad0();
  var map154 = map(Monad0.Bind1().Apply0().Functor0());
  var pure98 = pure(Monad0.Applicative0());
  return function(a) {
    return catchError1(map154(Right.create)(a))(function($52) {
      return pure98(Left.create($52));
    });
  };
};

// output/Data.Identity/index.js
var Identity = function(x) {
  return x;
};
var functorIdentity = {
  map: function(f) {
    return function(m) {
      return f(m);
    };
  }
};
var applyIdentity = {
  apply: function(v) {
    return function(v1) {
      return v(v1);
    };
  },
  Functor0: function() {
    return functorIdentity;
  }
};
var bindIdentity = {
  bind: function(v) {
    return function(f) {
      return f(v);
    };
  },
  Apply0: function() {
    return applyIdentity;
  }
};
var applicativeIdentity = {
  pure: Identity,
  Apply0: function() {
    return applyIdentity;
  }
};
var monadIdentity = {
  Applicative0: function() {
    return applicativeIdentity;
  },
  Bind1: function() {
    return bindIdentity;
  }
};

// output/Effect.Ref/foreign.js
var _new = function(val) {
  return function() {
    return { value: val };
  };
};
var read = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write = function(val) {
  return function(ref2) {
    return function() {
      ref2.value = val;
    };
  };
};

// output/Effect.Ref/index.js
var $$void2 = /* @__PURE__ */ $$void(functorEffect);
var $$new = _new;
var modify$prime = modifyImpl;
var modify = function(f) {
  return modify$prime(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var modify_ = function(f) {
  return function(s) {
    return $$void2(modify(f)(s));
  };
};

// output/Control.Monad.Rec.Class/index.js
var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEffect);
var map5 = /* @__PURE__ */ map(functorEffect);
var Loop = /* @__PURE__ */ function() {
  function Loop2(value0) {
    this.value0 = value0;
  }
  ;
  Loop2.create = function(value0) {
    return new Loop2(value0);
  };
  return Loop2;
}();
var Done = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var tailRecM = function(dict) {
  return dict.tailRecM;
};
var tailRec = function(f) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Loop) {
        $copy_v = f(v.value0);
        return;
      }
      ;
      if (v instanceof Done) {
        $tco_done = true;
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 103, column 3 - line 103, column 25): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return function($85) {
    return go(f($85));
  };
};
var monadRecIdentity = {
  tailRecM: function(f) {
    var runIdentity = function(v) {
      return v;
    };
    var $86 = tailRec(function($88) {
      return runIdentity(f($88));
    });
    return function($87) {
      return Identity($86($87));
    };
  },
  Monad0: function() {
    return monadIdentity;
  }
};
var monadRecEither = {
  tailRecM: function(f) {
    return function(a0) {
      var g = function(v) {
        if (v instanceof Left) {
          return new Done(new Left(v.value0));
        }
        ;
        if (v instanceof Right && v.value0 instanceof Loop) {
          return new Loop(f(v.value0.value0));
        }
        ;
        if (v instanceof Right && v.value0 instanceof Done) {
          return new Done(new Right(v.value0.value0));
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 145, column 7 - line 145, column 33): " + [v.constructor.name]);
      };
      return tailRec(g)(f(a0));
    };
  },
  Monad0: function() {
    return monadEither;
  }
};
var monadRecEffect = {
  tailRecM: function(f) {
    return function(a) {
      var fromDone = function(v) {
        if (v instanceof Done) {
          return v.value0;
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 137, column 30 - line 137, column 44): " + [v.constructor.name]);
      };
      return function __do3() {
        var r = bindFlipped2($$new)(f(a))();
        (function() {
          while (!function __do4() {
            var v = read(r)();
            if (v instanceof Loop) {
              var e = f(v.value0)();
              write(e)(r)();
              return false;
            }
            ;
            if (v instanceof Done) {
              return true;
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 128, column 22 - line 133, column 28): " + [v.constructor.name]);
          }()) {
          }
          ;
          return {};
        })();
        return map5(fromDone)(read(r))();
      };
    };
  },
  Monad0: function() {
    return monadEffect;
  }
};
var bifunctorStep = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Loop) {
          return new Loop(v(v2.value0));
        }
        ;
        if (v2 instanceof Done) {
          return new Done(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 33, column 1 - line 35, column 34): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Unsafe.Coerce/foreign.js
var unsafeCoerce2 = function(x) {
  return x;
};

// output/Control.Monad.ST.Internal/foreign.js
var map_ = function(f) {
  return function(a) {
    return function() {
      return f(a());
    };
  };
};
var pure_ = function(a) {
  return function() {
    return a;
  };
};
var bind_ = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};
function forST(lo) {
  return function(hi) {
    return function(f) {
      return function() {
        for (var i = lo; i < hi; i++) {
          f(i)();
        }
      };
    };
  };
}
var foreach = function(as3) {
  return function(f) {
    return function() {
      for (var i = 0, l = as3.length; i < l; i++) {
        f(as3[i])();
      }
    };
  };
};
function newSTRef(val) {
  return function() {
    return { value: val };
  };
}
var read2 = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl2 = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write2 = function(a) {
  return function(ref2) {
    return function() {
      return ref2.value = a;
    };
  };
};

// output/Control.Monad.ST.Internal/index.js
var $runtime_lazy2 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var modify$prime2 = modifyImpl2;
var modify2 = function(f) {
  return modify$prime2(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var functorST = {
  map: map_
};
var monadST = {
  Applicative0: function() {
    return applicativeST;
  },
  Bind1: function() {
    return bindST;
  }
};
var bindST = {
  bind: bind_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var applicativeST = {
  pure: pure_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2("applyST", "Control.Monad.ST.Internal", function() {
  return {
    apply: ap(monadST),
    Functor0: function() {
      return functorST;
    }
  };
});
var applyST = /* @__PURE__ */ $lazy_applyST(47);

// output/Control.Lazy/index.js
var defer = function(dict) {
  return dict.defer;
};

// output/Data.HeytingAlgebra/foreign.js
var boolConj = function(b1) {
  return function(b2) {
    return b1 && b2;
  };
};
var boolDisj = function(b1) {
  return function(b2) {
    return b1 || b2;
  };
};
var boolNot = function(b) {
  return !b;
};

// output/Data.HeytingAlgebra/index.js
var ttRecord = function(dict) {
  return dict.ttRecord;
};
var tt = function(dict) {
  return dict.tt;
};
var notRecord = function(dict) {
  return dict.notRecord;
};
var not = function(dict) {
  return dict.not;
};
var impliesRecord = function(dict) {
  return dict.impliesRecord;
};
var implies = function(dict) {
  return dict.implies;
};
var heytingAlgebraRecordNil = {
  conjRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  disjRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  ffRecord: function(v) {
    return function(v1) {
      return {};
    };
  },
  impliesRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  notRecord: function(v) {
    return function(v1) {
      return {};
    };
  },
  ttRecord: function(v) {
    return function(v1) {
      return {};
    };
  }
};
var ffRecord = function(dict) {
  return dict.ffRecord;
};
var ff = function(dict) {
  return dict.ff;
};
var disjRecord = function(dict) {
  return dict.disjRecord;
};
var disj = function(dict) {
  return dict.disj;
};
var heytingAlgebraBoolean = {
  ff: false,
  tt: true,
  implies: function(a) {
    return function(b) {
      return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
    };
  },
  conj: boolConj,
  disj: boolDisj,
  not: boolNot
};
var conjRecord = function(dict) {
  return dict.conjRecord;
};
var heytingAlgebraRecord = function() {
  return function(dictHeytingAlgebraRecord) {
    return {
      ff: ffRecord(dictHeytingAlgebraRecord)($$Proxy.value)($$Proxy.value),
      tt: ttRecord(dictHeytingAlgebraRecord)($$Proxy.value)($$Proxy.value),
      conj: conjRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      disj: disjRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      implies: impliesRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      not: notRecord(dictHeytingAlgebraRecord)($$Proxy.value)
    };
  };
};
var conj = function(dict) {
  return dict.conj;
};
var heytingAlgebraFunction = function(dictHeytingAlgebra) {
  var ff1 = ff(dictHeytingAlgebra);
  var tt1 = tt(dictHeytingAlgebra);
  var implies1 = implies(dictHeytingAlgebra);
  var conj1 = conj(dictHeytingAlgebra);
  var disj12 = disj(dictHeytingAlgebra);
  var not13 = not(dictHeytingAlgebra);
  return {
    ff: function(v) {
      return ff1;
    },
    tt: function(v) {
      return tt1;
    },
    implies: function(f) {
      return function(g) {
        return function(a) {
          return implies1(f(a))(g(a));
        };
      };
    },
    conj: function(f) {
      return function(g) {
        return function(a) {
          return conj1(f(a))(g(a));
        };
      };
    },
    disj: function(f) {
      return function(g) {
        return function(a) {
          return disj12(f(a))(g(a));
        };
      };
    },
    not: function(f) {
      return function(a) {
        return not13(f(a));
      };
    }
  };
};
var heytingAlgebraRecordCons = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictHeytingAlgebraRecord) {
      var conjRecord1 = conjRecord(dictHeytingAlgebraRecord);
      var disjRecord1 = disjRecord(dictHeytingAlgebraRecord);
      var impliesRecord1 = impliesRecord(dictHeytingAlgebraRecord);
      var ffRecord1 = ffRecord(dictHeytingAlgebraRecord);
      var notRecord1 = notRecord(dictHeytingAlgebraRecord);
      var ttRecord1 = ttRecord(dictHeytingAlgebraRecord);
      return function(dictHeytingAlgebra) {
        var conj1 = conj(dictHeytingAlgebra);
        var disj12 = disj(dictHeytingAlgebra);
        var implies1 = implies(dictHeytingAlgebra);
        var ff1 = ff(dictHeytingAlgebra);
        var not13 = not(dictHeytingAlgebra);
        var tt1 = tt(dictHeytingAlgebra);
        return {
          conjRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail4 = conjRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert22 = unsafeSet(key);
                var get6 = unsafeGet(key);
                return insert22(conj1(get6(ra))(get6(rb)))(tail4);
              };
            };
          },
          disjRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail4 = disjRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert22 = unsafeSet(key);
                var get6 = unsafeGet(key);
                return insert22(disj12(get6(ra))(get6(rb)))(tail4);
              };
            };
          },
          impliesRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail4 = impliesRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol2($$Proxy.value);
                var insert22 = unsafeSet(key);
                var get6 = unsafeGet(key);
                return insert22(implies1(get6(ra))(get6(rb)))(tail4);
              };
            };
          },
          ffRecord: function(v) {
            return function(row) {
              var tail4 = ffRecord1($$Proxy.value)(row);
              var key = reflectSymbol2($$Proxy.value);
              var insert22 = unsafeSet(key);
              return insert22(ff1)(tail4);
            };
          },
          notRecord: function(v) {
            return function(row) {
              var tail4 = notRecord1($$Proxy.value)(row);
              var key = reflectSymbol2($$Proxy.value);
              var insert22 = unsafeSet(key);
              var get6 = unsafeGet(key);
              return insert22(not13(get6(row)))(tail4);
            };
          },
          ttRecord: function(v) {
            return function(row) {
              var tail4 = ttRecord1($$Proxy.value)(row);
              var key = reflectSymbol2($$Proxy.value);
              var insert22 = unsafeSet(key);
              return insert22(tt1)(tail4);
            };
          }
        };
      };
    };
  };
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ function() {
  function Tuple2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value12) {
      return new Tuple2(value0, value12);
    };
  };
  return Tuple2;
}();
var uncurry = function(f) {
  return function(v) {
    return f(v.value0)(v.value1);
  };
};
var snd = function(v) {
  return v.value1;
};
var semigroupTuple = function(dictSemigroup) {
  var append127 = append(dictSemigroup);
  return function(dictSemigroup1) {
    var append214 = append(dictSemigroup1);
    return {
      append: function(v) {
        return function(v1) {
          return new Tuple(append127(v.value0)(v1.value0), append214(v.value1)(v1.value1));
        };
      }
    };
  };
};
var monoidTuple = function(dictMonoid) {
  var mempty33 = mempty(dictMonoid);
  var semigroupTuple1 = semigroupTuple(dictMonoid.Semigroup0());
  return function(dictMonoid1) {
    var semigroupTuple2 = semigroupTuple1(dictMonoid1.Semigroup0());
    return {
      mempty: new Tuple(mempty33, mempty(dictMonoid1)),
      Semigroup0: function() {
        return semigroupTuple2;
      }
    };
  };
};
var functorTuple = {
  map: function(f) {
    return function(m) {
      return new Tuple(m.value0, f(m.value1));
    };
  }
};
var fst = function(v) {
  return v.value0;
};
var eqTuple = function(dictEq) {
  var eq46 = eq(dictEq);
  return function(dictEq1) {
    var eq116 = eq(dictEq1);
    return {
      eq: function(x) {
        return function(y) {
          return eq46(x.value0)(y.value0) && eq116(x.value1)(y.value1);
        };
      }
    };
  };
};
var ordTuple = function(dictOrd) {
  var compare21 = compare(dictOrd);
  var eqTuple1 = eqTuple(dictOrd.Eq0());
  return function(dictOrd1) {
    var compare110 = compare(dictOrd1);
    var eqTuple2 = eqTuple1(dictOrd1.Eq0());
    return {
      compare: function(x) {
        return function(y) {
          var v = compare21(x.value0)(y.value0);
          if (v instanceof LT) {
            return LT.value;
          }
          ;
          if (v instanceof GT) {
            return GT.value;
          }
          ;
          return compare110(x.value1)(y.value1);
        };
      },
      Eq0: function() {
        return eqTuple2;
      }
    };
  };
};
var curry = function(f) {
  return function(a) {
    return function(b) {
      return f(new Tuple(a, b));
    };
  };
};
var applyTuple = function(dictSemigroup) {
  var append127 = append(dictSemigroup);
  return {
    apply: function(v) {
      return function(v1) {
        return new Tuple(append127(v.value0)(v1.value0), v.value1(v1.value1));
      };
    },
    Functor0: function() {
      return functorTuple;
    }
  };
};
var applicativeTuple = function(dictMonoid) {
  var applyTuple1 = applyTuple(dictMonoid.Semigroup0());
  return {
    pure: Tuple.create(mempty(dictMonoid)),
    Apply0: function() {
      return applyTuple1;
    }
  };
};

// output/Control.Monad.State.Class/index.js
var state = function(dict) {
  return dict.state;
};
var put = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(s) {
    return state1(function(v) {
      return new Tuple(unit, s);
    });
  };
};
var modify_2 = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(f) {
    return state1(function(s) {
      return new Tuple(unit, f(s));
    });
  };
};
var gets = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(f) {
    return state1(function(s) {
      return new Tuple(f(s), s);
    });
  };
};
var get = function(dictMonadState) {
  return state(dictMonadState)(function(s) {
    return new Tuple(s, s);
  });
};

// output/Control.Monad.Trans.Class/index.js
var lift = function(dict) {
  return dict.lift;
};

// output/Safe.Coerce/index.js
var coerce = function() {
  return unsafeCoerce2;
};

// output/Data.Newtype/index.js
var coerce2 = /* @__PURE__ */ coerce();
var wrap = function() {
  return coerce2;
};
var wrap1 = /* @__PURE__ */ wrap();
var unwrap = function() {
  return coerce2;
};
var unwrap1 = /* @__PURE__ */ unwrap();
var under = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var un = function() {
  return function(v) {
    return unwrap1;
  };
};
var over = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var alaF = function() {
  return function() {
    return function() {
      return function() {
        return function(v) {
          return coerce2;
        };
      };
    };
  };
};
var ala = function() {
  return function() {
    return function() {
      return function(v) {
        return function(f) {
          return coerce2(f(wrap1));
        };
      };
    };
  };
};

// output/Type.Equality/index.js
var refl = {
  proof: function(a) {
    return a;
  },
  Coercible0: function() {
    return void 0;
  }
};
var proof = function(dict) {
  return dict.proof;
};
var from2 = function(dictTypeEquals) {
  var v = proof(dictTypeEquals)(function(a) {
    return a;
  });
  return v;
};

// output/Effect.Class/index.js
var monadEffectEffect = {
  liftEffect: /* @__PURE__ */ identity(categoryFn),
  Monad0: function() {
    return monadEffect;
  }
};
var liftEffect = function(dict) {
  return dict.liftEffect;
};

// output/Control.Monad.Reader.Trans/index.js
var ReaderT = function(x) {
  return x;
};
var withReaderT = function(f) {
  return function(v) {
    return function($152) {
      return v(f($152));
    };
  };
};
var runReaderT = function(v) {
  return v;
};
var monadTransReaderT = {
  lift: function(dictMonad) {
    return function($153) {
      return ReaderT($$const($153));
    };
  }
};
var lift3 = /* @__PURE__ */ lift(monadTransReaderT);
var mapReaderT = function(f) {
  return function(v) {
    return function($154) {
      return f(v($154));
    };
  };
};
var functorReaderT = function(dictFunctor) {
  return {
    map: function() {
      var $155 = map(dictFunctor);
      return function($156) {
        return mapReaderT($155($156));
      };
    }()
  };
};
var applyReaderT = function(dictApply) {
  var apply30 = apply2(dictApply);
  var functorReaderT1 = functorReaderT(dictApply.Functor0());
  return {
    apply: function(v) {
      return function(v1) {
        return function(r) {
          return apply30(v(r))(v1(r));
        };
      };
    },
    Functor0: function() {
      return functorReaderT1;
    }
  };
};
var bindReaderT = function(dictBind) {
  var bind82 = bind(dictBind);
  var applyReaderT1 = applyReaderT(dictBind.Apply0());
  return {
    bind: function(v) {
      return function(k) {
        return function(r) {
          return bind82(v(r))(function(a) {
            var v1 = k(a);
            return v1(r);
          });
        };
      };
    },
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var semigroupReaderT = function(dictApply) {
  var lift26 = lift2(applyReaderT(dictApply));
  return function(dictSemigroup) {
    return {
      append: lift26(append(dictSemigroup))
    };
  };
};
var applicativeReaderT = function(dictApplicative) {
  var applyReaderT1 = applyReaderT(dictApplicative.Apply0());
  return {
    pure: function() {
      var $160 = pure(dictApplicative);
      return function($161) {
        return ReaderT($$const($160($161)));
      };
    }(),
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var monadReaderT = function(dictMonad) {
  var applicativeReaderT1 = applicativeReaderT(dictMonad.Applicative0());
  var bindReaderT1 = bindReaderT(dictMonad.Bind1());
  return {
    Applicative0: function() {
      return applicativeReaderT1;
    },
    Bind1: function() {
      return bindReaderT1;
    }
  };
};
var monadAskReaderT = function(dictMonad) {
  var monadReaderT12 = monadReaderT(dictMonad);
  return {
    ask: pure(dictMonad.Applicative0()),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadReaderReaderT = function(dictMonad) {
  var monadAskReaderT1 = monadAskReaderT(dictMonad);
  return {
    local: withReaderT,
    MonadAsk0: function() {
      return monadAskReaderT1;
    }
  };
};
var monadEffectReader = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    liftEffect: function() {
      var $163 = lift3(Monad0);
      var $164 = liftEffect(dictMonadEffect);
      return function($165) {
        return $163($164($165));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadThrowReaderT = function(dictMonadThrow) {
  var Monad0 = dictMonadThrow.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    throwError: function() {
      var $172 = lift3(Monad0);
      var $173 = throwError(dictMonadThrow);
      return function($174) {
        return $172($173($174));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadErrorReaderT = function(dictMonadError) {
  var catchError3 = catchError(dictMonadError);
  var monadThrowReaderT1 = monadThrowReaderT(dictMonadError.MonadThrow0());
  return {
    catchError: function(v) {
      return function(h) {
        return function(r) {
          return catchError3(v(r))(function(e) {
            var v1 = h(e);
            return v1(r);
          });
        };
      };
    },
    MonadThrow0: function() {
      return monadThrowReaderT1;
    }
  };
};

// output/Data.Array/foreign.js
var rangeImpl = function(start, end4) {
  var step3 = start > end4 ? -1 : 1;
  var result = new Array(step3 * (end4 - start) + 1);
  var i = start, n = 0;
  while (i !== end4) {
    result[n++] = i;
    i += step3;
  }
  result[n] = i;
  return result;
};
var replicateFill = function(count, value4) {
  if (count < 1) {
    return [];
  }
  var result = new Array(count);
  return result.fill(value4);
};
var replicatePolyfill = function(count, value4) {
  var result = [];
  var n = 0;
  for (var i = 0; i < count; i++) {
    result[n++] = value4;
  }
  return result;
};
var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var fromFoldableImpl = /* @__PURE__ */ function() {
  function Cons4(head6, tail4) {
    this.head = head6;
    this.tail = tail4;
  }
  var emptyList = {};
  function curryCons(head6) {
    return function(tail4) {
      return new Cons4(head6, tail4);
    };
  }
  function listToArray(list3) {
    var result = [];
    var count = 0;
    var xs = list3;
    while (xs !== emptyList) {
      result[count++] = xs.head;
      xs = xs.tail;
    }
    return result;
  }
  return function(foldr21, xs) {
    return listToArray(foldr21(curryCons)(emptyList)(xs));
  };
}();
var length = function(xs) {
  return xs.length;
};
var unconsImpl = function(empty14, next2, xs) {
  return xs.length === 0 ? empty14({}) : next2(xs[0])(xs.slice(1));
};
var indexImpl = function(just, nothing, xs, i) {
  return i < 0 || i >= xs.length ? nothing : just(xs[i]);
};
var findMapImpl = function(nothing, isJust2, f, xs) {
  for (var i = 0; i < xs.length; i++) {
    var result = f(xs[i]);
    if (isJust2(result))
      return result;
  }
  return nothing;
};
var findIndexImpl = function(just, nothing, f, xs) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (f(xs[i]))
      return just(i);
  }
  return nothing;
};
var reverse = function(l) {
  return l.slice().reverse();
};
var concat = function(xss) {
  if (xss.length <= 1e4) {
    return Array.prototype.concat.apply([], xss);
  }
  var result = [];
  for (var i = 0, l = xss.length; i < l; i++) {
    var xs = xss[i];
    for (var j = 0, m = xs.length; j < m; j++) {
      result.push(xs[j]);
    }
  }
  return result;
};
var filterImpl = function(f, xs) {
  return xs.filter(f);
};
var partitionImpl = function(f, xs) {
  var yes = [];
  var no = [];
  for (var i = 0; i < xs.length; i++) {
    var x = xs[i];
    if (f(x))
      yes.push(x);
    else
      no.push(x);
  }
  return { yes, no };
};
var sortByImpl = /* @__PURE__ */ function() {
  function mergeFromTo(compare21, fromOrdering, xs1, xs2, from4, to2) {
    var mid;
    var i;
    var j;
    var k;
    var x;
    var y;
    var c;
    mid = from4 + (to2 - from4 >> 1);
    if (mid - from4 > 1)
      mergeFromTo(compare21, fromOrdering, xs2, xs1, from4, mid);
    if (to2 - mid > 1)
      mergeFromTo(compare21, fromOrdering, xs2, xs1, mid, to2);
    i = from4;
    j = mid;
    k = from4;
    while (i < mid && j < to2) {
      x = xs2[i];
      y = xs2[j];
      c = fromOrdering(compare21(x)(y));
      if (c > 0) {
        xs1[k++] = y;
        ++j;
      } else {
        xs1[k++] = x;
        ++i;
      }
    }
    while (i < mid) {
      xs1[k++] = xs2[i++];
    }
    while (j < to2) {
      xs1[k++] = xs2[j++];
    }
  }
  return function(compare21, fromOrdering, xs) {
    var out;
    if (xs.length < 2)
      return xs;
    out = xs.slice(0);
    mergeFromTo(compare21, fromOrdering, out, xs.slice(0), 0, xs.length);
    return out;
  };
}();
var sliceImpl = function(s, e, l) {
  return l.slice(s, e);
};
var zipWithImpl = function(f, xs, ys) {
  var l = xs.length < ys.length ? xs.length : ys.length;
  var result = new Array(l);
  for (var i = 0; i < l; i++) {
    result[i] = f(xs[i])(ys[i]);
  }
  return result;
};
var anyImpl = function(p, xs) {
  var len = xs.length;
  for (var i = 0; i < len; i++) {
    if (p(xs[i]))
      return true;
  }
  return false;
};
var allImpl = function(p, xs) {
  var len = xs.length;
  for (var i = 0; i < len; i++) {
    if (!p(xs[i]))
      return false;
  }
  return true;
};
var unsafeIndexImpl = function(xs, n) {
  return xs[n];
};

// output/Data.Array.ST/foreign.js
function newSTArray() {
  return [];
}
function unsafeFreezeThawImpl(xs) {
  return xs;
}
var unsafeFreezeImpl = unsafeFreezeThawImpl;
var unsafeThawImpl = unsafeFreezeThawImpl;
function copyImpl(xs) {
  return xs.slice();
}
var thawImpl = copyImpl;
var pushImpl = function(a, xs) {
  return xs.push(a);
};

// output/Control.Monad.ST.Uncurried/foreign.js
var runSTFn1 = function runSTFn12(fn) {
  return function(a) {
    return function() {
      return fn(a);
    };
  };
};
var runSTFn2 = function runSTFn22(fn) {
  return function(a) {
    return function(b) {
      return function() {
        return fn(a, b);
      };
    };
  };
};

// output/Data.Array.ST/index.js
var bind2 = /* @__PURE__ */ bind(bindST);
var unsafeThaw = /* @__PURE__ */ runSTFn1(unsafeThawImpl);
var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);
var thaw = /* @__PURE__ */ runSTFn1(thawImpl);
var withArray = function(f) {
  return function(xs) {
    return function __do3() {
      var result = thaw(xs)();
      f(result)();
      return unsafeFreeze(result)();
    };
  };
};
var run2 = function(st) {
  return bind2(st)(unsafeFreeze)();
};
var push = /* @__PURE__ */ runSTFn2(pushImpl);

// output/Data.Array.ST.Iterator/index.js
var map6 = /* @__PURE__ */ map(functorST);
var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);
var $$void3 = /* @__PURE__ */ $$void(functorST);
var Iterator = /* @__PURE__ */ function() {
  function Iterator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Iterator2.create = function(value0) {
    return function(value12) {
      return new Iterator2(value0, value12);
    };
  };
  return Iterator2;
}();
var peek = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    return v.value0(i);
  };
};
var next = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    modify2(function(v1) {
      return v1 + 1 | 0;
    })(v.value1)();
    return v.value0(i);
  };
};
var pushWhile = function(p) {
  return function(iter) {
    return function(array2) {
      return function __do3() {
        var $$break2 = newSTRef(false)();
        while (map6(not2)(read2($$break2))()) {
          (function __do4() {
            var mx = peek(iter)();
            if (mx instanceof Just && p(mx.value0)) {
              push(mx.value0)(array2)();
              return $$void3(next(iter))();
            }
            ;
            return $$void3(write2(true)($$break2))();
          })();
        }
        ;
        return {};
      };
    };
  };
};
var iterator = function(f) {
  return map6(Iterator.create(f))(newSTRef(0));
};
var iterate = function(iter) {
  return function(f) {
    return function __do3() {
      var $$break2 = newSTRef(false)();
      while (map6(not2)(read2($$break2))()) {
        (function __do4() {
          var mx = next(iter)();
          if (mx instanceof Just) {
            return f(mx.value0)();
          }
          ;
          if (mx instanceof Nothing) {
            return $$void3(write2(true)($$break2))();
          }
          ;
          throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [mx.constructor.name]);
        })();
      }
      ;
      return {};
    };
  };
};

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init4) {
    return function(xs) {
      var acc = init4;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init4) {
    return function(xs) {
      var acc = init4;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Data.Bifunctor/index.js
var identity5 = /* @__PURE__ */ identity(categoryFn);
var bimap = function(dict) {
  return dict.bimap;
};
var lmap = function(dictBifunctor) {
  var bimap1 = bimap(dictBifunctor);
  return function(f) {
    return bimap1(f)(identity5);
  };
};
var rmap = function(dictBifunctor) {
  return bimap(dictBifunctor)(identity5);
};
var bifunctorTuple = {
  bimap: function(f) {
    return function(g) {
      return function(v) {
        return new Tuple(f(v.value0), g(v.value1));
      };
    };
  }
};
var bifunctorEither = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return new Left(v(v2.value0));
        }
        ;
        if (v2 instanceof Right) {
          return new Right(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Data.Maybe.First/index.js
var semigroupFirst = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v;
      }
      ;
      return v1;
    };
  }
};
var monoidFirst = /* @__PURE__ */ function() {
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupFirst;
    }
  };
}();

// output/Data.Monoid.Conj/index.js
var Conj = function(x) {
  return x;
};
var semigroupConj = function(dictHeytingAlgebra) {
  var conj2 = conj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return conj2(v)(v1);
      };
    }
  };
};
var monoidConj = function(dictHeytingAlgebra) {
  var semigroupConj1 = semigroupConj(dictHeytingAlgebra);
  return {
    mempty: tt(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupConj1;
    }
  };
};

// output/Data.Monoid.Disj/index.js
var Disj = function(x) {
  return x;
};
var semigroupDisj = function(dictHeytingAlgebra) {
  var disj3 = disj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return disj3(v)(v1);
      };
    }
  };
};
var monoidDisj = function(dictHeytingAlgebra) {
  var semigroupDisj1 = semigroupDisj(dictHeytingAlgebra);
  return {
    mempty: ff(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupDisj1;
    }
  };
};

// output/Data.Monoid.Endo/index.js
var semigroupEndo = function(dictSemigroupoid) {
  var compose3 = compose(dictSemigroupoid);
  return {
    append: function(v) {
      return function(v1) {
        return compose3(v)(v1);
      };
    }
  };
};
var monoidEndo = function(dictCategory) {
  var semigroupEndo1 = semigroupEndo(dictCategory.Semigroupoid0());
  return {
    mempty: identity(dictCategory),
    Semigroup0: function() {
      return semigroupEndo1;
    }
  };
};

// output/Data.Foldable/index.js
var identity6 = /* @__PURE__ */ identity(categoryFn);
var eq12 = /* @__PURE__ */ eq(eqOrdering);
var unwrap2 = /* @__PURE__ */ unwrap();
var alaF2 = /* @__PURE__ */ alaF()()()();
var foldr = function(dict) {
  return dict.foldr;
};
var oneOf = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    return foldr22(alt(dictPlus.Alt0()))(empty(dictPlus));
  };
};
var oneOfMap = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    var alt40 = alt(dictPlus.Alt0());
    var empty14 = empty(dictPlus);
    return function(f) {
      return foldr22(function($453) {
        return alt40(f($453));
      })(empty14);
    };
  };
};
var traverse_ = function(dictApplicative) {
  var applySecond12 = applySecond(dictApplicative.Apply0());
  var pure98 = pure(dictApplicative);
  return function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(f) {
      return foldr22(function($454) {
        return applySecond12(f($454));
      })(pure98(unit));
    };
  };
};
var for_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return flip(traverse_1(dictFoldable));
  };
};
var sequence_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return traverse_1(dictFoldable)(identity6);
  };
};
var foldl = function(dict) {
  return dict.foldl;
};
var intercalate = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictMonoid) {
    var append48 = append(dictMonoid.Semigroup0());
    var mempty33 = mempty(dictMonoid);
    return function(sep3) {
      return function(xs) {
        var go = function(v) {
          return function(v1) {
            if (v.init) {
              return {
                init: false,
                acc: v1
              };
            }
            ;
            return {
              init: false,
              acc: append48(v.acc)(append48(sep3)(v1))
            };
          };
        };
        return foldl22(go)({
          init: true,
          acc: mempty33
        })(xs).acc;
      };
    };
  };
};
var maximumBy = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(cmp) {
    var max$prime = function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return new Just(v1);
        }
        ;
        if (v instanceof Just) {
          return new Just(function() {
            var $303 = eq12(cmp(v.value0)(v1))(GT.value);
            if ($303) {
              return v.value0;
            }
            ;
            return v1;
          }());
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
    return foldl22(max$prime)(Nothing.value);
  };
};
var maximum = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(dictFoldable) {
    return maximumBy(dictFoldable)(compare21);
  };
};
var sum = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictSemiring) {
    return foldl22(add(dictSemiring))(zero(dictSemiring));
  };
};
var foldableMaybe = {
  foldr: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldl: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v1)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty33 = mempty(dictMonoid);
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return mempty33;
        }
        ;
        if (v1 instanceof Just) {
          return v(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  }
};
var foldableEither = {
  foldr: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return v1;
        }
        ;
        if (v2 instanceof Right) {
          return v(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldl: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return v1;
        }
        ;
        if (v2 instanceof Right) {
          return v(v1)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty33 = mempty(dictMonoid);
    return function(v) {
      return function(v1) {
        if (v1 instanceof Left) {
          return mempty33;
        }
        ;
        if (v1 instanceof Right) {
          return v(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  }
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append48 = append(dictMonoid.Semigroup0());
    var mempty33 = mempty(dictMonoid);
    return function(f) {
      return foldr22(function(x) {
        return function(acc) {
          return append48(f(x))(acc);
        };
      })(mempty33);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};
var foldMap = function(dict) {
  return dict.foldMap;
};
var lookup = function(dictFoldable) {
  var foldMap210 = foldMap(dictFoldable)(monoidFirst);
  return function(dictEq) {
    var eq213 = eq(dictEq);
    return function(a) {
      var $460 = foldMap210(function(v) {
        var $444 = eq213(a)(v.value0);
        if ($444) {
          return new Just(v.value1);
        }
        ;
        return Nothing.value;
      });
      return function($461) {
        return unwrap2($460($461));
      };
    };
  };
};
var fold = function(dictFoldable) {
  var foldMap210 = foldMap(dictFoldable);
  return function(dictMonoid) {
    return foldMap210(dictMonoid)(identity6);
  };
};
var find = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(p) {
    var go = function(v) {
      return function(v1) {
        if (v instanceof Nothing && p(v1)) {
          return new Just(v1);
        }
        ;
        return v;
      };
    };
    return foldl22(go)(Nothing.value);
  };
};
var any = function(dictFoldable) {
  var foldMap210 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Disj)(foldMap210(monoidDisj(dictHeytingAlgebra)));
  };
};
var elem = function(dictFoldable) {
  var any1 = any(dictFoldable)(heytingAlgebraBoolean);
  return function(dictEq) {
    var $462 = eq(dictEq);
    return function($463) {
      return any1($462($463));
    };
  };
};
var notElem = function(dictFoldable) {
  var elem12 = elem(dictFoldable);
  return function(dictEq) {
    var elem22 = elem12(dictEq);
    return function(x) {
      var $464 = elem22(x);
      return function($465) {
        return !$464($465);
      };
    };
  };
};
var or = function(dictFoldable) {
  var any1 = any(dictFoldable);
  return function(dictHeytingAlgebra) {
    return any1(dictHeytingAlgebra)(identity6);
  };
};
var all = function(dictFoldable) {
  var foldMap210 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Conj)(foldMap210(monoidConj(dictHeytingAlgebra)));
  };
};
var and = function(dictFoldable) {
  var all1 = all(dictFoldable);
  return function(dictHeytingAlgebra) {
    return all1(dictHeytingAlgebra)(identity6);
  };
};

// output/Data.Function.Uncurried/foreign.js
var mkFn5 = function(fn) {
  return function(a, b, c, d, e) {
    return fn(a)(b)(c)(d)(e);
  };
};
var runFn2 = function(fn) {
  return function(a) {
    return function(b) {
      return fn(a, b);
    };
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.Function.Uncurried/index.js
var runFn1 = function(f) {
  return f;
};

// output/Data.FunctorWithIndex/foreign.js
var mapWithIndexArray = function(f) {
  return function(xs) {
    var l = xs.length;
    var result = Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(i)(xs[i]);
    }
    return result;
  };
};

// output/Data.Functor.App/index.js
var App = function(x) {
  return x;
};
var semigroupApp = function(dictApply) {
  var lift26 = lift2(dictApply);
  return function(dictSemigroup) {
    var append127 = append(dictSemigroup);
    return {
      append: function(v) {
        return function(v1) {
          return lift26(append127)(v)(v1);
        };
      }
    };
  };
};

// output/Data.FunctorWithIndex/index.js
var mapWithIndex = function(dict) {
  return dict.mapWithIndex;
};
var functorWithIndexArray = {
  mapWithIndex: mapWithIndexArray,
  Functor0: function() {
    return functorArray;
  }
};

// output/Data.Traversable/foreign.js
var traverseArrayImpl = /* @__PURE__ */ function() {
  function array1(a) {
    return [a];
  }
  function array2(a) {
    return function(b) {
      return [a, b];
    };
  }
  function array3(a) {
    return function(b) {
      return function(c) {
        return [a, b, c];
      };
    };
  }
  function concat22(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }
  return function(apply30) {
    return function(map154) {
      return function(pure98) {
        return function(f) {
          return function(array4) {
            function go(bot, top4) {
              switch (top4 - bot) {
                case 0:
                  return pure98([]);
                case 1:
                  return map154(array1)(f(array4[bot]));
                case 2:
                  return apply30(map154(array2)(f(array4[bot])))(f(array4[bot + 1]));
                case 3:
                  return apply30(apply30(map154(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                default:
                  var pivot = bot + Math.floor((top4 - bot) / 4) * 2;
                  return apply30(map154(concat22)(go(bot, pivot)))(go(pivot, top4));
              }
            }
            return go(0, array4.length);
          };
        };
      };
    };
  };
}();

// output/Data.Traversable/index.js
var identity7 = /* @__PURE__ */ identity(categoryFn);
var traverse = function(dict) {
  return dict.traverse;
};
var traversableMaybe = {
  traverse: function(dictApplicative) {
    var pure98 = pure(dictApplicative);
    var map154 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return pure98(Nothing.value);
        }
        ;
        if (v1 instanceof Just) {
          return map154(Just.create)(v(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  sequence: function(dictApplicative) {
    var pure98 = pure(dictApplicative);
    var map154 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      if (v instanceof Nothing) {
        return pure98(Nothing.value);
      }
      ;
      if (v instanceof Just) {
        return map154(Just.create)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  },
  Foldable1: function() {
    return foldableMaybe;
  }
};
var sequenceDefault = function(dictTraversable) {
  var traverse22 = traverse(dictTraversable);
  return function(dictApplicative) {
    return traverse22(dictApplicative)(identity7);
  };
};
var traversableArray = {
  traverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    return traverseArrayImpl(apply2(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
  },
  sequence: function(dictApplicative) {
    return sequenceDefault(traversableArray)(dictApplicative);
  },
  Functor0: function() {
    return functorArray;
  },
  Foldable1: function() {
    return foldableArray;
  }
};
var sequence = function(dict) {
  return dict.sequence;
};
var $$for = function(dictApplicative) {
  return function(dictTraversable) {
    var traverse22 = traverse(dictTraversable)(dictApplicative);
    return function(x) {
      return function(f) {
        return traverse22(f)(x);
      };
    };
  };
};

// output/Data.Unfoldable/foreign.js
var unfoldrArrayImpl = function(isNothing2) {
  return function(fromJust12) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value4 = b;
            while (true) {
              var maybe3 = f(value4);
              if (isNothing2(maybe3))
                return result;
              var tuple2 = fromJust12(maybe3);
              result.push(fst2(tuple2));
              value4 = snd2(tuple2);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/foreign.js
var unfoldr1ArrayImpl = function(isNothing2) {
  return function(fromJust12) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value4 = b;
            while (true) {
              var tuple2 = f(value4);
              result.push(fst2(tuple2));
              var maybe3 = snd2(tuple2);
              if (isNothing2(maybe3))
                return result;
              value4 = fromJust12(maybe3);
            }
          };
        };
      };
    };
  };
};

// output/Data.Ord.Min/index.js
var Min = function(x) {
  return x;
};
var semigroupMin = function(dictOrd) {
  var min8 = min(dictOrd);
  return {
    append: function(v) {
      return function(v1) {
        return min8(v)(v1);
      };
    }
  };
};

// output/Data.Semigroup.Foldable/index.js
var ala2 = /* @__PURE__ */ ala()()();
var JoinWith = function(x) {
  return x;
};
var semigroupJoinWith = function(dictSemigroup) {
  var append48 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        return function(j) {
          return append48(v(j))(append48(j)(v1(j)));
        };
      };
    }
  };
};
var joinee = function(v) {
  return v;
};
var foldr1 = function(dict) {
  return dict.foldr1;
};
var foldl1 = function(dict) {
  return dict.foldl1;
};
var foldMap1DefaultL = function(dictFoldable1) {
  var foldl112 = foldl1(dictFoldable1);
  return function(dictFunctor) {
    var map154 = map(dictFunctor);
    return function(dictSemigroup) {
      var append48 = append(dictSemigroup);
      return function(f) {
        var $162 = foldl112(append48);
        var $163 = map154(f);
        return function($164) {
          return $162($163($164));
        };
      };
    };
  };
};
var foldMap1 = function(dict) {
  return dict.foldMap1;
};
var intercalateMap = function(dictFoldable1) {
  var foldMap112 = foldMap1(dictFoldable1);
  return function(dictSemigroup) {
    var foldMap122 = foldMap112(semigroupJoinWith(dictSemigroup));
    return function(j) {
      return function(f) {
        return function(foldable) {
          return joinee(foldMap122(function($171) {
            return JoinWith($$const(f($171)));
          })(foldable))(j);
        };
      };
    };
  };
};
var minimum2 = function(dictOrd) {
  var semigroupMin2 = semigroupMin(dictOrd);
  return function(dictFoldable1) {
    return ala2(Min)(foldMap1(dictFoldable1)(semigroupMin2));
  };
};

// output/Data.Unfoldable1/index.js
var fromJust2 = /* @__PURE__ */ fromJust();
var unfoldr1 = function(dict) {
  return dict.unfoldr1;
};
var unfoldable1Array = {
  unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
};
var replicate1 = function(dictUnfoldable1) {
  var unfoldr11 = unfoldr1(dictUnfoldable1);
  return function(n) {
    return function(v) {
      var step3 = function(i) {
        if (i <= 0) {
          return new Tuple(v, Nothing.value);
        }
        ;
        if (otherwise) {
          return new Tuple(v, new Just(i - 1 | 0));
        }
        ;
        throw new Error("Failed pattern match at Data.Unfoldable1 (line 68, column 5 - line 68, column 39): " + [i.constructor.name]);
      };
      return unfoldr11(step3)(n - 1 | 0);
    };
  };
};
var singleton = function(dictUnfoldable1) {
  return replicate1(dictUnfoldable1)(1);
};

// output/Data.Unfoldable/index.js
var fromJust3 = /* @__PURE__ */ fromJust();
var unfoldr = function(dict) {
  return dict.unfoldr;
};
var unfoldableArray = {
  unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
  Unfoldable10: function() {
    return unfoldable1Array;
  }
};

// output/Data.Array/index.js
var $$void4 = /* @__PURE__ */ $$void(functorST);
var intercalate1 = /* @__PURE__ */ intercalate(foldableArray);
var apply3 = /* @__PURE__ */ apply2(applyMaybe);
var map7 = /* @__PURE__ */ map(functorMaybe);
var map1 = /* @__PURE__ */ map(functorArray);
var map22 = /* @__PURE__ */ map(functorST);
var fromJust4 = /* @__PURE__ */ fromJust();
var when2 = /* @__PURE__ */ when(applicativeST);
var notEq3 = /* @__PURE__ */ notEq(eqOrdering);
var foldMap12 = /* @__PURE__ */ foldMap(foldableArray);
var fold1 = /* @__PURE__ */ fold(foldableArray);
var append2 = /* @__PURE__ */ append(semigroupArray);
var zipWith = /* @__PURE__ */ runFn3(zipWithImpl);
var zip = /* @__PURE__ */ function() {
  return zipWith(Tuple.create);
}();
var unsafeIndex = function() {
  return runFn2(unsafeIndexImpl);
};
var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();
var uncons = /* @__PURE__ */ function() {
  return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {
    return function(xs) {
      return new Just({
        head: x,
        tail: xs
      });
    };
  });
}();
var toUnfoldable = function(dictUnfoldable) {
  var unfoldr4 = unfoldr(dictUnfoldable);
  return function(xs) {
    var len = length(xs);
    var f = function(i) {
      if (i < len) {
        return new Just(new Tuple(unsafeIndex1(xs)(i), i + 1 | 0));
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Array (line 163, column 3 - line 165, column 26): " + [i.constructor.name]);
    };
    return unfoldr4(f)(0);
  };
};
var tail = /* @__PURE__ */ function() {
  return runFn3(unconsImpl)($$const(Nothing.value))(function(v) {
    return function(xs) {
      return new Just(xs);
    };
  });
}();
var sortBy = function(comp) {
  return runFn3(sortByImpl)(comp)(function(v) {
    if (v instanceof GT) {
      return 1;
    }
    ;
    if (v instanceof EQ) {
      return 0;
    }
    ;
    if (v instanceof LT) {
      return -1 | 0;
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 897, column 38 - line 900, column 11): " + [v.constructor.name]);
  });
};
var sortWith = function(dictOrd) {
  var comparing3 = comparing(dictOrd);
  return function(f) {
    return sortBy(comparing3(f));
  };
};
var sortWith1 = /* @__PURE__ */ sortWith(ordInt);
var sort = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(xs) {
    return sortBy(compare21)(xs);
  };
};
var snoc = function(xs) {
  return function(x) {
    return withArray(push(x))(xs)();
  };
};
var slice = /* @__PURE__ */ runFn3(sliceImpl);
var take = function(n) {
  return function(xs) {
    var $152 = n < 1;
    if ($152) {
      return [];
    }
    ;
    return slice(0)(n)(xs);
  };
};
var singleton2 = function(a) {
  return [a];
};
var replicate = /* @__PURE__ */ runFn2(replicateImpl);
var range2 = /* @__PURE__ */ runFn2(rangeImpl);
var partition = /* @__PURE__ */ runFn2(partitionImpl);
var $$null = function(xs) {
  return length(xs) === 0;
};
var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var intersperse = function(a) {
  return function(arr) {
    var v = length(arr);
    if (v < 2) {
      return arr;
    }
    ;
    if (otherwise) {
      return run2(/* @__PURE__ */ function() {
        var unsafeGetElem = function(idx) {
          return unsafeIndex1(arr)(idx);
        };
        return function __do3() {
          var out = newSTArray();
          push(unsafeGetElem(0))(out)();
          forST(1)(v)(function(idx) {
            return function __do4() {
              push(a)(out)();
              return $$void4(push(unsafeGetElem(idx))(out))();
            };
          })();
          return out;
        };
      }());
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 623, column 21 - line 633, column 17): " + [v.constructor.name]);
  };
};
var intercalate2 = function(dictMonoid) {
  return intercalate1(dictMonoid);
};
var init = function(xs) {
  if ($$null(xs)) {
    return Nothing.value;
  }
  ;
  if (otherwise) {
    return new Just(slice(0)(length(xs) - 1 | 0)(xs));
  }
  ;
  throw new Error("Failed pattern match at Data.Array (line 351, column 1 - line 351, column 45): " + [xs.constructor.name]);
};
var index = /* @__PURE__ */ function() {
  return runFn4(indexImpl)(Just.create)(Nothing.value);
}();
var last = function(xs) {
  return index(xs)(length(xs) - 1 | 0);
};
var unsnoc = function(xs) {
  return apply3(map7(function(v) {
    return function(v1) {
      return {
        init: v,
        last: v1
      };
    };
  })(init(xs)))(last(xs));
};
var span = function(p) {
  return function(arr) {
    var go = function($copy_i) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(i) {
        var v = index(arr)(i);
        if (v instanceof Just) {
          var $156 = p(v.value0);
          if ($156) {
            $copy_i = i + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return new Just(i);
        }
        ;
        if (v instanceof Nothing) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Array (line 1035, column 5 - line 1037, column 25): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_i);
      }
      ;
      return $tco_result;
    };
    var breakIndex = go(0);
    if (breakIndex instanceof Just && breakIndex.value0 === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    if (breakIndex instanceof Just) {
      return {
        init: slice(0)(breakIndex.value0)(arr),
        rest: slice(breakIndex.value0)(length(arr))(arr)
      };
    }
    ;
    if (breakIndex instanceof Nothing) {
      return {
        init: arr,
        rest: []
      };
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 1022, column 3 - line 1028, column 30): " + [breakIndex.constructor.name]);
  };
};
var takeWhile = function(p) {
  return function(xs) {
    return span(p)(xs).init;
  };
};
var head = function(xs) {
  return index(xs)(0);
};
var nubBy = function(comp) {
  return function(xs) {
    var indexedAndSorted = sortBy(function(x) {
      return function(y) {
        return comp(snd(x))(snd(y));
      };
    })(mapWithIndex2(Tuple.create)(xs));
    var v = head(indexedAndSorted);
    if (v instanceof Nothing) {
      return [];
    }
    ;
    if (v instanceof Just) {
      return map1(snd)(sortWith1(fst)(function __do3() {
        var result = unsafeThaw(singleton2(v.value0))();
        foreach(indexedAndSorted)(function(v1) {
          return function __do4() {
            var lst = map22(/* @__PURE__ */ function() {
              var $183 = function($185) {
                return fromJust4(last($185));
              };
              return function($184) {
                return snd($183($184));
              };
            }())(unsafeFreeze(result))();
            return when2(notEq3(comp(lst)(v1.value1))(EQ.value))($$void4(push(v1)(result)))();
          };
        })();
        return unsafeFreeze(result)();
      }()));
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 1115, column 17 - line 1123, column 28): " + [v.constructor.name]);
  };
};
var nub = function(dictOrd) {
  return nubBy(compare(dictOrd));
};
var groupBy = function(op) {
  return function(xs) {
    return function __do3() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function(x) {
        return $$void4(function __do4() {
          var sub1 = newSTArray();
          push(x)(sub1)();
          pushWhile(op(x))(iter)(sub1)();
          var grp = unsafeFreeze(sub1)();
          return push(grp)(result)();
        });
      })();
      return unsafeFreeze(result)();
    }();
  };
};
var fromFoldable = function(dictFoldable) {
  return runFn2(fromFoldableImpl)(foldr(dictFoldable));
};
var foldr2 = /* @__PURE__ */ foldr(foldableArray);
var foldl2 = /* @__PURE__ */ foldl(foldableArray);
var foldMap2 = function(dictMonoid) {
  return foldMap12(dictMonoid);
};
var foldM = function(dictMonad) {
  var pure129 = pure(dictMonad.Applicative0());
  var bind128 = bind(dictMonad.Bind1());
  return function(f) {
    return function(b) {
      return runFn3(unconsImpl)(function(v) {
        return pure129(b);
      })(function(a) {
        return function(as3) {
          return bind128(f(b)(a))(function(b$prime) {
            return foldM(dictMonad)(f)(b$prime)(as3);
          });
        };
      });
    };
  };
};
var fold2 = function(dictMonoid) {
  return fold1(dictMonoid);
};
var findMap = /* @__PURE__ */ function() {
  return runFn4(findMapImpl)(Nothing.value)(isJust);
}();
var findIndex = /* @__PURE__ */ function() {
  return runFn4(findIndexImpl)(Just.create)(Nothing.value);
}();
var find2 = function(f) {
  return function(xs) {
    return map7(unsafeIndex1(xs))(findIndex(f)(xs));
  };
};
var filter = /* @__PURE__ */ runFn2(filterImpl);
var elemIndex = function(dictEq) {
  var eq213 = eq(dictEq);
  return function(x) {
    return findIndex(function(v) {
      return eq213(v)(x);
    });
  };
};
var notElem2 = function(dictEq) {
  var elemIndex1 = elemIndex(dictEq);
  return function(a) {
    return function(arr) {
      return isNothing(elemIndex1(a)(arr));
    };
  };
};
var elem2 = function(dictEq) {
  var elemIndex1 = elemIndex(dictEq);
  return function(a) {
    return function(arr) {
      return isJust(elemIndex1(a)(arr));
    };
  };
};
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};
var cons = function(x) {
  return function(xs) {
    return append2([x])(xs);
  };
};
var some = function(dictAlternative) {
  var apply111 = apply2(dictAlternative.Applicative0().Apply0());
  var map317 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return apply111(map317(cons)(v))(defer6(function(v1) {
        return many(dictAlternative)(dictLazy)(v);
      }));
    };
  };
};
var many = function(dictAlternative) {
  var alt40 = alt(dictAlternative.Plus1().Alt0());
  var pure129 = pure(dictAlternative.Applicative0());
  return function(dictLazy) {
    return function(v) {
      return alt40(some(dictAlternative)(dictLazy)(v))(pure129([]));
    };
  };
};
var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
var mapMaybe = function(f) {
  return concatMap(function() {
    var $189 = maybe([])(singleton2);
    return function($190) {
      return $189(f($190));
    };
  }());
};
var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));
var any2 = /* @__PURE__ */ runFn2(anyImpl);
var all2 = /* @__PURE__ */ runFn2(allImpl);

// output/Data.Array.NonEmpty.Internal/foreign.js
var foldr1Impl = function(f, xs) {
  var acc = xs[xs.length - 1];
  for (var i = xs.length - 2; i >= 0; i--) {
    acc = f(xs[i])(acc);
  }
  return acc;
};
var foldl1Impl = function(f, xs) {
  var acc = xs[0];
  var len = xs.length;
  for (var i = 1; i < len; i++) {
    acc = f(acc)(xs[i]);
  }
  return acc;
};

// output/Data.FoldableWithIndex/index.js
var foldr8 = /* @__PURE__ */ foldr(foldableArray);
var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var foldl8 = /* @__PURE__ */ foldl(foldableArray);
var unwrap3 = /* @__PURE__ */ unwrap();
var foldrWithIndex = function(dict) {
  return dict.foldrWithIndex;
};
var traverseWithIndex_ = function(dictApplicative) {
  var applySecond12 = applySecond(dictApplicative.Apply0());
  var pure98 = pure(dictApplicative);
  return function(dictFoldableWithIndex) {
    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
    return function(f) {
      return foldrWithIndex1(function(i) {
        var $289 = f(i);
        return function($290) {
          return applySecond12($289($290));
        };
      })(pure98(unit));
    };
  };
};
var forWithIndex_ = function(dictApplicative) {
  var traverseWithIndex_1 = traverseWithIndex_(dictApplicative);
  return function(dictFoldableWithIndex) {
    return flip(traverseWithIndex_1(dictFoldableWithIndex));
  };
};
var foldlWithIndex = function(dict) {
  return dict.foldlWithIndex;
};
var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {
  var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
  return function(dictMonoid) {
    var append48 = append(dictMonoid.Semigroup0());
    var mempty33 = mempty(dictMonoid);
    return function(f) {
      return foldrWithIndex1(function(i) {
        return function(x) {
          return function(acc) {
            return append48(f(i)(x))(acc);
          };
        };
      })(mempty33);
    };
  };
};
var foldableWithIndexArray = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $291 = foldr8(function(v) {
        return function(y) {
          return f(v.value0)(v.value1)(y);
        };
      })(z);
      var $292 = mapWithIndex3(Tuple.create);
      return function($293) {
        return $291($292($293));
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $294 = foldl8(function(y) {
        return function(v) {
          return f(v.value0)(y)(v.value1);
        };
      })(z);
      var $295 = mapWithIndex3(Tuple.create);
      return function($296) {
        return $294($295($296));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
  },
  Foldable0: function() {
    return foldableArray;
  }
};
var foldMapWithIndex = function(dict) {
  return dict.foldMapWithIndex;
};
var findMapWithIndex = function(dictFoldableWithIndex) {
  var foldlWithIndex1 = foldlWithIndex(dictFoldableWithIndex);
  return function(f) {
    var go = function(v) {
      return function(v1) {
        return function(v2) {
          if (v1 instanceof Nothing) {
            return f(v)(v2);
          }
          ;
          return v1;
        };
      };
    };
    return foldlWithIndex1(go)(Nothing.value);
  };
};
var anyWithIndex = function(dictFoldableWithIndex) {
  var foldMapWithIndex12 = foldMapWithIndex(dictFoldableWithIndex);
  return function(dictHeytingAlgebra) {
    var foldMapWithIndex23 = foldMapWithIndex12(monoidDisj(dictHeytingAlgebra));
    return function(t) {
      var $317 = foldMapWithIndex23(function(i) {
        var $319 = t(i);
        return function($320) {
          return Disj($319($320));
        };
      });
      return function($318) {
        return unwrap3($317($318));
      };
    };
  };
};

// output/Data.TraversableWithIndex/index.js
var traverseWithIndexDefault = function(dictTraversableWithIndex) {
  var sequence6 = sequence(dictTraversableWithIndex.Traversable2());
  var mapWithIndex6 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());
  return function(dictApplicative) {
    var sequence12 = sequence6(dictApplicative);
    return function(f) {
      var $174 = mapWithIndex6(f);
      return function($175) {
        return sequence12($174($175));
      };
    };
  };
};
var traverseWithIndex = function(dict) {
  return dict.traverseWithIndex;
};
var traversableWithIndexArray = {
  traverseWithIndex: function(dictApplicative) {
    return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
  },
  FunctorWithIndex0: function() {
    return functorWithIndexArray;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexArray;
  },
  Traversable2: function() {
    return traversableArray;
  }
};
var forWithIndex = function(dictApplicative) {
  return function(dictTraversableWithIndex) {
    return flip(traverseWithIndex(dictTraversableWithIndex)(dictApplicative));
  };
};

// output/Data.Array.NonEmpty.Internal/index.js
var NonEmptyArray = function(x) {
  return x;
};
var traversableNonEmptyArray = traversableArray;
var semigroupNonEmptyArray = semigroupArray;
var functorNonEmptyArray = functorArray;
var foldableNonEmptyArray = foldableArray;
var foldable1NonEmptyArray = {
  foldMap1: function(dictSemigroup) {
    return foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);
  },
  foldr1: /* @__PURE__ */ runFn2(foldr1Impl),
  foldl1: /* @__PURE__ */ runFn2(foldl1Impl),
  Foldable0: function() {
    return foldableNonEmptyArray;
  }
};
var bindNonEmptyArray = bindArray;
var applicativeNonEmptyArray = applicativeArray;

// output/Data.NonEmpty/index.js
var map8 = /* @__PURE__ */ map(functorTuple);
var map12 = /* @__PURE__ */ map(functorMaybe);
var NonEmpty = /* @__PURE__ */ function() {
  function NonEmpty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  NonEmpty2.create = function(value0) {
    return function(value12) {
      return new NonEmpty2(value0, value12);
    };
  };
  return NonEmpty2;
}();
var unfoldable1NonEmpty = function(dictUnfoldable) {
  var unfoldr4 = unfoldr(dictUnfoldable);
  return {
    unfoldr1: function(f) {
      return function(b) {
        return uncurry(NonEmpty.create)(map8(unfoldr4(map12(f)))(f(b)));
      };
    }
  };
};
var singleton3 = function(dictPlus) {
  var empty14 = empty(dictPlus);
  return function(a) {
    return new NonEmpty(a, empty14);
  };
};
var functorNonEmpty = function(dictFunctor) {
  var map233 = map(dictFunctor);
  return {
    map: function(f) {
      return function(m) {
        return new NonEmpty(f(m.value0), map233(f)(m.value1));
      };
    }
  };
};
var foldableNonEmpty = function(dictFoldable) {
  var foldMap32 = foldMap(dictFoldable);
  var foldl21 = foldl(dictFoldable);
  var foldr21 = foldr(dictFoldable);
  return {
    foldMap: function(dictMonoid) {
      var append127 = append(dictMonoid.Semigroup0());
      var foldMap111 = foldMap32(dictMonoid);
      return function(f) {
        return function(v) {
          return append127(f(v.value0))(foldMap111(f)(v.value1));
        };
      };
    },
    foldl: function(f) {
      return function(b) {
        return function(v) {
          return foldl21(f)(f(b)(v.value0))(v.value1);
        };
      };
    },
    foldr: function(f) {
      return function(b) {
        return function(v) {
          return f(v.value0)(foldr21(f)(b)(v.value1));
        };
      };
    }
  };
};
var foldable1NonEmpty = function(dictFoldable) {
  var foldl21 = foldl(dictFoldable);
  var foldr21 = foldr(dictFoldable);
  var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);
  return {
    foldMap1: function(dictSemigroup) {
      var append127 = append(dictSemigroup);
      return function(f) {
        return function(v) {
          return foldl21(function(s) {
            return function(a1) {
              return append127(s)(f(a1));
            };
          })(f(v.value0))(v.value1);
        };
      };
    },
    foldr1: function(f) {
      return function(v) {
        return maybe(v.value0)(f(v.value0))(foldr21(function(a1) {
          var $250 = maybe(a1)(f(a1));
          return function($251) {
            return Just.create($250($251));
          };
        })(Nothing.value)(v.value1));
      };
    },
    foldl1: function(f) {
      return function(v) {
        return foldl21(f)(v.value0)(v.value1);
      };
    },
    Foldable0: function() {
      return foldableNonEmpty1;
    }
  };
};

// output/Data.Array.NonEmpty/index.js
var foldMap11 = /* @__PURE__ */ foldMap1(foldable1NonEmptyArray);
var fromJust5 = /* @__PURE__ */ fromJust();
var unsafeFromArray = NonEmptyArray;
var toArray = function(v) {
  return v;
};
var snoc$prime = function(xs) {
  return function(x) {
    return unsafeFromArray(snoc(xs)(x));
  };
};
var snoc2 = function(xs) {
  return function(x) {
    return unsafeFromArray(snoc(toArray(xs))(x));
  };
};
var singleton4 = function($110) {
  return unsafeFromArray(singleton2($110));
};
var fromArray = function(xs) {
  if (length(xs) > 0) {
    return new Just(unsafeFromArray(xs));
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): " + [xs.constructor.name]);
};
var fromFoldable2 = function(dictFoldable) {
  var $119 = fromFoldable(dictFoldable);
  return function($120) {
    return fromArray($119($120));
  };
};
var foldMap13 = function(dictSemigroup) {
  return foldMap11(dictSemigroup);
};
var cons$prime = function(x) {
  return function(xs) {
    return unsafeFromArray(cons(x)(xs));
  };
};
var adaptMaybe = function(f) {
  return function($126) {
    return fromJust5(f(toArray($126)));
  };
};
var head2 = /* @__PURE__ */ adaptMaybe(head);
var init2 = /* @__PURE__ */ adaptMaybe(init);
var last2 = /* @__PURE__ */ adaptMaybe(last);
var tail2 = /* @__PURE__ */ adaptMaybe(tail);
var uncons2 = /* @__PURE__ */ adaptMaybe(uncons);
var adaptAny = function(f) {
  return function($128) {
    return f(toArray($128));
  };
};
var any3 = function(p) {
  return adaptAny(any2(p));
};
var filter2 = function(f) {
  return adaptAny(filter(f));
};
var find3 = function(p) {
  return adaptAny(find2(p));
};
var length2 = /* @__PURE__ */ adaptAny(length);
var takeWhile2 = function(f) {
  return adaptAny(takeWhile(f));
};
var toUnfoldable2 = function(dictUnfoldable) {
  return adaptAny(toUnfoldable(dictUnfoldable));
};
var unsafeAdapt = function(f) {
  var $129 = adaptAny(f);
  return function($130) {
    return unsafeFromArray($129($130));
  };
};
var cons2 = function(x) {
  return unsafeAdapt(cons(x));
};

// output/Control.Monad.Except.Trans/index.js
var map9 = /* @__PURE__ */ map(functorEither);
var ExceptT = function(x) {
  return x;
};
var withExceptT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(f) {
    return function(v) {
      var mapLeft = function(v1) {
        return function(v2) {
          if (v2 instanceof Right) {
            return new Right(v2.value0);
          }
          ;
          if (v2 instanceof Left) {
            return new Left(v1(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 43, column 3 - line 43, column 32): " + [v1.constructor.name, v2.constructor.name]);
        };
      };
      return map154(mapLeft(f))(v);
    };
  };
};
var runExceptT = function(v) {
  return v;
};
var monadTransExceptT = {
  lift: function(dictMonad) {
    var bind82 = bind(dictMonad.Bind1());
    var pure98 = pure(dictMonad.Applicative0());
    return function(m) {
      return bind82(m)(function(a) {
        return pure98(new Right(a));
      });
    };
  }
};
var lift4 = /* @__PURE__ */ lift(monadTransExceptT);
var mapExceptT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorExceptT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return {
    map: function(f) {
      return mapExceptT(map154(map9(f)));
    }
  };
};
var except = function(dictApplicative) {
  var $191 = pure(dictApplicative);
  return function($192) {
    return ExceptT($191($192));
  };
};
var monadExceptT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeExceptT(dictMonad);
    },
    Bind1: function() {
      return bindExceptT(dictMonad);
    }
  };
};
var bindExceptT = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var pure98 = pure(dictMonad.Applicative0());
  return {
    bind: function(v) {
      return function(k) {
        return bind82(v)(either(function($193) {
          return pure98(Left.create($193));
        })(function(a) {
          var v1 = k(a);
          return v1;
        }));
      };
    },
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var applyExceptT = function(dictMonad) {
  var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadExceptT(dictMonad)),
    Functor0: function() {
      return functorExceptT1;
    }
  };
};
var applicativeExceptT = function(dictMonad) {
  return {
    pure: function() {
      var $194 = pure(dictMonad.Applicative0());
      return function($195) {
        return ExceptT($194(Right.create($195)));
      };
    }(),
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var monadAskExceptT = function(dictMonadAsk) {
  var Monad0 = dictMonadAsk.Monad0();
  var monadExceptT1 = monadExceptT(Monad0);
  return {
    ask: lift4(Monad0)(ask(dictMonadAsk)),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var monadEffectExceptT = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadExceptT1 = monadExceptT(Monad0);
  return {
    liftEffect: function() {
      var $196 = lift4(Monad0);
      var $197 = liftEffect(dictMonadEffect);
      return function($198) {
        return $196($197($198));
      };
    }(),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var monadThrowExceptT = function(dictMonad) {
  var monadExceptT1 = monadExceptT(dictMonad);
  return {
    throwError: function() {
      var $204 = pure(dictMonad.Applicative0());
      return function($205) {
        return ExceptT($204(Left.create($205)));
      };
    }(),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var altExceptT = function(dictSemigroup) {
  var append48 = append(dictSemigroup);
  return function(dictMonad) {
    var Bind1 = dictMonad.Bind1();
    var bind82 = bind(Bind1);
    var pure98 = pure(dictMonad.Applicative0());
    var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
    return {
      alt: function(v) {
        return function(v1) {
          return bind82(v)(function(rm3) {
            if (rm3 instanceof Right) {
              return pure98(new Right(rm3.value0));
            }
            ;
            if (rm3 instanceof Left) {
              return bind82(v1)(function(rn) {
                if (rn instanceof Right) {
                  return pure98(new Right(rn.value0));
                }
                ;
                if (rn instanceof Left) {
                  return pure98(new Left(append48(rm3.value0)(rn.value0)));
                }
                ;
                throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 87, column 9 - line 89, column 49): " + [rn.constructor.name]);
              });
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 83, column 5 - line 89, column 49): " + [rm3.constructor.name]);
          });
        };
      },
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
};

// output/Data.Codec/index.js
var map10 = /* @__PURE__ */ map(functorTuple);
var Codec = /* @__PURE__ */ function() {
  function Codec2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Codec2.create = function(value0) {
    return function(value12) {
      return new Codec2(value0, value12);
    };
  };
  return Codec2;
}();
var profunctorCodec = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return {
    dimap: function(f) {
      return function(g) {
        return function(v) {
          return new Codec(function() {
            var $91 = map154(g);
            return function($92) {
              return $91(v.value0($92));
            };
          }(), function() {
            var $93 = map10(g);
            return function($94) {
              return $93(v.value1(f($94)));
            };
          }());
        };
      };
    }
  };
};
var functorCodec = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return new Codec(function() {
          var $95 = map154(f);
          return function($96) {
            return $95(v.value0($96));
          };
        }(), function() {
          var $97 = map10(f);
          return function($98) {
            return $97(v.value1($98));
          };
        }());
      };
    }
  };
};
var applyCodec = function(dictApply) {
  var apply30 = apply2(dictApply);
  var functorCodec1 = functorCodec(dictApply.Functor0());
  return function(dictSemigroup) {
    var apply111 = apply2(applyTuple(dictSemigroup));
    return {
      apply: function(v) {
        return function(v1) {
          return new Codec(function(a) {
            return apply30(v.value0(a))(v1.value0(a));
          }, function(c) {
            return apply111(v.value1(c))(v1.value1(c));
          });
        };
      },
      Functor0: function() {
        return functorCodec1;
      }
    };
  };
};
var encode = function(v) {
  return function($100) {
    return fst(v.value1($100));
  };
};
var decode = function(v) {
  return v.value0;
};
var codec$prime = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};
var codec = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};

// output/Data.String.Common/foreign.js
var replace = function(s1) {
  return function(s2) {
    return function(s3) {
      return s3.replace(s1, s2);
    };
  };
};
var replaceAll = function(s1) {
  return function(s2) {
    return function(s3) {
      return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
    };
  };
};
var split = function(sep3) {
  return function(s) {
    return s.split(sep3);
  };
};
var toLower = function(s) {
  return s.toLowerCase();
};
var toUpper = function(s) {
  return s.toUpperCase();
};
var trim = function(s) {
  return s.trim();
};
var joinWith = function(s) {
  return function(xs) {
    return xs.join(s);
  };
};

// output/Data.String.Common/index.js
var $$null2 = function(s) {
  return s === "";
};

// output/JSON/foreign.js
var coerce3 = (x) => x;
var _null = null;
var fromBoolean = coerce3;
var fromString = coerce3;
var fromJArray = coerce3;
var fromJObject = coerce3;
var print = (j) => JSON.stringify(j);
var printIndented = (j) => JSON.stringify(j, null, 2);

// output/Data.Int/foreign.js
var fromNumberImpl = function(just) {
  return function(nothing) {
    return function(n) {
      return (n | 0) === n ? just(n) : nothing;
    };
  };
};
var toNumber = function(n) {
  return n;
};
var fromStringAsImpl = function(just) {
  return function(nothing) {
    return function(radix) {
      var digits;
      if (radix < 11) {
        digits = "[0-" + (radix - 1).toString() + "]";
      } else if (radix === 11) {
        digits = "[0-9a]";
      } else {
        digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
      }
      var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");
      return function(s) {
        if (pattern.test(s)) {
          var i = parseInt(s, radix);
          return (i | 0) === i ? just(i) : nothing;
        } else {
          return nothing;
        }
      };
    };
  };
};
var toStringAs = function(radix) {
  return function(i) {
    return i.toString(radix);
  };
};
var pow = function(x) {
  return function(y) {
    return Math.pow(x, y) | 0;
  };
};

// output/Data.Number/foreign.js
var infinity = Infinity;
var isFiniteImpl = isFinite;
function fromStringImpl(str2, isFinite2, just, nothing) {
  var num = parseFloat(str2);
  if (isFinite2(num)) {
    return just(num);
  } else {
    return nothing;
  }
}
var ceil = Math.ceil;
var floor = Math.floor;
var round = Math.round;

// output/Data.Number/index.js
var fromString2 = function(str2) {
  return fromStringImpl(str2, isFiniteImpl, Just.create, Nothing.value);
};

// output/Data.Int/index.js
var top2 = /* @__PURE__ */ top(boundedInt);
var bottom2 = /* @__PURE__ */ bottom(boundedInt);
var hexadecimal = 16;
var fromStringAs = /* @__PURE__ */ function() {
  return fromStringAsImpl(Just.create)(Nothing.value);
}();
var fromString3 = /* @__PURE__ */ fromStringAs(10);
var fromNumber = /* @__PURE__ */ function() {
  return fromNumberImpl(Just.create)(Nothing.value);
}();
var unsafeClamp = function(x) {
  if (!isFiniteImpl(x)) {
    return 0;
  }
  ;
  if (x >= toNumber(top2)) {
    return top2;
  }
  ;
  if (x <= toNumber(bottom2)) {
    return bottom2;
  }
  ;
  if (otherwise) {
    return fromMaybe(0)(fromNumber(x));
  }
  ;
  throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
};
var round2 = function($37) {
  return unsafeClamp(round($37));
};
var floor2 = function($39) {
  return unsafeClamp(floor($39));
};
var decimal = 10;
var ceil2 = function($40) {
  return unsafeClamp(ceil($40));
};

// output/JSON.Internal/foreign.js
var toString = Object.prototype.toString;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var _parse = (left3, right2, s) => {
  try {
    return right2(JSON.parse(s));
  } catch (e) {
    return left3(e.message);
  }
};
var _fromNumberWithDefault = (fallback, n) => isNaN(n) || !isFinite(n) ? fallback : n;
var _case = (isNull3, isBool, isNum, isStr, isArr, isObj, j) => {
  if (j == null)
    return isNull3(null);
  const ty = typeof j;
  if (ty === "boolean")
    return isBool(j);
  if (ty === "number")
    return isNum(j);
  if (ty === "string")
    return isStr(j);
  if (toString.call(j) === "[object Array]")
    return isArr(j);
  return isObj(j);
};
var toArray2 = (js) => js;
var fromArray2 = (js) => js;
var _fromEntries = (fst2, snd2, entries3) => {
  const result = {};
  for (var i = 0; i < entries3.length; i++) {
    result[fst2(entries3[i])] = snd2(entries3[i]);
  }
  return result;
};
var _entries = (tuple2, obj) => Object.entries(obj).map(([k, v]) => tuple2(k)(v));
var _lookup = (nothing, just, key, obj) => hasOwnProperty2.call(obj, key) ? just(obj[key]) : nothing;
var _index = (nothing, just, ix, arr) => ix >= 0 && ix < arr.length ? just(arr[ix]) : nothing;

// output/JSON/index.js
var parse = function(j) {
  return _parse(Left.create, Right.create, j);
};
var $$null3 = _null;
var fromNumber2 = function(n) {
  return _fromNumberWithDefault(0, n);
};
var fromArray3 = function(js) {
  return fromJArray(fromArray2(js));
};
var fail = function(v) {
  return Nothing.value;
};
var toBoolean = function(json4) {
  return _case(fail, Just.create, fail, fail, fail, fail, json4);
};
var toJArray = function(json4) {
  return _case(fail, fail, fail, fail, Just.create, fail, json4);
};
var toJObject = function(json4) {
  return _case(fail, fail, fail, fail, fail, Just.create, json4);
};
var toNull = function(json4) {
  return _case(Just.create, fail, fail, fail, fail, fail, json4);
};
var toNumber2 = function(json4) {
  return _case(fail, fail, Just.create, fail, fail, fail, json4);
};
var toString2 = function(json4) {
  return _case(fail, fail, fail, Just.create, fail, fail, json4);
};

// output/JSON.Array/index.js
var index2 = function(ix) {
  return function(arr) {
    return _index(Nothing.value, Just.create, ix, arr);
  };
};
var fromFoldable3 = function(dictFoldable) {
  var fromFoldable122 = fromFoldable(dictFoldable);
  return function(js) {
    return fromArray2(fromFoldable122(js));
  };
};

// output/JSON.Object/index.js
var lookup2 = function(k) {
  return function(obj) {
    return _lookup(Nothing.value, Just.create, k, obj);
  };
};
var fromEntries = function(kvs) {
  return _fromEntries(fst, snd, kvs);
};
var fromFoldable4 = function(dictFoldable) {
  var fromFoldable122 = fromFoldable(dictFoldable);
  return function(kvs) {
    return fromEntries(fromFoldable122(kvs));
  };
};
var fromFoldableWithIndex = function(dictFoldableWithIndex) {
  var foldrWithIndex2 = foldrWithIndex(dictFoldableWithIndex);
  return function(kvs) {
    return fromEntries(foldrWithIndex2(function(k) {
      return function(v) {
        return cons(new Tuple(k, v));
      };
    })([])(kvs));
  };
};
var entries = function(obj) {
  return _entries(Tuple.create, obj);
};
var toUnfoldable3 = function(dictUnfoldable) {
  var toUnfoldable112 = toUnfoldable(dictUnfoldable);
  return function(obj) {
    return toUnfoldable112(entries(obj));
  };
};

// output/JSON.Path/index.js
var show2 = /* @__PURE__ */ show(showString);
var show1 = /* @__PURE__ */ show(showInt);
var Tip = /* @__PURE__ */ function() {
  function Tip2() {
  }
  ;
  Tip2.value = new Tip2();
  return Tip2;
}();
var AtKey = /* @__PURE__ */ function() {
  function AtKey3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtKey3.create = function(value0) {
    return function(value12) {
      return new AtKey3(value0, value12);
    };
  };
  return AtKey3;
}();
var AtIndex = /* @__PURE__ */ function() {
  function AtIndex3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtIndex3.create = function(value0) {
    return function(value12) {
      return new AtIndex3(value0, value12);
    };
  };
  return AtIndex3;
}();
var showPath = {
  show: function(v) {
    if (v instanceof Tip) {
      return "Tip";
    }
    ;
    if (v instanceof AtKey) {
      return "(AtKey " + (show2(v.value0) + (" " + (show(showPath)(v.value1) + ")")));
    }
    ;
    if (v instanceof AtIndex) {
      return "(AtIndex " + (show1(v.value0) + (" " + (show(showPath)(v.value1) + ")")));
    }
    ;
    throw new Error("Failed pattern match at JSON.Path (line 23, column 10 - line 26, column 73): " + [v.constructor.name]);
  }
};
var eqPath = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Tip && y instanceof Tip) {
        return true;
      }
      ;
      if (x instanceof AtKey && y instanceof AtKey) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      if (x instanceof AtIndex && y instanceof AtIndex) {
        return x.value0 === y.value0 && eq(eqPath)(x.value1)(y.value1);
      }
      ;
      return false;
    };
  }
};
var stripPrefix = function($copy_v) {
  return function($copy_v1) {
    var $tco_var_v = $copy_v;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v, v1) {
      if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
        $tco_var_v = v.value1;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      if (v instanceof Tip) {
        $tco_done = true;
        return new Just(v1);
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_v, $copy_v1);
    }
    ;
    return $tco_result;
  };
};
var print2 = function(path14) {
  var go = function(p) {
    if (p instanceof Tip) {
      return "";
    }
    ;
    if (p instanceof AtKey) {
      return "." + (p.value0 + go(p.value1));
    }
    ;
    if (p instanceof AtIndex) {
      return "[" + (show1(p.value0) + ("]" + go(p.value1)));
    }
    ;
    throw new Error("Failed pattern match at JSON.Path (line 41, column 10 - line 44, column 56): " + [p.constructor.name]);
  };
  return "$" + go(path14);
};
var findCommonPrefix = function(v) {
  return function(v1) {
    if (v instanceof AtKey && (v1 instanceof AtKey && v.value0 === v1.value0)) {
      return new AtKey(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    if (v instanceof AtIndex && (v1 instanceof AtIndex && v.value0 === v1.value0)) {
      return new AtIndex(v.value0, findCommonPrefix(v.value1)(v1.value1));
    }
    ;
    return Tip.value;
  };
};
var extend2 = function(p1) {
  return function(p2) {
    if (p1 instanceof Tip) {
      return p2;
    }
    ;
    if (p1 instanceof AtKey) {
      return new AtKey(p1.value0, extend2(p1.value1)(p2));
    }
    ;
    if (p1 instanceof AtIndex) {
      return new AtIndex(p1.value0, extend2(p1.value1)(p2));
    }
    ;
    throw new Error("Failed pattern match at JSON.Path (line 50, column 16 - line 53, column 49): " + [p1.constructor.name]);
  };
};

// output/Codec.JSON.DecodeError/index.js
var showRecord2 = /* @__PURE__ */ showRecord()();
var showRecordFieldsCons2 = /* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "causes";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "path";
  }
})(showPath))(showString));
var append1 = /* @__PURE__ */ append(semigroupArray);
var eq13 = /* @__PURE__ */ eq(eqPath);
var over2 = /* @__PURE__ */ over()();
var map11 = /* @__PURE__ */ map(functorArray);
var DecodeError = function(x) {
  return x;
};
var showDecodeError = {
  show: function(v) {
    return "(DecodeError " + (show(showRecord2(showRecordFieldsCons2(showArray(showDecodeError))))(v) + ")");
  }
};
var semigroupDecodeError = {
  append: function(v) {
    return function(v1) {
      return {
        path: findCommonPrefix(v.path)(v1.path),
        message: "Failed to decode alternatives",
        causes: append1(function() {
          var $50 = v.message === "Failed to decode alternatives";
          if ($50) {
            return v.causes;
          }
          ;
          return [v];
        }())(function() {
          var $51 = v1.message === "Failed to decode alternatives";
          if ($51) {
            return v1.causes;
          }
          ;
          return [v1];
        }())
      };
    };
  }
};
var withPath = function(f) {
  return over2(DecodeError)(function(err) {
    return {
      message: err.message,
      path: f(err.path),
      causes: map11(withPath(f))(err.causes)
    };
  });
};
var withContext = function(message3) {
  return over2(DecodeError)(function(err) {
    return {
      path: err.path,
      message: message3,
      causes: [err]
    };
  });
};
var print3 = function(v) {
  var pathPart = function() {
    var $61 = eq13(v.path)(Tip.value);
    if ($61) {
      return "";
    }
    ;
    return print2(v.path) + ": ";
  }();
  var causes = map11(function(e) {
    return replaceAll("\n")(function() {
      var $62 = length(v.causes) === 1;
      if ($62) {
        return "\n  ";
      }
      ;
      return "\n    ";
    }())(print3(withPath(function(p) {
      return fromMaybe(p)(stripPrefix(v.path)(p));
    })(e)));
  })(v.causes);
  var details = function() {
    var v1 = length(v.causes);
    if (v1 === 0) {
      return "";
    }
    ;
    if (v1 === 1) {
      return ":\n  " + joinWith("\n  ")(causes);
    }
    ;
    return ":\n  - " + joinWith("\n  - ")(causes);
  }();
  return pathPart + (v.message + details);
};
var error2 = function(path14) {
  return function(message3) {
    return {
      path: path14,
      message: message3,
      causes: []
    };
  };
};
var noValueFound = function(path14) {
  return error2(path14)("No value found");
};
var basic = /* @__PURE__ */ function() {
  return error2(Tip.value);
}();

// output/Control.Monad.Except/index.js
var unwrap4 = /* @__PURE__ */ unwrap();
var withExcept = /* @__PURE__ */ withExceptT(functorIdentity);
var runExcept = function($3) {
  return unwrap4(runExceptT($3));
};

// output/Data.List.Types/index.js
var Nil = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var NonEmptyList = function(x) {
  return x;
};
var toList = function(v) {
  return new Cons(v.value0, v.value1);
};
var nelCons = function(a) {
  return function(v) {
    return new NonEmpty(a, new Cons(v.value0, v.value1));
  };
};
var listMap = function(f) {
  var chunkedRevMap = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {
          $tco_var_v = new Cons(v1, v);
          $copy_v1 = v1.value1.value1.value1;
          return;
        }
        ;
        var unrolledMap = function(v2) {
          if (v2 instanceof Cons && (v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil)) {
            return new Cons(f(v2.value0), new Cons(f(v2.value1.value0), Nil.value));
          }
          ;
          if (v2 instanceof Cons && v2.value1 instanceof Nil) {
            return new Cons(f(v2.value0), Nil.value);
          }
          ;
          return Nil.value;
        };
        var reverseUnrolledMap = function($copy_v2) {
          return function($copy_v3) {
            var $tco_var_v2 = $copy_v2;
            var $tco_done1 = false;
            var $tco_result2;
            function $tco_loop2(v2, v3) {
              if (v2 instanceof Cons && (v2.value0 instanceof Cons && (v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons))) {
                $tco_var_v2 = v2.value1;
                $copy_v3 = new Cons(f(v2.value0.value0), new Cons(f(v2.value0.value1.value0), new Cons(f(v2.value0.value1.value1.value0), v3)));
                return;
              }
              ;
              $tco_done1 = true;
              return v3;
            }
            ;
            while (!$tco_done1) {
              $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);
            }
            ;
            return $tco_result2;
          };
        };
        $tco_done = true;
        return reverseUnrolledMap(v)(unrolledMap(v1));
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return chunkedRevMap(Nil.value);
};
var functorList = {
  map: listMap
};
var map13 = /* @__PURE__ */ map(functorList);
var functorNonEmptyList = /* @__PURE__ */ functorNonEmpty(functorList);
var foldableList = {
  foldr: function(f) {
    return function(b) {
      var rev = function() {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 instanceof Nil) {
                $tco_done = true;
                return v;
              }
              ;
              if (v1 instanceof Cons) {
                $tco_var_v = new Cons(v1.value0, v);
                $copy_v1 = v1.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(Nil.value);
      }();
      var $284 = foldl(foldableList)(flip(f))(b);
      return function($285) {
        return $284(rev($285));
      };
    };
  },
  foldl: function(f) {
    var go = function($copy_b) {
      return function($copy_v) {
        var $tco_var_b = $copy_b;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(b, v) {
          if (v instanceof Nil) {
            $tco_done1 = true;
            return b;
          }
          ;
          if (v instanceof Cons) {
            $tco_var_b = f(b)(v.value0);
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_b, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append214 = append(dictMonoid.Semigroup0());
    var mempty33 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList)(function(acc) {
        var $286 = append214(acc);
        return function($287) {
          return $286(f($287));
        };
      })(mempty33);
    };
  }
};
var foldl3 = /* @__PURE__ */ foldl(foldableList);
var foldr3 = /* @__PURE__ */ foldr(foldableList);
var intercalate4 = /* @__PURE__ */ intercalate(foldableList)(monoidString);
var foldableNonEmptyList = /* @__PURE__ */ foldableNonEmpty(foldableList);
var semigroupList = {
  append: function(xs) {
    return function(ys) {
      return foldr3(Cons.create)(ys)(xs);
    };
  }
};
var append12 = /* @__PURE__ */ append(semigroupList);
var monoidList = /* @__PURE__ */ function() {
  return {
    mempty: Nil.value,
    Semigroup0: function() {
      return semigroupList;
    }
  };
}();
var semigroupNonEmptyList = {
  append: function(v) {
    return function(as$prime) {
      return new NonEmpty(v.value0, append12(v.value1)(toList(as$prime)));
    };
  }
};
var showList = function(dictShow) {
  var show57 = show(dictShow);
  return {
    show: function(v) {
      if (v instanceof Nil) {
        return "Nil";
      }
      ;
      return "(" + (intercalate4(" : ")(map13(show57)(v)) + " : Nil)");
    }
  };
};
var unfoldable1List = {
  unfoldr1: function(f) {
    return function(b) {
      var go = function($copy_source) {
        return function($copy_memo) {
          var $tco_var_source = $copy_source;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(source2, memo) {
            var v = f(source2);
            if (v.value1 instanceof Just) {
              $tco_var_source = v.value1.value0;
              $copy_memo = new Cons(v.value0, memo);
              return;
            }
            ;
            if (v.value1 instanceof Nothing) {
              $tco_done = true;
              return foldl3(flip(Cons.create))(Nil.value)(new Cons(v.value0, memo));
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 135, column 22 - line 137, column 61): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_source, $copy_memo);
          }
          ;
          return $tco_result;
        };
      };
      return go(b)(Nil.value);
    };
  }
};
var unfoldableList = {
  unfoldr: function(f) {
    return function(b) {
      var go = function($copy_source) {
        return function($copy_memo) {
          var $tco_var_source = $copy_source;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(source2, memo) {
            var v = f(source2);
            if (v instanceof Nothing) {
              $tco_done = true;
              return foldl3(flip(Cons.create))(Nil.value)(memo);
            }
            ;
            if (v instanceof Just) {
              $tco_var_source = v.value0.value1;
              $copy_memo = new Cons(v.value0.value0, memo);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 142, column 22 - line 144, column 52): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_source, $copy_memo);
          }
          ;
          return $tco_result;
        };
      };
      return go(b)(Nil.value);
    };
  },
  Unfoldable10: function() {
    return unfoldable1List;
  }
};
var unfoldable1NonEmptyList = /* @__PURE__ */ unfoldable1NonEmpty(unfoldableList);
var foldable1NonEmptyList = /* @__PURE__ */ foldable1NonEmpty(foldableList);
var eq1List = {
  eq1: function(dictEq) {
    var eq46 = eq(dictEq);
    return function(xs) {
      return function(ys) {
        var go = function($copy_v) {
          return function($copy_v1) {
            return function($copy_v2) {
              var $tco_var_v = $copy_v;
              var $tco_var_v1 = $copy_v1;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v, v1, v2) {
                if (!v2) {
                  $tco_done = true;
                  return false;
                }
                ;
                if (v instanceof Nil && v1 instanceof Nil) {
                  $tco_done = true;
                  return v2;
                }
                ;
                if (v instanceof Cons && v1 instanceof Cons) {
                  $tco_var_v = v.value1;
                  $tco_var_v1 = v1.value1;
                  $copy_v2 = v2 && eq46(v1.value0)(v.value0);
                  return;
                }
                ;
                $tco_done = true;
                return false;
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
              }
              ;
              return $tco_result;
            };
          };
        };
        return go(xs)(ys)(true);
      };
    };
  }
};
var eq14 = /* @__PURE__ */ eq1(eq1List);
var eqList = function(dictEq) {
  return {
    eq: eq14(dictEq)
  };
};
var ord1List = {
  compare1: function(dictOrd) {
    var compare21 = compare(dictOrd);
    return function(xs) {
      return function(ys) {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v instanceof Nil && v1 instanceof Nil) {
                $tco_done = true;
                return EQ.value;
              }
              ;
              if (v instanceof Nil) {
                $tco_done = true;
                return LT.value;
              }
              ;
              if (v1 instanceof Nil) {
                $tco_done = true;
                return GT.value;
              }
              ;
              if (v instanceof Cons && v1 instanceof Cons) {
                var v2 = compare21(v.value0)(v1.value0);
                if (v2 instanceof EQ) {
                  $tco_var_v = v.value1;
                  $copy_v1 = v1.value1;
                  return;
                }
                ;
                $tco_done = true;
                return v2;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 60, column 5 - line 60, column 20): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(xs)(ys);
      };
    };
  },
  Eq10: function() {
    return eq1List;
  }
};
var compare12 = /* @__PURE__ */ compare1(ord1List);
var ordList = function(dictOrd) {
  var eqList1 = eqList(dictOrd.Eq0());
  return {
    compare: compare12(dictOrd),
    Eq0: function() {
      return eqList1;
    }
  };
};
var applyList = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Nil) {
        return Nil.value;
      }
      ;
      if (v instanceof Cons) {
        return append12(map13(v.value0)(v1))(apply2(applyList)(v.value1)(v1));
      }
      ;
      throw new Error("Failed pattern match at Data.List.Types (line 157, column 1 - line 159, column 48): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorList;
  }
};
var apply4 = /* @__PURE__ */ apply2(applyList);
var applyNonEmptyList = {
  apply: function(v) {
    return function(v1) {
      return new NonEmpty(v.value0(v1.value0), append12(apply4(v.value1)(new Cons(v1.value0, Nil.value)))(apply4(new Cons(v.value0, v.value1))(v1.value1)));
    };
  },
  Functor0: function() {
    return functorNonEmptyList;
  }
};
var bindList = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Nil) {
        return Nil.value;
      }
      ;
      if (v instanceof Cons) {
        return append12(v1(v.value0))(bind(bindList)(v.value1)(v1));
      }
      ;
      throw new Error("Failed pattern match at Data.List.Types (line 164, column 1 - line 166, column 37): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyList;
  }
};
var applicativeList = {
  pure: function(a) {
    return new Cons(a, Nil.value);
  },
  Apply0: function() {
    return applyList;
  }
};
var altList = {
  alt: append12,
  Functor0: function() {
    return functorList;
  }
};
var plusList = /* @__PURE__ */ function() {
  return {
    empty: Nil.value,
    Alt0: function() {
      return altList;
    }
  };
}();
var applicativeNonEmptyList = {
  pure: /* @__PURE__ */ function() {
    var $315 = singleton3(plusList);
    return function($316) {
      return NonEmptyList($315($316));
    };
  }(),
  Apply0: function() {
    return applyNonEmptyList;
  }
};

// output/Data.String.CodePoints/foreign.js
var hasArrayFrom = typeof Array.from === "function";
var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
var hasCodePointAt = typeof String.prototype.codePointAt === "function";
var _unsafeCodePointAt0 = function(fallback) {
  return hasCodePointAt ? function(str2) {
    return str2.codePointAt(0);
  } : fallback;
};
var _codePointAt = function(fallback) {
  return function(Just2) {
    return function(Nothing2) {
      return function(unsafeCodePointAt02) {
        return function(index5) {
          return function(str2) {
            var length9 = str2.length;
            if (index5 < 0 || index5 >= length9)
              return Nothing2;
            if (hasStringIterator) {
              var iter = str2[Symbol.iterator]();
              for (var i = index5; ; --i) {
                var o = iter.next();
                if (o.done)
                  return Nothing2;
                if (i === 0)
                  return Just2(unsafeCodePointAt02(o.value));
              }
            }
            return fallback(index5)(str2);
          };
        };
      };
    };
  };
};
var _countPrefix = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasStringIterator) {
      return function(pred2) {
        return function(str2) {
          var iter = str2[Symbol.iterator]();
          for (var cpCount = 0; ; ++cpCount) {
            var o = iter.next();
            if (o.done)
              return cpCount;
            var cp = unsafeCodePointAt02(o.value);
            if (!pred2(cp))
              return cpCount;
          }
        };
      };
    }
    return fallback;
  };
};
var _fromCodePointArray = function(singleton16) {
  return hasFromCodePoint ? function(cps) {
    if (cps.length < 1e4) {
      return String.fromCodePoint.apply(String, cps);
    }
    return cps.map(singleton16).join("");
  } : function(cps) {
    return cps.map(singleton16).join("");
  };
};
var _singleton = function(fallback) {
  return hasFromCodePoint ? String.fromCodePoint : fallback;
};
var _take = function(fallback) {
  return function(n) {
    if (hasStringIterator) {
      return function(str2) {
        var accum = "";
        var iter = str2[Symbol.iterator]();
        for (var i = 0; i < n; ++i) {
          var o = iter.next();
          if (o.done)
            return accum;
          accum += o.value;
        }
        return accum;
      };
    }
    return fallback(n);
  };
};
var _toCodePointArray = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasArrayFrom) {
      return function(str2) {
        return Array.from(str2, unsafeCodePointAt02);
      };
    }
    return fallback;
  };
};

// output/Data.Enum/foreign.js
function toCharCode(c) {
  return c.charCodeAt(0);
}
function fromCharCode(c) {
  return String.fromCharCode(c);
}

// output/Data.Enum/index.js
var bind3 = /* @__PURE__ */ bind(bindMaybe);
var voidLeft2 = /* @__PURE__ */ voidLeft(functorMaybe);
var guard3 = /* @__PURE__ */ guard(alternativeMaybe);
var bottom1 = /* @__PURE__ */ bottom(boundedChar);
var top1 = /* @__PURE__ */ top(boundedChar);
var toEnum = function(dict) {
  return dict.toEnum;
};
var succ = function(dict) {
  return dict.succ;
};
var pred = function(dict) {
  return dict.pred;
};
var fromEnum = function(dict) {
  return dict.fromEnum;
};
var toEnumWithDefaults = function(dictBoundedEnum) {
  var toEnum13 = toEnum(dictBoundedEnum);
  var fromEnum16 = fromEnum(dictBoundedEnum);
  var bottom22 = bottom(dictBoundedEnum.Bounded0());
  return function(low) {
    return function(high) {
      return function(x) {
        var v = toEnum13(x);
        if (v instanceof Just) {
          return v.value0;
        }
        ;
        if (v instanceof Nothing) {
          var $140 = x < fromEnum16(bottom22);
          if ($140) {
            return low;
          }
          ;
          return high;
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v.constructor.name]);
      };
    };
  };
};
var enumFromTo = function(dictEnum) {
  var Ord0 = dictEnum.Ord0();
  var eq116 = eq(Ord0.Eq0());
  var lessThan12 = lessThan(Ord0);
  var succ1 = succ(dictEnum);
  var lessThanOrEq1 = lessThanOrEq(Ord0);
  var pred1 = pred(dictEnum);
  var greaterThanOrEq12 = greaterThanOrEq(Ord0);
  return function(dictUnfoldable1) {
    var singleton16 = singleton(dictUnfoldable1);
    var unfoldr12 = unfoldr1(dictUnfoldable1);
    var go = function(step3) {
      return function(op) {
        return function(to2) {
          return function(a) {
            return new Tuple(a, bind3(step3(a))(function(a$prime) {
              return voidLeft2(guard3(op(a$prime)(to2)))(a$prime);
            }));
          };
        };
      };
    };
    return function(v) {
      return function(v1) {
        if (eq116(v)(v1)) {
          return singleton16(v);
        }
        ;
        if (lessThan12(v)(v1)) {
          return unfoldr12(go(succ1)(lessThanOrEq1)(v1))(v);
        }
        ;
        if (otherwise) {
          return unfoldr12(go(pred1)(greaterThanOrEq12)(v1))(v);
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 186, column 14 - line 190, column 51): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  };
};
var defaultSucc = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) + 1 | 0);
    };
  };
};
var defaultPred = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) - 1 | 0);
    };
  };
};
var charToEnum = function(v) {
  if (v >= toCharCode(bottom1) && v <= toCharCode(top1)) {
    return new Just(fromCharCode(v));
  }
  ;
  return Nothing.value;
};
var enumChar = {
  succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
  pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
  Ord0: function() {
    return ordChar;
  }
};
var boundedEnumChar = /* @__PURE__ */ function() {
  return {
    cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
    toEnum: charToEnum,
    fromEnum: toCharCode,
    Bounded0: function() {
      return boundedChar;
    },
    Enum1: function() {
      return enumChar;
    }
  };
}();

// output/Data.String.CodeUnits/foreign.js
var fromCharArray = function(a) {
  return a.join("");
};
var toCharArray = function(s) {
  return s.split("");
};
var singleton6 = function(c) {
  return c;
};
var _charAt = function(just) {
  return function(nothing) {
    return function(i) {
      return function(s) {
        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
      };
    };
  };
};
var length4 = function(s) {
  return s.length;
};
var _indexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.indexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var _indexOfStartingAt = function(just) {
  return function(nothing) {
    return function(x) {
      return function(startAt) {
        return function(s) {
          if (startAt < 0 || startAt > s.length)
            return nothing;
          var i = s.indexOf(x, startAt);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };
};
var take2 = function(n) {
  return function(s) {
    return s.substr(0, n);
  };
};
var drop2 = function(n) {
  return function(s) {
    return s.substring(n);
  };
};
var slice2 = function(b) {
  return function(e) {
    return function(s) {
      return s.slice(b, e);
    };
  };
};
var splitAt2 = function(i) {
  return function(s) {
    return { before: s.substring(0, i), after: s.substring(i) };
  };
};

// output/Data.String.Unsafe/foreign.js
var charAt = function(i) {
  return function(s) {
    if (i >= 0 && i < s.length)
      return s.charAt(i);
    throw new Error("Data.String.Unsafe.charAt: Invalid index.");
  };
};

// output/Data.String.CodeUnits/index.js
var stripSuffix = function(v) {
  return function(str2) {
    var v1 = splitAt2(length4(str2) - length4(v) | 0)(str2);
    var $14 = v1.after === v;
    if ($14) {
      return new Just(v1.before);
    }
    ;
    return Nothing.value;
  };
};
var stripPrefix2 = function(v) {
  return function(str2) {
    var v1 = splitAt2(length4(v))(str2);
    var $20 = v1.before === v;
    if ($20) {
      return new Just(v1.after);
    }
    ;
    return Nothing.value;
  };
};
var indexOf$prime = /* @__PURE__ */ function() {
  return _indexOfStartingAt(Just.create)(Nothing.value);
}();
var indexOf = /* @__PURE__ */ function() {
  return _indexOf(Just.create)(Nothing.value);
}();
var dropRight = function(i) {
  return function(s) {
    return take2(length4(s) - i | 0)(s);
  };
};
var contains = function(pat) {
  var $23 = indexOf(pat);
  return function($24) {
    return isJust($23($24));
  };
};
var charAt2 = /* @__PURE__ */ function() {
  return _charAt(Just.create)(Nothing.value);
}();

// output/Data.String.CodePoints/index.js
var $runtime_lazy3 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var map14 = /* @__PURE__ */ map(functorMaybe);
var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
var div3 = /* @__PURE__ */ div(euclideanRingInt);
var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
var compare2 = /* @__PURE__ */ compare(ordInt);
var CodePoint = function(x) {
  return x;
};
var unsurrogate = function(lead) {
  return function(trail) {
    return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
  };
};
var isTrail = function(cu) {
  return 56320 <= cu && cu <= 57343;
};
var isLead = function(cu) {
  return 55296 <= cu && cu <= 56319;
};
var uncons3 = function(s) {
  var v = length4(s);
  if (v === 0) {
    return Nothing.value;
  }
  ;
  if (v === 1) {
    return new Just({
      head: fromEnum2(charAt(0)(s)),
      tail: ""
    });
  }
  ;
  var cu1 = fromEnum2(charAt(1)(s));
  var cu0 = fromEnum2(charAt(0)(s));
  var $43 = isLead(cu0) && isTrail(cu1);
  if ($43) {
    return new Just({
      head: unsurrogate(cu0)(cu1),
      tail: drop2(2)(s)
    });
  }
  ;
  return new Just({
    head: cu0,
    tail: drop2(1)(s)
  });
};
var unconsButWithTuple = function(s) {
  return map14(function(v) {
    return new Tuple(v.head, v.tail);
  })(uncons3(s));
};
var toCodePointArrayFallback = function(s) {
  return unfoldr2(unconsButWithTuple)(s);
};
var unsafeCodePointAt0Fallback = function(s) {
  var cu0 = fromEnum2(charAt(0)(s));
  var $47 = isLead(cu0) && length4(s) > 1;
  if ($47) {
    var cu1 = fromEnum2(charAt(1)(s));
    var $48 = isTrail(cu1);
    if ($48) {
      return unsurrogate(cu0)(cu1);
    }
    ;
    return cu0;
  }
  ;
  return cu0;
};
var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
var length5 = function($74) {
  return length(toCodePointArray($74));
};
var indexOf2 = function(p) {
  return function(s) {
    return map14(function(i) {
      return length5(take2(i)(s));
    })(indexOf(p)(s));
  };
};
var fromCharCode2 = /* @__PURE__ */ function() {
  var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
  return function($76) {
    return singleton6($75($76));
  };
}();
var singletonFallback = function(v) {
  if (v <= 65535) {
    return fromCharCode2(v);
  }
  ;
  var lead = div3(v - 65536 | 0)(1024) + 55296 | 0;
  var trail = mod3(v - 65536 | 0)(1024) + 56320 | 0;
  return fromCharCode2(lead) + fromCharCode2(trail);
};
var fromCodePointArray = /* @__PURE__ */ _fromCodePointArray(singletonFallback);
var singleton7 = /* @__PURE__ */ _singleton(singletonFallback);
var takeFallback = function(v) {
  return function(v1) {
    if (v < 1) {
      return "";
    }
    ;
    var v2 = uncons3(v1);
    if (v2 instanceof Just) {
      return singleton7(v2.value0.head) + takeFallback(v - 1 | 0)(v2.value0.tail);
    }
    ;
    return v1;
  };
};
var take3 = /* @__PURE__ */ _take(takeFallback);
var splitAt3 = function(i) {
  return function(s) {
    var before = take3(i)(s);
    return {
      before,
      after: drop2(length4(before))(s)
    };
  };
};
var eqCodePoint = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordCodePoint = {
  compare: function(x) {
    return function(y) {
      return compare2(x)(y);
    };
  },
  Eq0: function() {
    return eqCodePoint;
  }
};
var drop3 = function(n) {
  return function(s) {
    return drop2(length4(take3(n)(s)))(s);
  };
};
var countTail = function($copy_p) {
  return function($copy_s) {
    return function($copy_accum) {
      var $tco_var_p = $copy_p;
      var $tco_var_s = $copy_s;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(p, s, accum) {
        var v = uncons3(s);
        if (v instanceof Just) {
          var $61 = p(v.value0.head);
          if ($61) {
            $tco_var_p = p;
            $tco_var_s = v.value0.tail;
            $copy_accum = accum + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return accum;
        }
        ;
        $tco_done = true;
        return accum;
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_p, $tco_var_s, $copy_accum);
      }
      ;
      return $tco_result;
    };
  };
};
var countFallback = function(p) {
  return function(s) {
    return countTail(p)(s)(0);
  };
};
var countPrefix2 = /* @__PURE__ */ _countPrefix(countFallback)(unsafeCodePointAt0);
var takeWhile3 = function(p) {
  return function(s) {
    return take3(countPrefix2(p)(s))(s);
  };
};
var codePointFromChar = function($77) {
  return CodePoint(fromEnum2($77));
};
var codePointAtFallback = function($copy_n) {
  return function($copy_s) {
    var $tco_var_n = $copy_n;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(n, s) {
      var v = uncons3(s);
      if (v instanceof Just) {
        var $66 = n === 0;
        if ($66) {
          $tco_done = true;
          return new Just(v.value0.head);
        }
        ;
        $tco_var_n = n - 1 | 0;
        $copy_s = v.value0.tail;
        return;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_n, $copy_s);
    }
    ;
    return $tco_result;
  };
};
var codePointAt = function(v) {
  return function(v1) {
    if (v < 0) {
      return Nothing.value;
    }
    ;
    if (v === 0 && v1 === "") {
      return Nothing.value;
    }
    ;
    if (v === 0) {
      return new Just(unsafeCodePointAt0(v1));
    }
    ;
    return _codePointAt(codePointAtFallback)(Just.create)(Nothing.value)(unsafeCodePointAt0)(v)(v1);
  };
};
var boundedCodePoint = {
  bottom: 0,
  top: 1114111,
  Ord0: function() {
    return ordCodePoint;
  }
};
var boundedEnumCodePoint = /* @__PURE__ */ function() {
  return {
    cardinality: 1114111 + 1 | 0,
    fromEnum: function(v) {
      return v;
    },
    toEnum: function(n) {
      if (n >= 0 && n <= 1114111) {
        return new Just(n);
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.String.CodePoints (line 63, column 1 - line 68, column 26): " + [n.constructor.name]);
    },
    Bounded0: function() {
      return boundedCodePoint;
    },
    Enum1: function() {
      return $lazy_enumCodePoint(0);
    }
  };
}();
var $lazy_enumCodePoint = /* @__PURE__ */ $runtime_lazy3("enumCodePoint", "Data.String.CodePoints", function() {
  return {
    succ: defaultSucc(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    pred: defaultPred(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    Ord0: function() {
      return ordCodePoint;
    }
  };
});

// output/Data.Codec.JSON/index.js
var applicativeExceptT2 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var pure3 = /* @__PURE__ */ pure(applicativeExceptT2);
var except2 = /* @__PURE__ */ except(applicativeIdentity);
var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindMaybe);
var bindExceptT2 = /* @__PURE__ */ bindExceptT(monadIdentity);
var bindFlipped1 = /* @__PURE__ */ bindFlipped(bindExceptT2);
var fromFoldable5 = /* @__PURE__ */ fromFoldable3(foldableList);
var fromFoldable1 = /* @__PURE__ */ fromFoldable4(foldableList);
var pure1 = /* @__PURE__ */ pure(applicativeList);
var append13 = /* @__PURE__ */ append(semigroupDecodeError);
var bind4 = /* @__PURE__ */ bind(bindExceptT2);
var map15 = /* @__PURE__ */ map(functorEither);
var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeExceptT2);
var map16 = /* @__PURE__ */ map(functorArray);
var record = /* @__PURE__ */ function() {
  return new Codec($$const(pure3({})), pure(applicativeTuple(monoidList)));
}();
var jsonPrimCodec = function(ty) {
  return function(f) {
    return codec$prime(function(j) {
      return except2(function() {
        var v = f(j);
        if (v instanceof Just) {
          return new Right(v.value0);
        }
        ;
        if (v instanceof Nothing) {
          return new Left({
            path: Tip.value,
            message: "Expected value of type " + ty,
            causes: []
          });
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 81, column 12 - line 89, column 10): " + [v.constructor.name]);
      }());
    });
  };
};
var $$null4 = /* @__PURE__ */ jsonPrimCodec("Null")(toNull)(/* @__PURE__ */ $$const($$null3));
var number = /* @__PURE__ */ jsonPrimCodec("Number")(toNumber2)(fromNumber2);
var string = /* @__PURE__ */ jsonPrimCodec("String")(toString2)(fromString);
var json = /* @__PURE__ */ codec$prime(pure3)(/* @__PURE__ */ identity(categoryFn));
var jobject = /* @__PURE__ */ jsonPrimCodec("Object")(toJObject)(fromJObject);
var jarray = /* @__PURE__ */ jsonPrimCodec("Array")(toJArray)(fromJArray);
var $$int = /* @__PURE__ */ jsonPrimCodec("Int")(function(j) {
  return bindFlipped3(fromNumber)(toNumber2(j));
})(function(n) {
  return fromNumber2(toNumber(n));
});
var encode2 = encode;
var indexedArray = function(codec12) {
  return codec$prime(function(j) {
    return bindFlipped1(decode(codec12))(decode(jarray)(j));
  })(function(a) {
    return encode2(jarray)(fromFoldable5(encode2(codec12)(a)));
  });
};
var object = function(codec12) {
  return codec$prime(function(j) {
    return bindFlipped1(decode(codec12))(decode(jobject)(j));
  })(function(a) {
    return encode2(jobject)(fromFoldable1(encode2(codec12)(a)));
  });
};
var decode2 = function(codec12) {
  return function(j) {
    return runExcept(decode(codec12)(j));
  };
};
var index3 = function(ix) {
  return function(codec12) {
    return codec(function(xs) {
      return except2(function() {
        var v = index2(ix)(xs);
        if (v instanceof Just) {
          var v1 = decode2(codec12)(v.value0);
          if (v1 instanceof Left) {
            return new Left(withPath(AtIndex.create(ix))(v1.value0));
          }
          ;
          return v1;
        }
        ;
        if (v instanceof Nothing) {
          return new Left(noValueFound(new AtIndex(ix, Tip.value)));
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 194, column 16 - line 200, column 61): " + [v.constructor.name]);
      }());
    })(function(a) {
      return pure1(encode2(codec12)(a));
    });
  };
};
var named = function(name5) {
  return function(codec12) {
    return codec$prime(function(j) {
      return except2(function() {
        var v = decode2(codec12)(j);
        if (v instanceof Left) {
          return new Left(withContext("Could not decode " + name5)(v.value0));
        }
        ;
        return v;
      }());
    })(encode2(codec12));
  };
};
var nullable = function(codec12) {
  return codec$prime(function(j) {
    return except2(function() {
      var v = decode2(codec12)(j);
      if (v instanceof Left) {
        var v1 = decode2($$null4)(j);
        if (v1 instanceof Left) {
          return new Left(append13(v.value0)(v1.value0));
        }
        ;
        if (v1 instanceof Right) {
          return new Right(Nothing.value);
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 341, column 11 - line 343, column 36): " + [v1.constructor.name]);
      }
      ;
      if (v instanceof Right) {
        return new Right(new Just(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.Codec.JSON (line 339, column 19 - line 345, column 29): " + [v.constructor.name]);
    }());
  })(function(v) {
    if (v instanceof Just) {
      return encode2(codec12)(v.value0);
    }
    ;
    if (v instanceof Nothing) {
      return $$null3;
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.JSON (line 347, column 5 - line 349, column 23): " + [v.constructor.name]);
  });
};
var prismaticCodec = function(name5) {
  return function(f) {
    return function(g) {
      return function(codec12) {
        return codec$prime(function(j) {
          return except2(function() {
            var v = decode2(codec12)(j);
            if (v instanceof Left) {
              return new Left(withContext("Could not decode " + name5)(v.value0));
            }
            ;
            if (v instanceof Right) {
              var v1 = f(v.value0);
              if (v1 instanceof Just) {
                return new Right(v1.value0);
              }
              ;
              if (v1 instanceof Nothing) {
                return new Left(basic("Could not decode " + (name5 + ", unexpected value found")));
              }
              ;
              throw new Error("Failed pattern match at Data.Codec.JSON (line 424, column 13 - line 428, column 95): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Data.Codec.JSON (line 420, column 18 - line 428, column 95): " + [v.constructor.name]);
          }());
        })(function(b) {
          return encode2(codec12)(g(b));
        });
      };
    };
  };
};
var prop = function(key) {
  return function(codec12) {
    return codec(function(obj) {
      return except2(function() {
        var v = lookup2(key)(obj);
        if (v instanceof Just) {
          var v1 = decode2(codec12)(v.value0);
          if (v1 instanceof Left) {
            return new Left(withPath(AtKey.create(key))(v1.value0));
          }
          ;
          return v1;
        }
        ;
        if (v instanceof Nothing) {
          return new Left(noValueFound(new AtKey(key, Tip.value)));
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON (line 228, column 16 - line 234, column 60): " + [v.constructor.name]);
      }());
    })(function(a) {
      return pure1(new Tuple(key, encode2(codec12)(a)));
    });
  };
};
var recordProp = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(p) {
      return function(codecA) {
        return function(codecR) {
          var enc$prime = function(key2) {
            return function(val) {
              return new Cons(new Tuple(key2, encode(codecA)(unsafeGet(key2)(val))), encode(codecR)(val));
            };
          };
          var dec$prime = function(key2) {
            return function(obj) {
              return bind4(decode(codecR)(obj))(function(r) {
                return bind4(except2(function() {
                  var v = lookup2(key2)(obj);
                  if (v instanceof Just) {
                    var v1 = decode2(codecA)(v.value0);
                    if (v1 instanceof Left) {
                      return new Left(withPath(AtKey.create(key2))(v1.value0));
                    }
                    ;
                    return v1;
                  }
                  ;
                  if (v instanceof Nothing) {
                    return new Left(noValueFound(new AtKey(key2, Tip.value)));
                  }
                  ;
                  throw new Error("Failed pattern match at Data.Codec.JSON (line 278, column 16 - line 284, column 56): " + [v.constructor.name]);
                }()))(function(a) {
                  return pure3(unsafeSet(key2)(a)(r));
                });
              });
            };
          };
          var key = reflectSymbol2(p);
          return codec(dec$prime(key))(enc$prime(key));
        };
      };
    };
  };
};
var recordPropOptional = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(p) {
      return function(codecA) {
        return function(codecR) {
          var key = reflectSymbol2(p);
          var enc$prime = function(val) {
            var w = encode(codecR)(val);
            var v = unsafeGet(key)(val);
            if (v instanceof Just) {
              return new Cons(new Tuple(key, encode(codecA)(v.value0)), w);
            }
            ;
            if (v instanceof Nothing) {
              return w;
            }
            ;
            throw new Error("Failed pattern match at Data.Codec.JSON (line 327, column 5 - line 329, column 18): " + [v.constructor.name]);
          };
          var dec$prime = function(obj) {
            return bind4(decode(codecR)(obj))(function(r) {
              return bind4(except2(function() {
                var v = lookup2(key)(obj);
                if (v instanceof Just) {
                  var v1 = decode2(codecA)(v.value0);
                  if (v1 instanceof Left) {
                    return new Left(withPath(AtKey.create(key))(v1.value0));
                  }
                  ;
                  return map15(Just.create)(v1);
                }
                ;
                return new Right(Nothing.value);
              }()))(function(a) {
                return pure3(unsafeSet(key)(a)(r));
              });
            });
          };
          return codec(dec$prime)(enc$prime);
        };
      };
    };
  };
};
var $$boolean = /* @__PURE__ */ jsonPrimCodec("Boolean")(toBoolean)(fromBoolean);
var array = function(codec12) {
  return codec$prime(function(j) {
    return bind4(decode(jarray)(j))(function(arr) {
      return traverseWithIndex2(function(ix) {
        return function(a) {
          return except2(function() {
            var v = decode2(codec12)(a);
            if (v instanceof Left) {
              return new Left(withPath(AtIndex.create(ix))(v.value0));
            }
            ;
            return v;
          }());
        };
      })(toArray2(arr));
    });
  })(function(a) {
    return fromArray3(map16(encode2(codec12))(a));
  });
};

// output/Data.Codec.JSON.Sum/index.js
var map17 = /* @__PURE__ */ map(functorMaybe);
var except3 = /* @__PURE__ */ except(applicativeIdentity);
var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);
var bind5 = /* @__PURE__ */ bind(bindEither);
var pure4 = /* @__PURE__ */ pure(applicativeEither);
var taggedSum = function(name5) {
  return function(printTag) {
    return function(parseTag) {
      return function(f) {
        return function(g) {
          var encodeCase = function(a) {
            var v = g(a);
            return encode(jobject)(fromEntries(catMaybes([new Just(new Tuple("tag", encode(string)(printTag(v.value0)))), map17(Tuple.create("value"))(v.value1)])));
          };
          var decodeCase = function(j) {
            return except3(lmap2(withContext("Could not decode " + name5))(bind5(decode2(jobject)(j))(function(obj) {
              return bind5(decode2(prop("tag")(string))(obj))(function(tag) {
                var v = parseTag(tag);
                if (v instanceof Nothing) {
                  return new Left(error2(new AtKey("tag", Tip.value))("Unexpected value '" + (tag + "' found")));
                }
                ;
                if (v instanceof Just) {
                  var v1 = f(v.value0);
                  if (v1 instanceof Left) {
                    return pure4(v1.value0);
                  }
                  ;
                  if (v1 instanceof Right) {
                    return bind5(decode2(prop("value")(json))(obj))(function(value4) {
                      return lmap2(withPath(AtKey.create("value")))(v1.value0(value4));
                    });
                  }
                  ;
                  throw new Error("Failed pattern match at Data.Codec.JSON.Sum (line 49, column 11 - line 53, column 71): " + [v1.constructor.name]);
                }
                ;
                throw new Error("Failed pattern match at Data.Codec.JSON.Sum (line 45, column 7 - line 53, column 71): " + [v.constructor.name]);
              });
            })));
          };
          return codec(decodeCase)(encodeCase);
        };
      };
    };
  };
};
var enumSum = function(printTag) {
  return function(parseTag) {
    var encode6 = function() {
      var $21 = encode(string);
      return function($22) {
        return $21(printTag($22));
      };
    }();
    var decode4 = function(json4) {
      return except3(bind5(decode2(string)(json4))(function(tag) {
        var v = parseTag(tag);
        if (v instanceof Nothing) {
          return new Left(basic("Unexpected value '" + (tag + "' found")));
        }
        ;
        if (v instanceof Just) {
          return pure4(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Codec.JSON.Sum (line 72, column 5 - line 74, column 22): " + [v.constructor.name]);
      }));
    };
    return codec$prime(decode4)(encode6);
  };
};

// output/Data.List/index.js
var map18 = /* @__PURE__ */ map(functorMaybe);
var eq3 = /* @__PURE__ */ eq(eqOrdering);
var notEq4 = /* @__PURE__ */ notEq(eqOrdering);
var bimap2 = /* @__PURE__ */ bimap(bifunctorStep);
var foldl4 = /* @__PURE__ */ foldl(foldableList);
var bind6 = /* @__PURE__ */ bind(bindList);
var identity9 = /* @__PURE__ */ identity(categoryFn);
var uncons4 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just({
      head: v.value0,
      tail: v.value1
    });
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [v.constructor.name]);
};
var toUnfoldable4 = function(dictUnfoldable) {
  return unfoldr(dictUnfoldable)(function(xs) {
    return map18(function(rec) {
      return new Tuple(rec.head, rec.tail);
    })(uncons4(xs));
  });
};
var span2 = function(v) {
  return function(v1) {
    if (v1 instanceof Cons && v(v1.value0)) {
      var v2 = span2(v)(v1.value1);
      return {
        init: new Cons(v1.value0, v2.init),
        rest: v2.rest
      };
    }
    ;
    return {
      init: Nil.value,
      rest: v1
    };
  };
};
var singleton8 = function(a) {
  return new Cons(a, Nil.value);
};
var sortBy2 = function(cmp) {
  var merge4 = function(v) {
    return function(v1) {
      if (v instanceof Cons && v1 instanceof Cons) {
        if (eq3(cmp(v.value0)(v1.value0))(GT.value)) {
          return new Cons(v1.value0, merge4(v)(v1.value1));
        }
        ;
        if (otherwise) {
          return new Cons(v.value0, merge4(v.value1)(v1));
        }
        ;
      }
      ;
      if (v instanceof Nil) {
        return v1;
      }
      ;
      if (v1 instanceof Nil) {
        return v;
      }
      ;
      throw new Error("Failed pattern match at Data.List (line 466, column 3 - line 466, column 38): " + [v.constructor.name, v1.constructor.name]);
    };
  };
  var mergePairs = function(v) {
    if (v instanceof Cons && v.value1 instanceof Cons) {
      return new Cons(merge4(v.value0)(v.value1.value0), mergePairs(v.value1.value1));
    }
    ;
    return v;
  };
  var mergeAll = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Cons && v.value1 instanceof Nil) {
        $tco_done = true;
        return v.value0;
      }
      ;
      $copy_v = mergePairs(v);
      return;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  var sequences = function(v) {
    if (v instanceof Cons && v.value1 instanceof Cons) {
      if (eq3(cmp(v.value0)(v.value1.value0))(GT.value)) {
        return descending(v.value1.value0)(singleton8(v.value0))(v.value1.value1);
      }
      ;
      if (otherwise) {
        return ascending(v.value1.value0)(function(v1) {
          return new Cons(v.value0, v1);
        })(v.value1.value1);
      }
      ;
    }
    ;
    return singleton8(v);
  };
  var descending = function($copy_v) {
    return function($copy_v1) {
      return function($copy_v2) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(v, v1, v2) {
          if (v2 instanceof Cons && eq3(cmp(v)(v2.value0))(GT.value)) {
            $tco_var_v = v2.value0;
            $tco_var_v1 = new Cons(v, v1);
            $copy_v2 = v2.value1;
            return;
          }
          ;
          $tco_done1 = true;
          return new Cons(new Cons(v, v1), sequences(v2));
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
        }
        ;
        return $tco_result;
      };
    };
  };
  var ascending = function($copy_v) {
    return function($copy_v1) {
      return function($copy_v2) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_done2 = false;
        var $tco_result;
        function $tco_loop(v, v1, v2) {
          if (v2 instanceof Cons && notEq4(cmp(v)(v2.value0))(GT.value)) {
            $tco_var_v = v2.value0;
            $tco_var_v1 = function(ys) {
              return v1(new Cons(v, ys));
            };
            $copy_v2 = v2.value1;
            return;
          }
          ;
          $tco_done2 = true;
          return new Cons(v1(singleton8(v)), sequences(v2));
        }
        ;
        while (!$tco_done2) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
        }
        ;
        return $tco_result;
      };
    };
  };
  return function($444) {
    return mergeAll(sequences($444));
  };
};
var reverse2 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
}();
var take4 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      return function($copy_v2) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1, v2) {
          if (v1 < 1) {
            $tco_done = true;
            return reverse2(v);
          }
          ;
          if (v2 instanceof Nil) {
            $tco_done = true;
            return reverse2(v);
          }
          ;
          if (v2 instanceof Cons) {
            $tco_var_v = new Cons(v2.value0, v);
            $tco_var_v1 = v1 - 1 | 0;
            $copy_v2 = v2.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List (line 513, column 3 - line 513, column 35): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
        }
        ;
        return $tco_result;
      };
    };
  };
  return go(Nil.value);
}();
var takeWhile4 = function(p) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Cons && p(v1.value0)) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        $tco_done = true;
        return reverse2(v);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var $$null5 = function(v) {
  if (v instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var manyRec = function(dictMonadRec) {
  var bind128 = bind(dictMonadRec.Monad0().Bind1());
  var tailRecM8 = tailRecM(dictMonadRec);
  return function(dictAlternative) {
    var Alt0 = dictAlternative.Plus1().Alt0();
    var alt40 = alt(Alt0);
    var map154 = map(Alt0.Functor0());
    var pure98 = pure(dictAlternative.Applicative0());
    return function(p) {
      var go = function(acc) {
        return bind128(alt40(map154(Loop.create)(p))(pure98(new Done(unit))))(function(aa) {
          return pure98(bimap2(function(v) {
            return new Cons(v, acc);
          })(function(v) {
            return reverse2(acc);
          })(aa));
        });
      };
      return tailRecM8(go)(Nil.value);
    };
  };
};
var some2 = function(dictAlternative) {
  var apply30 = apply2(dictAlternative.Applicative0().Apply0());
  var map154 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return apply30(map154(Cons.create)(v))(defer6(function(v1) {
        return many2(dictAlternative)(dictLazy)(v);
      }));
    };
  };
};
var many2 = function(dictAlternative) {
  var alt40 = alt(dictAlternative.Plus1().Alt0());
  var pure98 = pure(dictAlternative.Applicative0());
  return function(dictLazy) {
    return function(v) {
      return alt40(some2(dictAlternative)(dictLazy)(v))(pure98(Nil.value));
    };
  };
};
var length6 = /* @__PURE__ */ foldl4(function(acc) {
  return function(v) {
    return acc + 1 | 0;
  };
})(0);
var head3 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 230, column 1 - line 230, column 22): " + [v.constructor.name]);
};
var fromFoldable6 = function(dictFoldable) {
  return foldr(dictFoldable)(Cons.create)(Nil.value);
};
var filter3 = function(p) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return reverse2(v);
        }
        ;
        if (v1 instanceof Cons) {
          if (p(v1.value0)) {
            $tco_var_v = new Cons(v1.value0, v);
            $copy_v1 = v1.value1;
            return;
          }
          ;
          if (otherwise) {
            $tco_var_v = v;
            $copy_v1 = v1.value1;
            return;
          }
          ;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 390, column 3 - line 390, column 27): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var nubByEq2 = function(v) {
  return function(v1) {
    if (v1 instanceof Nil) {
      return Nil.value;
    }
    ;
    if (v1 instanceof Cons) {
      return new Cons(v1.value0, nubByEq2(v)(filter3(function(y) {
        return !v(v1.value0)(y);
      })(v1.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.List (line 705, column 1 - line 705, column 61): " + [v.constructor.name, v1.constructor.name]);
  };
};
var drop4 = function($copy_v) {
  return function($copy_v1) {
    var $tco_var_v = $copy_v;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v, v1) {
      if (v < 1) {
        $tco_done = true;
        return v1;
      }
      ;
      if (v1 instanceof Nil) {
        $tco_done = true;
        return Nil.value;
      }
      ;
      if (v1 instanceof Cons) {
        $tco_var_v = v - 1 | 0;
        $copy_v1 = v1.value1;
        return;
      }
      ;
      throw new Error("Failed pattern match at Data.List (line 536, column 1 - line 536, column 42): " + [v.constructor.name, v1.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_v, $copy_v1);
    }
    ;
    return $tco_result;
  };
};
var concat2 = function(v) {
  return bind6(v)(identity9);
};

// output/Partial.Unsafe/foreign.js
var _unsafePartial = function(f) {
  return f();
};

// output/Partial/foreign.js
var _crashWith = function(msg) {
  throw new Error(msg);
};

// output/Partial/index.js
var crashWith = function() {
  return _crashWith;
};

// output/Partial.Unsafe/index.js
var crashWith2 = /* @__PURE__ */ crashWith();
var unsafePartial = _unsafePartial;
var unsafeCrashWith = function(msg) {
  return unsafePartial(function() {
    return crashWith2(msg);
  });
};

// output/Data.List.NonEmpty/index.js
var wrappedOperation = function(name5) {
  return function(f) {
    return function(v) {
      var v1 = f(new Cons(v.value0, v.value1));
      if (v1 instanceof Cons) {
        return new NonEmpty(v1.value0, v1.value1);
      }
      ;
      if (v1 instanceof Nil) {
        return unsafeCrashWith("Impossible: empty list in NonEmptyList " + name5);
      }
      ;
      throw new Error("Failed pattern match at Data.List.NonEmpty (line 92, column 3 - line 94, column 81): " + [v1.constructor.name]);
    };
  };
};
var toList2 = function(v) {
  return new Cons(v.value0, v.value1);
};
var tail3 = function(v) {
  return v.value1;
};
var singleton9 = /* @__PURE__ */ function() {
  var $200 = singleton3(plusList);
  return function($201) {
    return NonEmptyList($200($201));
  };
}();
var reverse3 = /* @__PURE__ */ wrappedOperation("reverse")(reverse2);
var head4 = function(v) {
  return v.value0;
};
var fromList = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just(new NonEmpty(v.value0, v.value1));
  }
  ;
  throw new Error("Failed pattern match at Data.List.NonEmpty (line 121, column 1 - line 121, column 57): " + [v.constructor.name]);
};
var cons3 = function(y) {
  return function(v) {
    return new NonEmpty(y, new Cons(v.value0, v.value1));
  };
};

// output/Data.Map.Internal/index.js
var $runtime_lazy4 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var identity10 = /* @__PURE__ */ identity(categoryFn);
var Leaf = /* @__PURE__ */ function() {
  function Leaf3() {
  }
  ;
  Leaf3.value = new Leaf3();
  return Leaf3;
}();
var Node = /* @__PURE__ */ function() {
  function Node4(value0, value12, value22, value32, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  Node4.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return new Node4(value0, value12, value22, value32, value4, value5);
            };
          };
        };
      };
    };
  };
  return Node4;
}();
var IterLeaf = /* @__PURE__ */ function() {
  function IterLeaf2() {
  }
  ;
  IterLeaf2.value = new IterLeaf2();
  return IterLeaf2;
}();
var IterEmit = /* @__PURE__ */ function() {
  function IterEmit2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  IterEmit2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new IterEmit2(value0, value12, value22);
      };
    };
  };
  return IterEmit2;
}();
var IterNode = /* @__PURE__ */ function() {
  function IterNode2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  IterNode2.create = function(value0) {
    return function(value12) {
      return new IterNode2(value0, value12);
    };
  };
  return IterNode2;
}();
var IterDone = /* @__PURE__ */ function() {
  function IterDone2() {
  }
  ;
  IterDone2.value = new IterDone2();
  return IterDone2;
}();
var IterNext = /* @__PURE__ */ function() {
  function IterNext2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  IterNext2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new IterNext2(value0, value12, value22);
      };
    };
  };
  return IterNext2;
}();
var Split = /* @__PURE__ */ function() {
  function Split2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Split2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Split2(value0, value12, value22);
      };
    };
  };
  return Split2;
}();
var SplitLast = /* @__PURE__ */ function() {
  function SplitLast2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SplitLast2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SplitLast2(value0, value12, value22);
      };
    };
  };
  return SplitLast2;
}();
var unsafeNode = function(k, v, l, r) {
  if (l instanceof Leaf) {
    if (r instanceof Leaf) {
      return new Node(1, 1, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + r.value0 | 0, 1 + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 702, column 5 - line 706, column 39): " + [r.constructor.name]);
  }
  ;
  if (l instanceof Node) {
    if (r instanceof Leaf) {
      return new Node(1 + l.value0 | 0, 1 + l.value1 | 0, k, v, l, r);
    }
    ;
    if (r instanceof Node) {
      return new Node(1 + function() {
        var $280 = l.value0 > r.value0;
        if ($280) {
          return l.value0;
        }
        ;
        return r.value0;
      }() | 0, (1 + l.value1 | 0) + r.value1 | 0, k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 708, column 5 - line 712, column 68): " + [r.constructor.name]);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 700, column 32 - line 712, column 68): " + [l.constructor.name]);
};
var toMapIter = /* @__PURE__ */ function() {
  return flip(IterNode.create)(IterLeaf.value);
}();
var stepWith = function(f) {
  return function(next2) {
    return function(done) {
      var go = function($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
          if (v instanceof IterLeaf) {
            $tco_done = true;
            return done(unit);
          }
          ;
          if (v instanceof IterEmit) {
            $tco_done = true;
            return next2(v.value0, v.value1, v.value2);
          }
          ;
          if (v instanceof IterNode) {
            $copy_v = f(v.value1)(v.value0);
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 940, column 8 - line 946, column 20): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_v);
        }
        ;
        return $tco_result;
      };
      return go;
    };
  };
};
var size = function(v) {
  if (v instanceof Leaf) {
    return 0;
  }
  ;
  if (v instanceof Node) {
    return v.value1;
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 618, column 8 - line 620, column 24): " + [v.constructor.name]);
};
var singleton10 = function(k) {
  return function(v) {
    return new Node(1, 1, k, v, Leaf.value, Leaf.value);
  };
};
var unsafeBalancedNode = /* @__PURE__ */ function() {
  var height = function(v) {
    if (v instanceof Leaf) {
      return 0;
    }
    ;
    if (v instanceof Node) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 757, column 12 - line 759, column 26): " + [v.constructor.name]);
  };
  var rotateLeft = function(k, v, l, rk, rv, rl, rr) {
    if (rl instanceof Node && rl.value0 > height(rr)) {
      return unsafeNode(rl.value2, rl.value3, unsafeNode(k, v, l, rl.value4), unsafeNode(rk, rv, rl.value5, rr));
    }
    ;
    return unsafeNode(rk, rv, unsafeNode(k, v, l, rl), rr);
  };
  var rotateRight = function(k, v, lk, lv, ll, lr, r) {
    if (lr instanceof Node && height(ll) <= lr.value0) {
      return unsafeNode(lr.value2, lr.value3, unsafeNode(lk, lv, ll, lr.value4), unsafeNode(k, v, lr.value5, r));
    }
    ;
    return unsafeNode(lk, lv, ll, unsafeNode(k, v, lr, r));
  };
  return function(k, v, l, r) {
    if (l instanceof Leaf) {
      if (r instanceof Leaf) {
        return singleton10(k)(v);
      }
      ;
      if (r instanceof Node && r.value0 > 1) {
        return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    if (l instanceof Node) {
      if (r instanceof Node) {
        if (r.value0 > (l.value0 + 1 | 0)) {
          return rotateLeft(k, v, l, r.value2, r.value3, r.value4, r.value5);
        }
        ;
        if (l.value0 > (r.value0 + 1 | 0)) {
          return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
        }
        ;
      }
      ;
      if (r instanceof Leaf && l.value0 > 1) {
        return rotateRight(k, v, l.value2, l.value3, l.value4, l.value5, r);
      }
      ;
      return unsafeNode(k, v, l, r);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 717, column 40 - line 738, column 34): " + [l.constructor.name]);
  };
}();
var $lazy_unsafeSplit = /* @__PURE__ */ $runtime_lazy4("unsafeSplit", "Data.Map.Internal", function() {
  return function(comp, k, m) {
    if (m instanceof Leaf) {
      return new Split(Nothing.value, Leaf.value, Leaf.value);
    }
    ;
    if (m instanceof Node) {
      var v = comp(k)(m.value2);
      if (v instanceof LT) {
        var v1 = $lazy_unsafeSplit(793)(comp, k, m.value4);
        return new Split(v1.value0, v1.value1, unsafeBalancedNode(m.value2, m.value3, v1.value2, m.value5));
      }
      ;
      if (v instanceof GT) {
        var v1 = $lazy_unsafeSplit(796)(comp, k, m.value5);
        return new Split(v1.value0, unsafeBalancedNode(m.value2, m.value3, m.value4, v1.value1), v1.value2);
      }
      ;
      if (v instanceof EQ) {
        return new Split(new Just(m.value3), m.value4, m.value5);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 791, column 5 - line 799, column 30): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 787, column 34 - line 799, column 30): " + [m.constructor.name]);
  };
});
var unsafeSplit = /* @__PURE__ */ $lazy_unsafeSplit(786);
var $lazy_unsafeSplitLast = /* @__PURE__ */ $runtime_lazy4("unsafeSplitLast", "Data.Map.Internal", function() {
  return function(k, v, l, r) {
    if (r instanceof Leaf) {
      return new SplitLast(k, v, l);
    }
    ;
    if (r instanceof Node) {
      var v1 = $lazy_unsafeSplitLast(779)(r.value2, r.value3, r.value4, r.value5);
      return new SplitLast(v1.value0, v1.value1, unsafeBalancedNode(k, v, l, v1.value2));
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 776, column 37 - line 780, column 57): " + [r.constructor.name]);
  };
});
var unsafeSplitLast = /* @__PURE__ */ $lazy_unsafeSplitLast(775);
var unsafeJoinNodes = function(v, v1) {
  if (v instanceof Leaf) {
    return v1;
  }
  ;
  if (v instanceof Node) {
    var v2 = unsafeSplitLast(v.value2, v.value3, v.value4, v.value5);
    return unsafeBalancedNode(v2.value0, v2.value1, v2.value2, v1);
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 764, column 25 - line 768, column 38): " + [v.constructor.name, v1.constructor.name]);
};
var $lazy_unsafeDifference = /* @__PURE__ */ $runtime_lazy4("unsafeDifference", "Data.Map.Internal", function() {
  return function(comp, l, r) {
    if (l instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeDifference(841)(comp, v.value1, r.value4);
      var r$prime = $lazy_unsafeDifference(842)(comp, v.value2, r.value5);
      return unsafeJoinNodes(l$prime, r$prime);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 836, column 39 - line 843, column 33): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeDifference = /* @__PURE__ */ $lazy_unsafeDifference(835);
var $lazy_unsafeIntersectionWith = /* @__PURE__ */ $runtime_lazy4("unsafeIntersectionWith", "Data.Map.Internal", function() {
  return function(comp, app, l, r) {
    if (l instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Leaf) {
      return Leaf.value;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeIntersectionWith(825)(comp, app, v.value1, r.value4);
      var r$prime = $lazy_unsafeIntersectionWith(826)(comp, app, v.value2, r.value5);
      if (v.value0 instanceof Just) {
        return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);
      }
      ;
      if (v.value0 instanceof Nothing) {
        return unsafeJoinNodes(l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 827, column 5 - line 831, column 37): " + [v.value0.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 820, column 49 - line 831, column 37): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeIntersectionWith = /* @__PURE__ */ $lazy_unsafeIntersectionWith(819);
var $lazy_unsafeUnionWith = /* @__PURE__ */ $runtime_lazy4("unsafeUnionWith", "Data.Map.Internal", function() {
  return function(comp, app, l, r) {
    if (l instanceof Leaf) {
      return r;
    }
    ;
    if (r instanceof Leaf) {
      return l;
    }
    ;
    if (r instanceof Node) {
      var v = unsafeSplit(comp, r.value2, l);
      var l$prime = $lazy_unsafeUnionWith(809)(comp, app, v.value1, r.value4);
      var r$prime = $lazy_unsafeUnionWith(810)(comp, app, v.value2, r.value5);
      if (v.value0 instanceof Just) {
        return unsafeBalancedNode(r.value2, app(v.value0.value0)(r.value3), l$prime, r$prime);
      }
      ;
      if (v.value0 instanceof Nothing) {
        return unsafeBalancedNode(r.value2, r.value3, l$prime, r$prime);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 811, column 5 - line 815, column 46): " + [v.value0.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 804, column 42 - line 815, column 46): " + [l.constructor.name, r.constructor.name]);
  };
});
var unsafeUnionWith = /* @__PURE__ */ $lazy_unsafeUnionWith(803);
var unionWith = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(app) {
    return function(m1) {
      return function(m2) {
        return unsafeUnionWith(compare21, app, m1, m2);
      };
    };
  };
};
var union2 = function(dictOrd) {
  return unionWith(dictOrd)($$const);
};
var member = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return false;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare21(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 459, column 7 - line 462, column 19): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 456, column 8 - line 462, column 19): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var mapMaybeWithKey = function(dictOrd) {
  return function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        var v2 = f(v.value2)(v.value3);
        if (v2 instanceof Just) {
          return unsafeBalancedNode(v.value2, v2.value0, go(v.value4), go(v.value5));
        }
        ;
        if (v2 instanceof Nothing) {
          return unsafeJoinNodes(go(v.value4), go(v.value5));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 661, column 7 - line 665, column 47): " + [v2.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 658, column 8 - line 665, column 47): " + [v.constructor.name]);
    };
    return go;
  };
};
var mapMaybe3 = function(dictOrd) {
  var $780 = mapMaybeWithKey(dictOrd);
  return function($781) {
    return $780($$const($781));
  };
};
var lookup3 = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Node) {
          var v1 = compare21(k)(v.value2);
          if (v1 instanceof LT) {
            $copy_v = v.value4;
            return;
          }
          ;
          if (v1 instanceof GT) {
            $copy_v = v.value5;
            return;
          }
          ;
          if (v1 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value3);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 283, column 7 - line 286, column 22): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 280, column 8 - line 286, column 22): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var iterMapU = function(iter) {
  return function(v) {
    if (v instanceof Leaf) {
      return iter;
    }
    ;
    if (v instanceof Node) {
      if (v.value4 instanceof Leaf) {
        if (v.value5 instanceof Leaf) {
          return new IterEmit(v.value2, v.value3, iter);
        }
        ;
        return new IterEmit(v.value2, v.value3, new IterNode(v.value5, iter));
      }
      ;
      if (v.value5 instanceof Leaf) {
        return new IterEmit(v.value2, v.value3, new IterNode(v.value4, iter));
      }
      ;
      return new IterEmit(v.value2, v.value3, new IterNode(v.value4, new IterNode(v.value5, iter)));
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 973, column 17 - line 988, column 56): " + [v.constructor.name]);
  };
};
var stepUnorderedCps = /* @__PURE__ */ stepWith(iterMapU);
var stepUnfoldrUnordered = /* @__PURE__ */ function() {
  var step3 = function(k, v, next2) {
    return new Just(new Tuple(new Tuple(k, v), next2));
  };
  return stepUnorderedCps(step3)(function(v) {
    return Nothing.value;
  });
}();
var toUnfoldableUnordered = function(dictUnfoldable) {
  var $782 = unfoldr(dictUnfoldable)(stepUnfoldrUnordered);
  return function($783) {
    return $782(toMapIter($783));
  };
};
var iterMapL = /* @__PURE__ */ function() {
  var go = function($copy_iter) {
    return function($copy_v) {
      var $tco_var_iter = $copy_iter;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(iter, v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return iter;
        }
        ;
        if (v instanceof Node) {
          if (v.value5 instanceof Leaf) {
            $tco_var_iter = new IterEmit(v.value2, v.value3, iter);
            $copy_v = v.value4;
            return;
          }
          ;
          $tco_var_iter = new IterEmit(v.value2, v.value3, new IterNode(v.value5, iter));
          $copy_v = v.value4;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 951, column 13 - line 958, column 48): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_iter, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
}();
var stepAscCps = /* @__PURE__ */ stepWith(iterMapL);
var stepAsc = /* @__PURE__ */ function() {
  return stepAscCps(function(k, v, next2) {
    return new IterNext(k, v, next2);
  })($$const(IterDone.value));
}();
var eqMapIter = function(dictEq) {
  var eq116 = eq(dictEq);
  return function(dictEq1) {
    var eq213 = eq(dictEq1);
    return {
      eq: /* @__PURE__ */ function() {
        var go = function($copy_a) {
          return function($copy_b) {
            var $tco_var_a = $copy_a;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(a, b) {
              var v = stepAsc(a);
              if (v instanceof IterNext) {
                var v2 = stepAsc(b);
                if (v2 instanceof IterNext && (eq116(v.value0)(v2.value0) && eq213(v.value1)(v2.value1))) {
                  $tco_var_a = v.value2;
                  $copy_b = v2.value2;
                  return;
                }
                ;
                $tco_done = true;
                return false;
              }
              ;
              if (v instanceof IterDone) {
                $tco_done = true;
                return true;
              }
              ;
              throw new Error("Failed pattern match at Data.Map.Internal (line 859, column 14 - line 868, column 13): " + [v.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_a, $copy_b);
            }
            ;
            return $tco_result;
          };
        };
        return go;
      }()
    };
  };
};
var stepUnfoldr = /* @__PURE__ */ function() {
  var step3 = function(k, v, next2) {
    return new Just(new Tuple(new Tuple(k, v), next2));
  };
  return stepAscCps(step3)(function(v) {
    return Nothing.value;
  });
}();
var toUnfoldable5 = function(dictUnfoldable) {
  var $784 = unfoldr(dictUnfoldable)(stepUnfoldr);
  return function($785) {
    return $784(toMapIter($785));
  };
};
var isEmpty = function(v) {
  if (v instanceof Leaf) {
    return true;
  }
  ;
  return false;
};
var intersectionWith = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(app) {
    return function(m1) {
      return function(m2) {
        return unsafeIntersectionWith(compare21, app, m1, m2);
      };
    };
  };
};
var intersection = function(dictOrd) {
  return intersectionWith(dictOrd)($$const);
};
var insertWith = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(app) {
    return function(k) {
      return function(v) {
        var go = function(v1) {
          if (v1 instanceof Leaf) {
            return singleton10(k)(v);
          }
          ;
          if (v1 instanceof Node) {
            var v2 = compare21(k)(v1.value2);
            if (v2 instanceof LT) {
              return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
            }
            ;
            if (v2 instanceof GT) {
              return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
            }
            ;
            if (v2 instanceof EQ) {
              return new Node(v1.value0, v1.value1, k, app(v1.value3)(v), v1.value4, v1.value5);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 486, column 7 - line 489, column 44): " + [v2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 483, column 8 - line 489, column 44): " + [v1.constructor.name]);
        };
        return go;
      };
    };
  };
};
var insert2 = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(k) {
    return function(v) {
      var go = function(v1) {
        if (v1 instanceof Leaf) {
          return singleton10(k)(v);
        }
        ;
        if (v1 instanceof Node) {
          var v2 = compare21(k)(v1.value2);
          if (v2 instanceof LT) {
            return unsafeBalancedNode(v1.value2, v1.value3, go(v1.value4), v1.value5);
          }
          ;
          if (v2 instanceof GT) {
            return unsafeBalancedNode(v1.value2, v1.value3, v1.value4, go(v1.value5));
          }
          ;
          if (v2 instanceof EQ) {
            return new Node(v1.value0, v1.value1, k, v, v1.value4, v1.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 471, column 7 - line 474, column 35): " + [v2.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 468, column 8 - line 474, column 35): " + [v1.constructor.name]);
      };
      return go;
    };
  };
};
var functorMap = {
  map: function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        return new Node(v.value0, v.value1, v.value2, f(v.value3), go(v.value4), go(v.value5));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 147, column 10 - line 150, column 39): " + [v.constructor.name]);
    };
    return go;
  }
};
var functorWithIndexMap = {
  mapWithIndex: function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        return new Node(v.value0, v.value1, v.value2, f(v.value2)(v.value3), go(v.value4), go(v.value5));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 155, column 10 - line 158, column 41): " + [v.constructor.name]);
    };
    return go;
  },
  Functor0: function() {
    return functorMap;
  }
};
var foldableMap = {
  foldr: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(172)(m$prime.value4, f(m$prime.value3)($lazy_go(172)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 169, column 26 - line 172, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(169);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(178)(f($lazy_go(178)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 175, column 26 - line 178, column 43): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(175);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty33 = mempty(dictMonoid);
    var append127 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty33;
        }
        ;
        if (v instanceof Node) {
          return append127(go(v.value4))(append127(f(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 181, column 10 - line 184, column 28): " + [v.constructor.name]);
      };
      return go;
    };
  }
};
var foldableWithIndexMap = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(m$prime, z$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(192)(m$prime.value4, f(m$prime.value2)(m$prime.value3)($lazy_go(192)(m$prime.value5, z$prime)));
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 189, column 26 - line 192, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(189);
      return function(m) {
        return go(m, z);
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $lazy_go = $runtime_lazy4("go", "Data.Map.Internal", function() {
        return function(z$prime, m$prime) {
          if (m$prime instanceof Leaf) {
            return z$prime;
          }
          ;
          if (m$prime instanceof Node) {
            return $lazy_go(198)(f(m$prime.value2)($lazy_go(198)(z$prime, m$prime.value4))(m$prime.value3), m$prime.value5);
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 195, column 26 - line 198, column 45): " + [m$prime.constructor.name]);
        };
      });
      var go = $lazy_go(195);
      return function(m) {
        return go(z, m);
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    var mempty33 = mempty(dictMonoid);
    var append127 = append(dictMonoid.Semigroup0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return mempty33;
        }
        ;
        if (v instanceof Node) {
          return append127(go(v.value4))(append127(f(v.value2)(v.value3))(go(v.value5)));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 201, column 10 - line 204, column 30): " + [v.constructor.name]);
      };
      return go;
    };
  },
  Foldable0: function() {
    return foldableMap;
  }
};
var keys = /* @__PURE__ */ function() {
  return foldrWithIndex(foldableWithIndexMap)(function(k) {
    return function(v) {
      return function(acc) {
        return new Cons(k, acc);
      };
    };
  })(Nil.value);
}();
var traversableMap = {
  traverse: function(dictApplicative) {
    var pure98 = pure(dictApplicative);
    var Apply0 = dictApplicative.Apply0();
    var apply30 = apply2(Apply0);
    var map154 = map(Apply0.Functor0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return pure98(Leaf.value);
        }
        ;
        if (v instanceof Node) {
          return apply30(apply30(map154(function(l$prime) {
            return function(v$prime) {
              return function(r$prime) {
                return new Node(v.value0, v.value1, v.value2, v$prime, l$prime, r$prime);
              };
            };
          })(go(v.value4)))(f(v.value3)))(go(v.value5));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 209, column 10 - line 215, column 19): " + [v.constructor.name]);
      };
      return go;
    };
  },
  sequence: function(dictApplicative) {
    return traverse(traversableMap)(dictApplicative)(identity10);
  },
  Functor0: function() {
    return functorMap;
  },
  Foldable1: function() {
    return foldableMap;
  }
};
var traversableWithIndexMap = {
  traverseWithIndex: function(dictApplicative) {
    var pure98 = pure(dictApplicative);
    var Apply0 = dictApplicative.Apply0();
    var apply30 = apply2(Apply0);
    var map154 = map(Apply0.Functor0());
    return function(f) {
      var go = function(v) {
        if (v instanceof Leaf) {
          return pure98(Leaf.value);
        }
        ;
        if (v instanceof Node) {
          return apply30(apply30(map154(function(l$prime) {
            return function(v$prime) {
              return function(r$prime) {
                return new Node(v.value0, v.value1, v.value2, v$prime, l$prime, r$prime);
              };
            };
          })(go(v.value4)))(f(v.value2)(v.value3)))(go(v.value5));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 221, column 10 - line 227, column 19): " + [v.constructor.name]);
      };
      return go;
    };
  },
  FunctorWithIndex0: function() {
    return functorWithIndexMap;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexMap;
  },
  Traversable2: function() {
    return traversableMap;
  }
};
var values = /* @__PURE__ */ function() {
  return foldr(foldableMap)(Cons.create)(Nil.value);
}();
var findMin = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v instanceof Leaf) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v instanceof Node) {
      if (v.value4 instanceof Leaf) {
        $tco_done = true;
        return new Just({
          key: v.value2,
          value: v.value3
        });
      }
      ;
      $copy_v = v.value4;
      return;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 361, column 11 - line 366, column 21): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var findMax = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v instanceof Leaf) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v instanceof Node) {
      if (v.value5 instanceof Leaf) {
        $tco_done = true;
        return new Just({
          key: v.value2,
          value: v.value3
        });
      }
      ;
      $copy_v = v.value5;
      return;
    }
    ;
    throw new Error("Failed pattern match at Data.Map.Internal (line 352, column 11 - line 357, column 21): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var filterWithKey = function(dictOrd) {
  return function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        if (f(v.value2)(v.value3)) {
          return unsafeBalancedNode(v.value2, v.value3, go(v.value4), go(v.value5));
        }
        ;
        if (otherwise) {
          return unsafeJoinNodes(go(v.value4), go(v.value5));
        }
        ;
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 627, column 8 - line 633, column 47): " + [v.constructor.name]);
    };
    return go;
  };
};
var filterKeys = function(dictOrd) {
  return function(f) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        if (f(v.value2)) {
          return unsafeBalancedNode(v.value2, v.value3, go(v.value4), go(v.value5));
        }
        ;
        if (otherwise) {
          return unsafeJoinNodes(go(v.value4), go(v.value5));
        }
        ;
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 640, column 8 - line 646, column 47): " + [v.constructor.name]);
    };
    return go;
  };
};
var filter4 = function(dictOrd) {
  var $786 = filterWithKey(dictOrd);
  return function($787) {
    return $786($$const($787));
  };
};
var eqMap = function(dictEq) {
  var eqMapIter1 = eqMapIter(dictEq);
  return function(dictEq1) {
    var eq116 = eq(eqMapIter1(dictEq1));
    return {
      eq: function(xs) {
        return function(ys) {
          if (xs instanceof Leaf) {
            if (ys instanceof Leaf) {
              return true;
            }
            ;
            return false;
          }
          ;
          if (xs instanceof Node) {
            if (ys instanceof Node && xs.value1 === ys.value1) {
              return eq116(toMapIter(xs))(toMapIter(ys));
            }
            ;
            return false;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 94, column 14 - line 105, column 16): " + [xs.constructor.name]);
        };
      }
    };
  };
};
var empty4 = /* @__PURE__ */ function() {
  return Leaf.value;
}();
var fromFoldable7 = function(dictOrd) {
  var insert111 = insert2(dictOrd);
  return function(dictFoldable) {
    return foldl(dictFoldable)(function(m) {
      return function(v) {
        return insert111(v.value0)(v.value1)(m);
      };
    })(empty4);
  };
};
var difference2 = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(m1) {
    return function(m2) {
      return unsafeDifference(compare21, m1, m2);
    };
  };
};
var $$delete2 = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(k) {
    var go = function(v) {
      if (v instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v instanceof Node) {
        var v1 = compare21(k)(v.value2);
        if (v1 instanceof LT) {
          return unsafeBalancedNode(v.value2, v.value3, go(v.value4), v.value5);
        }
        ;
        if (v1 instanceof GT) {
          return unsafeBalancedNode(v.value2, v.value3, v.value4, go(v.value5));
        }
        ;
        if (v1 instanceof EQ) {
          return unsafeJoinNodes(v.value4, v.value5);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 498, column 7 - line 501, column 43): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 495, column 8 - line 501, column 43): " + [v.constructor.name]);
    };
    return go;
  };
};
var applyMap = function(dictOrd) {
  return {
    apply: intersectionWith(dictOrd)(identity10),
    Functor0: function() {
      return functorMap;
    }
  };
};
var alter = function(dictOrd) {
  var compare21 = compare(dictOrd);
  return function(f) {
    return function(k) {
      return function(m) {
        var v = unsafeSplit(compare21, k, m);
        var v2 = f(v.value0);
        if (v2 instanceof Nothing) {
          return unsafeJoinNodes(v.value1, v.value2);
        }
        ;
        if (v2 instanceof Just) {
          return unsafeBalancedNode(k, v2.value0, v.value1, v.value2);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 514, column 3 - line 518, column 41): " + [v2.constructor.name]);
      };
    };
  };
};

// output/Data.Profunctor/index.js
var identity11 = /* @__PURE__ */ identity(categoryFn);
var wrap2 = /* @__PURE__ */ wrap();
var unwrap5 = /* @__PURE__ */ unwrap();
var profunctorFn = {
  dimap: function(a2b) {
    return function(c2d) {
      return function(b2c) {
        return function($18) {
          return c2d(b2c(a2b($18)));
        };
      };
    };
  }
};
var dimap = function(dict) {
  return dict.dimap;
};
var lcmap = function(dictProfunctor) {
  var dimap1 = dimap(dictProfunctor);
  return function(a2b) {
    return dimap1(a2b)(identity11);
  };
};
var wrapIso = function(dictProfunctor) {
  var dimap1 = dimap(dictProfunctor);
  return function() {
    return function(v) {
      return dimap1(unwrap5)(wrap2);
    };
  };
};

// output/Data.Set/index.js
var coerce4 = /* @__PURE__ */ coerce();
var foldMap3 = /* @__PURE__ */ foldMap(foldableList);
var foldl5 = /* @__PURE__ */ foldl(foldableList);
var foldr4 = /* @__PURE__ */ foldr(foldableList);
var $$Set = function(x) {
  return x;
};
var union3 = function(dictOrd) {
  return coerce4(union2(dictOrd));
};
var toMap = function(v) {
  return v;
};
var toList3 = function(v) {
  return keys(v);
};
var toUnfoldable6 = function(dictUnfoldable) {
  var $96 = toUnfoldable4(dictUnfoldable);
  return function($97) {
    return $96(toList3($97));
  };
};
var singleton11 = function(a) {
  return singleton10(a)(unit);
};
var semigroupSet = function(dictOrd) {
  return {
    append: union3(dictOrd)
  };
};
var member2 = function(dictOrd) {
  return coerce4(member(dictOrd));
};
var isEmpty2 = /* @__PURE__ */ coerce4(isEmpty);
var intersection2 = function(dictOrd) {
  return coerce4(intersection(dictOrd));
};
var insert3 = function(dictOrd) {
  var insert111 = insert2(dictOrd);
  return function(a) {
    return function(v) {
      return insert111(a)(unit)(v);
    };
  };
};
var fromMap = $$Set;
var foldableSet = {
  foldMap: function(dictMonoid) {
    var foldMap111 = foldMap3(dictMonoid);
    return function(f) {
      var $98 = foldMap111(f);
      return function($99) {
        return $98(toList3($99));
      };
    };
  },
  foldl: function(f) {
    return function(x) {
      var $100 = foldl5(f)(x);
      return function($101) {
        return $100(toList3($101));
      };
    };
  },
  foldr: function(f) {
    return function(x) {
      var $102 = foldr4(f)(x);
      return function($103) {
        return $102(toList3($103));
      };
    };
  }
};
var foldl12 = /* @__PURE__ */ foldl(foldableSet);
var filter5 = function(dictOrd) {
  return coerce4(filterKeys(dictOrd));
};
var eqSet = function(dictEq) {
  var eq46 = eq(eqMap(dictEq)(eqUnit));
  return {
    eq: function(v) {
      return function(v1) {
        return eq46(v)(v1);
      };
    }
  };
};
var empty5 = empty4;
var fromFoldable8 = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictOrd) {
    var insert111 = insert3(dictOrd);
    return foldl22(function(m) {
      return function(a) {
        return insert111(a)(m);
      };
    })(empty5);
  };
};
var map19 = function(dictOrd) {
  var insert111 = insert3(dictOrd);
  return function(f) {
    return foldl12(function(m) {
      return function(a) {
        return insert111(f(a))(m);
      };
    })(empty5);
  };
};
var monoidSet = function(dictOrd) {
  var semigroupSet1 = semigroupSet(dictOrd);
  return {
    mempty: empty5,
    Semigroup0: function() {
      return semigroupSet1;
    }
  };
};
var difference3 = function(dictOrd) {
  return coerce4(difference2(dictOrd));
};

// output/Data.Set.NonEmpty/index.js
var coerce5 = /* @__PURE__ */ coerce();
var map110 = /* @__PURE__ */ map(functorTuple);
var foldMap14 = /* @__PURE__ */ foldMap1(foldable1NonEmptyList);
var foldr12 = /* @__PURE__ */ foldr1(foldable1NonEmptyList);
var foldl13 = /* @__PURE__ */ foldl1(foldable1NonEmptyList);
var toUnfoldable1 = function(dictUnfoldable1) {
  var stepNext = stepAscCps(function(k, v, next2) {
    return new Just(new Tuple(k, next2));
  })(function(v) {
    return Nothing.value;
  });
  var stepHead = stepAscCps(function(k, v, next2) {
    return new Tuple(k, next2);
  })(function(v) {
    return unsafeCrashWith("toUnfoldable1: impossible");
  });
  var $82 = unfoldr1(dictUnfoldable1)(function(v) {
    return map110(stepNext)(v);
  });
  return function($83) {
    return $82(stepHead(toMapIter(toMap(coerce5($83)))));
  };
};
var toUnfoldable12 = /* @__PURE__ */ toUnfoldable1(unfoldable1NonEmptyList);
var toSet = function(v) {
  return v;
};
var singleton12 = /* @__PURE__ */ coerce5(singleton11);
var semigroupNonEmptySet = function(dictOrd) {
  return semigroupSet(dictOrd);
};
var member3 = function(dictOrd) {
  return coerce5(member2(dictOrd));
};
var fromFoldable12 = function(dictFoldable1) {
  var foldMap112 = foldMap1(dictFoldable1);
  return function(dictOrd) {
    return foldMap112(semigroupNonEmptySet(dictOrd))(singleton12);
  };
};
var foldableNonEmptySet = foldableSet;
var foldable1NonEmptySet = {
  foldMap1: function(dictSemigroup) {
    var foldMap112 = foldMap14(dictSemigroup);
    return function(f) {
      var $86 = foldMap112(f);
      return function($87) {
        return $86(toUnfoldable12($87));
      };
    };
  },
  foldr1: function(f) {
    var $88 = foldr12(f);
    return function($89) {
      return $88(toUnfoldable12($89));
    };
  },
  foldl1: function(f) {
    var $90 = foldl13(f);
    return function($91) {
      return $90(toUnfoldable12($91));
    };
  },
  Foldable0: function() {
    return foldableNonEmptySet;
  }
};
var eqNonEmptySet = function(dictEq) {
  return eqSet(dictEq);
};

// output/Data.String.NonEmpty.Internal/index.js
var toString3 = function(v) {
  return v;
};
var fromString4 = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(v);
};

// output/Foreign.Object/foreign.js
function _copyST(m) {
  return function() {
    var r = {};
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r[k] = m[k];
      }
    }
    return r;
  };
}
var empty6 = {};
function runST(f) {
  return f();
}
function _foldM(bind82) {
  return function(f) {
    return function(mz) {
      return function(m) {
        var acc = mz;
        function g(k2) {
          return function(z) {
            return f(z)(k2)(m[k2]);
          };
        }
        for (var k in m) {
          if (hasOwnProperty.call(m, k)) {
            acc = bind82(acc)(g(k));
          }
        }
        return acc;
      };
    };
  };
}
function all3(f) {
  return function(m) {
    for (var k in m) {
      if (hasOwnProperty.call(m, k) && !f(k)(m[k]))
        return false;
    }
    return true;
  };
}
function _lookup2(no, yes, k, m) {
  return k in m ? yes(m[k]) : no;
}
function toArrayWithKey(f) {
  return function(m) {
    var r = [];
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r.push(f(k)(m[k]));
      }
    }
    return r;
  };
}
var keys2 = Object.keys || toArrayWithKey(function(k) {
  return function() {
    return k;
  };
});

// output/Foreign.Object.ST/foreign.js
var newImpl = function() {
  return {};
};
function poke2(k) {
  return function(v) {
    return function(m) {
      return function() {
        m[k] = v;
        return m;
      };
    };
  };
}
var deleteImpl = function(k) {
  return function(m) {
    return function() {
      delete m[k];
      return m;
    };
  };
};

// output/Foreign.Object/index.js
var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindST);
var $$void5 = /* @__PURE__ */ $$void(functorST);
var foldr5 = /* @__PURE__ */ foldr(foldableArray);
var values2 = /* @__PURE__ */ toArrayWithKey(function(v) {
  return function(v1) {
    return v1;
  };
});
var toUnfoldable7 = function(dictUnfoldable) {
  var $89 = toUnfoldable(dictUnfoldable);
  var $90 = toArrayWithKey(Tuple.create);
  return function($91) {
    return $89($90($91));
  };
};
var thawST = _copyST;
var singleton13 = function(k) {
  return function(v) {
    return runST(bindFlipped4(poke2(k)(v))(newImpl));
  };
};
var mutate = function(f) {
  return function(m) {
    return runST(function __do3() {
      var s = thawST(m)();
      f(s)();
      return s;
    });
  };
};
var lookup4 = /* @__PURE__ */ function() {
  return runFn4(_lookup2)(Nothing.value)(Just.create);
}();
var isEmpty3 = /* @__PURE__ */ all3(function(v) {
  return function(v1) {
    return false;
  };
});
var insert4 = function(k) {
  return function(v) {
    return mutate(poke2(k)(v));
  };
};
var fromHomogeneous = function() {
  return unsafeCoerce2;
};
var fromFoldable9 = function(dictFoldable) {
  var fromFoldable122 = fromFoldable(dictFoldable);
  return function(l) {
    return runST(function __do3() {
      var s = newImpl();
      foreach(fromFoldable122(l))(function(v) {
        return $$void5(poke2(v.value0)(v.value1)(s));
      })();
      return s;
    });
  };
};
var foldM3 = function(dictMonad) {
  var bind128 = bind(dictMonad.Bind1());
  var pure129 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(z) {
      return _foldM(bind128)(f)(pure129(z));
    };
  };
};
var foldM1 = /* @__PURE__ */ foldM3(monadST);
var union4 = function(m) {
  return mutate(function(s) {
    return foldM1(function(s$prime) {
      return function(k) {
        return function(v) {
          return poke2(k)(v)(s$prime);
        };
      };
    })(s)(m);
  });
};
var fold3 = /* @__PURE__ */ _foldM(applyFlipped);
var foldMap4 = function(dictMonoid) {
  var append127 = append(dictMonoid.Semigroup0());
  var mempty33 = mempty(dictMonoid);
  return function(f) {
    return fold3(function(acc) {
      return function(k) {
        return function(v) {
          return append127(acc)(f(k)(v));
        };
      };
    })(mempty33);
  };
};
var foldableObject = {
  foldl: function(f) {
    return fold3(function(z) {
      return function(v) {
        return f(z);
      };
    });
  },
  foldr: function(f) {
    return function(z) {
      return function(m) {
        return foldr5(f)(z)(values2(m));
      };
    };
  },
  foldMap: function(dictMonoid) {
    var foldMap111 = foldMap4(dictMonoid);
    return function(f) {
      return foldMap111($$const(f));
    };
  }
};
var foldableWithIndexObject = {
  foldlWithIndex: function(f) {
    return fold3(flip(f));
  },
  foldrWithIndex: function(f) {
    return function(z) {
      return function(m) {
        return foldr5(uncurry(f))(z)(toArrayWithKey(Tuple.create)(m));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMap4(dictMonoid);
  },
  Foldable0: function() {
    return foldableObject;
  }
};
var $$delete4 = function(k) {
  return mutate(deleteImpl(k));
};
var alter2 = function(f) {
  return function(k) {
    return function(m) {
      var v = f(lookup4(k)(m));
      if (v instanceof Nothing) {
        return $$delete4(k)(m);
      }
      ;
      if (v instanceof Just) {
        return insert4(k)(v.value0)(m);
      }
      ;
      throw new Error("Failed pattern match at Foreign.Object (line 210, column 15 - line 212, column 25): " + [v.constructor.name]);
    };
  };
};

// output/Data.Codec.JSON.Common/index.js
var apply5 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyCodec(/* @__PURE__ */ applyExceptT(monadIdentity))(semigroupList));
var functorExceptT2 = /* @__PURE__ */ functorExceptT(functorIdentity);
var map111 = /* @__PURE__ */ map(/* @__PURE__ */ functorCodec(functorExceptT2));
var profunctorCodec2 = /* @__PURE__ */ profunctorCodec(functorExceptT2);
var lcmap2 = /* @__PURE__ */ lcmap(profunctorCodec2);
var dimap2 = /* @__PURE__ */ dimap(profunctorCodec2);
var fromFoldable13 = /* @__PURE__ */ fromFoldable(foldableSet);
var fromFoldable22 = /* @__PURE__ */ fromFoldable8(foldableArray);
var map42 = /* @__PURE__ */ map(functorEither);
var toUnfoldable13 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var fromFoldable62 = /* @__PURE__ */ fromFoldable(foldableList);
var fromFoldable72 = /* @__PURE__ */ fromFoldable6(foldableArray);
var tuple = function(codecA) {
  return function(codecB) {
    return named("Tuple")(indexedArray(apply5(map111(Tuple.create)(lcmap2(fst)(index3(0)(codecA))))(lcmap2(snd)(index3(1)(codecB)))));
  };
};
var set = function(dictOrd) {
  var fromFoldable82 = fromFoldable22(dictOrd);
  return function(codec12) {
    return dimap2(fromFoldable13)(fromFoldable82)(named("Set")(array(codec12)));
  };
};
var nonEmptyString = /* @__PURE__ */ prismaticCodec("NonEmptyString")(fromString4)(toString3)(string);
var nonEmptyArray = function(codec12) {
  return prismaticCodec("NonEmptyArray")(fromArray)(toArray)(array(codec12));
};
var maybe2 = function(codec12) {
  var printTag = function(v) {
    if (!v) {
      return "Nothing";
    }
    ;
    if (v) {
      return "Just";
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.JSON.Common (line 58, column 14 - line 60, column 18): " + [v.constructor.name]);
  };
  var parseTag = function(v) {
    if (v === "Nothing") {
      return new Just(false);
    }
    ;
    if (v === "Just") {
      return new Just(true);
    }
    ;
    return Nothing.value;
  };
  var enc = function(v) {
    if (v instanceof Nothing) {
      return new Tuple(false, Nothing.value);
    }
    ;
    if (v instanceof Just) {
      return new Tuple(true, new Just(encode2(codec12)(v.value0)));
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.JSON.Common (line 68, column 9 - line 70, column 51): " + [v.constructor.name]);
  };
  var dec = function(v) {
    if (!v) {
      return new Left(Nothing.value);
    }
    ;
    if (v) {
      return new Right(function() {
        var $67 = map42(Just.create);
        var $68 = decode2(codec12);
        return function($69) {
          return $67($68($69));
        };
      }());
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.JSON.Common (line 65, column 9 - line 67, column 50): " + [v.constructor.name]);
  };
  return taggedSum("Maybe")(printTag)(parseTag)(dec)(enc);
};
var map20 = function(dictOrd) {
  var fromFoldable82 = fromFoldable7(dictOrd)(foldableArray);
  return function(codecA) {
    return function(codecB) {
      return dimap2(toUnfoldable13)(fromFoldable82)(named("Map")(array(tuple(codecA)(codecB))));
    };
  };
};
var list = function(codec12) {
  return dimap2(fromFoldable62)(fromFoldable72)(named("List")(array(codec12)));
};

// output/Data.Compactable/index.js
var $$void7 = /* @__PURE__ */ $$void(functorST);
var pure12 = /* @__PURE__ */ pure(applicativeST);
var apply6 = /* @__PURE__ */ apply2(applyST);
var map21 = /* @__PURE__ */ map(functorST);
var compactableArray = {
  compact: function(xs) {
    return function __do3() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function($108) {
        return $$void7(function(v) {
          if (v instanceof Nothing) {
            return pure12(0);
          }
          ;
          if (v instanceof Just) {
            return push(v.value0)(result);
          }
          ;
          throw new Error("Failed pattern match at Data.Compactable (line 111, column 34 - line 113, column 35): " + [v.constructor.name]);
        }($108));
      })();
      return unsafeFreeze(result)();
    }();
  },
  separate: function(xs) {
    return function __do3() {
      var ls3 = newSTArray();
      var rs = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function($109) {
        return $$void7(function(v) {
          if (v instanceof Left) {
            return push(v.value0)(ls3);
          }
          ;
          if (v instanceof Right) {
            return push(v.value0)(rs);
          }
          ;
          throw new Error("Failed pattern match at Data.Compactable (line 122, column 34 - line 124, column 31): " + [v.constructor.name]);
        }($109));
      })();
      return apply6(map21(function(v) {
        return function(v1) {
          return {
            left: v,
            right: v1
          };
        };
      })(unsafeFreeze(ls3)))(unsafeFreeze(rs))();
    }();
  }
};

// output/Data.Filterable/index.js
var append3 = /* @__PURE__ */ append(semigroupArray);
var foldl6 = /* @__PURE__ */ foldl(foldableArray);
var partitionMap = function(dict) {
  return dict.partitionMap;
};
var partition3 = function(dict) {
  return dict.partition;
};
var filterableArray = {
  partitionMap: function(p) {
    var go = function(acc) {
      return function(x) {
        var v = p(x);
        if (v instanceof Left) {
          return {
            right: acc.right,
            left: append3(acc.left)([v.value0])
          };
        }
        ;
        if (v instanceof Right) {
          return {
            left: acc.left,
            right: append3(acc.right)([v.value0])
          };
        }
        ;
        throw new Error("Failed pattern match at Data.Filterable (line 149, column 16 - line 151, column 50): " + [v.constructor.name]);
      };
    };
    return foldl6(go)({
      left: [],
      right: []
    });
  },
  partition,
  filterMap: mapMaybe,
  filter,
  Compactable0: function() {
    return compactableArray;
  },
  Functor1: function() {
    return functorArray;
  }
};
var filterMap = function(dict) {
  return dict.filterMap;
};
var filter6 = function(dict) {
  return dict.filter;
};

// output/Data.String.Regex/foreign.js
var regexImpl = function(left3) {
  return function(right2) {
    return function(s1) {
      return function(s2) {
        try {
          return right2(new RegExp(s1, s2));
        } catch (e) {
          return left3(e.message);
        }
      };
    };
  };
};
var test = function(r) {
  return function(s) {
    var lastIndex = r.lastIndex;
    var result = r.test(s);
    r.lastIndex = lastIndex;
    return result;
  };
};
var _match = function(just) {
  return function(nothing) {
    return function(r) {
      return function(s) {
        var m = s.match(r);
        if (m == null || m.length === 0) {
          return nothing;
        } else {
          for (var i = 0; i < m.length; i++) {
            m[i] = m[i] == null ? nothing : just(m[i]);
          }
          return just(m);
        }
      };
    };
  };
};
var replace2 = function(r) {
  return function(s1) {
    return function(s2) {
      return s2.replace(r, s1);
    };
  };
};
var split2 = function(r) {
  return function(s) {
    return s.split(r);
  };
};

// output/Data.String.Regex.Flags/index.js
var unicode = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: true
};
var semigroupRegexFlags = {
  append: function(v) {
    return function(v1) {
      return {
        global: v.global || v1.global,
        ignoreCase: v.ignoreCase || v1.ignoreCase,
        multiline: v.multiline || v1.multiline,
        dotAll: v.dotAll || v1.dotAll,
        sticky: v.sticky || v1.sticky,
        unicode: v.unicode || v1.unicode
      };
    };
  }
};
var noFlags = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var monoidRegexFlags = {
  mempty: noFlags,
  Semigroup0: function() {
    return semigroupRegexFlags;
  }
};
var ignoreCase = {
  global: false,
  ignoreCase: true,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var global2 = {
  global: true,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};

// output/Data.String.Regex/index.js
var renderFlags = function(v) {
  return function() {
    if (v.global) {
      return "g";
    }
    ;
    return "";
  }() + (function() {
    if (v.ignoreCase) {
      return "i";
    }
    ;
    return "";
  }() + (function() {
    if (v.multiline) {
      return "m";
    }
    ;
    return "";
  }() + (function() {
    if (v.dotAll) {
      return "s";
    }
    ;
    return "";
  }() + (function() {
    if (v.sticky) {
      return "y";
    }
    ;
    return "";
  }() + function() {
    if (v.unicode) {
      return "u";
    }
    ;
    return "";
  }()))));
};
var regex = function(s) {
  return function(f) {
    return regexImpl(Left.create)(Right.create)(s)(renderFlags(f));
  };
};
var match = /* @__PURE__ */ function() {
  return _match(Just.create)(Nothing.value);
}();

// output/Data.String.Regex.Unsafe/index.js
var identity12 = /* @__PURE__ */ identity(categoryFn);
var unsafeRegex = function(s) {
  return function(f) {
    return either(unsafeCrashWith)(identity12)(regex(s)(f));
  };
};

// output/Dodo.Internal/index.js
var Append = /* @__PURE__ */ function() {
  function Append2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Append2.create = function(value0) {
    return function(value12) {
      return new Append2(value0, value12);
    };
  };
  return Append2;
}();
var Indent = /* @__PURE__ */ function() {
  function Indent2(value0) {
    this.value0 = value0;
  }
  ;
  Indent2.create = function(value0) {
    return new Indent2(value0);
  };
  return Indent2;
}();
var Align = /* @__PURE__ */ function() {
  function Align2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Align2.create = function(value0) {
    return function(value12) {
      return new Align2(value0, value12);
    };
  };
  return Align2;
}();
var Annotate = /* @__PURE__ */ function() {
  function Annotate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Annotate2.create = function(value0) {
    return function(value12) {
      return new Annotate2(value0, value12);
    };
  };
  return Annotate2;
}();
var FlexSelect = /* @__PURE__ */ function() {
  function FlexSelect2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FlexSelect2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FlexSelect2(value0, value12, value22);
      };
    };
  };
  return FlexSelect2;
}();
var FlexAlt = /* @__PURE__ */ function() {
  function FlexAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlexAlt2.create = function(value0) {
    return function(value12) {
      return new FlexAlt2(value0, value12);
    };
  };
  return FlexAlt2;
}();
var WithPosition = /* @__PURE__ */ function() {
  function WithPosition2(value0) {
    this.value0 = value0;
  }
  ;
  WithPosition2.create = function(value0) {
    return new WithPosition2(value0);
  };
  return WithPosition2;
}();
var Local = /* @__PURE__ */ function() {
  function Local3(value0) {
    this.value0 = value0;
  }
  ;
  Local3.create = function(value0) {
    return new Local3(value0);
  };
  return Local3;
}();
var Text = /* @__PURE__ */ function() {
  function Text3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text3.create = function(value0) {
    return function(value12) {
      return new Text3(value0, value12);
    };
  };
  return Text3;
}();
var Break = /* @__PURE__ */ function() {
  function Break2() {
  }
  ;
  Break2.value = new Break2();
  return Break2;
}();
var Empty = /* @__PURE__ */ function() {
  function Empty4() {
  }
  ;
  Empty4.value = new Empty4();
  return Empty4;
}();
var notEmpty = function(f) {
  return function(v) {
    if (v instanceof Empty) {
      return Empty.value;
    }
    ;
    return f(v);
  };
};
var isEmpty4 = function(v) {
  if (v instanceof Empty) {
    return true;
  }
  ;
  return false;
};
var bothNotEmpty = function(f) {
  return function(v) {
    return function(v1) {
      if (v instanceof Empty) {
        return v1;
      }
      ;
      if (v1 instanceof Empty) {
        return v;
      }
      ;
      return f(v)(v1);
    };
  };
};
var semigroupDoc = {
  append: /* @__PURE__ */ bothNotEmpty(function(v) {
    return function(v1) {
      if (v instanceof Text && v1 instanceof Text) {
        return new Text(v.value0 + v1.value0 | 0, v.value1 + v1.value1);
      }
      ;
      return new Append(v, v1);
    };
  })
};
var monoidDoc = /* @__PURE__ */ function() {
  return {
    mempty: Empty.value,
    Semigroup0: function() {
      return semigroupDoc;
    }
  };
}();

// output/Dodo.Internal.Buffer/index.js
var foldr6 = /* @__PURE__ */ foldr(foldableList);
var $$new2 = function(buffer) {
  return {
    buffer,
    queue: Nil.value
  };
};
var modify4 = function(f) {
  return function(v) {
    if (v.queue instanceof Cons) {
      return {
        buffer: v.buffer,
        queue: new Cons(new Cons(f, v.queue.value0), v.queue.value1)
      };
    }
    ;
    return {
      queue: v.queue,
      buffer: f(v.buffer)
    };
  };
};
var commit = function(v) {
  return {
    buffer: foldr6(flip(foldr6(apply)))(v.buffer)(v.queue),
    queue: Nil.value
  };
};
var get2 = function($23) {
  return function(v) {
    return v.buffer;
  }(commit($23));
};
var branch = function(v) {
  return {
    buffer: v.buffer,
    queue: new Cons(Nil.value, v.queue)
  };
};

// output/Dodo/index.js
var mempty2 = /* @__PURE__ */ mempty(monoidDoc);
var append14 = /* @__PURE__ */ append(semigroupDoc);
var max3 = /* @__PURE__ */ max(ordInt);
var max1 = /* @__PURE__ */ max(ordNumber);
var min3 = /* @__PURE__ */ min(ordNumber);
var power2 = /* @__PURE__ */ power(monoidString);
var pure5 = /* @__PURE__ */ pure(applicativeList);
var Doc = /* @__PURE__ */ function() {
  function Doc2(value0) {
    this.value0 = value0;
  }
  ;
  Doc2.create = function(value0) {
    return new Doc2(value0);
  };
  return Doc2;
}();
var Dedent = /* @__PURE__ */ function() {
  function Dedent2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Dedent2.create = function(value0) {
    return function(value12) {
      return new Dedent2(value0, value12);
    };
  };
  return Dedent2;
}();
var LeaveAnnotation = /* @__PURE__ */ function() {
  function LeaveAnnotation2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LeaveAnnotation2.create = function(value0) {
    return function(value12) {
      return new LeaveAnnotation2(value0, value12);
    };
  };
  return LeaveAnnotation2;
}();
var LeaveFlexGroup = /* @__PURE__ */ function() {
  function LeaveFlexGroup2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LeaveFlexGroup2.create = function(value0) {
    return function(value12) {
      return new LeaveFlexGroup2(value0, value12);
    };
  };
  return LeaveFlexGroup2;
}();
var LeaveLocal = /* @__PURE__ */ function() {
  function LeaveLocal2(value0) {
    this.value0 = value0;
  }
  ;
  LeaveLocal2.create = function(value0) {
    return new LeaveLocal2(value0);
  };
  return LeaveLocal2;
}();
var NoFlexGroup = /* @__PURE__ */ function() {
  function NoFlexGroup2() {
  }
  ;
  NoFlexGroup2.value = new NoFlexGroup2();
  return NoFlexGroup2;
}();
var FlexGroupPending = /* @__PURE__ */ function() {
  function FlexGroupPending2() {
  }
  ;
  FlexGroupPending2.value = new FlexGroupPending2();
  return FlexGroupPending2;
}();
var FlexGroupReset = /* @__PURE__ */ function() {
  function FlexGroupReset2(value0) {
    this.value0 = value0;
  }
  ;
  FlexGroupReset2.create = function(value0) {
    return new FlexGroupReset2(value0);
  };
  return FlexGroupReset2;
}();
var twoSpaces = {
  pageWidth: 80,
  ribbonRatio: 1,
  indentUnit: "  ",
  indentWidth: 2
};
var text = function(v) {
  if (v === "") {
    return Empty.value;
  }
  ;
  return new Text(length5(v), v);
};
var storeState = function(stack) {
  return function(v) {
    return {
      position: v.position,
      buffer: v.buffer,
      annotations: v.annotations,
      indentSpaces: v.indentSpaces,
      stack,
      options: v.options
    };
  };
};
var space = /* @__PURE__ */ text(" ");
var resetState = function(v) {
  return {
    position: v.position,
    buffer: v.buffer,
    annotations: v.annotations,
    indentSpaces: v.indentSpaces,
    flexGroup: NoFlexGroup.value,
    options: v.options
  };
};
var plainText = {
  emptyBuffer: "",
  writeText: function(v) {
    return function(str2) {
      return function(buff) {
        return buff + str2;
      };
    };
  },
  writeIndent: function(v) {
    return function(str2) {
      return function(buff) {
        return buff + str2;
      };
    };
  },
  writeBreak: function(buff) {
    return buff + "\n";
  },
  enterAnnotation: function(v) {
    return function(v1) {
      return function(buff) {
        return buff;
      };
    };
  },
  leaveAnnotation: function(v) {
    return function(v1) {
      return function(buff) {
        return buff;
      };
    };
  },
  flushBuffer: function(buff) {
    return buff;
  }
};
var indent = /* @__PURE__ */ function() {
  return notEmpty(Indent.create);
}();
var foldWith = function(dictFoldable) {
  var foldr21 = foldr(dictFoldable);
  return function(f) {
    return foldr21(bothNotEmpty(f))(mempty2);
  };
};
var foldWithSeparator = function(dictFoldable) {
  var foldWith1 = foldWith(dictFoldable);
  return function(separator) {
    return foldWith1(function(a) {
      return function(b) {
        return append14(a)(append14(separator)(b));
      };
    });
  };
};
var calcRibbonWidth = function(v) {
  return function(n) {
    return max3(0)(ceil2(v.ribbonRatio * toNumber(v.pageWidth - n | 0)));
  };
};
var storeOptions = function(prevIndent) {
  return function(localOptions) {
    return function(state2) {
      var newOptions = {
        indentUnit: localOptions.indentUnit,
        indentWidth: localOptions.indentWidth,
        pageWidth: localOptions.pageWidth,
        ribbonRatio: localOptions.ribbonRatio
      };
      return {
        buffer: state2.buffer,
        annotations: state2.annotations,
        flexGroup: state2.flexGroup,
        indentSpaces: localOptions.indentSpaces,
        options: newOptions,
        position: {
          line: state2.position.line,
          column: state2.position.column,
          indent: state2.position.indent,
          pageWidth: newOptions.pageWidth,
          ribbonWidth: calcRibbonWidth(newOptions)(prevIndent),
          nextIndent: localOptions.indent
        }
      };
    };
  };
};
var print4 = function(v) {
  return function(opts) {
    var initOptions = {
      pageWidth: opts.pageWidth,
      indentUnit: opts.indentUnit,
      indentWidth: opts.indentWidth,
      ribbonRatio: max1(0)(min3(1)(opts.ribbonRatio))
    };
    var initState = {
      position: {
        line: 0,
        column: 0,
        indent: 0,
        nextIndent: 0,
        pageWidth: initOptions.pageWidth,
        ribbonWidth: calcRibbonWidth(initOptions)(0)
      },
      buffer: $$new2(v.emptyBuffer),
      annotations: Nil.value,
      indentSpaces: "",
      flexGroup: NoFlexGroup.value,
      options: initOptions
    };
    var go = function($copy_stack) {
      return function($copy_state) {
        var $tco_var_stack = $copy_stack;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(stack, state2) {
          if (stack instanceof Nil) {
            $tco_done = true;
            return v.flushBuffer(get2(state2.buffer));
          }
          ;
          if (stack instanceof Cons) {
            if (stack.value0 instanceof Doc) {
              if (stack.value0.value0 instanceof Append) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof Text) {
                if (state2.position.column === 0 && state2.position.indent > 0) {
                  $tco_var_stack = stack;
                  $copy_state = {
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth,
                      column: state2.position.indent
                    },
                    buffer: modify4(v.writeIndent(state2.position.indent)(state2.indentSpaces))(state2.buffer)
                  };
                  return;
                }
                ;
                if ((state2.position.column + stack.value0.value0.value0 | 0) <= (state2.position.indent + state2.position.ribbonWidth | 0)) {
                  $tco_var_stack = stack.value1;
                  $copy_state = {
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth,
                      column: state2.position.column + stack.value0.value0.value0 | 0
                    },
                    buffer: modify4(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state2.buffer)
                  };
                  return;
                }
                ;
                if (otherwise) {
                  if (state2.flexGroup instanceof FlexGroupReset) {
                    $tco_var_stack = state2.flexGroup.value0.stack;
                    $copy_state = resetState(state2.flexGroup.value0);
                    return;
                  }
                  ;
                  $tco_var_stack = stack.value1;
                  $copy_state = {
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth,
                      column: state2.position.column + stack.value0.value0.value0 | 0
                    },
                    flexGroup: NoFlexGroup.value,
                    buffer: modify4(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state2.buffer)
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Break) {
                if (state2.flexGroup instanceof FlexGroupReset) {
                  $tco_var_stack = state2.flexGroup.value0.stack;
                  $copy_state = resetState(state2.flexGroup.value0);
                  return;
                }
                ;
                $tco_var_stack = stack.value1;
                $copy_state = {
                  annotations: state2.annotations,
                  indentSpaces: state2.indentSpaces,
                  options: state2.options,
                  position: {
                    nextIndent: state2.position.nextIndent,
                    pageWidth: state2.position.pageWidth,
                    line: state2.position.line + 1 | 0,
                    column: 0,
                    indent: state2.position.nextIndent,
                    ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent)
                  },
                  buffer: modify4(v.writeBreak)(state2.buffer),
                  flexGroup: NoFlexGroup.value
                };
                return;
              }
              ;
              if (stack.value0.value0 instanceof Indent) {
                if (state2.position.column === 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      pageWidth: state2.position.pageWidth,
                      indent: state2.position.nextIndent + opts.indentWidth | 0,
                      nextIndent: state2.position.nextIndent + opts.indentWidth | 0,
                      ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent + opts.indentWidth | 0)
                    },
                    indentSpaces: state2.indentSpaces + opts.indentUnit
                  };
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.indent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth,
                      nextIndent: state2.position.nextIndent + opts.indentWidth | 0
                    },
                    indentSpaces: state2.indentSpaces + opts.indentUnit
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Align) {
                if (state2.position.column === 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      pageWidth: state2.position.pageWidth,
                      indent: state2.position.nextIndent + stack.value0.value0.value0 | 0,
                      nextIndent: state2.position.nextIndent + stack.value0.value0.value0 | 0,
                      ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent + stack.value0.value0.value0 | 0)
                    },
                    indentSpaces: state2.indentSpaces + power2(" ")(stack.value0.value0.value0)
                  };
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    flexGroup: state2.flexGroup,
                    options: state2.options,
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.indent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth,
                      nextIndent: state2.position.nextIndent + stack.value0.value0.value0 | 0
                    },
                    indentSpaces: state2.indentSpaces + power2(" ")(stack.value0.value0.value0)
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof FlexSelect) {
                if (state2.flexGroup instanceof NoFlexGroup) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new LeaveFlexGroup(stack.value0.value0.value1, stack.value0.value0.value2), stack.value1));
                  $copy_state = {
                    position: state2.position,
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    options: state2.options,
                    flexGroup: FlexGroupPending.value
                  };
                  return;
                }
                ;
                if (state2.flexGroup instanceof FlexGroupPending && state2.position.ribbonWidth > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                  $copy_state = {
                    position: state2.position,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    options: state2.options,
                    flexGroup: new FlexGroupReset(storeState(stack)(state2)),
                    buffer: branch(state2.buffer)
                  };
                  return;
                }
                ;
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof FlexAlt) {
                if (state2.flexGroup instanceof FlexGroupReset) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
                if (state2.flexGroup instanceof FlexGroupPending && state2.position.ribbonWidth > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), stack.value1);
                  $copy_state = {
                    position: state2.position,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    options: state2.options,
                    flexGroup: new FlexGroupReset(storeState(new Cons(new Doc(stack.value0.value0.value1), stack.value1))(state2)),
                    buffer: branch(state2.buffer)
                  };
                  return;
                }
                ;
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), stack.value1);
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof WithPosition) {
                if (state2.position.column === 0 && state2.position.nextIndent > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0({
                    line: state2.position.line,
                    indent: state2.position.indent,
                    nextIndent: state2.position.nextIndent,
                    pageWidth: state2.position.pageWidth,
                    ribbonWidth: state2.position.ribbonWidth,
                    column: state2.position.nextIndent
                  })), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0(state2.position)), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Annotate) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new LeaveAnnotation(stack.value0.value0.value0, state2.annotations), stack.value1));
                $copy_state = {
                  position: state2.position,
                  indentSpaces: state2.indentSpaces,
                  flexGroup: state2.flexGroup,
                  options: state2.options,
                  annotations: new Cons(stack.value0.value0.value0, state2.annotations),
                  buffer: modify4(v.enterAnnotation(stack.value0.value0.value0)(state2.annotations))(state2.buffer)
                };
                return;
              }
              ;
              if (stack.value0.value0 instanceof Local) {
                var prevOptions = {
                  indent: state2.position.indent,
                  indentSpaces: state2.indentSpaces,
                  indentUnit: state2.options.indentUnit,
                  indentWidth: state2.options.indentWidth,
                  pageWidth: state2.options.pageWidth,
                  ribbonRatio: state2.options.ribbonRatio
                };
                var v1 = stack.value0.value0.value0(prevOptions);
                $tco_var_stack = new Cons(new Doc(v1.value1), new Cons(new LeaveLocal(prevOptions), stack.value1));
                $copy_state = storeOptions(state2.position.indent)(v1.value0)(state2);
                return;
              }
              ;
              if (stack.value0.value0 instanceof Empty) {
                $tco_var_stack = stack.value1;
                $copy_state = state2;
                return;
              }
              ;
              throw new Error("Failed pattern match at Dodo (line 365, column 18 - line 477, column 23): " + [stack.value0.value0.constructor.name]);
            }
            ;
            if (stack.value0 instanceof LeaveFlexGroup) {
              if (state2.flexGroup instanceof NoFlexGroup) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value1), stack.value1);
                $copy_state = {
                  position: state2.position,
                  annotations: state2.annotations,
                  indentSpaces: state2.indentSpaces,
                  flexGroup: state2.flexGroup,
                  options: state2.options,
                  buffer: commit(state2.buffer)
                };
                return;
              }
              ;
              $tco_var_stack = new Cons(new Doc(stack.value0.value0), stack.value1);
              $copy_state = {
                position: state2.position,
                annotations: state2.annotations,
                indentSpaces: state2.indentSpaces,
                options: state2.options,
                flexGroup: NoFlexGroup.value,
                buffer: commit(state2.buffer)
              };
              return;
            }
            ;
            if (stack.value0 instanceof Dedent) {
              $tco_var_stack = stack.value1;
              $copy_state = {
                buffer: state2.buffer,
                annotations: state2.annotations,
                flexGroup: state2.flexGroup,
                options: state2.options,
                position: {
                  line: state2.position.line,
                  column: state2.position.column,
                  indent: state2.position.indent,
                  pageWidth: state2.position.pageWidth,
                  ribbonWidth: state2.position.ribbonWidth,
                  nextIndent: stack.value0.value1
                },
                indentSpaces: stack.value0.value0
              };
              return;
            }
            ;
            if (stack.value0 instanceof LeaveAnnotation) {
              $tco_var_stack = stack.value1;
              $copy_state = {
                position: state2.position,
                indentSpaces: state2.indentSpaces,
                flexGroup: state2.flexGroup,
                options: state2.options,
                annotations: stack.value0.value1,
                buffer: modify4(v.leaveAnnotation(stack.value0.value0)(stack.value0.value1))(state2.buffer)
              };
              return;
            }
            ;
            if (stack.value0 instanceof LeaveLocal) {
              $tco_var_stack = stack.value1;
              $copy_state = storeOptions(state2.position.indent)(stack.value0.value0)(state2);
              return;
            }
            ;
            throw new Error("Failed pattern match at Dodo (line 364, column 18 - line 499, column 70): " + [stack.value0.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Dodo (line 361, column 20 - line 499, column 70): " + [stack.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_stack, $copy_state);
        }
        ;
        return $tco_result;
      };
    };
    var $135 = flip(go)(initState);
    return function($136) {
      return $135(pure5(Doc.create($136)));
    };
  };
};
var $$break = /* @__PURE__ */ function() {
  return Break.value;
}();
var appendSpace = /* @__PURE__ */ bothNotEmpty(function(a) {
  return function(b) {
    return append14(a)(append14(space)(b));
  };
});
var words = function(dictFoldable) {
  return foldr(dictFoldable)(appendSpace)(Empty.value);
};
var appendBreak = /* @__PURE__ */ bothNotEmpty(function(a) {
  return function(b) {
    return append14(a)(append14($$break)(b));
  };
});
var lines = function(dictFoldable) {
  return foldr(dictFoldable)(appendBreak)(Empty.value);
};
var annotate = function($141) {
  return notEmpty(Annotate.create($141));
};

// output/Effect.Aff/foreign.js
var Aff = function() {
  var EMPTY = {};
  var PURE = "Pure";
  var THROW = "Throw";
  var CATCH = "Catch";
  var SYNC = "Sync";
  var ASYNC2 = "Async";
  var BIND = "Bind";
  var BRACKET = "Bracket";
  var FORK = "Fork";
  var SEQ = "Sequential";
  var MAP = "Map";
  var APPLY = "Apply";
  var ALT = "Alt";
  var CONS = "Cons";
  var RESUME2 = "Resume";
  var RELEASE = "Release";
  var FINALIZER = "Finalizer";
  var FINALIZED = "Finalized";
  var FORKED = "Forked";
  var FIBER = "Fiber";
  var THUNK = "Thunk";
  function Aff2(tag, _1, _2, _3) {
    this.tag = tag;
    this._1 = _1;
    this._2 = _2;
    this._3 = _3;
  }
  function AffCtr(tag) {
    var fn = function(_1, _2, _3) {
      return new Aff2(tag, _1, _2, _3);
    };
    fn.tag = tag;
    return fn;
  }
  function nonCanceler2(error5) {
    return new Aff2(PURE, void 0);
  }
  function runEff(eff) {
    try {
      eff();
    } catch (error5) {
      setTimeout(function() {
        throw error5;
      }, 0);
    }
  }
  function runSync(left3, right2, eff) {
    try {
      return right2(eff());
    } catch (error5) {
      return left3(error5);
    }
  }
  function runAsync(left3, eff, k) {
    try {
      return eff(k)();
    } catch (error5) {
      k(left3(error5))();
      return nonCanceler2;
    }
  }
  var Scheduler = function() {
    var limit = 1024;
    var size8 = 0;
    var ix = 0;
    var queue = new Array(limit);
    var draining = false;
    function drain() {
      var thunk;
      draining = true;
      while (size8 !== 0) {
        size8--;
        thunk = queue[ix];
        queue[ix] = void 0;
        ix = (ix + 1) % limit;
        thunk();
      }
      draining = false;
    }
    return {
      isDraining: function() {
        return draining;
      },
      enqueue: function(cb) {
        var i, tmp;
        if (size8 === limit) {
          tmp = draining;
          drain();
          draining = tmp;
        }
        queue[(ix + size8) % limit] = cb;
        size8++;
        if (!draining) {
          drain();
        }
      }
    };
  }();
  function Supervisor(util) {
    var fibers = {};
    var fiberId = 0;
    var count = 0;
    return {
      register: function(fiber) {
        var fid = fiberId++;
        fiber.onComplete({
          rethrow: true,
          handler: function(result) {
            return function() {
              count--;
              delete fibers[fid];
            };
          }
        })();
        fibers[fid] = fiber;
        count++;
      },
      isEmpty: function() {
        return count === 0;
      },
      killAll: function(killError, cb) {
        return function() {
          if (count === 0) {
            return cb();
          }
          var killCount = 0;
          var kills = {};
          function kill3(fid) {
            kills[fid] = fibers[fid].kill(killError, function(result) {
              return function() {
                delete kills[fid];
                killCount--;
                if (util.isLeft(result) && util.fromLeft(result)) {
                  setTimeout(function() {
                    throw util.fromLeft(result);
                  }, 0);
                }
                if (killCount === 0) {
                  cb();
                }
              };
            })();
          }
          for (var k in fibers) {
            if (fibers.hasOwnProperty(k)) {
              killCount++;
              kill3(k);
            }
          }
          fibers = {};
          fiberId = 0;
          count = 0;
          return function(error5) {
            return new Aff2(SYNC, function() {
              for (var k2 in kills) {
                if (kills.hasOwnProperty(k2)) {
                  kills[k2]();
                }
              }
            });
          };
        };
      }
    };
  }
  var SUSPENDED = 0;
  var CONTINUE = 1;
  var STEP_BIND = 2;
  var STEP_RESULT = 3;
  var PENDING2 = 4;
  var RETURN = 5;
  var COMPLETED = 6;
  function Fiber(util, supervisor, aff) {
    var runTick = 0;
    var status2 = SUSPENDED;
    var step3 = aff;
    var fail7 = null;
    var interrupt = null;
    var bhead = null;
    var btail = null;
    var attempts = null;
    var bracketCount = 0;
    var joinId = 0;
    var joins = null;
    var rethrow = true;
    function run16(localRunTick) {
      var tmp, result, attempt2;
      while (true) {
        tmp = null;
        result = null;
        attempt2 = null;
        switch (status2) {
          case STEP_BIND:
            status2 = CONTINUE;
            try {
              step3 = bhead(step3);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status2 = RETURN;
              fail7 = util.left(e);
              step3 = null;
            }
            break;
          case STEP_RESULT:
            if (util.isLeft(step3)) {
              status2 = RETURN;
              fail7 = step3;
              step3 = null;
            } else if (bhead === null) {
              status2 = RETURN;
            } else {
              status2 = STEP_BIND;
              step3 = util.fromRight(step3);
            }
            break;
          case CONTINUE:
            switch (step3.tag) {
              case BIND:
                if (bhead) {
                  btail = new Aff2(CONS, bhead, btail);
                }
                bhead = step3._2;
                status2 = CONTINUE;
                step3 = step3._1;
                break;
              case PURE:
                if (bhead === null) {
                  status2 = RETURN;
                  step3 = util.right(step3._1);
                } else {
                  status2 = STEP_BIND;
                  step3 = step3._1;
                }
                break;
              case SYNC:
                status2 = STEP_RESULT;
                step3 = runSync(util.left, util.right, step3._1);
                break;
              case ASYNC2:
                status2 = PENDING2;
                step3 = runAsync(util.left, step3._1, function(result2) {
                  return function() {
                    if (runTick !== localRunTick) {
                      return;
                    }
                    runTick++;
                    Scheduler.enqueue(function() {
                      if (runTick !== localRunTick + 1) {
                        return;
                      }
                      status2 = STEP_RESULT;
                      step3 = result2;
                      run16(runTick);
                    });
                  };
                });
                return;
              case THROW:
                status2 = RETURN;
                fail7 = util.left(step3._1);
                step3 = null;
                break;
              case CATCH:
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME2, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status2 = CONTINUE;
                step3 = step3._1;
                break;
              case BRACKET:
                bracketCount++;
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME2, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status2 = CONTINUE;
                step3 = step3._1;
                break;
              case FORK:
                status2 = STEP_RESULT;
                tmp = Fiber(util, supervisor, step3._2);
                if (supervisor) {
                  supervisor.register(tmp);
                }
                if (step3._1) {
                  tmp.run();
                }
                step3 = util.right(tmp);
                break;
              case SEQ:
                status2 = CONTINUE;
                step3 = sequential5(util, supervisor, step3._1);
                break;
            }
            break;
          case RETURN:
            bhead = null;
            btail = null;
            if (attempts === null) {
              status2 = COMPLETED;
              step3 = interrupt || fail7 || step3;
            } else {
              tmp = attempts._3;
              attempt2 = attempts._1;
              attempts = attempts._2;
              switch (attempt2.tag) {
                case CATCH:
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    status2 = RETURN;
                  } else if (fail7) {
                    status2 = CONTINUE;
                    step3 = attempt2._2(util.fromLeft(fail7));
                    fail7 = null;
                  }
                  break;
                case RESUME2:
                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail7) {
                    status2 = RETURN;
                  } else {
                    bhead = attempt2._1;
                    btail = attempt2._2;
                    status2 = STEP_BIND;
                    step3 = util.fromRight(step3);
                  }
                  break;
                case BRACKET:
                  bracketCount--;
                  if (fail7 === null) {
                    result = util.fromRight(step3);
                    attempts = new Aff2(CONS, new Aff2(RELEASE, attempt2._2, result), attempts, tmp);
                    if (interrupt === tmp || bracketCount > 0) {
                      status2 = CONTINUE;
                      step3 = attempt2._3(result);
                    }
                  }
                  break;
                case RELEASE:
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail7), attempts, interrupt);
                  status2 = CONTINUE;
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    step3 = attempt2._1.killed(util.fromLeft(interrupt))(attempt2._2);
                  } else if (fail7) {
                    step3 = attempt2._1.failed(util.fromLeft(fail7))(attempt2._2);
                  } else {
                    step3 = attempt2._1.completed(util.fromRight(step3))(attempt2._2);
                  }
                  fail7 = null;
                  bracketCount++;
                  break;
                case FINALIZER:
                  bracketCount++;
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail7), attempts, interrupt);
                  status2 = CONTINUE;
                  step3 = attempt2._1;
                  break;
                case FINALIZED:
                  bracketCount--;
                  status2 = RETURN;
                  step3 = attempt2._1;
                  fail7 = attempt2._2;
                  break;
              }
            }
            break;
          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step3));
              }
            }
            joins = null;
            if (interrupt && fail7) {
              setTimeout(function() {
                throw util.fromLeft(fail7);
              }, 0);
            } else if (util.isLeft(step3) && rethrow) {
              setTimeout(function() {
                if (rethrow) {
                  throw util.fromLeft(step3);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status2 = CONTINUE;
            break;
          case PENDING2:
            return;
        }
      }
    }
    function onComplete(join12) {
      return function() {
        if (status2 === COMPLETED) {
          rethrow = rethrow && join12.rethrow;
          join12.handler(step3)();
          return function() {
          };
        }
        var jid = joinId++;
        joins = joins || {};
        joins[jid] = join12;
        return function() {
          if (joins !== null) {
            delete joins[jid];
          }
        };
      };
    }
    function kill3(error5, cb) {
      return function() {
        if (status2 === COMPLETED) {
          cb(util.right(void 0))();
          return function() {
          };
        }
        var canceler = onComplete({
          rethrow: false,
          handler: function() {
            return cb(util.right(void 0));
          }
        })();
        switch (status2) {
          case SUSPENDED:
            interrupt = util.left(error5);
            status2 = COMPLETED;
            step3 = interrupt;
            run16(runTick);
            break;
          case PENDING2:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              if (status2 === PENDING2) {
                attempts = new Aff2(CONS, new Aff2(FINALIZER, step3(error5)), attempts, interrupt);
              }
              status2 = RETURN;
              step3 = null;
              fail7 = null;
              run16(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error5);
            }
            if (bracketCount === 0) {
              status2 = RETURN;
              step3 = null;
              fail7 = null;
            }
        }
        return canceler;
      };
    }
    function join11(cb) {
      return function() {
        var canceler = onComplete({
          rethrow: false,
          handler: cb
        })();
        if (status2 === SUSPENDED) {
          run16(runTick);
        }
        return canceler;
      };
    }
    return {
      kill: kill3,
      join: join11,
      onComplete,
      isSuspended: function() {
        return status2 === SUSPENDED;
      },
      run: function() {
        if (status2 === SUSPENDED) {
          if (!Scheduler.isDraining()) {
            Scheduler.enqueue(function() {
              run16(runTick);
            });
          } else {
            run16(runTick);
          }
        }
      }
    };
  }
  function runPar(util, supervisor, par, cb) {
    var fiberId = 0;
    var fibers = {};
    var killId = 0;
    var kills = {};
    var early = new Error("[ParAff] Early exit");
    var interrupt = null;
    var root2 = EMPTY;
    function kill3(error5, par2, cb2) {
      var step3 = par2;
      var head6 = null;
      var tail4 = null;
      var count = 0;
      var kills2 = {};
      var tmp, kid;
      loop:
        while (true) {
          tmp = null;
          switch (step3.tag) {
            case FORKED:
              if (step3._3 === EMPTY) {
                tmp = fibers[step3._1];
                kills2[count++] = tmp.kill(error5, function(result) {
                  return function() {
                    count--;
                    if (count === 0) {
                      cb2(result)();
                    }
                  };
                });
              }
              if (head6 === null) {
                break loop;
              }
              step3 = head6._2;
              if (tail4 === null) {
                head6 = null;
              } else {
                head6 = tail4._1;
                tail4 = tail4._2;
              }
              break;
            case MAP:
              step3 = step3._2;
              break;
            case APPLY:
            case ALT:
              if (head6) {
                tail4 = new Aff2(CONS, head6, tail4);
              }
              head6 = step3;
              step3 = step3._1;
              break;
          }
        }
      if (count === 0) {
        cb2(util.right(void 0))();
      } else {
        kid = 0;
        tmp = count;
        for (; kid < tmp; kid++) {
          kills2[kid] = kills2[kid]();
        }
      }
      return kills2;
    }
    function join11(result, head6, tail4) {
      var fail7, step3, lhs, rhs, tmp, kid;
      if (util.isLeft(result)) {
        fail7 = result;
        step3 = null;
      } else {
        step3 = result;
        fail7 = null;
      }
      loop:
        while (true) {
          lhs = null;
          rhs = null;
          tmp = null;
          kid = null;
          if (interrupt !== null) {
            return;
          }
          if (head6 === null) {
            cb(fail7 || step3)();
            return;
          }
          if (head6._3 !== EMPTY) {
            return;
          }
          switch (head6.tag) {
            case MAP:
              if (fail7 === null) {
                head6._3 = util.right(head6._1(util.fromRight(step3)));
                step3 = head6._3;
              } else {
                head6._3 = fail7;
              }
              break;
            case APPLY:
              lhs = head6._1._3;
              rhs = head6._2._3;
              if (fail7) {
                head6._3 = fail7;
                tmp = true;
                kid = killId++;
                kills[kid] = kill3(early, fail7 === lhs ? head6._2 : head6._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail4 === null) {
                      join11(fail7, null, null);
                    } else {
                      join11(fail7, tail4._1, tail4._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              } else if (lhs === EMPTY || rhs === EMPTY) {
                return;
              } else {
                step3 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
                head6._3 = step3;
              }
              break;
            case ALT:
              lhs = head6._1._3;
              rhs = head6._2._3;
              if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
                return;
              }
              if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
                fail7 = step3 === lhs ? rhs : lhs;
                step3 = null;
                head6._3 = fail7;
              } else {
                head6._3 = step3;
                tmp = true;
                kid = killId++;
                kills[kid] = kill3(early, step3 === lhs ? head6._2 : head6._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail4 === null) {
                      join11(step3, null, null);
                    } else {
                      join11(step3, tail4._1, tail4._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              }
              break;
          }
          if (tail4 === null) {
            head6 = null;
          } else {
            head6 = tail4._1;
            tail4 = tail4._2;
          }
        }
    }
    function resolve3(fiber) {
      return function(result) {
        return function() {
          delete fibers[fiber._1];
          fiber._3 = result;
          join11(result, fiber._2._1, fiber._2._2);
        };
      };
    }
    function run16() {
      var status2 = CONTINUE;
      var step3 = par;
      var head6 = null;
      var tail4 = null;
      var tmp, fid;
      loop:
        while (true) {
          tmp = null;
          fid = null;
          switch (status2) {
            case CONTINUE:
              switch (step3.tag) {
                case MAP:
                  if (head6) {
                    tail4 = new Aff2(CONS, head6, tail4);
                  }
                  head6 = new Aff2(MAP, step3._1, EMPTY, EMPTY);
                  step3 = step3._2;
                  break;
                case APPLY:
                  if (head6) {
                    tail4 = new Aff2(CONS, head6, tail4);
                  }
                  head6 = new Aff2(APPLY, EMPTY, step3._2, EMPTY);
                  step3 = step3._1;
                  break;
                case ALT:
                  if (head6) {
                    tail4 = new Aff2(CONS, head6, tail4);
                  }
                  head6 = new Aff2(ALT, EMPTY, step3._2, EMPTY);
                  step3 = step3._1;
                  break;
                default:
                  fid = fiberId++;
                  status2 = RETURN;
                  tmp = step3;
                  step3 = new Aff2(FORKED, fid, new Aff2(CONS, head6, tail4), EMPTY);
                  tmp = Fiber(util, supervisor, tmp);
                  tmp.onComplete({
                    rethrow: false,
                    handler: resolve3(step3)
                  })();
                  fibers[fid] = tmp;
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
              }
              break;
            case RETURN:
              if (head6 === null) {
                break loop;
              }
              if (head6._1 === EMPTY) {
                head6._1 = step3;
                status2 = CONTINUE;
                step3 = head6._2;
                head6._2 = EMPTY;
              } else {
                head6._2 = step3;
                step3 = head6;
                if (tail4 === null) {
                  head6 = null;
                } else {
                  head6 = tail4._1;
                  tail4 = tail4._2;
                }
              }
          }
        }
      root2 = step3;
      for (fid = 0; fid < fiberId; fid++) {
        fibers[fid].run();
      }
    }
    function cancel(error5, cb2) {
      interrupt = util.left(error5);
      var innerKills;
      for (var kid in kills) {
        if (kills.hasOwnProperty(kid)) {
          innerKills = kills[kid];
          for (kid in innerKills) {
            if (innerKills.hasOwnProperty(kid)) {
              innerKills[kid]();
            }
          }
        }
      }
      kills = null;
      var newKills = kill3(error5, root2, cb2);
      return function(killError) {
        return new Aff2(ASYNC2, function(killCb) {
          return function() {
            for (var kid2 in newKills) {
              if (newKills.hasOwnProperty(kid2)) {
                newKills[kid2]();
              }
            }
            return nonCanceler2;
          };
        });
      };
    }
    run16();
    return function(killError) {
      return new Aff2(ASYNC2, function(killCb) {
        return function() {
          return cancel(killError, killCb);
        };
      });
    };
  }
  function sequential5(util, supervisor, par) {
    return new Aff2(ASYNC2, function(cb) {
      return function() {
        return runPar(util, supervisor, par, cb);
      };
    });
  }
  Aff2.EMPTY = EMPTY;
  Aff2.Pure = AffCtr(PURE);
  Aff2.Throw = AffCtr(THROW);
  Aff2.Catch = AffCtr(CATCH);
  Aff2.Sync = AffCtr(SYNC);
  Aff2.Async = AffCtr(ASYNC2);
  Aff2.Bind = AffCtr(BIND);
  Aff2.Bracket = AffCtr(BRACKET);
  Aff2.Fork = AffCtr(FORK);
  Aff2.Seq = AffCtr(SEQ);
  Aff2.ParMap = AffCtr(MAP);
  Aff2.ParApply = AffCtr(APPLY);
  Aff2.ParAlt = AffCtr(ALT);
  Aff2.Fiber = Fiber;
  Aff2.Supervisor = Supervisor;
  Aff2.Scheduler = Scheduler;
  Aff2.nonCanceler = nonCanceler2;
  return Aff2;
}();
var _pure = Aff.Pure;
var _throwError = Aff.Throw;
function _catchError(aff) {
  return function(k) {
    return Aff.Catch(aff, k);
  };
}
function _map(f) {
  return function(aff) {
    if (aff.tag === Aff.Pure.tag) {
      return Aff.Pure(f(aff._1));
    } else {
      return Aff.Bind(aff, function(value4) {
        return Aff.Pure(f(value4));
      });
    }
  };
}
function _bind(aff) {
  return function(k) {
    return Aff.Bind(aff, k);
  };
}
function _fork(immediate) {
  return function(aff) {
    return Aff.Fork(immediate, aff);
  };
}
var _liftEffect = Aff.Sync;
function _parAffMap(f) {
  return function(aff) {
    return Aff.ParMap(f, aff);
  };
}
function _parAffApply(aff1) {
  return function(aff2) {
    return Aff.ParApply(aff1, aff2);
  };
}
function _parAffAlt(aff1) {
  return function(aff2) {
    return Aff.ParAlt(aff1, aff2);
  };
}
var makeAff = Aff.Async;
function generalBracket(acquire) {
  return function(options) {
    return function(k) {
      return Aff.Bracket(acquire, options, k);
    };
  };
}
function _makeFiber(util, aff) {
  return function() {
    return Aff.Fiber(util, null, aff);
  };
}
var _delay = /* @__PURE__ */ function() {
  function setDelay(n, k) {
    if (n === 0 && typeof setImmediate !== "undefined") {
      return setImmediate(k);
    } else {
      return setTimeout(k, n);
    }
  }
  function clearDelay(n, t) {
    if (n === 0 && typeof clearImmediate !== "undefined") {
      return clearImmediate(t);
    } else {
      return clearTimeout(t);
    }
  }
  return function(right2, ms) {
    return Aff.Async(function(cb) {
      return function() {
        var timer = setDelay(ms, cb(right2()));
        return function() {
          return Aff.Sync(function() {
            return right2(clearDelay(ms, timer));
          });
        };
      };
    });
  };
}();
var _sequential = Aff.Seq;

// output/Control.Monad.Maybe.Trans/index.js
var map23 = /* @__PURE__ */ map(functorMaybe);
var MaybeT = function(x) {
  return x;
};
var runMaybeT = function(v) {
  return v;
};
var monadTransMaybeT = {
  lift: function(dictMonad) {
    var $163 = liftM1(dictMonad)(Just.create);
    return function($164) {
      return MaybeT($163($164));
    };
  }
};
var functorMaybeT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return map154(map23(f))(v);
      };
    }
  };
};
var monadMaybeT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeMaybeT(dictMonad);
    },
    Bind1: function() {
      return bindMaybeT(dictMonad);
    }
  };
};
var bindMaybeT = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  var pure98 = pure(dictMonad.Applicative0());
  return {
    bind: function(v) {
      return function(f) {
        return bind82(v)(function(v1) {
          if (v1 instanceof Nothing) {
            return pure98(Nothing.value);
          }
          ;
          if (v1 instanceof Just) {
            var v2 = f(v1.value0);
            return v2;
          }
          ;
          throw new Error("Failed pattern match at Control.Monad.Maybe.Trans (line 55, column 11 - line 57, column 42): " + [v1.constructor.name]);
        });
      };
    },
    Apply0: function() {
      return applyMaybeT(dictMonad);
    }
  };
};
var applyMaybeT = function(dictMonad) {
  var functorMaybeT1 = functorMaybeT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadMaybeT(dictMonad)),
    Functor0: function() {
      return functorMaybeT1;
    }
  };
};
var applicativeMaybeT = function(dictMonad) {
  return {
    pure: function() {
      var $165 = pure(dictMonad.Applicative0());
      return function($166) {
        return MaybeT($165(Just.create($166)));
      };
    }(),
    Apply0: function() {
      return applyMaybeT(dictMonad);
    }
  };
};
var altMaybeT = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var bind82 = bind(Bind1);
  var pure98 = pure(dictMonad.Applicative0());
  var functorMaybeT1 = functorMaybeT(Bind1.Apply0().Functor0());
  return {
    alt: function(v) {
      return function(v1) {
        return bind82(v)(function(m) {
          if (m instanceof Nothing) {
            return v1;
          }
          ;
          return pure98(m);
        });
      };
    },
    Functor0: function() {
      return functorMaybeT1;
    }
  };
};
var plusMaybeT = function(dictMonad) {
  var altMaybeT1 = altMaybeT(dictMonad);
  return {
    empty: pure(dictMonad.Applicative0())(Nothing.value),
    Alt0: function() {
      return altMaybeT1;
    }
  };
};
var alternativeMaybeT = function(dictMonad) {
  var applicativeMaybeT1 = applicativeMaybeT(dictMonad);
  var plusMaybeT1 = plusMaybeT(dictMonad);
  return {
    Applicative0: function() {
      return applicativeMaybeT1;
    },
    Plus1: function() {
      return plusMaybeT1;
    }
  };
};

// output/Control.Parallel.Class/index.js
var sequential = function(dict) {
  return dict.sequential;
};
var parallel = function(dict) {
  return dict.parallel;
};

// output/Control.Parallel/index.js
var identity13 = /* @__PURE__ */ identity(categoryFn);
var parTraverse_ = function(dictParallel) {
  var sequential5 = sequential(dictParallel);
  var parallel6 = parallel(dictParallel);
  return function(dictApplicative) {
    var traverse_6 = traverse_(dictApplicative);
    return function(dictFoldable) {
      var traverse_1 = traverse_6(dictFoldable);
      return function(f) {
        var $51 = traverse_1(function($53) {
          return parallel6(f($53));
        });
        return function($52) {
          return sequential5($51($52));
        };
      };
    };
  };
};
var parTraverse = function(dictParallel) {
  var sequential5 = sequential(dictParallel);
  var parallel6 = parallel(dictParallel);
  return function(dictApplicative) {
    return function(dictTraversable) {
      var traverse13 = traverse(dictTraversable)(dictApplicative);
      return function(f) {
        var $54 = traverse13(function($56) {
          return parallel6(f($56));
        });
        return function($55) {
          return sequential5($54($55));
        };
      };
    };
  };
};
var parSequence_ = function(dictParallel) {
  var parTraverse_1 = parTraverse_(dictParallel);
  return function(dictApplicative) {
    var parTraverse_2 = parTraverse_1(dictApplicative);
    return function(dictFoldable) {
      return parTraverse_2(dictFoldable)(identity13);
    };
  };
};
var parSequence = function(dictParallel) {
  var parTraverse1 = parTraverse(dictParallel);
  return function(dictApplicative) {
    var parTraverse22 = parTraverse1(dictApplicative);
    return function(dictTraversable) {
      return parTraverse22(dictTraversable)(identity13);
    };
  };
};
var parOneOf = function(dictParallel) {
  var sequential5 = sequential(dictParallel);
  var parallel6 = parallel(dictParallel);
  return function(dictAlternative) {
    var Plus1 = dictAlternative.Plus1();
    return function(dictFoldable) {
      var oneOfMap2 = oneOfMap(dictFoldable)(Plus1);
      return function(dictFunctor) {
        var $60 = oneOfMap2(parallel6);
        return function($61) {
          return sequential5($60($61));
        };
      };
    };
  };
};

// output/Data.Time.Duration/index.js
var show3 = /* @__PURE__ */ show(showNumber);
var over3 = /* @__PURE__ */ over()();
var negate2 = /* @__PURE__ */ negate(ringNumber);
var identity14 = /* @__PURE__ */ identity(categoryFn);
var Minutes = function(x) {
  return x;
};
var Milliseconds = function(x) {
  return x;
};
var toDuration = function(dict) {
  return dict.toDuration;
};
var showMilliseconds = {
  show: function(v) {
    return "(Milliseconds " + (show3(v) + ")");
  }
};
var semigroupMilliseconds = {
  append: function(v) {
    return function(v1) {
      return v + v1;
    };
  }
};
var ordMinutes = ordNumber;
var ordMilliseconds = ordNumber;
var fromDuration = function(dict) {
  return dict.fromDuration;
};
var negateDuration = function(dictDuration) {
  var $57 = toDuration(dictDuration);
  var $58 = over3(Milliseconds)(negate2);
  var $59 = fromDuration(dictDuration);
  return function($60) {
    return $57($58($59($60)));
  };
};
var durationMinutes = {
  fromDuration: /* @__PURE__ */ over3(Minutes)(function(v) {
    return v * 6e4;
  }),
  toDuration: /* @__PURE__ */ over3(Milliseconds)(function(v) {
    return v / 6e4;
  })
};
var durationMilliseconds = {
  fromDuration: identity14,
  toDuration: identity14
};

// output/Effect.Unsafe/foreign.js
var unsafePerformEffect = function(f) {
  return f();
};

// output/Effect.Aff/index.js
var $runtime_lazy5 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var pure6 = /* @__PURE__ */ pure(applicativeEffect);
var $$void8 = /* @__PURE__ */ $$void(functorEffect);
var map24 = /* @__PURE__ */ map(functorEffect);
var Canceler = function(x) {
  return x;
};
var suspendAff = /* @__PURE__ */ _fork(false);
var functorParAff = {
  map: _parAffMap
};
var functorAff = {
  map: _map
};
var forkAff = /* @__PURE__ */ _fork(true);
var ffiUtil = /* @__PURE__ */ function() {
  var unsafeFromRight2 = function(v) {
    if (v instanceof Right) {
      return v.value0;
    }
    ;
    if (v instanceof Left) {
      return unsafeCrashWith("unsafeFromRight: Left");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
  };
  var unsafeFromLeft = function(v) {
    if (v instanceof Left) {
      return v.value0;
    }
    ;
    if (v instanceof Right) {
      return unsafeCrashWith("unsafeFromLeft: Right");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
  };
  var isLeft2 = function(v) {
    if (v instanceof Left) {
      return true;
    }
    ;
    if (v instanceof Right) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
  };
  return {
    isLeft: isLeft2,
    fromLeft: unsafeFromLeft,
    fromRight: unsafeFromRight2,
    left: Left.create,
    right: Right.create
  };
}();
var makeFiber = function(aff) {
  return _makeFiber(ffiUtil, aff);
};
var launchAff = function(aff) {
  return function __do3() {
    var fiber = makeFiber(aff)();
    fiber.run();
    return fiber;
  };
};
var launchAff_ = function($75) {
  return $$void8(launchAff($75));
};
var delay = function(v) {
  return _delay(Right.create, v);
};
var bracket = function(acquire) {
  return function(completed) {
    return generalBracket(acquire)({
      killed: $$const(completed),
      failed: $$const(completed),
      completed: $$const(completed)
    });
  };
};
var applyParAff = {
  apply: _parAffApply,
  Functor0: function() {
    return functorParAff;
  }
};
var monadAff = {
  Applicative0: function() {
    return applicativeAff;
  },
  Bind1: function() {
    return bindAff;
  }
};
var bindAff = {
  bind: _bind,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var applicativeAff = {
  pure: _pure,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy5("applyAff", "Effect.Aff", function() {
  return {
    apply: ap(monadAff),
    Functor0: function() {
      return functorAff;
    }
  };
});
var applyAff = /* @__PURE__ */ $lazy_applyAff(73);
var pure22 = /* @__PURE__ */ pure(applicativeAff);
var lift21 = /* @__PURE__ */ lift2(applyAff);
var $$finally = function(fin) {
  return function(a) {
    return bracket(pure22(unit))($$const(fin))($$const(a));
  };
};
var parallelAff = {
  parallel: unsafeCoerce2,
  sequential: _sequential,
  Apply0: function() {
    return applyAff;
  },
  Apply1: function() {
    return applyParAff;
  }
};
var parallel2 = /* @__PURE__ */ parallel(parallelAff);
var applicativeParAff = {
  pure: function($76) {
    return parallel2(pure22($76));
  },
  Apply0: function() {
    return applyParAff;
  }
};
var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(applicativeParAff)(foldableArray);
var semigroupCanceler = {
  append: function(v) {
    return function(v1) {
      return function(err) {
        return parSequence_2([v(err), v1(err)]);
      };
    };
  }
};
var semigroupAff = function(dictSemigroup) {
  return {
    append: lift21(append(dictSemigroup))
  };
};
var monadEffectAff = {
  liftEffect: _liftEffect,
  Monad0: function() {
    return monadAff;
  }
};
var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
var effectCanceler = function($77) {
  return Canceler($$const(liftEffect2($77)));
};
var joinFiber = function(v) {
  return makeAff(function(k) {
    return map24(effectCanceler)(v.join(k));
  });
};
var monadThrowAff = {
  throwError: _throwError,
  Monad0: function() {
    return monadAff;
  }
};
var monadErrorAff = {
  catchError: _catchError,
  MonadThrow0: function() {
    return monadThrowAff;
  }
};
var $$try3 = /* @__PURE__ */ $$try2(monadErrorAff);
var catchError2 = /* @__PURE__ */ catchError(monadErrorAff);
var attempt = $$try3;
var monoidAff = function(dictMonoid) {
  var semigroupAff1 = semigroupAff(dictMonoid.Semigroup0());
  return {
    mempty: pure22(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupAff1;
    }
  };
};
var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure22(unit));
var monoidCanceler = {
  mempty: nonCanceler,
  Semigroup0: function() {
    return semigroupCanceler;
  }
};
var mempty3 = /* @__PURE__ */ mempty(monoidCanceler);
var never = /* @__PURE__ */ makeAff(function(v) {
  return pure6(mempty3);
});
var altParAff = {
  alt: _parAffAlt,
  Functor0: function() {
    return functorParAff;
  }
};
var altAff = {
  alt: function(a1) {
    return function(a2) {
      return catchError2(a1)($$const(a2));
    };
  },
  Functor0: function() {
    return functorAff;
  }
};
var plusAff = {
  empty: /* @__PURE__ */ throwError(monadThrowAff)(/* @__PURE__ */ error("Always fails")),
  Alt0: function() {
    return altAff;
  }
};
var plusParAff = {
  empty: /* @__PURE__ */ parallel2(/* @__PURE__ */ empty(plusAff)),
  Alt0: function() {
    return altParAff;
  }
};
var alternativeParAff = {
  Applicative0: function() {
    return applicativeParAff;
  },
  Plus1: function() {
    return plusParAff;
  }
};

// output/Effect.AVar/foreign.js
var AVar = function() {
  function MutableQueue() {
    this.head = null;
    this.last = null;
    this.size = 0;
  }
  function MutableCell(queue, value4) {
    this.queue = queue;
    this.value = value4;
    this.next = null;
    this.prev = null;
  }
  function AVar2(value4) {
    this.draining = false;
    this.error = null;
    this.value = value4;
    this.takes = new MutableQueue();
    this.reads = new MutableQueue();
    this.puts = new MutableQueue();
  }
  var EMPTY = {};
  function runEff(eff) {
    try {
      eff();
    } catch (error5) {
      setTimeout(function() {
        throw error5;
      }, 0);
    }
  }
  function putLast(queue, value4) {
    var cell = new MutableCell(queue, value4);
    switch (queue.size) {
      case 0:
        queue.head = cell;
        break;
      case 1:
        cell.prev = queue.head;
        queue.head.next = cell;
        queue.last = cell;
        break;
      default:
        cell.prev = queue.last;
        queue.last.next = cell;
        queue.last = cell;
    }
    queue.size++;
    return cell;
  }
  function takeLast(queue) {
    var cell;
    switch (queue.size) {
      case 0:
        return null;
      case 1:
        cell = queue.head;
        queue.head = null;
        break;
      case 2:
        cell = queue.last;
        queue.head.next = null;
        queue.last = null;
        break;
      default:
        cell = queue.last;
        queue.last = cell.prev;
        queue.last.next = null;
    }
    cell.prev = null;
    cell.queue = null;
    queue.size--;
    return cell.value;
  }
  function takeHead(queue) {
    var cell;
    switch (queue.size) {
      case 0:
        return null;
      case 1:
        cell = queue.head;
        queue.head = null;
        break;
      case 2:
        cell = queue.head;
        queue.last.prev = null;
        queue.head = queue.last;
        queue.last = null;
        break;
      default:
        cell = queue.head;
        queue.head = cell.next;
        queue.head.prev = null;
    }
    cell.next = null;
    cell.queue = null;
    queue.size--;
    return cell.value;
  }
  function deleteCell(cell) {
    if (cell.queue === null) {
      return;
    }
    if (cell.queue.last === cell) {
      takeLast(cell.queue);
      return;
    }
    if (cell.queue.head === cell) {
      takeHead(cell.queue);
      return;
    }
    if (cell.prev) {
      cell.prev.next = cell.next;
    }
    if (cell.next) {
      cell.next.prev = cell.prev;
    }
    cell.queue.size--;
    cell.queue = null;
    cell.value = null;
    cell.next = null;
    cell.prev = null;
  }
  function drainVar(util, avar) {
    if (avar.draining) {
      return;
    }
    var ps = avar.puts;
    var ts = avar.takes;
    var rs = avar.reads;
    var p, r, t, value4, rsize;
    avar.draining = true;
    while (1) {
      p = null;
      r = null;
      t = null;
      value4 = avar.value;
      rsize = rs.size;
      if (avar.error !== null) {
        value4 = util.left(avar.error);
        while (p = takeHead(ps)) {
          runEff(p.cb(value4));
        }
        while (r = takeHead(rs)) {
          runEff(r(value4));
        }
        while (t = takeHead(ts)) {
          runEff(t(value4));
        }
        break;
      }
      if (value4 === EMPTY && (p = takeHead(ps))) {
        avar.value = value4 = p.value;
      }
      if (value4 !== EMPTY) {
        t = takeHead(ts);
        while (rsize-- && (r = takeHead(rs))) {
          runEff(r(util.right(value4)));
        }
        if (t !== null) {
          avar.value = EMPTY;
          runEff(t(util.right(value4)));
        }
      }
      if (p !== null) {
        runEff(p.cb(util.right(void 0)));
      }
      if (avar.value === EMPTY && ps.size === 0 || avar.value !== EMPTY && ts.size === 0) {
        break;
      }
    }
    avar.draining = false;
  }
  AVar2.EMPTY = EMPTY;
  AVar2.putLast = putLast;
  AVar2.takeLast = takeLast;
  AVar2.takeHead = takeHead;
  AVar2.deleteCell = deleteCell;
  AVar2.drainVar = drainVar;
  return AVar2;
}();
function empty7() {
  return new AVar(AVar.EMPTY);
}
function _newVar(value4) {
  return function() {
    return new AVar(value4);
  };
}
function _putVar(util, value4, avar, cb) {
  return function() {
    var cell = AVar.putLast(avar.puts, { cb, value: value4 });
    AVar.drainVar(util, avar);
    return function() {
      AVar.deleteCell(cell);
    };
  };
}
function _takeVar(util, avar, cb) {
  return function() {
    var cell = AVar.putLast(avar.takes, cb);
    AVar.drainVar(util, avar);
    return function() {
      AVar.deleteCell(cell);
    };
  };
}
function _tryReadVar(util, avar) {
  return function() {
    if (avar.value === AVar.EMPTY) {
      return util.nothing;
    } else {
      return util.just(avar.value);
    }
  };
}

// output/Effect.AVar/index.js
var Killed = /* @__PURE__ */ function() {
  function Killed2(value0) {
    this.value0 = value0;
  }
  ;
  Killed2.create = function(value0) {
    return new Killed2(value0);
  };
  return Killed2;
}();
var Filled = /* @__PURE__ */ function() {
  function Filled2(value0) {
    this.value0 = value0;
  }
  ;
  Filled2.create = function(value0) {
    return new Filled2(value0);
  };
  return Filled2;
}();
var Empty2 = /* @__PURE__ */ function() {
  function Empty4() {
  }
  ;
  Empty4.value = new Empty4();
  return Empty4;
}();
var $$new3 = _newVar;
var ffiUtil2 = /* @__PURE__ */ function() {
  return {
    left: Left.create,
    right: Right.create,
    nothing: Nothing.value,
    just: Just.create,
    killed: Killed.create,
    filled: Filled.create,
    empty: Empty2.value
  };
}();
var put2 = function(value4) {
  return function(avar) {
    return function(cb) {
      return _putVar(ffiUtil2, value4, avar, cb);
    };
  };
};
var take5 = function(avar) {
  return function(cb) {
    return _takeVar(ffiUtil2, avar, cb);
  };
};
var tryRead = function(avar) {
  return _tryReadVar(ffiUtil2, avar);
};

// output/Effect.Aff.AVar/index.js
var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
var tryRead2 = function($5) {
  return liftEffect3(tryRead($5));
};
var take6 = function(avar) {
  return makeAff(function(k) {
    return function __do3() {
      var c = take5(avar)(k)();
      return effectCanceler(c);
    };
  });
};
var put3 = function(value4) {
  return function(avar) {
    return makeAff(function(k) {
      return function __do3() {
        var c = put2(value4)(avar)(k)();
        return effectCanceler(c);
      };
    });
  };
};
var $$new4 = function($9) {
  return liftEffect3($$new3($9));
};
var empty8 = /* @__PURE__ */ liftEffect3(empty7);

// output/Data.Lazy/foreign.js
var defer2 = function(thunk) {
  var v = null;
  return function() {
    if (thunk === void 0)
      return v;
    v = thunk();
    thunk = void 0;
    return v;
  };
};
var force = function(l) {
  return l();
};

// output/Data.Lazy/index.js
var functorLazy = {
  map: function(f) {
    return function(l) {
      return defer2(function(v) {
        return f(force(l));
      });
    };
  }
};
var applyLazy = {
  apply: function(f) {
    return function(x) {
      return defer2(function(v) {
        return force(f)(force(x));
      });
    };
  },
  Functor0: function() {
    return functorLazy;
  }
};
var bindLazy = {
  bind: function(l) {
    return function(f) {
      return defer2(function(v) {
        return force(f(force(l)));
      });
    };
  },
  Apply0: function() {
    return applyLazy;
  }
};

// output/Control.Monad.State.Trans/index.js
var StateT = function(x) {
  return x;
};
var runStateT = function(v) {
  return v;
};
var monadTransStateT = {
  lift: function(dictMonad) {
    var bind82 = bind(dictMonad.Bind1());
    var pure98 = pure(dictMonad.Applicative0());
    return function(m) {
      return function(s) {
        return bind82(m)(function(x) {
          return pure98(new Tuple(x, s));
        });
      };
    };
  }
};
var functorStateT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return function(s) {
          return map154(function(v1) {
            return new Tuple(f(v1.value0), v1.value1);
          })(v(s));
        };
      };
    }
  };
};
var execStateT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(v) {
    return function(s) {
      return map154(snd)(v(s));
    };
  };
};
var evalStateT = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(v) {
    return function(s) {
      return map154(fst)(v(s));
    };
  };
};
var monadStateT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeStateT(dictMonad);
    },
    Bind1: function() {
      return bindStateT(dictMonad);
    }
  };
};
var bindStateT = function(dictMonad) {
  var bind82 = bind(dictMonad.Bind1());
  return {
    bind: function(v) {
      return function(f) {
        return function(s) {
          return bind82(v(s))(function(v1) {
            var v3 = f(v1.value0);
            return v3(v1.value1);
          });
        };
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var applyStateT = function(dictMonad) {
  var functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadStateT(dictMonad)),
    Functor0: function() {
      return functorStateT1;
    }
  };
};
var applicativeStateT = function(dictMonad) {
  var pure98 = pure(dictMonad.Applicative0());
  return {
    pure: function(a) {
      return function(s) {
        return pure98(new Tuple(a, s));
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var monadRecStateT = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var bind82 = bind(Monad0.Bind1());
  var pure98 = pure(Monad0.Applicative0());
  var tailRecM8 = tailRecM(dictMonadRec);
  var monadStateT1 = monadStateT(Monad0);
  return {
    tailRecM: function(f) {
      return function(a) {
        var f$prime = function(v) {
          var v1 = f(v.value0);
          return bind82(v1(v.value1))(function(v2) {
            return pure98(function() {
              if (v2.value0 instanceof Loop) {
                return new Loop(new Tuple(v2.value0.value0, v2.value1));
              }
              ;
              if (v2.value0 instanceof Done) {
                return new Done(new Tuple(v2.value0.value0, v2.value1));
              }
              ;
              throw new Error("Failed pattern match at Control.Monad.State.Trans (line 88, column 16 - line 90, column 40): " + [v2.value0.constructor.name]);
            }());
          });
        };
        return function(s) {
          return tailRecM8(f$prime)(new Tuple(a, s));
        };
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};
var monadStateStateT = function(dictMonad) {
  var pure98 = pure(dictMonad.Applicative0());
  var monadStateT1 = monadStateT(dictMonad);
  return {
    state: function(f) {
      return function($206) {
        return pure98(f($206));
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};

// output/Effect.Aff.Class/index.js
var lift42 = /* @__PURE__ */ lift(monadTransReaderT);
var monadAffAff = {
  liftAff: /* @__PURE__ */ identity(categoryFn),
  MonadEffect0: function() {
    return monadEffectAff;
  }
};
var liftAff = function(dict) {
  return dict.liftAff;
};
var monadAffReader = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var monadEffectReader2 = monadEffectReader(MonadEffect0);
  return {
    liftAff: function() {
      var $79 = lift42(MonadEffect0.Monad0());
      var $80 = liftAff(dictMonadAff);
      return function($81) {
        return $79($80($81));
      };
    }(),
    MonadEffect0: function() {
      return monadEffectReader2;
    }
  };
};

// output/Effect.Now/foreign.js
function now() {
  return Date.now();
}

// output/Data.DateTime/foreign.js
var createUTC = function(y, mo, d, h, m, s, ms) {
  var date2 = new Date(Date.UTC(y, mo, d, h, m, s, ms));
  if (y >= 0 && y < 100) {
    date2.setUTCFullYear(y);
  }
  return date2.getTime();
};
function calcDiff(rec1, rec2) {
  var msUTC1 = createUTC(rec1.year, rec1.month - 1, rec1.day, rec1.hour, rec1.minute, rec1.second, rec1.millisecond);
  var msUTC2 = createUTC(rec2.year, rec2.month - 1, rec2.day, rec2.hour, rec2.minute, rec2.second, rec2.millisecond);
  return msUTC1 - msUTC2;
}

// output/Data.Date/foreign.js
var createDate = function(y, m, d) {
  var date2 = new Date(Date.UTC(y, m, d));
  if (y >= 0 && y < 100) {
    date2.setUTCFullYear(y);
  }
  return date2;
};
function canonicalDateImpl(ctor, y, m, d) {
  var date2 = createDate(y, m - 1, d);
  return ctor(date2.getUTCFullYear())(date2.getUTCMonth() + 1)(date2.getUTCDate());
}
function calcWeekday(y, m, d) {
  return createDate(y, m - 1, d).getUTCDay();
}

// output/Data.Date.Component/index.js
var $runtime_lazy6 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var Monday = /* @__PURE__ */ function() {
  function Monday2() {
  }
  ;
  Monday2.value = new Monday2();
  return Monday2;
}();
var Tuesday = /* @__PURE__ */ function() {
  function Tuesday2() {
  }
  ;
  Tuesday2.value = new Tuesday2();
  return Tuesday2;
}();
var Wednesday = /* @__PURE__ */ function() {
  function Wednesday2() {
  }
  ;
  Wednesday2.value = new Wednesday2();
  return Wednesday2;
}();
var Thursday = /* @__PURE__ */ function() {
  function Thursday2() {
  }
  ;
  Thursday2.value = new Thursday2();
  return Thursday2;
}();
var Friday = /* @__PURE__ */ function() {
  function Friday2() {
  }
  ;
  Friday2.value = new Friday2();
  return Friday2;
}();
var Saturday = /* @__PURE__ */ function() {
  function Saturday2() {
  }
  ;
  Saturday2.value = new Saturday2();
  return Saturday2;
}();
var Sunday = /* @__PURE__ */ function() {
  function Sunday2() {
  }
  ;
  Sunday2.value = new Sunday2();
  return Sunday2;
}();
var January = /* @__PURE__ */ function() {
  function January2() {
  }
  ;
  January2.value = new January2();
  return January2;
}();
var February = /* @__PURE__ */ function() {
  function February2() {
  }
  ;
  February2.value = new February2();
  return February2;
}();
var March = /* @__PURE__ */ function() {
  function March2() {
  }
  ;
  March2.value = new March2();
  return March2;
}();
var April = /* @__PURE__ */ function() {
  function April2() {
  }
  ;
  April2.value = new April2();
  return April2;
}();
var May = /* @__PURE__ */ function() {
  function May2() {
  }
  ;
  May2.value = new May2();
  return May2;
}();
var June = /* @__PURE__ */ function() {
  function June2() {
  }
  ;
  June2.value = new June2();
  return June2;
}();
var July = /* @__PURE__ */ function() {
  function July2() {
  }
  ;
  July2.value = new July2();
  return July2;
}();
var August = /* @__PURE__ */ function() {
  function August2() {
  }
  ;
  August2.value = new August2();
  return August2;
}();
var September = /* @__PURE__ */ function() {
  function September2() {
  }
  ;
  September2.value = new September2();
  return September2;
}();
var October = /* @__PURE__ */ function() {
  function October2() {
  }
  ;
  October2.value = new October2();
  return October2;
}();
var November = /* @__PURE__ */ function() {
  function November2() {
  }
  ;
  November2.value = new November2();
  return November2;
}();
var December = /* @__PURE__ */ function() {
  function December2() {
  }
  ;
  December2.value = new December2();
  return December2;
}();
var showWeekday = {
  show: function(v) {
    if (v instanceof Monday) {
      return "Monday";
    }
    ;
    if (v instanceof Tuesday) {
      return "Tuesday";
    }
    ;
    if (v instanceof Wednesday) {
      return "Wednesday";
    }
    ;
    if (v instanceof Thursday) {
      return "Thursday";
    }
    ;
    if (v instanceof Friday) {
      return "Friday";
    }
    ;
    if (v instanceof Saturday) {
      return "Saturday";
    }
    ;
    if (v instanceof Sunday) {
      return "Sunday";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 184, column 1 - line 191, column 25): " + [v.constructor.name]);
  }
};
var showMonth = {
  show: function(v) {
    if (v instanceof January) {
      return "January";
    }
    ;
    if (v instanceof February) {
      return "February";
    }
    ;
    if (v instanceof March) {
      return "March";
    }
    ;
    if (v instanceof April) {
      return "April";
    }
    ;
    if (v instanceof May) {
      return "May";
    }
    ;
    if (v instanceof June) {
      return "June";
    }
    ;
    if (v instanceof July) {
      return "July";
    }
    ;
    if (v instanceof August) {
      return "August";
    }
    ;
    if (v instanceof September) {
      return "September";
    }
    ;
    if (v instanceof October) {
      return "October";
    }
    ;
    if (v instanceof November) {
      return "November";
    }
    ;
    if (v instanceof December) {
      return "December";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 101, column 1 - line 113, column 29): " + [v.constructor.name]);
  }
};
var ordYear = ordInt;
var ordDay = ordInt;
var eqWeekday = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return true;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return true;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return true;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return true;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return true;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return true;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordWeekday = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return EQ.value;
      }
      ;
      if (x instanceof Monday) {
        return LT.value;
      }
      ;
      if (y instanceof Monday) {
        return GT.value;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Tuesday) {
        return LT.value;
      }
      ;
      if (y instanceof Tuesday) {
        return GT.value;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Wednesday) {
        return LT.value;
      }
      ;
      if (y instanceof Wednesday) {
        return GT.value;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return EQ.value;
      }
      ;
      if (x instanceof Thursday) {
        return LT.value;
      }
      ;
      if (y instanceof Thursday) {
        return GT.value;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return EQ.value;
      }
      ;
      if (x instanceof Friday) {
        return LT.value;
      }
      ;
      if (y instanceof Friday) {
        return GT.value;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return EQ.value;
      }
      ;
      if (x instanceof Saturday) {
        return LT.value;
      }
      ;
      if (y instanceof Saturday) {
        return GT.value;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqWeekday;
  }
};
var eqMonth = {
  eq: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return true;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return true;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return true;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return true;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return true;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return true;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return true;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return true;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return true;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return true;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return true;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordMonth = {
  compare: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return EQ.value;
      }
      ;
      if (x instanceof January) {
        return LT.value;
      }
      ;
      if (y instanceof January) {
        return GT.value;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return EQ.value;
      }
      ;
      if (x instanceof February) {
        return LT.value;
      }
      ;
      if (y instanceof February) {
        return GT.value;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return EQ.value;
      }
      ;
      if (x instanceof March) {
        return LT.value;
      }
      ;
      if (y instanceof March) {
        return GT.value;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return EQ.value;
      }
      ;
      if (x instanceof April) {
        return LT.value;
      }
      ;
      if (y instanceof April) {
        return GT.value;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return EQ.value;
      }
      ;
      if (x instanceof May) {
        return LT.value;
      }
      ;
      if (y instanceof May) {
        return GT.value;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return EQ.value;
      }
      ;
      if (x instanceof June) {
        return LT.value;
      }
      ;
      if (y instanceof June) {
        return GT.value;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return EQ.value;
      }
      ;
      if (x instanceof July) {
        return LT.value;
      }
      ;
      if (y instanceof July) {
        return GT.value;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return EQ.value;
      }
      ;
      if (x instanceof August) {
        return LT.value;
      }
      ;
      if (y instanceof August) {
        return GT.value;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return EQ.value;
      }
      ;
      if (x instanceof September) {
        return LT.value;
      }
      ;
      if (y instanceof September) {
        return GT.value;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return EQ.value;
      }
      ;
      if (x instanceof October) {
        return LT.value;
      }
      ;
      if (y instanceof October) {
        return GT.value;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return EQ.value;
      }
      ;
      if (x instanceof November) {
        return LT.value;
      }
      ;
      if (y instanceof November) {
        return GT.value;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqMonth;
  }
};
var boundedYear = /* @__PURE__ */ function() {
  return {
    bottom: -271820 | 0,
    top: 275759,
    Ord0: function() {
      return ordYear;
    }
  };
}();
var boundedWeekday = /* @__PURE__ */ function() {
  return {
    bottom: Monday.value,
    top: Sunday.value,
    Ord0: function() {
      return ordWeekday;
    }
  };
}();
var boundedMonth = /* @__PURE__ */ function() {
  return {
    bottom: January.value,
    top: December.value,
    Ord0: function() {
      return ordMonth;
    }
  };
}();
var boundedEnumYear = {
  cardinality: 547580,
  toEnum: function(n) {
    if (n >= (-271820 | 0) && n <= 275759) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 35, column 1 - line 40, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedYear;
  },
  Enum1: function() {
    return $lazy_enumYear(0);
  }
};
var $lazy_enumYear = /* @__PURE__ */ $runtime_lazy6("enumYear", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $55 = toEnum(boundedEnumYear);
      var $56 = fromEnum(boundedEnumYear);
      return function($57) {
        return $55(function(v) {
          return v + 1 | 0;
        }($56($57)));
      };
    }(),
    pred: function() {
      var $58 = toEnum(boundedEnumYear);
      var $59 = fromEnum(boundedEnumYear);
      return function($60) {
        return $58(function(v) {
          return v - 1 | 0;
        }($59($60)));
      };
    }(),
    Ord0: function() {
      return ordYear;
    }
  };
});
var boundedEnumWeekday = {
  cardinality: 7,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(Monday.value);
    }
    ;
    if (v === 2) {
      return new Just(Tuesday.value);
    }
    ;
    if (v === 3) {
      return new Just(Wednesday.value);
    }
    ;
    if (v === 4) {
      return new Just(Thursday.value);
    }
    ;
    if (v === 5) {
      return new Just(Friday.value);
    }
    ;
    if (v === 6) {
      return new Just(Saturday.value);
    }
    ;
    if (v === 7) {
      return new Just(Sunday.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Monday) {
      return 1;
    }
    ;
    if (v instanceof Tuesday) {
      return 2;
    }
    ;
    if (v instanceof Wednesday) {
      return 3;
    }
    ;
    if (v instanceof Thursday) {
      return 4;
    }
    ;
    if (v instanceof Friday) {
      return 5;
    }
    ;
    if (v instanceof Saturday) {
      return 6;
    }
    ;
    if (v instanceof Sunday) {
      return 7;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 175, column 14 - line 182, column 16): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedWeekday;
  },
  Enum1: function() {
    return $lazy_enumWeekday(0);
  }
};
var $lazy_enumWeekday = /* @__PURE__ */ $runtime_lazy6("enumWeekday", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $61 = toEnum(boundedEnumWeekday);
      var $62 = fromEnum(boundedEnumWeekday);
      return function($63) {
        return $61(function(v) {
          return v + 1 | 0;
        }($62($63)));
      };
    }(),
    pred: function() {
      var $64 = toEnum(boundedEnumWeekday);
      var $65 = fromEnum(boundedEnumWeekday);
      return function($66) {
        return $64(function(v) {
          return v - 1 | 0;
        }($65($66)));
      };
    }(),
    Ord0: function() {
      return ordWeekday;
    }
  };
});
var boundedEnumMonth = {
  cardinality: 12,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(January.value);
    }
    ;
    if (v === 2) {
      return new Just(February.value);
    }
    ;
    if (v === 3) {
      return new Just(March.value);
    }
    ;
    if (v === 4) {
      return new Just(April.value);
    }
    ;
    if (v === 5) {
      return new Just(May.value);
    }
    ;
    if (v === 6) {
      return new Just(June.value);
    }
    ;
    if (v === 7) {
      return new Just(July.value);
    }
    ;
    if (v === 8) {
      return new Just(August.value);
    }
    ;
    if (v === 9) {
      return new Just(September.value);
    }
    ;
    if (v === 10) {
      return new Just(October.value);
    }
    ;
    if (v === 11) {
      return new Just(November.value);
    }
    ;
    if (v === 12) {
      return new Just(December.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof January) {
      return 1;
    }
    ;
    if (v instanceof February) {
      return 2;
    }
    ;
    if (v instanceof March) {
      return 3;
    }
    ;
    if (v instanceof April) {
      return 4;
    }
    ;
    if (v instanceof May) {
      return 5;
    }
    ;
    if (v instanceof June) {
      return 6;
    }
    ;
    if (v instanceof July) {
      return 7;
    }
    ;
    if (v instanceof August) {
      return 8;
    }
    ;
    if (v instanceof September) {
      return 9;
    }
    ;
    if (v instanceof October) {
      return 10;
    }
    ;
    if (v instanceof November) {
      return 11;
    }
    ;
    if (v instanceof December) {
      return 12;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 87, column 14 - line 99, column 19): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedMonth;
  },
  Enum1: function() {
    return $lazy_enumMonth(0);
  }
};
var $lazy_enumMonth = /* @__PURE__ */ $runtime_lazy6("enumMonth", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $67 = toEnum(boundedEnumMonth);
      var $68 = fromEnum(boundedEnumMonth);
      return function($69) {
        return $67(function(v) {
          return v + 1 | 0;
        }($68($69)));
      };
    }(),
    pred: function() {
      var $70 = toEnum(boundedEnumMonth);
      var $71 = fromEnum(boundedEnumMonth);
      return function($72) {
        return $70(function(v) {
          return v - 1 | 0;
        }($71($72)));
      };
    }(),
    Ord0: function() {
      return ordMonth;
    }
  };
});
var boundedDay = {
  bottom: 1,
  top: 31,
  Ord0: function() {
    return ordDay;
  }
};
var boundedEnumDay = {
  cardinality: 31,
  toEnum: function(n) {
    if (n >= 1 && n <= 31) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 133, column 1 - line 138, column 23): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedDay;
  },
  Enum1: function() {
    return $lazy_enumDay(0);
  }
};
var $lazy_enumDay = /* @__PURE__ */ $runtime_lazy6("enumDay", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $73 = toEnum(boundedEnumDay);
      var $74 = fromEnum(boundedEnumDay);
      return function($75) {
        return $73(function(v) {
          return v + 1 | 0;
        }($74($75)));
      };
    }(),
    pred: function() {
      var $76 = toEnum(boundedEnumDay);
      var $77 = fromEnum(boundedEnumDay);
      return function($78) {
        return $76(function(v) {
          return v - 1 | 0;
        }($77($78)));
      };
    }(),
    Ord0: function() {
      return ordDay;
    }
  };
});

// output/Data.Date/index.js
var fromEnum3 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromJust6 = /* @__PURE__ */ fromJust();
var toEnum2 = /* @__PURE__ */ toEnum(boundedEnumWeekday);
var toEnum22 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var $$Date = /* @__PURE__ */ function() {
  function $$Date2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  $$Date2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new $$Date2(value0, value12, value22);
      };
    };
  };
  return $$Date2;
}();
var year = function(v) {
  return v.value0;
};
var weekday = function(v) {
  var n = calcWeekday(v.value0, fromEnum3(v.value1), v.value2);
  var $86 = n === 0;
  if ($86) {
    return fromJust6(toEnum2(7));
  }
  ;
  return fromJust6(toEnum2(n));
};
var month = function(v) {
  return v.value1;
};
var day = function(v) {
  return v.value2;
};
var canonicalDate = function(y) {
  return function(m) {
    return function(d) {
      var mkDate = function(y$prime) {
        return function(m$prime) {
          return function(d$prime) {
            return new $$Date(y$prime, fromJust6(toEnum22(m$prime)), d$prime);
          };
        };
      };
      return canonicalDateImpl(mkDate, y, fromEnum3(m), d);
    };
  };
};

// output/Data.Time.Component/index.js
var $runtime_lazy7 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var ordSecond = ordInt;
var ordMinute = ordInt;
var ordMillisecond = ordInt;
var ordHour = ordInt;
var eqSecond = eqInt;
var eqMinute = eqInt;
var eqMillisecond = eqInt;
var eqHour = eqInt;
var boundedSecond = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordSecond;
  }
};
var boundedMinute = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordMinute;
  }
};
var boundedMillisecond = {
  bottom: 0,
  top: 999,
  Ord0: function() {
    return ordMillisecond;
  }
};
var boundedHour = {
  bottom: 0,
  top: 23,
  Ord0: function() {
    return ordHour;
  }
};
var boundedEnumSecond = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 90, column 1 - line 95, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedSecond;
  },
  Enum1: function() {
    return $lazy_enumSecond(0);
  }
};
var $lazy_enumSecond = /* @__PURE__ */ $runtime_lazy7("enumSecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $36 = toEnum(boundedEnumSecond);
      var $37 = fromEnum(boundedEnumSecond);
      return function($38) {
        return $36(function(v) {
          return v + 1 | 0;
        }($37($38)));
      };
    }(),
    pred: function() {
      var $39 = toEnum(boundedEnumSecond);
      var $40 = fromEnum(boundedEnumSecond);
      return function($41) {
        return $39(function(v) {
          return v - 1 | 0;
        }($40($41)));
      };
    }(),
    Ord0: function() {
      return ordSecond;
    }
  };
});
var boundedEnumMinute = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 61, column 1 - line 66, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMinute;
  },
  Enum1: function() {
    return $lazy_enumMinute(0);
  }
};
var $lazy_enumMinute = /* @__PURE__ */ $runtime_lazy7("enumMinute", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $42 = toEnum(boundedEnumMinute);
      var $43 = fromEnum(boundedEnumMinute);
      return function($44) {
        return $42(function(v) {
          return v + 1 | 0;
        }($43($44)));
      };
    }(),
    pred: function() {
      var $45 = toEnum(boundedEnumMinute);
      var $46 = fromEnum(boundedEnumMinute);
      return function($47) {
        return $45(function(v) {
          return v - 1 | 0;
        }($46($47)));
      };
    }(),
    Ord0: function() {
      return ordMinute;
    }
  };
});
var boundedEnumMillisecond = {
  cardinality: 1e3,
  toEnum: function(n) {
    if (n >= 0 && n <= 999) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 120, column 1 - line 125, column 31): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMillisecond;
  },
  Enum1: function() {
    return $lazy_enumMillisecond(0);
  }
};
var $lazy_enumMillisecond = /* @__PURE__ */ $runtime_lazy7("enumMillisecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $48 = toEnum(boundedEnumMillisecond);
      var $49 = fromEnum(boundedEnumMillisecond);
      return function($50) {
        return $48(function(v) {
          return v + 1 | 0;
        }($49($50)));
      };
    }(),
    pred: function() {
      var $51 = toEnum(boundedEnumMillisecond);
      var $52 = fromEnum(boundedEnumMillisecond);
      return function($53) {
        return $51(function(v) {
          return v - 1 | 0;
        }($52($53)));
      };
    }(),
    Ord0: function() {
      return ordMillisecond;
    }
  };
});
var boundedEnumHour = {
  cardinality: 24,
  toEnum: function(n) {
    if (n >= 0 && n <= 23) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 32, column 1 - line 37, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedHour;
  },
  Enum1: function() {
    return $lazy_enumHour(0);
  }
};
var $lazy_enumHour = /* @__PURE__ */ $runtime_lazy7("enumHour", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $54 = toEnum(boundedEnumHour);
      var $55 = fromEnum(boundedEnumHour);
      return function($56) {
        return $54(function(v) {
          return v + 1 | 0;
        }($55($56)));
      };
    }(),
    pred: function() {
      var $57 = toEnum(boundedEnumHour);
      var $58 = fromEnum(boundedEnumHour);
      return function($59) {
        return $57(function(v) {
          return v - 1 | 0;
        }($58($59)));
      };
    }(),
    Ord0: function() {
      return ordHour;
    }
  };
});

// output/Data.Time/index.js
var eq4 = /* @__PURE__ */ eq(eqHour);
var eq15 = /* @__PURE__ */ eq(eqMinute);
var eq22 = /* @__PURE__ */ eq(eqSecond);
var eq32 = /* @__PURE__ */ eq(eqMillisecond);
var compare3 = /* @__PURE__ */ compare(ordHour);
var compare13 = /* @__PURE__ */ compare(ordMinute);
var compare22 = /* @__PURE__ */ compare(ordSecond);
var compare32 = /* @__PURE__ */ compare(ordMillisecond);
var Time = /* @__PURE__ */ function() {
  function Time2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  Time2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new Time2(value0, value12, value22, value32);
        };
      };
    };
  };
  return Time2;
}();
var second = function(v) {
  return v.value2;
};
var minute = function(v) {
  return v.value1;
};
var millisecond = function(v) {
  return v.value3;
};
var hour = function(v) {
  return v.value0;
};
var eqTime = {
  eq: function(x) {
    return function(y) {
      return eq4(x.value0)(y.value0) && eq15(x.value1)(y.value1) && eq22(x.value2)(y.value2) && eq32(x.value3)(y.value3);
    };
  }
};
var ordTime = {
  compare: function(x) {
    return function(y) {
      var v = compare3(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      var v1 = compare13(x.value1)(y.value1);
      if (v1 instanceof LT) {
        return LT.value;
      }
      ;
      if (v1 instanceof GT) {
        return GT.value;
      }
      ;
      var v2 = compare22(x.value2)(y.value2);
      if (v2 instanceof LT) {
        return LT.value;
      }
      ;
      if (v2 instanceof GT) {
        return GT.value;
      }
      ;
      return compare32(x.value3)(y.value3);
    };
  },
  Eq0: function() {
    return eqTime;
  }
};
var boundedTime = /* @__PURE__ */ function() {
  return {
    bottom: new Time(bottom(boundedHour), bottom(boundedMinute), bottom(boundedSecond), bottom(boundedMillisecond)),
    top: new Time(top(boundedHour), top(boundedMinute), top(boundedSecond), top(boundedMillisecond)),
    Ord0: function() {
      return ordTime;
    }
  };
}();

// output/Data.DateTime/index.js
var fromEnum4 = /* @__PURE__ */ fromEnum(boundedEnumYear);
var fromEnum1 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromEnum22 = /* @__PURE__ */ fromEnum(boundedEnumDay);
var fromEnum32 = /* @__PURE__ */ fromEnum(boundedEnumHour);
var fromEnum42 = /* @__PURE__ */ fromEnum(boundedEnumMinute);
var fromEnum5 = /* @__PURE__ */ fromEnum(boundedEnumSecond);
var fromEnum6 = /* @__PURE__ */ fromEnum(boundedEnumMillisecond);
var DateTime = /* @__PURE__ */ function() {
  function DateTime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DateTime2.create = function(value0) {
    return function(value12) {
      return new DateTime2(value0, value12);
    };
  };
  return DateTime2;
}();
var toRecord = function(v) {
  return {
    year: fromEnum4(year(v.value0)),
    month: fromEnum1(month(v.value0)),
    day: fromEnum22(day(v.value0)),
    hour: fromEnum32(hour(v.value1)),
    minute: fromEnum42(minute(v.value1)),
    second: fromEnum5(second(v.value1)),
    millisecond: fromEnum6(millisecond(v.value1))
  };
};
var diff = function(dictDuration) {
  var toDuration2 = toDuration(dictDuration);
  return function(dt1) {
    return function(dt2) {
      return toDuration2(calcDiff(toRecord(dt1), toRecord(dt2)));
    };
  };
};
var date = function(v) {
  return v.value0;
};

// output/Data.DateTime.Instant/foreign.js
var createDateTime = function(y, m, d, h, mi, s, ms) {
  var dateTime = new Date(Date.UTC(y, m, d, h, mi, s, ms));
  if (y >= 0 && y < 100) {
    dateTime.setUTCFullYear(y);
  }
  return dateTime;
};
function fromDateTimeImpl(y, mo, d, h, mi, s, ms) {
  return createDateTime(y, mo - 1, d, h, mi, s, ms).getTime();
}
function toDateTimeImpl(ctor) {
  return function(instant2) {
    var dt = new Date(instant2);
    return ctor(dt.getUTCFullYear())(dt.getUTCMonth() + 1)(dt.getUTCDate())(dt.getUTCHours())(dt.getUTCMinutes())(dt.getUTCSeconds())(dt.getUTCMilliseconds());
  };
}

// output/Data.DateTime.Instant/index.js
var fromJust7 = /* @__PURE__ */ fromJust();
var toEnum3 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var show4 = /* @__PURE__ */ show(showMilliseconds);
var fromEnum7 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var append15 = /* @__PURE__ */ append(semigroupMilliseconds);
var negateDuration2 = /* @__PURE__ */ negateDuration(durationMilliseconds);
var unInstant = function(v) {
  return v;
};
var toDateTime = /* @__PURE__ */ function() {
  var mkDateTime = function(y) {
    return function(mo) {
      return function(d) {
        return function(h) {
          return function(mi) {
            return function(s) {
              return function(ms) {
                return new DateTime(canonicalDate(y)(fromJust7(toEnum3(mo)))(d), new Time(h, mi, s, ms));
              };
            };
          };
        };
      };
    };
  };
  return toDateTimeImpl(mkDateTime);
}();
var showInstant = {
  show: function(v) {
    return "(Instant " + (show4(v) + ")");
  }
};
var instant = function(v) {
  if (v >= -86399778816e5 && v <= 8639977881599999) {
    return new Just(v);
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.DateTime.Instant (line 44, column 1 - line 44, column 41): " + [v.constructor.name]);
};
var fromDateTime = function(v) {
  return fromDateTimeImpl(year(v.value0), fromEnum7(month(v.value0)), day(v.value0), hour(v.value1), minute(v.value1), second(v.value1), millisecond(v.value1));
};
var diff2 = function(dictDuration) {
  var toDuration2 = toDuration(dictDuration);
  return function(dt1) {
    return function(dt2) {
      return toDuration2(append15(unInstant(dt1))(negateDuration2(unInstant(dt2))));
    };
  };
};

// output/Effect.Now/index.js
var map25 = /* @__PURE__ */ map(functorEffect);
var nowDateTime = /* @__PURE__ */ map25(toDateTime)(now);

// output/Node.Path/foreign.js
import path from "path";
var normalize = path.normalize;
function concat3(segments) {
  return path.join.apply(this, segments);
}
function resolve(from4) {
  return (to2) => () => path.resolve.apply(this, from4.concat([to2]));
}
function relative(from4) {
  return (to2) => path.relative(from4, to2);
}
function dirname(p) {
  return path.normalize(path.dirname(p));
}
var basename = path.basename;
var extname = path.extname;
var sep = path.sep;
var delimiter = path.delimiter;
var parse2 = path.parse;
var isAbsolute = path.isAbsolute;

// output/Node.Process/foreign.js
import process3 from "process";
var abortImpl = process3.abort ? () => process3.abort() : null;
var argv = () => process3.argv.slice();
var channelRefImpl = process3.channel && process3.channel.ref ? () => process3.channel.ref() : null;
var channelUnrefImpl = process3.channel && process3.channel.unref ? () => process3.channel.unref() : null;
var chdirImpl = (dir) => process3.chdir(dir);
var cwd = () => process3.cwd();
var debugPort = process3.debugPort;
var disconnectImpl = process3.disconnect ? () => process3.disconnect() : null;
var getEnv = () => Object.assign({}, process3.env);
var execPath = () => process3.execPath;
var exit = () => process3.exit();
var exitImpl = (code3) => process3.exit(code3);
var setExitCodeImpl = (code3) => {
  process3.exitCode = code3;
};
var getExitCodeImpl = () => process3.exitCode;
var getGidImpl = () => process3.getgid();
var getUidImpl = () => process3.getuid();
var killStrImpl = (pid3, sig) => process3.kill(pid3, sig);
var pid = process3.pid;
var platformStr = process3.platform;
var ppid = process3.ppid;
var stdin = process3.stdin;
var stdout = process3.stdout;
var stderr = process3.stderr;
var stdinIsTTY = process3.stdinIsTTY;
var stdoutIsTTY = process3.stdoutIsTTY;
var stderrIsTTY = process3.stderrIsTTY;
var version = process3.version;

// output/Data.Nullable/foreign.js
var nullImpl = null;
function nullable2(a, r, f) {
  return a == null ? r : f(a);
}
function notNull(x) {
  return x;
}

// output/Data.Nullable/index.js
var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);
var toMaybe = function(n) {
  return nullable2(n, Nothing.value, Just.create);
};
var showNullable = function(dictShow) {
  return {
    show: function() {
      var $17 = maybe("null")(show(dictShow));
      return function($18) {
        return $17(toMaybe($18));
      };
    }()
  };
};

// output/Effect.Uncurried/foreign.js
var mkEffectFn1 = function mkEffectFn12(fn) {
  return function(x) {
    return fn(x)();
  };
};
var runEffectFn1 = function runEffectFn12(fn) {
  return function(a) {
    return function() {
      return fn(a);
    };
  };
};
var runEffectFn2 = function runEffectFn22(fn) {
  return function(a) {
    return function(b) {
      return function() {
        return fn(a, b);
      };
    };
  };
};

// output/Node.EventEmitter/foreign.js
import EventEmitter from "node:events";
var newImpl2 = function() {
  return new EventEmitter();
};
var unsafeEmitFn = (emitter) => emitter.emit.bind(emitter);
var listenerCountImpl = (emitter, eventName) => emitter.listenerCount(eventName);
var unsafeOff = (emitter, eventName, cb) => emitter.off(eventName, cb);
var unsafeOn = (emitter, eventName, cb) => emitter.on(eventName, cb);
var unsafeOnce = (emitter, eventName, cb) => emitter.once(eventName, cb);
var setMaxListenersImpl = (emitter, max8) => emitter.setMaxListeners(max8);

// output/Node.EventEmitter/index.js
var EventHandle = /* @__PURE__ */ function() {
  function EventHandle2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  EventHandle2.create = function(value0) {
    return function(value12) {
      return new EventHandle2(value0, value12);
    };
  };
  return EventHandle2;
}();
var subscribeSameFunction = function(onXFn, eventEmitter, eventName, jsCb) {
  onXFn(eventEmitter, eventName, jsCb);
  return function() {
    return unsafeOff(eventEmitter, eventName, jsCb);
  };
};
var setMaxListeners = function(max8) {
  return function(emitter) {
    return function() {
      return setMaxListenersImpl(emitter, max8);
    };
  };
};
var setUnlimitedListeners = /* @__PURE__ */ setMaxListeners(0);
var once_ = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return unsafeOnce(eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var once = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return subscribeSameFunction(unsafeOnce, eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var on2 = function(v) {
  return function(psCb) {
    return function(eventEmitter) {
      return function() {
        return subscribeSameFunction(unsafeOn, eventEmitter, v.value0, v.value1(psCb));
      };
    };
  };
};
var listenerCount = function(emitter) {
  return function(eventName) {
    return function() {
      return listenerCountImpl(emitter, eventName);
    };
  };
};

// output/Node.Platform/index.js
var AIX = /* @__PURE__ */ function() {
  function AIX2() {
  }
  ;
  AIX2.value = new AIX2();
  return AIX2;
}();
var Darwin = /* @__PURE__ */ function() {
  function Darwin2() {
  }
  ;
  Darwin2.value = new Darwin2();
  return Darwin2;
}();
var FreeBSD = /* @__PURE__ */ function() {
  function FreeBSD2() {
  }
  ;
  FreeBSD2.value = new FreeBSD2();
  return FreeBSD2;
}();
var Linux = /* @__PURE__ */ function() {
  function Linux2() {
  }
  ;
  Linux2.value = new Linux2();
  return Linux2;
}();
var OpenBSD = /* @__PURE__ */ function() {
  function OpenBSD2() {
  }
  ;
  OpenBSD2.value = new OpenBSD2();
  return OpenBSD2;
}();
var SunOS = /* @__PURE__ */ function() {
  function SunOS2() {
  }
  ;
  SunOS2.value = new SunOS2();
  return SunOS2;
}();
var Win32 = /* @__PURE__ */ function() {
  function Win322() {
  }
  ;
  Win322.value = new Win322();
  return Win322;
}();
var Android = /* @__PURE__ */ function() {
  function Android2() {
  }
  ;
  Android2.value = new Android2();
  return Android2;
}();
var fromString5 = function(v) {
  if (v === "aix") {
    return new Just(AIX.value);
  }
  ;
  if (v === "darwin") {
    return new Just(Darwin.value);
  }
  ;
  if (v === "freebsd") {
    return new Just(FreeBSD.value);
  }
  ;
  if (v === "linux") {
    return new Just(Linux.value);
  }
  ;
  if (v === "openbsd") {
    return new Just(OpenBSD.value);
  }
  ;
  if (v === "sunos") {
    return new Just(SunOS.value);
  }
  ;
  if (v === "win32") {
    return new Just(Win32.value);
  }
  ;
  if (v === "android") {
    return new Just(Android.value);
  }
  ;
  return Nothing.value;
};
var eqPlatform = {
  eq: function(x) {
    return function(y) {
      if (x instanceof AIX && y instanceof AIX) {
        return true;
      }
      ;
      if (x instanceof Darwin && y instanceof Darwin) {
        return true;
      }
      ;
      if (x instanceof FreeBSD && y instanceof FreeBSD) {
        return true;
      }
      ;
      if (x instanceof Linux && y instanceof Linux) {
        return true;
      }
      ;
      if (x instanceof OpenBSD && y instanceof OpenBSD) {
        return true;
      }
      ;
      if (x instanceof SunOS && y instanceof SunOS) {
        return true;
      }
      ;
      if (x instanceof Win32 && y instanceof Win32) {
        return true;
      }
      ;
      if (x instanceof Android && y instanceof Android) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Node.Process/index.js
var identity15 = /* @__PURE__ */ identity(categoryFn);
var map26 = /* @__PURE__ */ map(functorEffect);
var setExitCode = function(code3) {
  return function() {
    return setExitCodeImpl(code3);
  };
};
var platform = /* @__PURE__ */ fromString5(platformStr);
var mkSignalH$prime = function(sig) {
  return new EventHandle(toUpper(sig), identity15);
};
var killStr = function(p) {
  return function(sig) {
    return function() {
      return killStrImpl(p, sig);
    };
  };
};
var getUid = /* @__PURE__ */ map26(toMaybe)(getUidImpl);
var getGid = /* @__PURE__ */ map26(toMaybe)(getGidImpl);
var getExitCode = /* @__PURE__ */ map26(toMaybe)(getExitCodeImpl);
var exit$prime = function(code3) {
  return function() {
    return exitImpl(code3);
  };
};
var chdir = function(dir) {
  return function() {
    return chdirImpl(dir);
  };
};

// output/ExitCodes/index.js
var Success = /* @__PURE__ */ function() {
  function Success4() {
  }
  ;
  Success4.value = new Success4();
  return Success4;
}();
var $$Error = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var MisuseOfShellBuiltins = /* @__PURE__ */ function() {
  function MisuseOfShellBuiltins2() {
  }
  ;
  MisuseOfShellBuiltins2.value = new MisuseOfShellBuiltins2();
  return MisuseOfShellBuiltins2;
}();
var CLIUsageError = /* @__PURE__ */ function() {
  function CLIUsageError2() {
  }
  ;
  CLIUsageError2.value = new CLIUsageError2();
  return CLIUsageError2;
}();
var DataFormatError = /* @__PURE__ */ function() {
  function DataFormatError2() {
  }
  ;
  DataFormatError2.value = new DataFormatError2();
  return DataFormatError2;
}();
var CannotOpenInput = /* @__PURE__ */ function() {
  function CannotOpenInput2() {
  }
  ;
  CannotOpenInput2.value = new CannotOpenInput2();
  return CannotOpenInput2;
}();
var AddresseeUnknown = /* @__PURE__ */ function() {
  function AddresseeUnknown2() {
  }
  ;
  AddresseeUnknown2.value = new AddresseeUnknown2();
  return AddresseeUnknown2;
}();
var HostNameUnknown = /* @__PURE__ */ function() {
  function HostNameUnknown2() {
  }
  ;
  HostNameUnknown2.value = new HostNameUnknown2();
  return HostNameUnknown2;
}();
var ServiceUnavailable = /* @__PURE__ */ function() {
  function ServiceUnavailable2() {
  }
  ;
  ServiceUnavailable2.value = new ServiceUnavailable2();
  return ServiceUnavailable2;
}();
var InternalSoftwareError = /* @__PURE__ */ function() {
  function InternalSoftwareError2() {
  }
  ;
  InternalSoftwareError2.value = new InternalSoftwareError2();
  return InternalSoftwareError2;
}();
var SystemError = /* @__PURE__ */ function() {
  function SystemError2() {
  }
  ;
  SystemError2.value = new SystemError2();
  return SystemError2;
}();
var CriticalOSFileMissing = /* @__PURE__ */ function() {
  function CriticalOSFileMissing2() {
  }
  ;
  CriticalOSFileMissing2.value = new CriticalOSFileMissing2();
  return CriticalOSFileMissing2;
}();
var CannotCreateOutputFile = /* @__PURE__ */ function() {
  function CannotCreateOutputFile2() {
  }
  ;
  CannotCreateOutputFile2.value = new CannotCreateOutputFile2();
  return CannotCreateOutputFile2;
}();
var IOError = /* @__PURE__ */ function() {
  function IOError2() {
  }
  ;
  IOError2.value = new IOError2();
  return IOError2;
}();
var TemporaryFailure = /* @__PURE__ */ function() {
  function TemporaryFailure2() {
  }
  ;
  TemporaryFailure2.value = new TemporaryFailure2();
  return TemporaryFailure2;
}();
var RemoteError = /* @__PURE__ */ function() {
  function RemoteError2() {
  }
  ;
  RemoteError2.value = new RemoteError2();
  return RemoteError2;
}();
var PermissionDenied = /* @__PURE__ */ function() {
  function PermissionDenied2() {
  }
  ;
  PermissionDenied2.value = new PermissionDenied2();
  return PermissionDenied2;
}();
var ConfigurationError = /* @__PURE__ */ function() {
  function ConfigurationError2() {
  }
  ;
  ConfigurationError2.value = new ConfigurationError2();
  return ConfigurationError2;
}();
var CannotExecute = /* @__PURE__ */ function() {
  function CannotExecute2() {
  }
  ;
  CannotExecute2.value = new CannotExecute2();
  return CannotExecute2;
}();
var CommandNotFound = /* @__PURE__ */ function() {
  function CommandNotFound2() {
  }
  ;
  CommandNotFound2.value = new CommandNotFound2();
  return CommandNotFound2;
}();
var InvalidExitArgument = /* @__PURE__ */ function() {
  function InvalidExitArgument2() {
  }
  ;
  InvalidExitArgument2.value = new InvalidExitArgument2();
  return InvalidExitArgument2;
}();
var SIGHUP = /* @__PURE__ */ function() {
  function SIGHUP2() {
  }
  ;
  SIGHUP2.value = new SIGHUP2();
  return SIGHUP2;
}();
var SIGINT = /* @__PURE__ */ function() {
  function SIGINT2() {
  }
  ;
  SIGINT2.value = new SIGINT2();
  return SIGINT2;
}();
var SIGQUIT = /* @__PURE__ */ function() {
  function SIGQUIT2() {
  }
  ;
  SIGQUIT2.value = new SIGQUIT2();
  return SIGQUIT2;
}();
var SIGILL = /* @__PURE__ */ function() {
  function SIGILL2() {
  }
  ;
  SIGILL2.value = new SIGILL2();
  return SIGILL2;
}();
var SIGABRT = /* @__PURE__ */ function() {
  function SIGABRT2() {
  }
  ;
  SIGABRT2.value = new SIGABRT2();
  return SIGABRT2;
}();
var SIGFPE = /* @__PURE__ */ function() {
  function SIGFPE2() {
  }
  ;
  SIGFPE2.value = new SIGFPE2();
  return SIGFPE2;
}();
var SIGKILL = /* @__PURE__ */ function() {
  function SIGKILL2() {
  }
  ;
  SIGKILL2.value = new SIGKILL2();
  return SIGKILL2;
}();
var SIGSEGV = /* @__PURE__ */ function() {
  function SIGSEGV2() {
  }
  ;
  SIGSEGV2.value = new SIGSEGV2();
  return SIGSEGV2;
}();
var SIGPIPE = /* @__PURE__ */ function() {
  function SIGPIPE2() {
  }
  ;
  SIGPIPE2.value = new SIGPIPE2();
  return SIGPIPE2;
}();
var SIGALRM = /* @__PURE__ */ function() {
  function SIGALRM2() {
  }
  ;
  SIGALRM2.value = new SIGALRM2();
  return SIGALRM2;
}();
var SIGTERM = /* @__PURE__ */ function() {
  function SIGTERM2() {
  }
  ;
  SIGTERM2.value = new SIGTERM2();
  return SIGTERM2;
}();
var eqExitCode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return true;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return true;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return true;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return true;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return true;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return true;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return true;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return true;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return true;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return true;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return true;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return true;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return true;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return true;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return true;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return true;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return true;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return true;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return true;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return true;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return true;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return true;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return true;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return true;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return true;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return true;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return true;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return true;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return true;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return true;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return true;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordExitCode = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return EQ.value;
      }
      ;
      if (x instanceof Success) {
        return LT.value;
      }
      ;
      if (y instanceof Success) {
        return GT.value;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return EQ.value;
      }
      ;
      if (x instanceof $$Error) {
        return LT.value;
      }
      ;
      if (y instanceof $$Error) {
        return GT.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return EQ.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins) {
        return LT.value;
      }
      ;
      if (y instanceof MisuseOfShellBuiltins) {
        return GT.value;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return EQ.value;
      }
      ;
      if (x instanceof CLIUsageError) {
        return LT.value;
      }
      ;
      if (y instanceof CLIUsageError) {
        return GT.value;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return EQ.value;
      }
      ;
      if (x instanceof DataFormatError) {
        return LT.value;
      }
      ;
      if (y instanceof DataFormatError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotOpenInput) {
        return LT.value;
      }
      ;
      if (y instanceof CannotOpenInput) {
        return GT.value;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof AddresseeUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof AddresseeUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof HostNameUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof HostNameUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return EQ.value;
      }
      ;
      if (x instanceof ServiceUnavailable) {
        return LT.value;
      }
      ;
      if (y instanceof ServiceUnavailable) {
        return GT.value;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return EQ.value;
      }
      ;
      if (x instanceof InternalSoftwareError) {
        return LT.value;
      }
      ;
      if (y instanceof InternalSoftwareError) {
        return GT.value;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return EQ.value;
      }
      ;
      if (x instanceof SystemError) {
        return LT.value;
      }
      ;
      if (y instanceof SystemError) {
        return GT.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return EQ.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing) {
        return LT.value;
      }
      ;
      if (y instanceof CriticalOSFileMissing) {
        return GT.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile) {
        return LT.value;
      }
      ;
      if (y instanceof CannotCreateOutputFile) {
        return GT.value;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return EQ.value;
      }
      ;
      if (x instanceof IOError) {
        return LT.value;
      }
      ;
      if (y instanceof IOError) {
        return GT.value;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return EQ.value;
      }
      ;
      if (x instanceof TemporaryFailure) {
        return LT.value;
      }
      ;
      if (y instanceof TemporaryFailure) {
        return GT.value;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return EQ.value;
      }
      ;
      if (x instanceof RemoteError) {
        return LT.value;
      }
      ;
      if (y instanceof RemoteError) {
        return GT.value;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return EQ.value;
      }
      ;
      if (x instanceof PermissionDenied) {
        return LT.value;
      }
      ;
      if (y instanceof PermissionDenied) {
        return GT.value;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return EQ.value;
      }
      ;
      if (x instanceof ConfigurationError) {
        return LT.value;
      }
      ;
      if (y instanceof ConfigurationError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotExecute) {
        return LT.value;
      }
      ;
      if (y instanceof CannotExecute) {
        return GT.value;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return EQ.value;
      }
      ;
      if (x instanceof CommandNotFound) {
        return LT.value;
      }
      ;
      if (y instanceof CommandNotFound) {
        return GT.value;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return EQ.value;
      }
      ;
      if (x instanceof InvalidExitArgument) {
        return LT.value;
      }
      ;
      if (y instanceof InvalidExitArgument) {
        return GT.value;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGHUP) {
        return LT.value;
      }
      ;
      if (y instanceof SIGHUP) {
        return GT.value;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGINT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGINT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGQUIT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGQUIT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGABRT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGABRT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGFPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGFPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGKILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGKILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGSEGV) {
        return LT.value;
      }
      ;
      if (y instanceof SIGSEGV) {
        return GT.value;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGPIPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGPIPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGALRM) {
        return LT.value;
      }
      ;
      if (y instanceof SIGALRM) {
        return GT.value;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at ExitCodes (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqExitCode;
  }
};
var enumExitCode = {
  succ: function(v) {
    if (v instanceof Success) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof $$Error) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGTERM.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  pred: function(v) {
    if (v instanceof Success) {
      return Nothing.value;
    }
    ;
    if (v instanceof $$Error) {
      return new Just(Success.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return new Just(SIGALRM.value);
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  Ord0: function() {
    return ordExitCode;
  }
};
var boundedExitCode = /* @__PURE__ */ function() {
  return {
    bottom: Success.value,
    top: SIGTERM.value,
    Ord0: function() {
      return ordExitCode;
    }
  };
}();
var boundedEnumExitCode = {
  cardinality: 32,
  toEnum: function(v) {
    if (v === 0) {
      return new Just(Success.value);
    }
    ;
    if (v === 1) {
      return new Just($$Error.value);
    }
    ;
    if (v === 2) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v === 64) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v === 65) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v === 66) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v === 67) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v === 68) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v === 69) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v === 70) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v === 71) {
      return new Just(SystemError.value);
    }
    ;
    if (v === 72) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v === 73) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v === 74) {
      return new Just(IOError.value);
    }
    ;
    if (v === 75) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v === 76) {
      return new Just(RemoteError.value);
    }
    ;
    if (v === 77) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v === 78) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v === 126) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v === 127) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v === 128) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v === 129) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v === 130) {
      return new Just(SIGINT.value);
    }
    ;
    if (v === 131) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v === 132) {
      return new Just(SIGILL.value);
    }
    ;
    if (v === 134) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v === 136) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v === 137) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v === 139) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v === 141) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v === 142) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v === 143) {
      return new Just(SIGTERM.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Success) {
      return 0;
    }
    ;
    if (v instanceof $$Error) {
      return 1;
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return 2;
    }
    ;
    if (v instanceof CLIUsageError) {
      return 64;
    }
    ;
    if (v instanceof DataFormatError) {
      return 65;
    }
    ;
    if (v instanceof CannotOpenInput) {
      return 66;
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return 67;
    }
    ;
    if (v instanceof HostNameUnknown) {
      return 68;
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return 69;
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return 70;
    }
    ;
    if (v instanceof SystemError) {
      return 71;
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return 72;
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return 73;
    }
    ;
    if (v instanceof IOError) {
      return 74;
    }
    ;
    if (v instanceof TemporaryFailure) {
      return 75;
    }
    ;
    if (v instanceof RemoteError) {
      return 76;
    }
    ;
    if (v instanceof PermissionDenied) {
      return 77;
    }
    ;
    if (v instanceof ConfigurationError) {
      return 78;
    }
    ;
    if (v instanceof CannotExecute) {
      return 126;
    }
    ;
    if (v instanceof CommandNotFound) {
      return 127;
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return 128;
    }
    ;
    if (v instanceof SIGHUP) {
      return 128 + 1 | 0;
    }
    ;
    if (v instanceof SIGINT) {
      return 128 + 2 | 0;
    }
    ;
    if (v instanceof SIGQUIT) {
      return 128 + 3 | 0;
    }
    ;
    if (v instanceof SIGILL) {
      return 128 + 4 | 0;
    }
    ;
    if (v instanceof SIGABRT) {
      return 128 + 6 | 0;
    }
    ;
    if (v instanceof SIGFPE) {
      return 128 + 8 | 0;
    }
    ;
    if (v instanceof SIGKILL) {
      return 128 + 9 | 0;
    }
    ;
    if (v instanceof SIGSEGV) {
      return 128 + 11 | 0;
    }
    ;
    if (v instanceof SIGPIPE) {
      return 128 + 13 | 0;
    }
    ;
    if (v instanceof SIGALRM) {
      return 128 + 14 | 0;
    }
    ;
    if (v instanceof SIGTERM) {
      return 128 + 15 | 0;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 153, column 1 - line 219, column 30): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedExitCode;
  },
  Enum1: function() {
    return enumExitCode;
  }
};

// output/Options.Applicative.Internal.Utils/index.js
var eq5 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var whitespaceRegex = /* @__PURE__ */ function() {
  var v = regex("\\s+")(noFlags);
  if (v instanceof Left) {
    return unsafeCrashWith("whitespaceRegex: `\\s+` seems to be invlaid, err: " + v.value0);
  }
  ;
  if (v instanceof Right) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Internal.Utils (line 39, column 19 - line 41, column 15): " + [v.constructor.name]);
}();
var words2 = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split2(whitespaceRegex)(v);
};
var unWords = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)(" ");
};
var unLines = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)("\n");
};
var startsWith = function(p) {
  return function(s) {
    return eq5(indexOf2(p)(s))(new Just(0));
  };
};
var lines2 = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split("\n")(v);
};
var apApplyFlipped = function(dictApply) {
  return lift2(dictApply)(applyFlipped);
};

// output/Data.CatQueue/index.js
var CatQueue = /* @__PURE__ */ function() {
  function CatQueue2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatQueue2.create = function(value0) {
    return function(value12) {
      return new CatQueue2(value0, value12);
    };
  };
  return CatQueue2;
}();
var uncons5 = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v.value0 instanceof Nil) {
      $copy_v = new CatQueue(reverse2(v.value1), Nil.value);
      return;
    }
    ;
    if (v.value0 instanceof Cons) {
      $tco_done = true;
      return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var snoc4 = function(v) {
  return function(a) {
    return new CatQueue(v.value0, new Cons(a, v.value1));
  };
};
var $$null6 = function(v) {
  if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var empty9 = /* @__PURE__ */ function() {
  return new CatQueue(Nil.value, Nil.value);
}();

// output/Data.CatList/index.js
var CatNil = /* @__PURE__ */ function() {
  function CatNil2() {
  }
  ;
  CatNil2.value = new CatNil2();
  return CatNil2;
}();
var CatCons = /* @__PURE__ */ function() {
  function CatCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatCons2.create = function(value0) {
    return function(value12) {
      return new CatCons2(value0, value12);
    };
  };
  return CatCons2;
}();
var link = function(v) {
  return function(v1) {
    if (v instanceof CatNil) {
      return v1;
    }
    ;
    if (v1 instanceof CatNil) {
      return v;
    }
    ;
    if (v instanceof CatCons) {
      return new CatCons(v.value0, snoc4(v.value1)(v1));
    }
    ;
    throw new Error("Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): " + [v.constructor.name, v1.constructor.name]);
  };
};
var foldr7 = function(k) {
  return function(b) {
    return function(q) {
      var foldl21 = function($copy_v) {
        return function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v = $copy_v;
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1, v2) {
              if (v2 instanceof Nil) {
                $tco_done = true;
                return v1;
              }
              ;
              if (v2 instanceof Cons) {
                $tco_var_v = v;
                $tco_var_v1 = v(v1)(v2.value0);
                $copy_v2 = v2.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
      };
      var go = function($copy_xs) {
        return function($copy_ys) {
          var $tco_var_xs = $copy_xs;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(xs, ys) {
            var v = uncons5(xs);
            if (v instanceof Nothing) {
              $tco_done1 = true;
              return foldl21(function(x) {
                return function(i) {
                  return i(x);
                };
              })(b)(ys);
            }
            ;
            if (v instanceof Just) {
              $tco_var_xs = v.value0.value1;
              $copy_ys = new Cons(k(v.value0.value0), ys);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_xs, $copy_ys);
          }
          ;
          return $tco_result;
        };
      };
      return go(q)(Nil.value);
    };
  };
};
var uncons6 = function(v) {
  if (v instanceof CatNil) {
    return Nothing.value;
  }
  ;
  if (v instanceof CatCons) {
    return new Just(new Tuple(v.value0, function() {
      var $66 = $$null6(v.value1);
      if ($66) {
        return CatNil.value;
      }
      ;
      return foldr7(link)(CatNil.value)(v.value1);
    }()));
  }
  ;
  throw new Error("Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var empty10 = /* @__PURE__ */ function() {
  return CatNil.value;
}();
var append4 = link;
var cons4 = function(a) {
  return function(cat) {
    return append4(new CatCons(a, empty9))(cat);
  };
};
var singleton14 = function(a) {
  return cons4(a)(CatNil.value);
};
var semigroupCatList = {
  append: append4
};
var monoidCatList = /* @__PURE__ */ function() {
  return {
    mempty: CatNil.value,
    Semigroup0: function() {
      return semigroupCatList;
    }
  };
}();
var fromFoldable14 = function(dictFoldable) {
  var foldMap111 = foldMap(dictFoldable)(monoidCatList);
  return function(f) {
    return foldMap111(singleton14)(f);
  };
};
var snoc5 = function(cat) {
  return function(a) {
    return append4(cat)(new CatCons(a, empty9));
  };
};

// output/Control.Monad.Free/index.js
var $runtime_lazy8 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var append5 = /* @__PURE__ */ append(semigroupCatList);
var Free = /* @__PURE__ */ function() {
  function Free2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Free2.create = function(value0) {
    return function(value12) {
      return new Free2(value0, value12);
    };
  };
  return Free2;
}();
var Return = /* @__PURE__ */ function() {
  function Return2(value0) {
    this.value0 = value0;
  }
  ;
  Return2.create = function(value0) {
    return new Return2(value0);
  };
  return Return2;
}();
var Bind = /* @__PURE__ */ function() {
  function Bind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Bind2.create = function(value0) {
    return function(value12) {
      return new Bind2(value0, value12);
    };
  };
  return Bind2;
}();
var toView = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    var runExpF = function(v22) {
      return v22;
    };
    var concatF = function(v22) {
      return function(r) {
        return new Free(v22.value0, append5(v22.value1)(r));
      };
    };
    if (v.value0 instanceof Return) {
      var v2 = uncons6(v.value1);
      if (v2 instanceof Nothing) {
        $tco_done = true;
        return new Return(v.value0.value0);
      }
      ;
      if (v2 instanceof Just) {
        $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);
        return;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): " + [v2.constructor.name]);
    }
    ;
    if (v.value0 instanceof Bind) {
      $tco_done = true;
      return new Bind(v.value0.value0, function(a) {
        return concatF(v.value0.value1(a))(v.value1);
      });
    }
    ;
    throw new Error("Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): " + [v.value0.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var resume$prime = function(k) {
  return function(j) {
    return function(f) {
      var v = toView(f);
      if (v instanceof Return) {
        return j(v.value0);
      }
      ;
      if (v instanceof Bind) {
        return k(v.value0)(v.value1);
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 213, column 17 - line 215, column 20): " + [v.constructor.name]);
    };
  };
};
var fromView = function(f) {
  return new Free(f, empty10);
};
var freeMonad = {
  Applicative0: function() {
    return freeApplicative;
  },
  Bind1: function() {
    return freeBind;
  }
};
var freeFunctor = {
  map: function(k) {
    return function(f) {
      return bindFlipped(freeBind)(function() {
        var $189 = pure(freeApplicative);
        return function($190) {
          return $189(k($190));
        };
      }())(f);
    };
  }
};
var freeBind = {
  bind: function(v) {
    return function(k) {
      return new Free(v.value0, snoc5(v.value1)(k));
    };
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var freeApplicative = {
  pure: function($191) {
    return fromView(Return.create($191));
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy8("freeApply", "Control.Monad.Free", function() {
  return {
    apply: ap(freeMonad),
    Functor0: function() {
      return freeFunctor;
    }
  };
});
var bind7 = /* @__PURE__ */ bind(freeBind);
var pure7 = /* @__PURE__ */ pure(freeApplicative);
var freeMonadRec = {
  tailRecM: function(k) {
    return function(a) {
      return bind7(k(a))(function(v) {
        if (v instanceof Loop) {
          return tailRecM(freeMonadRec)(k)(v.value0);
        }
        ;
        if (v instanceof Done) {
          return pure7(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Free (line 86, column 26 - line 88, column 21): " + [v.constructor.name]);
      });
    };
  },
  Monad0: function() {
    return freeMonad;
  }
};
var liftF = function(f) {
  return fromView(new Bind(f, function($192) {
    return pure7($192);
  }));
};

// output/Data.Exists/index.js
var runExists = unsafeCoerce2;
var mkExists = unsafeCoerce2;

// output/Data.Show.Generic/foreign.js
var intercalate5 = function(separator) {
  return function(xs) {
    return xs.join(separator);
  };
};

// output/Data.Show.Generic/index.js
var append6 = /* @__PURE__ */ append(semigroupArray);
var genericShowArgsNoArguments = {
  genericShowArgs: function(v) {
    return [];
  }
};
var genericShowArgs = function(dict) {
  return dict.genericShowArgs;
};
var genericShowConstructor = function(dictGenericShowArgs) {
  var genericShowArgs1 = genericShowArgs(dictGenericShowArgs);
  return function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return {
      "genericShow'": function(v) {
        var ctor = reflectSymbol2($$Proxy.value);
        var v1 = genericShowArgs1(v);
        if (v1.length === 0) {
          return ctor;
        }
        ;
        return "(" + (intercalate5(" ")(append6([ctor])(v1)) + ")");
      }
    };
  };
};
var genericShow$prime = function(dict) {
  return dict["genericShow'"];
};
var genericShowSum = function(dictGenericShow) {
  var genericShow$prime1 = genericShow$prime(dictGenericShow);
  return function(dictGenericShow1) {
    var genericShow$prime2 = genericShow$prime(dictGenericShow1);
    return {
      "genericShow'": function(v) {
        if (v instanceof Inl) {
          return genericShow$prime1(v.value0);
        }
        ;
        if (v instanceof Inr) {
          return genericShow$prime2(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): " + [v.constructor.name]);
      }
    };
  };
};
var genericShow = function(dictGeneric) {
  var from4 = from(dictGeneric);
  return function(dictGenericShow) {
    var genericShow$prime1 = genericShow$prime(dictGenericShow);
    return function(x) {
      return genericShow$prime1(from4(x));
    };
  };
};

// output/Data.List.Lazy.Types/index.js
var unwrap6 = /* @__PURE__ */ unwrap();
var Nil2 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons2 = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var nil = /* @__PURE__ */ defer2(function(v) {
  return Nil2.value;
});
var step = function($319) {
  return force(unwrap6($319));
};
var cons5 = function(x) {
  return function(xs) {
    return defer2(function(v) {
      return new Cons2(x, xs);
    });
  };
};
var foldableList2 = {
  foldr: function(op) {
    return function(z) {
      return function(xs) {
        var rev = foldl(foldableList2)(flip(cons5))(nil);
        return foldl(foldableList2)(flip(op))(z)(rev(xs));
      };
    };
  },
  foldl: function(op) {
    var go = function($copy_b) {
      return function($copy_xs) {
        var $tco_var_b = $copy_b;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(b, xs) {
          var v = step(xs);
          if (v instanceof Nil2) {
            $tco_done = true;
            return b;
          }
          ;
          if (v instanceof Cons2) {
            $tco_var_b = op(b)(v.value0);
            $copy_xs = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Lazy.Types (line 127, column 7 - line 129, column 40): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_b, $copy_xs);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append214 = append(dictMonoid.Semigroup0());
    var mempty33 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList2)(function(b) {
        return function(a) {
          return append214(b)(f(a));
        };
      })(mempty33);
    };
  }
};

// output/Data.List.Lazy/index.js
var replicateM = function(dictMonad) {
  var pure129 = pure(dictMonad.Applicative0());
  var bind218 = bind(dictMonad.Bind1());
  return function(n) {
    return function(m) {
      if (n < 1) {
        return pure129(nil);
      }
      ;
      if (otherwise) {
        return bind218(m)(function(a) {
          return bind218(replicateM(dictMonad)(n - 1 | 0)(m))(function(as3) {
            return pure129(cons5(a)(as3));
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Data.List.Lazy (line 164, column 1 - line 164, column 62): " + [n.constructor.name, m.constructor.name]);
    };
  };
};

// output/Text.PrettyPrint.Leijen/index.js
var max4 = /* @__PURE__ */ max(ordInt);
var min4 = /* @__PURE__ */ min(ordInt);
var foldr9 = /* @__PURE__ */ foldr(foldableArray);
var SFail = /* @__PURE__ */ function() {
  function SFail2() {
  }
  ;
  SFail2.value = new SFail2();
  return SFail2;
}();
var SEmpty = /* @__PURE__ */ function() {
  function SEmpty2() {
  }
  ;
  SEmpty2.value = new SEmpty2();
  return SEmpty2;
}();
var SChar = /* @__PURE__ */ function() {
  function SChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar2.create = function(value0) {
    return function(value12) {
      return new SChar2(value0, value12);
    };
  };
  return SChar2;
}();
var SText = /* @__PURE__ */ function() {
  function SText2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText2(value0, value12, value22);
      };
    };
  };
  return SText2;
}();
var SLine = /* @__PURE__ */ function() {
  function SLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine2.create = function(value0) {
    return function(value12) {
      return new SLine2(value0, value12);
    };
  };
  return SLine2;
}();
var SFail$prime = /* @__PURE__ */ function() {
  function SFail$prime2() {
  }
  ;
  SFail$prime2.value = new SFail$prime2();
  return SFail$prime2;
}();
var SEmpty$prime = /* @__PURE__ */ function() {
  function SEmpty$prime2() {
  }
  ;
  SEmpty$prime2.value = new SEmpty$prime2();
  return SEmpty$prime2;
}();
var SChar$prime = /* @__PURE__ */ function() {
  function SChar$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar$prime2.create = function(value0) {
    return function(value12) {
      return new SChar$prime2(value0, value12);
    };
  };
  return SChar$prime2;
}();
var SText$prime = /* @__PURE__ */ function() {
  function SText$prime2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText$prime2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText$prime2(value0, value12, value22);
      };
    };
  };
  return SText$prime2;
}();
var SLine$prime = /* @__PURE__ */ function() {
  function SLine$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine$prime2.create = function(value0) {
    return function(value12) {
      return new SLine$prime2(value0, value12);
    };
  };
  return SLine$prime2;
}();
var Fail = /* @__PURE__ */ function() {
  function Fail3() {
  }
  ;
  Fail3.value = new Fail3();
  return Fail3;
}();
var Empty3 = /* @__PURE__ */ function() {
  function Empty4() {
  }
  ;
  Empty4.value = new Empty4();
  return Empty4;
}();
var Char = /* @__PURE__ */ function() {
  function Char2(value0) {
    this.value0 = value0;
  }
  ;
  Char2.create = function(value0) {
    return new Char2(value0);
  };
  return Char2;
}();
var Text2 = /* @__PURE__ */ function() {
  function Text3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text3.create = function(value0) {
    return function(value12) {
      return new Text3(value0, value12);
    };
  };
  return Text3;
}();
var Line = /* @__PURE__ */ function() {
  function Line3() {
  }
  ;
  Line3.value = new Line3();
  return Line3;
}();
var FlatAlt = /* @__PURE__ */ function() {
  function FlatAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlatAlt2.create = function(value0) {
    return function(value12) {
      return new FlatAlt2(value0, value12);
    };
  };
  return FlatAlt2;
}();
var Cat = /* @__PURE__ */ function() {
  function Cat2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cat2.create = function(value0) {
    return function(value12) {
      return new Cat2(value0, value12);
    };
  };
  return Cat2;
}();
var Nest = /* @__PURE__ */ function() {
  function Nest2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Nest2.create = function(value0) {
    return function(value12) {
      return new Nest2(value0, value12);
    };
  };
  return Nest2;
}();
var Union = /* @__PURE__ */ function() {
  function Union2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Union2.create = function(value0) {
    return function(value12) {
      return new Union2(value0, value12);
    };
  };
  return Union2;
}();
var Column = /* @__PURE__ */ function() {
  function Column2(value0) {
    this.value0 = value0;
  }
  ;
  Column2.create = function(value0) {
    return new Column2(value0);
  };
  return Column2;
}();
var Columns = /* @__PURE__ */ function() {
  function Columns2(value0) {
    this.value0 = value0;
  }
  ;
  Columns2.create = function(value0) {
    return new Columns2(value0);
  };
  return Columns2;
}();
var Nesting = /* @__PURE__ */ function() {
  function Nesting2(value0) {
    this.value0 = value0;
  }
  ;
  Nesting2.create = function(value0) {
    return new Nesting2(value0);
  };
  return Nesting2;
}();
var Nil3 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons3 = /* @__PURE__ */ function() {
  function Cons4(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Cons4(value0, value12, value22);
      };
    };
  };
  return Cons4;
}();
var text2 = function(v) {
  if (v === "") {
    return Empty3.value;
  }
  ;
  return new Text2(length5(v), v);
};
var spaces = function(n) {
  if (n <= 0) {
    return "";
  }
  ;
  if (otherwise) {
    return fromCharArray(replicate(n)(" "));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 908, column 1 - line 908, column 24): " + [n.constructor.name]);
};
var space2 = /* @__PURE__ */ function() {
  return new Char(" ");
}();
var rparen = /* @__PURE__ */ function() {
  return new Char(")");
}();
var rbracket = /* @__PURE__ */ function() {
  return new Char("]");
}();
var nesting = function(f) {
  return new Nesting(f);
};
var nest = function(i) {
  return function(x) {
    return new Nest(i, x);
  };
};
var lparen = /* @__PURE__ */ function() {
  return new Char("(");
}();
var line = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, space2);
}();
var lbracket = /* @__PURE__ */ function() {
  return new Char("[");
}();
var indentation = function(n) {
  return spaces(n);
};
var forceSimpleDoc = function(v) {
  if (v instanceof SFail$prime) {
    return SFail.value;
  }
  ;
  if (v instanceof SEmpty$prime) {
    return SEmpty.value;
  }
  ;
  if (v instanceof SChar$prime) {
    return new SChar(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  if (v instanceof SText$prime) {
    return new SText(v.value0, v.value1, forceSimpleDoc(force(v.value2)));
  }
  ;
  if (v instanceof SLine$prime) {
    return new SLine(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 600, column 18 - line 605, column 51): " + [v.constructor.name]);
};
var renderFits = function(fits) {
  return function(rfrac) {
    return function(w) {
      return function(headNode) {
        var r = max4(0)(min4(w)(round2(toNumber(w) * rfrac)));
        var nicest$prime = function(n) {
          return function(k) {
            return function(i) {
              return function(ds) {
                return function(x) {
                  return function(y) {
                    var x$prime = best(n)(k)(new Cons3(i, x, ds));
                    var width$prime = min4(w - k | 0)((r - k | 0) + n | 0);
                    var $221 = fits(w)(min4(n)(k))(width$prime)(x$prime);
                    if ($221) {
                      return x$prime;
                    }
                    ;
                    var y$prime = best(n)(k)(new Cons3(i, y, ds));
                    return y$prime;
                  };
                };
              };
            };
          };
        };
        var best = function(v) {
          return function(v1) {
            return function(v2) {
              if (v2 instanceof Nil3) {
                return SEmpty$prime.value;
              }
              ;
              if (v2 instanceof Cons3) {
                if (v2.value1 instanceof Fail) {
                  return SFail$prime.value;
                }
                ;
                if (v2.value1 instanceof Empty3) {
                  return best(v)(v1)(v2.value2);
                }
                ;
                if (v2.value1 instanceof Char) {
                  var k$prime = v1 + 1 | 0;
                  return new SChar$prime(v2.value1.value0, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Text2) {
                  var k$prime = v1 + v2.value1.value0 | 0;
                  return new SText$prime(v2.value1.value0, v2.value1.value1, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Line) {
                  return new SLine$prime(v2.value0, defer2(function(v3) {
                    return best(v2.value0)(v2.value0)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof FlatAlt) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, v2.value2));
                }
                ;
                if (v2.value1 instanceof Cat) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, new Cons3(v2.value0, v2.value1.value1, v2.value2)));
                }
                ;
                if (v2.value1 instanceof Nest) {
                  var i$prime = v2.value0 + v2.value1.value0 | 0;
                  return best(v)(v1)(new Cons3(i$prime, v2.value1.value1, v2.value2));
                }
                ;
                if (v2.value1 instanceof Union) {
                  return nicest$prime(v)(v1)(v2.value0)(v2.value2)(v2.value1.value0)(v2.value1.value1);
                }
                ;
                if (v2.value1 instanceof Column) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v1), v2.value2));
                }
                ;
                if (v2.value1 instanceof Columns) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(new Just(w)), v2.value2));
                }
                ;
                if (v2.value1 instanceof Nesting) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v2.value0), v2.value2));
                }
                ;
                throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 788, column 11 - line 802, column 56): " + [v2.value1.constructor.name]);
              }
              ;
              throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 785, column 7 - line 785, column 50): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            };
          };
        };
        return forceSimpleDoc(best(0)(0)(new Cons3(0, headNode, Nil3.value)));
      };
    };
  };
};
var foldr13 = function(dictMonoid) {
  var mempty33 = mempty(dictMonoid);
  return function(f) {
    return function($297) {
      return function(v) {
        if (v instanceof Nothing) {
          return mempty33;
        }
        ;
        if (v instanceof Just) {
          return foldr9(f)(v.value0.last)(v.value0.init);
        }
        ;
        throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 122, column 29 - line 124, column 43): " + [v.constructor.name]);
      }(unsnoc($297));
    };
  };
};
var flatten = function(v) {
  if (v instanceof FlatAlt) {
    return v.value1;
  }
  ;
  if (v instanceof Cat) {
    return new Cat(flatten(v.value0), flatten(v.value1));
  }
  ;
  if (v instanceof Nest) {
    return new Nest(v.value0, flatten(v.value1));
  }
  ;
  if (v instanceof Line) {
    return Fail.value;
  }
  ;
  if (v instanceof Union) {
    return flatten(v.value0);
  }
  ;
  if (v instanceof Column) {
    return new Column(function($298) {
      return flatten(v.value0($298));
    });
  }
  ;
  if (v instanceof Columns) {
    return new Columns(function($299) {
      return flatten(v.value0($299));
    });
  }
  ;
  if (v instanceof Nesting) {
    return new Nesting(function($300) {
      return flatten(v.value0($300));
    });
  }
  ;
  return v;
};
var group3 = function(x) {
  return new Union(flatten(x), x);
};
var softline = /* @__PURE__ */ group3(line);
var fits1 = function($copy_v) {
  return function($copy_v1) {
    return function($copy_v2) {
      return function($copy_v3) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_var_v2 = $copy_v2;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1, v2, v3) {
          if (v2 < 0) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SFail$prime) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SEmpty$prime) {
            $tco_done = true;
            return true;
          }
          ;
          if (v3 instanceof SChar$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - 1 | 0;
            $copy_v3 = force(v3.value1);
            return;
          }
          ;
          if (v3 instanceof SText$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - v3.value0 | 0;
            $copy_v3 = force(v3.value2);
            return;
          }
          ;
          if (v3 instanceof SLine$prime) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 819, column 1 - line 819, column 55): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $tco_var_v2, $copy_v3);
        }
        ;
        return $tco_result;
      };
    };
  };
};
var renderPretty = /* @__PURE__ */ renderFits(fits1);
var empty11 = /* @__PURE__ */ function() {
  return Empty3.value;
}();
var linebreak = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, empty11);
}();
var displayS = function(v) {
  if (v instanceof SFail) {
    return unsafeCrashWith("@SFail@ can not appear uncaught in a rendered @SimpleDoc@");
  }
  ;
  if (v instanceof SEmpty) {
    return "";
  }
  ;
  if (v instanceof SChar) {
    return fromCharArray([v.value0]) + displayS(v.value1);
  }
  ;
  if (v instanceof SText) {
    return v.value1 + displayS(v.value2);
  }
  ;
  if (v instanceof SLine) {
    return "\n" + (indentation(v.value0) + displayS(v.value1));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 893, column 1 - line 893, column 32): " + [v.constructor.name]);
};
var column = function(f) {
  return new Column(f);
};
var $$char2 = function(v) {
  if (v === "\n") {
    return line;
  }
  ;
  return new Char(v);
};
var beside = function(x) {
  return function(y) {
    return new Cat(x, y);
  };
};
var docSemigroup = {
  append: beside
};
var append16 = /* @__PURE__ */ append(docSemigroup);
var docMonoid = {
  mempty: empty11,
  Semigroup0: function() {
    return docSemigroup;
  }
};
var foldr11 = /* @__PURE__ */ foldr13(docMonoid);
var string2 = /* @__PURE__ */ function() {
  var $303 = intercalate(foldableArray)(docMonoid)(line);
  var $304 = map(functorArray)(text2);
  var $305 = split("\n");
  return function($306) {
    return $303($304($305($306)));
  };
}();
var enclose = function(l) {
  return function(r) {
    return function(x) {
      return append16(l)(append16(x)(r));
    };
  };
};
var brackets = /* @__PURE__ */ enclose(lbracket)(rbracket);
var parens = /* @__PURE__ */ enclose(lparen)(rparen);
var width = function(d) {
  return function(f) {
    return column(function(k1) {
      return append16(d)(column(function(k2) {
        return f(k2 - k1 | 0);
      }));
    });
  };
};
var fillBreak = function(f) {
  return function(x) {
    return width(x)(function(w) {
      var $292 = w > f;
      if ($292) {
        return nest(f)(linebreak);
      }
      ;
      return text2(spaces(f - w | 0));
    });
  };
};
var appendWithSpace = function(x) {
  return function(y) {
    return append16(x)(append16(space2)(y));
  };
};
var hsep = /* @__PURE__ */ foldr11(appendWithSpace);
var appendWithSoftline = function(x) {
  return function(y) {
    return append16(x)(append16(softline)(y));
  };
};
var appendWithLinebreak = function(x) {
  return function(y) {
    return append16(x)(append16(linebreak)(y));
  };
};
var vcat = /* @__PURE__ */ foldr11(appendWithLinebreak);
var appendWithLine = function(x) {
  return function(y) {
    return append16(x)(append16(line)(y));
  };
};
var align = function(d) {
  return column(function(k) {
    return nesting(function(i) {
      return nest(k - i | 0)(d);
    });
  });
};
var hang = function(i) {
  return function(d) {
    return align(nest(i)(d));
  };
};
var indent2 = function(i) {
  return function(d) {
    return hang(i)(append16(text2(spaces(i)))(d));
  };
};

// output/Options.Applicative.Help.Chunk/index.js
var un2 = /* @__PURE__ */ un();
var foldr10 = /* @__PURE__ */ foldr(foldableArray);
var mempty4 = /* @__PURE__ */ mempty(docMonoid);
var fold4 = /* @__PURE__ */ fold(foldableArray);
var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);
var Chunk = function(x) {
  return x;
};
var chunked = function(v) {
  return function(v1) {
    return function(v2) {
      if (v1 instanceof Nothing) {
        return v2;
      }
      ;
      if (v2 instanceof Nothing) {
        return v1;
      }
      ;
      if (v1 instanceof Just && v2 instanceof Just) {
        return new Just(v(v1.value0)(v2.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Help.Chunk (line 57, column 1 - line 58, column 41): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var chunkSemigroup = function(dictSemigroup) {
  return {
    append: chunked(append(dictSemigroup))
  };
};
var extractChunk = function(dictMonoid) {
  var $56 = fromMaybe(mempty(dictMonoid));
  var $57 = un2(Chunk);
  return function($58) {
    return $56($57($58));
  };
};
var isEmpty6 = /* @__PURE__ */ function() {
  var $59 = un2(Chunk);
  return function($60) {
    return isNothing($59($60));
  };
}();
var chunkMonoid = function(dictSemigroup) {
  var chunkSemigroup1 = chunkSemigroup(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return chunkSemigroup1;
    }
  };
};
var mempty1 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var vcatChunks = /* @__PURE__ */ foldr10(/* @__PURE__ */ chunked(appendWithLine))(mempty1);
var vsepChunks = /* @__PURE__ */ foldr10(/* @__PURE__ */ chunked(function(x) {
  return function(y) {
    return appendWithLine(x)(appendWithLine(mempty4)(y));
  };
}))(mempty1);
var chunkFunctor = functorMaybe;
var chunkBesideOrBelow = /* @__PURE__ */ chunked(appendWithSoftline);
var chunkBeside = /* @__PURE__ */ chunked(appendWithSpace);
var chunkApply = applyMaybe;
var chunkApplicative = applicativeMaybe;
var pure8 = /* @__PURE__ */ pure(chunkApplicative);
var listToChunk = function(dictMonoid) {
  var mempty210 = mempty(chunkMonoid(dictMonoid.Semigroup0()));
  var fold113 = fold4(dictMonoid);
  return function(v) {
    if (v.length === 0) {
      return mempty210;
    }
    ;
    return pure8(fold113(v));
  };
};
var stringChunk = function(v) {
  if (v === "") {
    return mempty1;
  }
  ;
  return pure8(text2(v));
};
var paragraph = /* @__PURE__ */ function() {
  var $61 = foldr10(function() {
    var $63 = chunked(appendWithSoftline);
    return function($64) {
      return $63(stringChunk($64));
    };
  }())(mempty1);
  return function($62) {
    return $61(words2($62));
  };
}();
var tabulate$prime = function(v) {
  return function(v1) {
    if (v1.length === 0) {
      return mempty1;
    }
    ;
    return pure8(vcat(mapFlipped2(v1)(function(v2) {
      return indent2(2)(appendWithSpace(fillBreak(v)(v2.value0))(v2.value1));
    })));
  };
};
var tabulate = /* @__PURE__ */ tabulate$prime(24);

// output/Options.Applicative.Help.Types/index.js
var helpBodyIsSymbol = {
  reflectSymbol: function() {
    return "helpBody";
  }
};
var helpErrorIsSymbol = {
  reflectSymbol: function() {
    return "helpError";
  }
};
var helpFooterIsSymbol = {
  reflectSymbol: function() {
    return "helpFooter";
  }
};
var helpHeaderIsSymbol = {
  reflectSymbol: function() {
    return "helpHeader";
  }
};
var helpSuggestionsIsSymbol = {
  reflectSymbol: function() {
    return "helpSuggestions";
  }
};
var helpUsageIsSymbol = {
  reflectSymbol: function() {
    return "helpUsage";
  }
};
var chunkMonoid2 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var extractChunk2 = /* @__PURE__ */ extractChunk(docMonoid);
var ParserHelp = function(x) {
  return x;
};
var parserHelpMonoid = /* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(helpBodyIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpErrorIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpFooterIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpHeaderIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpSuggestionsIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpUsageIsSymbol)(chunkMonoid2)()(monoidRecordNil)))))));
var helpText = function(v) {
  return extractChunk2(vsepChunks([v.helpError, v.helpSuggestions, v.helpHeader, v.helpUsage, v.helpBody, v.helpFooter]));
};
var renderHelp = function(cols) {
  var $65 = renderPretty(1)(cols);
  return function($66) {
    return displayS($65(helpText($66)));
  };
};

// output/Options.Applicative.Types/index.js
var monadExceptT2 = /* @__PURE__ */ monadExceptT(monadIdentity);
var map27 = /* @__PURE__ */ map(/* @__PURE__ */ functorReaderT(/* @__PURE__ */ functorExceptT(functorIdentity)));
var apply7 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyReaderT(/* @__PURE__ */ applyExceptT(monadIdentity)));
var bind8 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(/* @__PURE__ */ bindExceptT(monadIdentity)));
var un3 = /* @__PURE__ */ un();
var map112 = /* @__PURE__ */ map(functorMaybe);
var compare4 = /* @__PURE__ */ compare(ordChar);
var compare14 = /* @__PURE__ */ compare(ordString);
var apply1 = /* @__PURE__ */ apply2(applyEffect);
var map28 = /* @__PURE__ */ map(functorEffect);
var append17 = /* @__PURE__ */ append(semigroupArray);
var pure9 = /* @__PURE__ */ pure(applicativeEffect);
var over4 = /* @__PURE__ */ over()();
var map32 = /* @__PURE__ */ map(freeFunctor);
var bimap3 = /* @__PURE__ */ bimap(bifunctorStep);
var ParserFailure = function(x) {
  return x;
};
var Internal = /* @__PURE__ */ function() {
  function Internal2() {
  }
  ;
  Internal2.value = new Internal2();
  return Internal2;
}();
var Hidden = /* @__PURE__ */ function() {
  function Hidden2() {
  }
  ;
  Hidden2.value = new Hidden2();
  return Hidden2;
}();
var Visible = /* @__PURE__ */ function() {
  function Visible2() {
  }
  ;
  Visible2.value = new Visible2();
  return Visible2;
}();
var Leaf2 = /* @__PURE__ */ function() {
  function Leaf3(value0) {
    this.value0 = value0;
  }
  ;
  Leaf3.create = function(value0) {
    return new Leaf3(value0);
  };
  return Leaf3;
}();
var MultNode = /* @__PURE__ */ function() {
  function MultNode2(value0) {
    this.value0 = value0;
  }
  ;
  MultNode2.create = function(value0) {
    return new MultNode2(value0);
  };
  return MultNode2;
}();
var AltNode = /* @__PURE__ */ function() {
  function AltNode2(value0) {
    this.value0 = value0;
  }
  ;
  AltNode2.create = function(value0) {
    return new AltNode2(value0);
  };
  return AltNode2;
}();
var OptProperties = function(x) {
  return x;
};
var OptShort = /* @__PURE__ */ function() {
  function OptShort2(value0) {
    this.value0 = value0;
  }
  ;
  OptShort2.create = function(value0) {
    return new OptShort2(value0);
  };
  return OptShort2;
}();
var OptLong = /* @__PURE__ */ function() {
  function OptLong2(value0) {
    this.value0 = value0;
  }
  ;
  OptLong2.create = function(value0) {
    return new OptLong2(value0);
  };
  return OptLong2;
}();
var OptHelpInfo = function(x) {
  return x;
};
var CmdStart = /* @__PURE__ */ function() {
  function CmdStart2() {
  }
  ;
  CmdStart2.value = new CmdStart2();
  return CmdStart2;
}();
var CmdCont = /* @__PURE__ */ function() {
  function CmdCont2() {
  }
  ;
  CmdCont2.value = new CmdCont2();
  return CmdCont2;
}();
var CompletionResult = function(x) {
  return x;
};
var Success2 = /* @__PURE__ */ function() {
  function Success4(value0) {
    this.value0 = value0;
  }
  ;
  Success4.create = function(value0) {
    return new Success4(value0);
  };
  return Success4;
}();
var Failure = /* @__PURE__ */ function() {
  function Failure2(value0) {
    this.value0 = value0;
  }
  ;
  Failure2.create = function(value0) {
    return new Failure2(value0);
  };
  return Failure2;
}();
var CompletionInvoked = /* @__PURE__ */ function() {
  function CompletionInvoked2(value0) {
    this.value0 = value0;
  }
  ;
  CompletionInvoked2.create = function(value0) {
    return new CompletionInvoked2(value0);
  };
  return CompletionInvoked2;
}();
var Completer = function(x) {
  return x;
};
var Backtrack = /* @__PURE__ */ function() {
  function Backtrack2() {
  }
  ;
  Backtrack2.value = new Backtrack2();
  return Backtrack2;
}();
var NoBacktrack = /* @__PURE__ */ function() {
  function NoBacktrack2() {
  }
  ;
  NoBacktrack2.value = new NoBacktrack2();
  return NoBacktrack2;
}();
var SubparserInline = /* @__PURE__ */ function() {
  function SubparserInline2() {
  }
  ;
  SubparserInline2.value = new SubparserInline2();
  return SubparserInline2;
}();
var ParserPrefs = function(x) {
  return x;
};
var Intersperse = /* @__PURE__ */ function() {
  function Intersperse2() {
  }
  ;
  Intersperse2.value = new Intersperse2();
  return Intersperse2;
}();
var NoIntersperse = /* @__PURE__ */ function() {
  function NoIntersperse2() {
  }
  ;
  NoIntersperse2.value = new NoIntersperse2();
  return NoIntersperse2;
}();
var AllPositionals = /* @__PURE__ */ function() {
  function AllPositionals2() {
  }
  ;
  AllPositionals2.value = new AllPositionals2();
  return AllPositionals2;
}();
var ForwardOptions = /* @__PURE__ */ function() {
  function ForwardOptions2() {
  }
  ;
  ForwardOptions2.value = new ForwardOptions2();
  return ForwardOptions2;
}();
var ParserInfo = function(x) {
  return x;
};
var NilP = /* @__PURE__ */ function() {
  function NilP2(value0) {
    this.value0 = value0;
  }
  ;
  NilP2.create = function(value0) {
    return new NilP2(value0);
  };
  return NilP2;
}();
var OptP = /* @__PURE__ */ function() {
  function OptP2(value0) {
    this.value0 = value0;
  }
  ;
  OptP2.create = function(value0) {
    return new OptP2(value0);
  };
  return OptP2;
}();
var MultP = /* @__PURE__ */ function() {
  function MultP2(value0) {
    this.value0 = value0;
  }
  ;
  MultP2.create = function(value0) {
    return new MultP2(value0);
  };
  return MultP2;
}();
var AltP = /* @__PURE__ */ function() {
  function AltP2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AltP2.create = function(value0) {
    return function(value12) {
      return new AltP2(value0, value12);
    };
  };
  return AltP2;
}();
var BindP = /* @__PURE__ */ function() {
  function BindP2(value0) {
    this.value0 = value0;
  }
  ;
  BindP2.create = function(value0) {
    return new BindP2(value0);
  };
  return BindP2;
}();
var Option = function(x) {
  return x;
};
var OptReader = /* @__PURE__ */ function() {
  function OptReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  OptReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new OptReader2(value0, value12, value22);
      };
    };
  };
  return OptReader2;
}();
var FlagReader = /* @__PURE__ */ function() {
  function FlagReader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlagReader2.create = function(value0) {
    return function(value12) {
      return new FlagReader2(value0, value12);
    };
  };
  return FlagReader2;
}();
var ArgReader = /* @__PURE__ */ function() {
  function ArgReader2(value0) {
    this.value0 = value0;
  }
  ;
  ArgReader2.create = function(value0) {
    return new ArgReader2(value0);
  };
  return ArgReader2;
}();
var CmdReader = /* @__PURE__ */ function() {
  function CmdReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  CmdReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new CmdReader2(value0, value12, value22);
      };
    };
  };
  return CmdReader2;
}();
var CReader = function(x) {
  return x;
};
var ReadM = function(x) {
  return x;
};
var ErrorMsg = /* @__PURE__ */ function() {
  function ErrorMsg2(value0) {
    this.value0 = value0;
  }
  ;
  ErrorMsg2.create = function(value0) {
    return new ErrorMsg2(value0);
  };
  return ErrorMsg2;
}();
var InfoMsg = /* @__PURE__ */ function() {
  function InfoMsg2(value0) {
    this.value0 = value0;
  }
  ;
  InfoMsg2.create = function(value0) {
    return new InfoMsg2(value0);
  };
  return InfoMsg2;
}();
var ShowHelpText = /* @__PURE__ */ function() {
  function ShowHelpText2() {
  }
  ;
  ShowHelpText2.value = new ShowHelpText2();
  return ShowHelpText2;
}();
var MissingError = /* @__PURE__ */ function() {
  function MissingError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MissingError2.create = function(value0) {
    return function(value12) {
      return new MissingError2(value0, value12);
    };
  };
  return MissingError2;
}();
var ExpectsArgError = /* @__PURE__ */ function() {
  function ExpectsArgError2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectsArgError2.create = function(value0) {
    return new ExpectsArgError2(value0);
  };
  return ExpectsArgError2;
}();
var UnexpectedError = /* @__PURE__ */ function() {
  function UnexpectedError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  UnexpectedError2.create = function(value0) {
    return function(value12) {
      return new UnexpectedError2(value0, value12);
    };
  };
  return UnexpectedError2;
}();
var SomeParser = /* @__PURE__ */ function() {
  function SomeParser2(value0) {
    this.value0 = value0;
  }
  ;
  SomeParser2.create = function(value0) {
    return new SomeParser2(value0);
  };
  return SomeParser2;
}();
var MultPE = /* @__PURE__ */ function() {
  function MultPE2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MultPE2.create = function(value0) {
    return function(value12) {
      return new MultPE2(value0, value12);
    };
  };
  return MultPE2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Context2.create = function(value0) {
    return function(value12) {
      return new Context2(value0, value12);
    };
  };
  return Context2;
}();
var ParserM = function(x) {
  return x;
};
var readerAsk = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadExceptT2));
var readerAbort = /* @__PURE__ */ function() {
  var $478 = lift(monadTransReaderT)(monadExceptT2);
  var $479 = throwError(monadThrowExceptT(monadIdentity));
  return function($480) {
    return ReadM($478($479($480)));
  };
}();
var readerError = function($481) {
  return readerAbort(ErrorMsg.create($481));
};
var readMFunctor = {
  map: function(f) {
    return function(v) {
      return map27(f)(v);
    };
  }
};
var map43 = /* @__PURE__ */ map(readMFunctor);
var readMApply = {
  apply: function(v) {
    return function(v1) {
      return apply7(v)(v1);
    };
  },
  Functor0: function() {
    return readMFunctor;
  }
};
var readMBind = {
  bind: function(v) {
    return function(f) {
      return bind8(v)(function() {
        var $482 = un3(ReadM);
        return function($483) {
          return $482(f($483));
        };
      }());
    };
  },
  Apply0: function() {
    return readMApply;
  }
};
var readMApplicative = {
  pure: /* @__PURE__ */ function() {
    var $484 = pure(applicativeReaderT(applicativeExceptT(monadIdentity)));
    return function($485) {
      return ReadM($484($485));
    };
  }(),
  Apply0: function() {
    return readMApply;
  }
};
var parserMMonadRec = freeMonadRec;
var tailRecM3 = /* @__PURE__ */ tailRecM(parserMMonadRec);
var parserMBind = freeBind;
var bind1 = /* @__PURE__ */ bind(parserMBind);
var parserMApplicative = freeApplicative;
var pure13 = /* @__PURE__ */ pure(parserMApplicative);
var parseErrorSemigroup = {
  append: function(v) {
    return function(m) {
      return m;
    };
  }
};
var optional2 = function(dictAlt) {
  var alt210 = alt(dictAlt);
  var map1010 = map(dictAlt.Functor0());
  return function(dictApplicative) {
    var pure312 = pure(dictApplicative);
    return function(a) {
      return alt210(map1010(Just.create)(a))(pure312(Nothing.value));
    };
  };
};
var optVisibilityEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return true;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return true;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return true;
      }
      ;
      return false;
    };
  }
};
var optVisibilityOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return EQ.value;
      }
      ;
      if (x instanceof Internal) {
        return LT.value;
      }
      ;
      if (y instanceof Internal) {
        return GT.value;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return EQ.value;
      }
      ;
      if (x instanceof Hidden) {
        return LT.value;
      }
      ;
      if (y instanceof Hidden) {
        return GT.value;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optVisibilityEq;
  }
};
var optShowDefault = /* @__PURE__ */ function() {
  var $486 = un3(OptProperties);
  var $487 = un3(Option);
  return function($488) {
    return function(v) {
      return v.propShowDefault;
    }($486(function(v) {
      return v.optProps;
    }($487($488))));
  };
}();
var optVisibility = /* @__PURE__ */ function() {
  var $489 = un3(OptProperties);
  var $490 = un3(Option);
  return function($491) {
    return function(v) {
      return v.propVisibility;
    }($489(function(v) {
      return v.optProps;
    }($490($491))));
  };
}();
var optNameEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var optNameOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return compare4(x.value0)(y.value0);
      }
      ;
      if (x instanceof OptShort) {
        return LT.value;
      }
      ;
      if (y instanceof OptShort) {
        return GT.value;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return compare14(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optNameEq;
  }
};
var optMetaVar = /* @__PURE__ */ function() {
  var $492 = un3(OptProperties);
  var $493 = un3(Option);
  return function($494) {
    return function(v) {
      return v.propMetaVar;
    }($492(function(v) {
      return v.optProps;
    }($493($494))));
  };
}();
var optHelp = /* @__PURE__ */ function() {
  var $495 = un3(OptProperties);
  var $496 = un3(Option);
  return function($497) {
    return function(v) {
      return v.propHelp;
    }($495(function(v) {
      return v.optProps;
    }($496($497))));
  };
}();
var optDescMod = /* @__PURE__ */ function() {
  var $498 = un3(OptProperties);
  var $499 = un3(Option);
  return function($500) {
    return function(v) {
      return v.propDescMod;
    }($498(function(v) {
      return v.optProps;
    }($499($500))));
  };
}();
var oneM = function($501) {
  return ParserM(liftF($501));
};
var fromM = function(v) {
  return new BindP(v);
};
var completerSemigroup = {
  append: function(v) {
    return function(v1) {
      return function(s) {
        return apply1(map28(append17)(v(s)))(v1(s));
      };
    };
  }
};
var completerMonoid = {
  mempty: function(v) {
    return pure9([]);
  },
  Semigroup0: function() {
    return completerSemigroup;
  }
};
var cReaderFunctor = {
  map: function(f) {
    return over4(CReader)(function(r) {
      return {
        crCompleter: r.crCompleter,
        crReader: map43(f)(r.crReader)
      };
    });
  }
};
var map82 = /* @__PURE__ */ map(cReaderFunctor);
var parserInfoFunctor = {
  map: function(f) {
    return over4(ParserInfo)(function(i) {
      return {
        infoFailureCode: i.infoFailureCode,
        infoFooter: i.infoFooter,
        infoFullDesc: i.infoFullDesc,
        infoHeader: i.infoHeader,
        infoPolicy: i.infoPolicy,
        infoProgDesc: i.infoProgDesc,
        infoParser: map(parserFunctor)(f)(i.infoParser)
      };
    });
  }
};
var parserFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return new NilP(v(v1.value0));
      }
      ;
      if (v1 instanceof OptP) {
        return new OptP(map(optionFunctor)(v)(v1.value0));
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          return new MultP(mkExists(new MultPE(map(parserFunctor)(function(v3) {
            return function($502) {
              return v(v3($502));
            };
          })(v2.value0), v2.value1)));
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return new AltP(map(parserFunctor)(v)(v1.value0), map(parserFunctor)(v)(v1.value1));
      }
      ;
      if (v1 instanceof BindP) {
        return new BindP(map32(v)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 317, column 1 - line 322, column 36): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var optionFunctor = {
  map: function(f) {
    return over4(Option)(function(o) {
      return {
        optProps: o.optProps,
        optMain: map(optReaderFunctor)(f)(o.optMain)
      };
    });
  }
};
var optReaderFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof OptReader) {
        return new OptReader(v1.value0, map82(v)(v1.value1), v1.value2);
      }
      ;
      if (v1 instanceof FlagReader) {
        return new FlagReader(v1.value0, v(v1.value1));
      }
      ;
      if (v1 instanceof ArgReader) {
        return new ArgReader(map82(v)(v1.value0));
      }
      ;
      if (v1 instanceof CmdReader) {
        return new CmdReader(v1.value0, v1.value1, function() {
          var $503 = map112(map(parserInfoFunctor)(v));
          return function($504) {
            return $503(v1.value2($504));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 264, column 1 - line 268, column 68): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var map92 = /* @__PURE__ */ map(parserFunctor);
var parserAlt = /* @__PURE__ */ function() {
  return {
    alt: AltP.create,
    Functor0: function() {
      return parserFunctor;
    }
  };
}();
var alt1 = /* @__PURE__ */ alt(parserAlt);
var parserApply = {
  apply: function(a) {
    return function(b) {
      return new MultP(mkExists(new MultPE(a, b)));
    };
  },
  Functor0: function() {
    return parserFunctor;
  }
};
var parserApplicative = /* @__PURE__ */ function() {
  return {
    pure: NilP.create,
    Apply0: function() {
      return parserApply;
    }
  };
}();
var pure23 = /* @__PURE__ */ pure(parserApplicative);
var manyM = function(p) {
  var go = function(acc) {
    return bind1(oneM(alt1(map92(Loop.create)(p))(pure23(new Done(unit)))))(function(aa) {
      return pure13(bimap3(function(v) {
        return new Cons(v, acc);
      })(function(v) {
        return reverse2(acc);
      })(aa));
    });
  };
  return tailRecM3(go)(Nil.value);
};
var many3 = function($505) {
  return fromM(manyM($505));
};
var argPolicyEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Intersperse && y instanceof Intersperse) {
        return true;
      }
      ;
      if (x instanceof NoIntersperse && y instanceof NoIntersperse) {
        return true;
      }
      ;
      if (x instanceof AllPositionals && y instanceof AllPositionals) {
        return true;
      }
      ;
      if (x instanceof ForwardOptions && y instanceof ForwardOptions) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Control.Monad.Reader/index.js
var unwrap7 = /* @__PURE__ */ unwrap();
var runReader = function(v) {
  return function($4) {
    return unwrap7(v($4));
  };
};

// output/Options.Applicative.Internal/index.js
var $runtime_lazy9 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var un4 = /* @__PURE__ */ un();
var map29 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorStateT(/* @__PURE__ */ functorReaderT(functorIdentity))));
var monadReaderT2 = /* @__PURE__ */ monadReaderT(monadIdentity);
var monadStateT2 = /* @__PURE__ */ monadStateT(monadReaderT2);
var apply8 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyExceptT(monadStateT2));
var bind9 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadStateT2));
var pure10 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadStateT2));
var altExceptT2 = /* @__PURE__ */ altExceptT(parseErrorSemigroup);
var alt2 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadStateT2));
var lift5 = /* @__PURE__ */ lift(monadTransExceptT);
var lift1 = /* @__PURE__ */ lift5(monadStateT2);
var modify_3 = /* @__PURE__ */ modify_2(/* @__PURE__ */ monadStateStateT(monadReaderT2));
var lift23 = /* @__PURE__ */ lift(monadTransStateT);
var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadStateT2));
var map113 = /* @__PURE__ */ map(functorArray);
var pure14 = /* @__PURE__ */ pure(applicativeArray);
var discard2 = /* @__PURE__ */ discard(discardUnit);
var identity16 = /* @__PURE__ */ identity(categoryFn);
var TNil = /* @__PURE__ */ function() {
  function TNil2() {
  }
  ;
  TNil2.value = new TNil2();
  return TNil2;
}();
var TCons = /* @__PURE__ */ function() {
  function TCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TCons2.create = function(value0) {
    return function(value12) {
      return new TCons2(value0, value12);
    };
  };
  return TCons2;
}();
var P = function(x) {
  return x;
};
var ListT = function(x) {
  return x;
};
var NondetT = function(x) {
  return x;
};
var ComplParser = /* @__PURE__ */ function() {
  function ComplParser2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ComplParser2.create = function(value0) {
    return function(value12) {
      return new ComplParser2(value0, value12);
    };
  };
  return ComplParser2;
}();
var ComplOption = /* @__PURE__ */ function() {
  function ComplOption2(value0) {
    this.value0 = value0;
  }
  ;
  ComplOption2.create = function(value0) {
    return new ComplOption2(value0);
  };
  return ComplOption2;
}();
var ComplResult = /* @__PURE__ */ function() {
  function ComplResult2(value0) {
    this.value0 = value0;
  }
  ;
  ComplResult2.create = function(value0) {
    return new ComplResult2(value0);
  };
  return ComplResult2;
}();
var Completion = function(x) {
  return x;
};
var withReadM = function(f) {
  var f$prime = function(v) {
    if (v instanceof ErrorMsg) {
      return new ErrorMsg(f(v.value0));
    }
    ;
    return v;
  };
  var $298 = mapReaderT(withExcept(f$prime));
  var $299 = un4(ReadM);
  return function($300) {
    return ReadM($298($299($300)));
  };
};
var stepListT = function(v) {
  return v;
};
var runP = function(v) {
  return runReader(flip(runStateT)([])(runExceptT(v)));
};
var runNondetT = function(v) {
  return v;
};
var runListT = function(dictMonad) {
  var bind218 = bind(dictMonad.Bind1());
  var pure411 = pure(dictMonad.Applicative0());
  var liftM12 = liftM1(dictMonad);
  return function(xs) {
    return bind218(stepListT(xs))(function(s) {
      if (s instanceof TNil) {
        return pure411(Nil.value);
      }
      ;
      if (s instanceof TCons) {
        return liftM12(Cons.create(s.value0))(runListT(dictMonad)(s.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 200, column 3 - line 202, column 53): " + [s.constructor.name]);
    });
  };
};
var runCompletion = function(v) {
  return function(prefs2) {
    var v1 = runReaderT(runExceptT(v))(prefs2);
    if (v1 instanceof ComplResult) {
      return Nothing.value;
    }
    ;
    if (v1 instanceof ComplParser) {
      return new Just(new Left(new Tuple(v1.value0, v1.value1)));
    }
    ;
    if (v1 instanceof ComplOption) {
      return new Just(new Right(v1.value0));
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Internal (line 170, column 38 - line 173, column 42): " + [v1.constructor.name]);
  };
};
var pFunctor = {
  map: function(f) {
    return function(v) {
      return map29(f)(v);
    };
  }
};
var pApply = {
  apply: function(v) {
    return function(v1) {
      return apply8(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var pBind = {
  bind: function(v) {
    return function(k) {
      return bind9(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return pApply;
  }
};
var pApplicative = {
  pure: function(a) {
    return pure10(a);
  },
  Apply0: function() {
    return pApply;
  }
};
var pMonad = {
  Applicative0: function() {
    return pApplicative;
  },
  Bind1: function() {
    return pBind;
  }
};
var pAlt = {
  alt: function(v) {
    return function(v1) {
      return alt2(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var missingArgP = function(dict) {
  return dict.missingArgP;
};
var getPrefs = function(dict) {
  return dict.getPrefs;
};
var exitP = function(dict) {
  return dict.exitP;
};
var exitContext = function(dict) {
  return dict.exitContext;
};
var errorP = function(dict) {
  return dict.errorP;
};
var hoistEither = function(dictMonadP) {
  return either(errorP(dictMonadP))(pure(dictMonadP.Monad0().Applicative0()));
};
var runReadM = function(dictMonadP) {
  var hoistEither1 = hoistEither(dictMonadP);
  return function(v) {
    return function(s) {
      return hoistEither1(runExcept(runReaderT(v)(s)));
    };
  };
};
var hoistMaybe = function(dictMonadP) {
  var errorP1 = errorP(dictMonadP);
  var pure411 = pure(dictMonadP.Monad0().Applicative0());
  return function(err) {
    return maybe(errorP1(err))(pure411);
  };
};
var pMonadP = {
  enterContext: function(name5) {
    return function(pinfo) {
      return lift1(modify_3(cons(new Context(name5, mkExists(pinfo)))));
    };
  },
  exitContext: /* @__PURE__ */ lift1(/* @__PURE__ */ modify_3(/* @__PURE__ */ drop(1))),
  getPrefs: /* @__PURE__ */ P(/* @__PURE__ */ lift1(/* @__PURE__ */ lift23(monadReaderT2)(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadIdentity))))),
  missingArgP: function(e) {
    return function(v) {
      return errorP(pMonadP)(e);
    };
  },
  exitP: function(i) {
    return function(v) {
      return function(p) {
        var $301 = maybe(throwError2(MissingError.create(i)(SomeParser.create(mkExists(p)))))(pure10);
        return function($302) {
          return P($301($302));
        };
      };
    };
  },
  errorP: function($303) {
    return P(throwError2($303));
  },
  Monad0: function() {
    return pMonad;
  },
  Alt1: function() {
    return pAlt;
  }
};
var enterContext = function(dict) {
  return dict.enterContext;
};
var contextNames = function(ns) {
  var go = function(v) {
    return v.value0;
  };
  return reverse(map113(go)(ns));
};
var complResultMonad = {
  Applicative0: function() {
    return complResultApplicative;
  },
  Bind1: function() {
    return complResultBind;
  }
};
var complResultBind = {
  bind: function(m) {
    return function(f) {
      if (m instanceof ComplResult) {
        return f(m.value0);
      }
      ;
      if (m instanceof ComplParser) {
        return new ComplParser(m.value0, m.value1);
      }
      ;
      if (m instanceof ComplOption) {
        return new ComplOption(m.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 134, column 14 - line 137, column 35): " + [m.constructor.name]);
    };
  },
  Apply0: function() {
    return $lazy_complResultApply(0);
  }
};
var complResultApplicative = /* @__PURE__ */ function() {
  return {
    pure: ComplResult.create,
    Apply0: function() {
      return $lazy_complResultApply(0);
    }
  };
}();
var $lazy_complResultFunctor = /* @__PURE__ */ $runtime_lazy9("complResultFunctor", "Options.Applicative.Internal", function() {
  return {
    map: liftM1(complResultMonad)
  };
});
var $lazy_complResultApply = /* @__PURE__ */ $runtime_lazy9("complResultApply", "Options.Applicative.Internal", function() {
  return {
    apply: ap(complResultMonad),
    Functor0: function() {
      return $lazy_complResultFunctor(0);
    }
  };
});
var complResultFunctor = /* @__PURE__ */ $lazy_complResultFunctor(124);
var map210 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorReaderT(complResultFunctor)));
var monadReaderT1 = /* @__PURE__ */ monadReaderT(complResultMonad);
var alt12 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadReaderT1));
var apply12 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyExceptT(monadReaderT1));
var pure24 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadReaderT1));
var bind12 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadReaderT1));
var lift32 = /* @__PURE__ */ lift5(monadReaderT1);
var lift43 = /* @__PURE__ */ lift(monadTransReaderT)(complResultMonad);
var completionFunctor = {
  map: function(f) {
    return function(v) {
      return map210(f)(v);
    };
  }
};
var completionAlt = {
  alt: function(v) {
    return function(v1) {
      return alt12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApply = {
  apply: function(v) {
    return function(v1) {
      return apply12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApplicative = {
  pure: function(a) {
    return pure24(a);
  },
  Apply0: function() {
    return completionApply;
  }
};
var pure32 = /* @__PURE__ */ pure(completionApplicative);
var completionBind = {
  bind: function(v) {
    return function(k) {
      return bind12(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return completionApply;
  }
};
var completionMonad = {
  Applicative0: function() {
    return completionApplicative;
  },
  Bind1: function() {
    return completionBind;
  }
};
var completionMonadP = {
  enterContext: function(v) {
    return function(v1) {
      return pure32(unit);
    };
  },
  exitContext: /* @__PURE__ */ pure32(unit),
  getPrefs: /* @__PURE__ */ lift32(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(complResultMonad))),
  missingArgP: function(v) {
    return function($304) {
      return Completion(lift32(lift43(ComplOption.create($304))));
    };
  },
  exitP: function(v) {
    return function(a) {
      return function(p) {
        return function(v1) {
          return Completion(lift32(lift43(new ComplParser(new SomeParser(mkExists(p)), a))));
        };
      };
    };
  },
  errorP: /* @__PURE__ */ function() {
    var $305 = throwError(monadThrowExceptT(monadReaderT1));
    return function($306) {
      return Completion($305($306));
    };
  }(),
  Monad0: function() {
    return completionMonad;
  },
  Alt1: function() {
    return completionAlt;
  }
};
var bimapTStep = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof TNil) {
        return TNil.value;
      }
      ;
      if (v2 instanceof TCons) {
        return new TCons(v(v2.value0), v1(v2.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 186, column 1 - line 186, column 77): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var listTFunctor = function(dictMonad) {
  var liftM12 = liftM1(dictMonad);
  return {
    map: function(f) {
      return function(v) {
        return liftM12(bimapTStep(f)(map(listTFunctor(dictMonad))(f)))(stepListT(v));
      };
    }
  };
};
var listTAlt = function(dictMonad) {
  var bind218 = bind(dictMonad.Bind1());
  var pure411 = pure(dictMonad.Applicative0());
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    alt: function(xs) {
      return function(ys) {
        return bind218(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return stepListT(ys);
          }
          ;
          if (s instanceof TCons) {
            return pure411(new TCons(s.value0, alt(listTAlt(dictMonad))(s.value1)(ys)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 227, column 5 - line 229, column 49): " + [s.constructor.name]);
        });
      };
    },
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTPlus = function(dictMonad) {
  var listTAlt1 = listTAlt(dictMonad);
  return {
    empty: pure(dictMonad.Applicative0())(TNil.value),
    Alt0: function() {
      return listTAlt1;
    }
  };
};
var hoistList = function(dictMonad) {
  var pure411 = pure(dictMonad.Applicative0());
  return foldr2(function(x) {
    return function(xt) {
      return pure411(new TCons(x, xt));
    };
  })(empty(listTPlus(dictMonad)));
};
var listTMonadTrans = {
  lift: function(dictMonad) {
    var empty14 = empty(listTPlus(dictMonad));
    var $307 = liftM1(dictMonad)(function(v) {
      return new TCons(v, empty14);
    });
    return function($308) {
      return ListT($307($308));
    };
  }
};
var lift52 = /* @__PURE__ */ lift(listTMonadTrans);
var cut = function(dictMonad) {
  return lift52(monadStateT(dictMonad))(put(monadStateStateT(dictMonad))(true));
};
var nondetTMonadTrans = {
  lift: function(dictMonad) {
    var $309 = lift52(monadStateT(dictMonad));
    var $310 = lift23(dictMonad);
    return function($311) {
      return NondetT($309($310($311)));
    };
  }
};
var listTMonad = function(dictMonad) {
  return {
    Applicative0: function() {
      return listTApplicative(dictMonad);
    },
    Bind1: function() {
      return listTBind(dictMonad);
    }
  };
};
var listTBind = function(dictMonad) {
  var bind218 = bind(dictMonad.Bind1());
  var pure411 = pure(dictMonad.Applicative0());
  var alt210 = alt(listTAlt(dictMonad));
  return {
    bind: function(xs) {
      return function(f) {
        return bind218(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return pure411(TNil.value);
          }
          ;
          if (s instanceof TCons) {
            return stepListT(alt210(f(s.value0))(bind(listTBind(dictMonad))(s.value1)(f)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 218, column 5 - line 220, column 53): " + [s.constructor.name]);
        });
      };
    },
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTApply = function(dictMonad) {
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    apply: ap(listTMonad(dictMonad)),
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTApplicative = function(dictMonad) {
  return {
    pure: function() {
      var $312 = hoistList(dictMonad);
      return function($313) {
        return $312(pure14($313));
      };
    }(),
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTAlternative = function(dictMonad) {
  var listTApplicative1 = listTApplicative(dictMonad);
  var listTPlus1 = listTPlus(dictMonad);
  return {
    Applicative0: function() {
      return listTApplicative1;
    },
    Plus1: function() {
      return listTPlus1;
    }
  };
};
var nondetTAltOp = function(dictMonad) {
  var monadStateT1 = monadStateT(dictMonad);
  var alt210 = alt(listTAlt(monadStateT1));
  var listTBind1 = listTBind(monadStateT1);
  var bind218 = bind(listTBind1);
  var lift62 = lift52(monadStateT1);
  var get6 = get(monadStateStateT(dictMonad));
  var discard115 = discard2(listTBind1);
  var guard17 = guard(listTAlternative(monadStateT1));
  return function(m1) {
    return function(m2) {
      return NondetT(alt210(runNondetT(m1))(bind218(lift62(get6))(function(s) {
        return discard115(guard17(!s))(function() {
          return runNondetT(m2);
        });
      })));
    };
  };
};
var nondetTFunctor = function(dictMonad) {
  var map317 = map(listTFunctor(monadStateT(dictMonad)));
  return {
    map: function(f) {
      var $314 = map317(f);
      return function($315) {
        return NondetT($314(runNondetT($315)));
      };
    }
  };
};
var nondetTAlt = function(dictMonad) {
  var alt210 = alt(listTAlt(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    alt: function(v) {
      return function(v1) {
        return alt210(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTPlus = function(dictMonad) {
  var nondetTAlt1 = nondetTAlt(dictMonad);
  return {
    empty: empty(listTPlus(monadStateT(dictMonad))),
    Alt0: function() {
      return nondetTAlt1;
    }
  };
};
var nondetTApply = function(dictMonad) {
  var apply210 = apply2(listTApply(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    apply: function(v) {
      return function(v1) {
        return apply210(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTApplicative = function(dictMonad) {
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    pure: function() {
      var $316 = pure(listTApplicative(monadStateT(dictMonad)));
      return function($317) {
        return NondetT($316($317));
      };
    }(),
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var nondetTBind = function(dictMonad) {
  var bind218 = bind(listTBind(monadStateT(dictMonad)));
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    bind: function(v) {
      return function(f) {
        return bind218(v)(function($318) {
          return runNondetT(f($318));
        });
      };
    },
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var takeListT = function(dictMonad) {
  var empty14 = empty(listTPlus(dictMonad));
  var liftM12 = liftM1(dictMonad);
  return function(v) {
    if (v === 0) {
      return $$const(empty14);
    }
    ;
    var $319 = liftM12(bimapTStep(identity16)(takeListT(dictMonad)(v - 1 | 0)));
    return function($320) {
      return ListT($319(stepListT($320)));
    };
  };
};
var disamb = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var bind218 = bind(Bind1);
  var evalStateT2 = evalStateT(Bind1.Apply0().Functor0());
  var monadStateT1 = monadStateT(dictMonad);
  var runListT1 = runListT(monadStateT1);
  var takeListT1 = takeListT(monadStateT1);
  var pure411 = pure(dictMonad.Applicative0());
  return function(allow_amb) {
    return function(xs) {
      return bind218(function(v) {
        return evalStateT2(v)(false);
      }(runListT1(takeListT1(function() {
        if (allow_amb) {
          return 1;
        }
        ;
        return 2;
      }())(runNondetT(xs)))))(function(xs$prime) {
        return pure411(function() {
          if (xs$prime instanceof Cons && xs$prime.value1 instanceof Nil) {
            return new Just(xs$prime.value0);
          }
          ;
          return Nothing.value;
        }());
      });
    };
  };
};

// output/Options.Applicative.Common/index.js
var bind10 = /* @__PURE__ */ bind(bindArray);
var fromFoldable16 = /* @__PURE__ */ fromFoldable(foldableList);
var map30 = /* @__PURE__ */ map(functorMaybe);
var voidRight2 = /* @__PURE__ */ voidRight(functorMaybe);
var guard4 = /* @__PURE__ */ guard(alternativeMaybe);
var any4 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var elem3 = /* @__PURE__ */ elem(foldableArray)(optNameEq);
var discard3 = /* @__PURE__ */ discard(discardUnit);
var discard1 = /* @__PURE__ */ discard3(bindMaybe);
var un5 = /* @__PURE__ */ un();
var lift6 = /* @__PURE__ */ lift(monadTransStateT);
var apply9 = /* @__PURE__ */ apply2(applyMaybe);
var alt3 = /* @__PURE__ */ alt(altMaybe);
var bind13 = /* @__PURE__ */ bind(bindMaybe);
var apply13 = /* @__PURE__ */ apply2(parserApply);
var oneOf2 = /* @__PURE__ */ oneOf(foldableArray);
var bind22 = /* @__PURE__ */ bind(freeBind);
var greaterThan2 = /* @__PURE__ */ greaterThan(optVisibilityOrd);
var lift12 = /* @__PURE__ */ lift(nondetTMonadTrans);
var pure11 = /* @__PURE__ */ pure(parserApplicative);
var pure15 = /* @__PURE__ */ pure(applicativeMaybe);
var notEq1 = /* @__PURE__ */ notEq(argPolicyEq);
var OptWord = /* @__PURE__ */ function() {
  function OptWord2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OptWord2.create = function(value0) {
    return function(value12) {
      return new OptWord2(value0, value12);
    };
  };
  return OptWord2;
}();
var unexpectedError = function(arg) {
  return function(p) {
    return new UnexpectedError(arg, new SomeParser(mkExists(p)));
  };
};
var simplify = function(v) {
  if (v instanceof Leaf2) {
    return new Leaf2(v.value0);
  }
  ;
  if (v instanceof MultNode) {
    var remove_mult = function(v12) {
      if (v12 instanceof MultNode) {
        return v12.value0;
      }
      ;
      return [v12];
    };
    var v1 = bind10(v.value0)(function($340) {
      return remove_mult(simplify($340));
    });
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new MultNode(v1);
  }
  ;
  if (v instanceof AltNode) {
    var remove_alt = function(v12) {
      if (v12 instanceof AltNode) {
        return v12.value0;
      }
      ;
      if (v12 instanceof MultNode && v12.value0.length === 0) {
        return [];
      }
      ;
      return [v12];
    };
    var v1 = bind10(v.value0)(function($341) {
      return remove_alt(simplify($341));
    });
    if (v1.length === 0) {
      return new MultNode([]);
    }
    ;
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new AltNode(v1);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 280, column 1 - line 280, column 45): " + [v.constructor.name]);
};
var showOption = function(v) {
  if (v instanceof OptLong) {
    return "--" + v.value0;
  }
  ;
  if (v instanceof OptShort) {
    return fromCharArray(["-", v.value0]);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 43, column 1 - line 43, column 32): " + [v.constructor.name]);
};
var parseWord = /* @__PURE__ */ function() {
  var go = function(v) {
    if (v instanceof Cons && (v.value0 === "-" && (v.value1 instanceof Cons && v.value1.value0 === "-"))) {
      return new Just(function() {
        var v1 = function() {
          var v2 = span2(function(v3) {
            return v3 !== "=";
          })(v.value1.value1);
          if (v2.rest instanceof Nil) {
            return new Tuple(v.value1.value1, Nothing.value);
          }
          ;
          if (v2.rest instanceof Cons) {
            return new Tuple(v2.init, new Just(v2.rest.value1));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 107, column 23 - line 109, column 70): " + [v2.constructor.name]);
        }();
        return new OptWord(new OptLong(fromCharArray(fromFoldable16(v1.value0))), map30(function($342) {
          return fromCharArray(fromFoldable16($342));
        })(v1.value1));
      }());
    }
    ;
    if (v instanceof Cons && v.value0 === "-") {
      if (v.value1 instanceof Nil) {
        return Nothing.value;
      }
      ;
      if (v.value1 instanceof Cons) {
        return new Just(function() {
          var arg = voidRight2(v.value1.value1)(guard4(!$$null5(v.value1.value1)));
          return new OptWord(new OptShort(v.value1.value0), map30(function($343) {
            return fromCharArray(fromFoldable16($343));
          })(arg));
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 111, column 25 - line 115, column 79): " + [v.value1.constructor.name]);
    }
    ;
    return Nothing.value;
  };
  var $344 = fromFoldable6(foldableArray);
  return function($345) {
    return go($344(toCharArray($345)));
  };
}();
var optionNames = function(v) {
  if (v instanceof OptReader) {
    return v.value0;
  }
  ;
  if (v instanceof FlagReader) {
    return v.value0;
  }
  ;
  return [];
};
var liftOpt = /* @__PURE__ */ function() {
  return OptP.create;
}();
var isOptionPrefix = function(v) {
  return function(v1) {
    if (v instanceof OptShort && v1 instanceof OptShort) {
      return v.value0 === v1.value0;
    }
    ;
    if (v instanceof OptLong && v1 instanceof OptLong) {
      return startsWith(v.value0)(v1.value0);
    }
    ;
    return false;
  };
};
var optMatches = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bindStateT3 = bindStateT(Monad0);
  var bind312 = bind(bindStateT3);
  var monadStateStateT4 = monadStateStateT(Monad0);
  var get6 = get(monadStateStateT4);
  var missingArgP2 = missingArgP(dictMonadP);
  var lift26 = lift6(Monad0);
  var pure217 = pure(applicativeStateT(Monad0));
  var discard213 = discard3(bindStateT3);
  var put7 = put(monadStateStateT4);
  var runReadM2 = runReadM(dictMonadP);
  return function(disambiguate) {
    return function(opt) {
      return function(v) {
        var is_short = function(v1) {
          if (v1 instanceof OptShort) {
            return true;
          }
          ;
          if (v1 instanceof OptLong) {
            return false;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 90, column 5 - line 90, column 33): " + [v1.constructor.name]);
        };
        var has_name = function(a) {
          if (disambiguate) {
            return any4(isOptionPrefix(a));
          }
          ;
          if (otherwise) {
            return elem3(a);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 93, column 5 - line 95, column 27): " + [a.constructor.name]);
        };
        var errorFor = function(name5) {
          return function(msg) {
            return "option " + (showOption(name5) + (": " + msg));
          };
        };
        if (opt instanceof OptReader) {
          return discard1(guard4(has_name(v.value0)(opt.value0)))(function() {
            return new Just(bind312(get6)(function(args) {
              var missing_arg = missingArgP2(opt.value2(showOption(v.value0)))(un5(CReader)(opt.value1).crCompleter);
              return bind312(function() {
                var v1 = maybe(args)(function(v2) {
                  return new Cons(v2, args);
                })(v.value1);
                if (v1 instanceof Nil) {
                  return lift26(missing_arg);
                }
                ;
                if (v1 instanceof Cons) {
                  return pure217(new Tuple(v1.value0, v1.value1));
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 68, column 27 - line 70, column 56): " + [v1.constructor.name]);
              }())(function(v1) {
                return discard213(put7(v1.value1))(function() {
                  return lift26(runReadM2(withReadM(errorFor(v.value0))(un5(CReader)(opt.value1).crReader))(v1.value0));
                });
              });
            }));
          });
        }
        ;
        if (opt instanceof FlagReader) {
          return discard1(guard4(has_name(v.value0)(opt.value0)))(function() {
            return discard1(guard4(is_short(v.value0) || isNothing(v.value1)))(function() {
              return new Just(bind312(get6)(function(args) {
                var val$prime = map30(function($346) {
                  return function(s) {
                    return cons("-")(s);
                  }(toCharArray($346));
                })(v.value1);
                return discard213(put7(maybe(args)(function() {
                  var $347 = flip(Cons.create)(args);
                  return function($348) {
                    return $347(fromCharArray($348));
                  };
                }())(val$prime)))(function() {
                  return pure217(opt.value1);
                });
              }));
            });
          });
        }
        ;
        return Nothing.value;
      };
    };
  };
};
var isArg = function(v) {
  if (v instanceof ArgReader) {
    return true;
  }
  ;
  return false;
};
var evalParser = function(v) {
  if (v instanceof NilP) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof OptP) {
    return Nothing.value;
  }
  ;
  if (v instanceof MultP) {
    return runExists(function(v1) {
      return apply9(evalParser(v1.value0))(evalParser(v1.value1));
    })(v.value0);
  }
  ;
  if (v instanceof AltP) {
    return alt3(evalParser(v.value0))(evalParser(v.value1));
  }
  ;
  if (v instanceof BindP) {
    return resume$prime(function(p) {
      return function(k) {
        return bind13(evalParser(p))(function($349) {
          return evalParser(BindP.create(k($349)));
        });
      };
    })(Just.create)(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 220, column 1 - line 220, column 44): " + [v.constructor.name]);
};
var searchParser = function(dictMonad) {
  var nondetTPlus2 = nondetTPlus(dictMonad);
  var empty14 = empty(nondetTPlus2);
  var mapFlipped25 = mapFlipped(nondetTFunctor(dictMonad));
  var nondetTAltOp2 = nondetTAltOp(dictMonad);
  var oneOf1 = oneOf2(nondetTPlus2);
  return function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return empty14;
      }
      ;
      if (v1 instanceof OptP) {
        return v(v1.value0);
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          var b = mapFlipped25(searchParser(dictMonad)(v)(v2.value1))(function(p2$prime) {
            return apply13(v2.value0)(p2$prime);
          });
          var a = mapFlipped25(searchParser(dictMonad)(v)(v2.value0))(function(p1$prime) {
            return apply13(p1$prime)(v2.value1);
          });
          return nondetTAltOp2(a)(b);
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return oneOf1([searchParser(dictMonad)(v)(v1.value0), searchParser(dictMonad)(v)(v1.value1)]);
      }
      ;
      if (v1 instanceof BindP) {
        return resume$prime(function(p) {
          return function(k) {
            return oneOf1([mapFlipped25(searchParser(dictMonad)(v)(p))(function(p$prime) {
              return new BindP(bind22(liftF(p$prime))(k));
            }), function() {
              var v2 = evalParser(p);
              if (v2 instanceof Nothing) {
                return empty14;
              }
              ;
              if (v2 instanceof Just) {
                return searchParser(dictMonad)(v)(new BindP(k(v2.value0)));
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Common (line 135, column 7 - line 137, column 49): " + [v2.constructor.name]);
            }()]);
          };
        })($$const(empty14))(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 118, column 1 - line 120, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var searchOpt = function(dictMonadP) {
  var monadStateT4 = monadStateT(dictMonadP.Monad0());
  var searchParser1 = searchParser(monadStateT4);
  var optMatches1 = optMatches(dictMonadP);
  var lift26 = lift12(monadStateT4);
  var map154 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var empty14 = empty(nondetTPlus(monadStateT4));
  return function(pprefs) {
    return function(w) {
      return searchParser1(function(opt) {
        var disambiguate = un5(ParserPrefs)(pprefs).prefDisambiguate && greaterThan2(optVisibility(opt))(Internal.value);
        var v = optMatches1(disambiguate)(un5(Option)(opt).optMain)(w);
        if (v instanceof Just) {
          return lift26(map154(pure11)(v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return empty14;
        }
        ;
        throw new Error("Failed pattern match at Options.Applicative.Common (line 144, column 3 - line 146, column 21): " + [v.constructor.name]);
      });
    };
  };
};
var stepParser = function(dictMonadP) {
  var alt110 = alt(nondetTAlt(monadStateT(dictMonadP.Monad0())));
  var searchOpt1 = searchOpt(dictMonadP);
  return function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          if (v1 instanceof AllPositionals) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          if (v1 instanceof ForwardOptions) {
            var v4 = parseWord(v2);
            if (v4 instanceof Just) {
              return alt110(searchOpt1(v)(v4.value0)(v3))(searchArg(dictMonadP)(v)(v2)(v3));
            }
            ;
            if (v4 instanceof Nothing) {
              return searchArg(dictMonadP)(v)(v2)(v3);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 174, column 42 - line 176, column 36): " + [v4.constructor.name]);
          }
          ;
          var v4 = parseWord(v2);
          if (v4 instanceof Just) {
            return searchOpt1(v)(v4.value0)(v3);
          }
          ;
          if (v4 instanceof Nothing) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 177, column 29 - line 179, column 36): " + [v4.constructor.name]);
        };
      };
    };
  };
};
var searchArg = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var monadStateT4 = monadStateT(Monad0);
  var searchParser1 = searchParser(monadStateT4);
  var discard213 = discard3(nondetTBind(monadStateT4));
  var when21 = when(nondetTApplicative(monadStateT4));
  var cut2 = cut(monadStateT4);
  var lift26 = lift12(monadStateT4);
  var bindStateT3 = bindStateT(Monad0);
  var bind312 = bind(bindStateT3);
  var applyFirst6 = applyFirst(applyStateT(Monad0));
  var monadStateStateT4 = monadStateStateT(Monad0);
  var get6 = get(monadStateStateT4);
  var put7 = put(monadStateStateT4);
  var map154 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var lift33 = lift6(Monad0);
  var Apply0 = Monad0.Bind1().Apply0();
  var applyFirst1 = applyFirst(Apply0);
  var applySecond12 = applySecond(Apply0);
  var enterContext2 = enterContext(dictMonadP);
  var exitContext2 = exitContext(dictMonadP);
  var map233 = map(nondetTFunctor(monadStateT4));
  var discard310 = discard3(bindStateT3);
  var pure217 = pure(applicativeStateT(Monad0));
  var empty14 = empty(nondetTPlus(monadStateT4));
  var runReadM2 = runReadM(dictMonadP);
  return function(prefs2) {
    return function(arg) {
      return searchParser1(function(opt) {
        return discard213(when21(isArg(un5(Option)(opt).optMain))(cut2))(function() {
          var v = un5(Option)(opt).optMain;
          if (v instanceof CmdReader) {
            var v1 = new Tuple(v.value2(arg), un5(ParserPrefs)(prefs2).prefBacktrack);
            if (v1.value0 instanceof Just && v1.value1 instanceof NoBacktrack) {
              return lift26(bind312(applyFirst6(get6)(put7(Nil.value)))(function(args) {
                return map154(pure11)(lift33(applyFirst1(applySecond12(enterContext2(arg)(v1.value0.value0))(runParserInfo(dictMonadP)(v1.value0.value0)(args)))(exitContext2)));
              }));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof Backtrack) {
              return map233(pure11)(lift26(StateT(function(args) {
                return applyFirst1(applySecond12(enterContext2(arg)(v1.value0.value0))(runParser(dictMonadP)(un5(ParserInfo)(v1.value0.value0).infoPolicy)(CmdStart.value)(un5(ParserInfo)(v1.value0.value0).infoParser)(args)))(exitContext2);
              })));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof SubparserInline) {
              return lift26(discard310(lift33(enterContext2(arg)(v1.value0.value0)))(function() {
                return pure217(un5(ParserInfo)(v1.value0.value0).infoParser);
              }));
            }
            ;
            if (v1.value0 instanceof Nothing) {
              return empty14;
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 154, column 7 - line 166, column 38): " + [v1.constructor.name]);
          }
          ;
          if (v instanceof ArgReader) {
            return map233(pure11)(lift26(lift33(runReadM2(un5(CReader)(v.value0).crReader)(arg))));
          }
          ;
          return empty14;
        });
      });
    };
  };
};
var runParserInfo = function(dictMonadP) {
  return function(i) {
    return runParserFully(dictMonadP)(un5(ParserInfo)(i).infoPolicy)(un5(ParserInfo)(i).infoParser);
  };
};
var runParserFully = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bind312 = bind(Monad0.Bind1());
  var pure217 = pure(Monad0.Applicative0());
  var errorP2 = errorP(dictMonadP);
  return function(policy) {
    return function(p) {
      return function(args) {
        return bind312(runParser(dictMonadP)(policy)(CmdStart.value)(p)(args))(function(v) {
          if (v.value1 instanceof Nil) {
            return pure217(v.value0);
          }
          ;
          if (v.value1 instanceof Cons) {
            return errorP2(unexpectedError(v.value1.value0)(pure11(unit)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 214, column 3 - line 216, column 66): " + [v.value1.constructor.name]);
        });
      };
    };
  };
};
var runParser = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var disamb2 = disamb(monadStateT(Monad0));
  var exitP2 = exitP(dictMonadP);
  var bind312 = bind(Monad0.Bind1());
  var getPrefs2 = getPrefs(dictMonadP);
  var hoistMaybe2 = hoistMaybe(dictMonadP);
  return function(policy) {
    return function(isCmdStart) {
      return function(p) {
        return function(args) {
          var result = apply9(map30(Tuple.create)(evalParser(p)))(pure15(args));
          var newPolicy = function(a) {
            if (policy instanceof NoIntersperse) {
              var $299 = isJust(parseWord(a));
              if ($299) {
                return NoIntersperse.value;
              }
              ;
              return AllPositionals.value;
            }
            ;
            return policy;
          };
          var do_step = function(prefs2) {
            return function(arg) {
              return function(argt) {
                return function(v) {
                  return runStateT(v)(argt);
                }(disamb2(!un5(ParserPrefs)(prefs2).prefDisambiguate)(stepParser(dictMonadP)(prefs2)(policy)(arg)(p)));
              };
            };
          };
          if (args instanceof Nil) {
            return exitP2(isCmdStart)(policy)(p)(result);
          }
          ;
          if (args instanceof Cons && (args.value0 === "--" && notEq1(policy)(AllPositionals.value))) {
            return runParser(dictMonadP)(AllPositionals.value)(CmdCont.value)(p)(args.value1);
          }
          ;
          if (args instanceof Cons) {
            return bind312(getPrefs2)(function(prefs2) {
              return bind312(do_step(prefs2)(args.value0)(args.value1))(function(v) {
                if (v.value0 instanceof Nothing) {
                  return hoistMaybe2(unexpectedError(args.value0)(p))(result);
                }
                ;
                if (v.value0 instanceof Just) {
                  return runParser(dictMonadP)(newPolicy(args.value0))(CmdCont.value)(v.value0.value0)(v.value1);
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 192, column 5 - line 194, column 60): " + [v.value0.constructor.name]);
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 186, column 38 - line 194, column 60): " + [args.constructor.name]);
        };
      };
    };
  };
};
var treeMapParser = function(g) {
  var has_default = function(p) {
    return isJust(evalParser(p));
  };
  var hasArg = function(v) {
    if (v instanceof NilP) {
      return false;
    }
    ;
    if (v instanceof OptP) {
      return isArg(un5(Option)(v.value0).optMain);
    }
    ;
    if (v instanceof MultP) {
      return runExists(function(v1) {
        return hasArg(v1.value0) || hasArg(v1.value1);
      })(v.value0);
    }
    ;
    if (v instanceof AltP) {
      return hasArg(v.value0) || hasArg(v.value1);
    }
    ;
    if (v instanceof BindP) {
      return resume$prime(function(p) {
        return function(v1) {
          return hasArg(p);
        };
      })($$const(false))(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 272, column 5 - line 272, column 44): " + [v.constructor.name]);
  };
  var go = function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return function(v4) {
            if (v4 instanceof NilP) {
              return new MultNode([]);
            }
            ;
            if (v4 instanceof OptP) {
              if (greaterThan2(optVisibility(v4.value0))(Internal.value)) {
                return new Leaf2(v3({
                  hinfoMulti: v,
                  hinfoDefault: v1,
                  hinfoUnreachableArgs: v2
                })(v4.value0));
              }
              ;
              if (otherwise) {
                return new MultNode([]);
              }
              ;
            }
            ;
            if (v4 instanceof MultP) {
              return runExists(function(v5) {
                var r$prime = v2 || hasArg(v5.value0);
                return new MultNode([go(v)(v1)(v2)(v3)(v5.value0), go(v)(v1)(r$prime)(v3)(v5.value1)]);
              })(v4.value0);
            }
            ;
            if (v4 instanceof AltP) {
              var d$prime = v1 || (has_default(v4.value0) || has_default(v4.value1));
              return new AltNode([go(v)(d$prime)(v2)(v3)(v4.value0), go(v)(d$prime)(v2)(v3)(v4.value1)]);
            }
            ;
            if (v4 instanceof BindP) {
              return resume$prime(function(p) {
                return function(k) {
                  var go$prime = go(true)(v1)(v2)(v3)(p);
                  var v5 = evalParser(p);
                  if (v5 instanceof Nothing) {
                    return go$prime;
                  }
                  ;
                  if (v5 instanceof Just) {
                    return new MultNode([go$prime, go(true)(v1)(v2)(v3)(new BindP(k(v5.value0)))]);
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.Common (line 267, column 12 - line 269, column 68): " + [v5.constructor.name]);
                };
              })($$const(new MultNode([])))(v4.value0);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 248, column 5 - line 251, column 21): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name, v4.constructor.name]);
          };
        };
      };
    };
  };
  var $350 = go(false)(false)(false)(g);
  return function($351) {
    return simplify($350($351));
  };
};
var mapParser = function(f) {
  var flatten2 = function(v) {
    if (v instanceof Leaf2) {
      return [v.value0];
    }
    ;
    if (v instanceof MultNode) {
      return bind10(v.value0)(flatten2);
    }
    ;
    if (v instanceof AltNode) {
      return bind10(v.value0)(flatten2);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 235, column 5 - line 235, column 27): " + [v.constructor.name]);
  };
  var $352 = treeMapParser(f);
  return function($353) {
    return flatten2($352($353));
  };
};

// output/Options.Applicative.Builder.Internal/index.js
var over5 = /* @__PURE__ */ over()();
var append7 = /* @__PURE__ */ append(semigroupArray);
var map31 = /* @__PURE__ */ map(functorArray);
var lookup5 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var alt4 = /* @__PURE__ */ alt(altMaybe);
var identity17 = /* @__PURE__ */ identity(categoryFn);
var apply10 = /* @__PURE__ */ apply2(applyMaybe);
var alt13 = /* @__PURE__ */ alt(parserAlt);
var pure16 = /* @__PURE__ */ pure(parserApplicative);
var OptionFields = function(x) {
  return x;
};
var FlagFields = function(x) {
  return x;
};
var DefaultProp = /* @__PURE__ */ function() {
  function DefaultProp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DefaultProp2.create = function(value0) {
    return function(value12) {
      return new DefaultProp2(value0, value12);
    };
  };
  return DefaultProp2;
}();
var Mod = /* @__PURE__ */ function() {
  function Mod2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Mod2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Mod2(value0, value12, value22);
      };
    };
  };
  return Mod2;
}();
var CommandFields = function(x) {
  return x;
};
var optionFieldsHasValue = {
  hasValueDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasName = {
  name: function(n) {
    return over5(OptionFields)(function(fields) {
      return {
        optCompleter: fields.optCompleter,
        optNoArgError: fields.optNoArgError,
        optNames: append7([n])(fields.optNames)
      };
    });
  }
};
var name2 = function(dict) {
  return dict.name;
};
var mkCommand = function(m) {
  var v = m.value0({
    cmdCommands: [],
    cmdGroup: Nothing.value
  });
  return new Tuple(v.cmdGroup, new Tuple(map31(fst)(v.cmdCommands), new Tuple(function(v1) {
    return lookup5(v1)(v.cmdCommands);
  }, unit)));
};
var flagFieldsHasName = {
  name: function(n) {
    return over5(FlagFields)(function(fields) {
      return {
        flagActive: fields.flagActive,
        flagNames: append7([n])(fields.flagNames)
      };
    });
  }
};
var defaultPropSemigroup = {
  append: function(v) {
    return function(v1) {
      return new DefaultProp(alt4(v.value0)(v1.value0), alt4(v.value1)(v1.value1));
    };
  }
};
var append18 = /* @__PURE__ */ append(defaultPropSemigroup);
var modSemigroup = {
  append: function(v) {
    return function(v1) {
      return new Mod(function($69) {
        return v1.value0(v.value0($69));
      }, append18(v1.value1)(v.value1), function($70) {
        return v1.value2(v.value2($70));
      });
    };
  }
};
var defaultPropMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new DefaultProp(Nothing.value, Nothing.value),
    Semigroup0: function() {
      return defaultPropSemigroup;
    }
  };
}();
var mempty5 = /* @__PURE__ */ mempty(defaultPropMonoid);
var fieldMod = function(f) {
  return new Mod(f, mempty5, identity17);
};
var modMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new Mod(identity17, mempty5, identity17),
    Semigroup0: function() {
      return modSemigroup;
    }
  };
}();
var optionMod = /* @__PURE__ */ function() {
  return Mod.create(identity17)(mempty5);
}();
var internal = /* @__PURE__ */ optionMod(/* @__PURE__ */ over5(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: Internal.value
  };
}));
var commandFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var baseProps = /* @__PURE__ */ function() {
  return {
    propMetaVar: "",
    propVisibility: Visible.value,
    propHelp: mempty(chunkMonoid(docSemigroup)),
    propShowDefault: Nothing.value,
    propDescMod: Nothing.value
  };
}();
var mkProps = function(v) {
  return function(g) {
    var props = over5(OptProperties)(function(r) {
      return {
        propDescMod: r.propDescMod,
        propHelp: r.propHelp,
        propMetaVar: r.propMetaVar,
        propVisibility: r.propVisibility,
        propShowDefault: apply10(v.value1)(v.value0)
      };
    })(g(baseProps));
    return props;
  };
};
var mkOption = function(d) {
  return function(g) {
    return function(rdr) {
      return {
        optMain: rdr,
        optProps: mkProps(d)(g)
      };
    };
  };
};
var mkParser = function(v) {
  return function(g) {
    return function(rdr) {
      var o = liftOpt(mkOption(v)(g)(rdr));
      return maybe(o)(function(a) {
        return alt13(o)(pure16(a));
      })(v.value0);
    };
  };
};
var argumentFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};

// output/Options.Applicative.Builder/index.js
var identity18 = /* @__PURE__ */ identity(categoryFn);
var over6 = /* @__PURE__ */ over()();
var un6 = /* @__PURE__ */ un();
var append8 = /* @__PURE__ */ append(modSemigroup);
var mempty6 = /* @__PURE__ */ mempty(completerMonoid);
var bind11 = /* @__PURE__ */ bind(readMBind);
var pure17 = /* @__PURE__ */ pure(readMApplicative);
var mempty12 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var min5 = /* @__PURE__ */ min(optVisibilityOrd);
var alt5 = /* @__PURE__ */ alt(parserAlt);
var pure18 = /* @__PURE__ */ pure(parserApplicative);
var show5 = /* @__PURE__ */ show(showString);
var append32 = /* @__PURE__ */ append(semigroupArray);
var mempty22 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "argCompleter";
  }
})(completerMonoid)()(monoidRecordNil)));
var fold5 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var PrefsMod = function(x) {
  return x;
};
var InfoMod = function(x) {
  return x;
};
var value = function(dictHasValue) {
  return function(x) {
    return new Mod(identity18, new DefaultProp(new Just(x), Nothing.value), identity18);
  };
};
var value1 = /* @__PURE__ */ value(optionFieldsHasValue);
var str = readerAsk;
var $$short = function(dictHasName) {
  var $121 = name2(dictHasName);
  return function($122) {
    return fieldMod($121(OptShort.create($122)));
  };
};
var progDesc = function(s) {
  return over6(ParserInfo)(function(i) {
    return {
      infoFailureCode: i.infoFailureCode,
      infoFooter: i.infoFooter,
      infoFullDesc: i.infoFullDesc,
      infoHeader: i.infoHeader,
      infoParser: i.infoParser,
      infoPolicy: i.infoPolicy,
      infoProgDesc: paragraph(s)
    };
  });
};
var noArgError = function(e) {
  return fieldMod(over6(OptionFields)(function(p) {
    return {
      optCompleter: p.optCompleter,
      optNames: p.optNames,
      optNoArgError: $$const(e)
    };
  }));
};
var prefs = function(m) {
  var base = {
    prefMultiSuffix: "",
    prefDisambiguate: false,
    prefShowHelpOnError: false,
    prefShowHelpOnEmpty: false,
    prefBacktrack: Backtrack.value,
    prefColumns: 80
  };
  return un6(PrefsMod)(m)(base);
};
var prefsModSemigroup = {
  append: function(m1) {
    return function(m2) {
      var $123 = un6(PrefsMod)(m2);
      var $124 = un6(PrefsMod)(m1);
      return function($125) {
        return $123($124($125));
      };
    };
  }
};
var prefsModMonoid = {
  mempty: identity18,
  Semigroup0: function() {
    return prefsModSemigroup;
  }
};
var metavar = function(dictHasMetavar) {
  return function($$var) {
    return optionMod(over6(OptProperties)(function(p) {
      return {
        propDescMod: p.propDescMod,
        propHelp: p.propHelp,
        propShowDefault: p.propShowDefault,
        propVisibility: p.propVisibility,
        propMetaVar: $$var
      };
    }));
  };
};
var metavar1 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var option = function(r) {
  return function(m) {
    var v = append8(metavar1("ARG"))(m);
    var v1 = v.value0({
      optNames: [],
      optCompleter: mempty6,
      optNoArgError: ExpectsArgError.create
    });
    var crdr = {
      crCompleter: v1.optCompleter,
      crReader: r
    };
    var rdr = new OptReader(v1.optNames, crdr, v1.optNoArgError);
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var strOption = /* @__PURE__ */ option(str);
var $$long = function(dictHasName) {
  var $126 = name2(dictHasName);
  return function($127) {
    return fieldMod($126(OptLong.create($127)));
  };
};
var info = function(parser6) {
  return function(m) {
    var base = {
      infoParser: parser6,
      infoFullDesc: true,
      infoProgDesc: mempty12,
      infoHeader: mempty12,
      infoFooter: mempty12,
      infoFailureCode: $$Error.value,
      infoPolicy: Intersperse.value
    };
    return un6(InfoMod)(m)(base);
  };
};
var idm = function(dictMonoid) {
  return mempty(dictMonoid);
};
var hidden = /* @__PURE__ */ optionMod(/* @__PURE__ */ over6(OptProperties)(function(p) {
  return {
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault,
    propVisibility: min5(Hidden.value)(p.propVisibility)
  };
}));
var help = function(s) {
  return optionMod(over6(OptProperties)(function(p) {
    return {
      propDescMod: p.propDescMod,
      propMetaVar: p.propMetaVar,
      propShowDefault: p.propShowDefault,
      propVisibility: p.propVisibility,
      propHelp: paragraph(s)
    };
  }));
};
var flag$prime = function(actv) {
  return function(v) {
    var rdr = function() {
      var v1 = v.value0({
        flagNames: [],
        flagActive: actv
      });
      return new FlagReader(v1.flagNames, v1.flagActive);
    }();
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var flag = function(defv) {
  return function(actv) {
    return function(m) {
      return alt5(flag$prime(actv)(m))(pure18(defv));
    };
  };
};
var $$switch = /* @__PURE__ */ flag(false)(true);
var eitherReader = function(f) {
  return bind11(readerAsk)(function() {
    var $131 = either(readerError)(pure17);
    return function($132) {
      return $131(f($132));
    };
  }());
};
var $$int2 = /* @__PURE__ */ eitherReader(function(s) {
  var v = fromString3(s);
  if (v instanceof Nothing) {
    return new Left("Can't parse as Int: `" + (show5(s) + "`"));
  }
  ;
  if (v instanceof Just) {
    return new Right(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Builder (line 124, column 28 - line 126, column 20): " + [v.constructor.name]);
});
var defaultPrefs = /* @__PURE__ */ prefs(/* @__PURE__ */ idm(prefsModMonoid));
var command = function(cmd) {
  return function(pinfo) {
    return fieldMod(over6(CommandFields)(function(p) {
      return {
        cmdGroup: p.cmdGroup,
        cmdCommands: append32([new Tuple(cmd, pinfo)])(p.cmdCommands)
      };
    }));
  };
};
var argument = function(p) {
  return function(v) {
    var v1 = v.value0(mempty22);
    var rdr = {
      crCompleter: v1.argCompleter,
      crReader: p
    };
    return mkParser(v.value1)(v.value2)(new ArgReader(rdr));
  };
};
var strArgument = /* @__PURE__ */ argument(str);
var abortOption = function(err) {
  return function(m) {
    return option(readerAbort(err))(function(v) {
      return append8(v)(m);
    }(fold5([noArgError(err), value1(identity18), metavar1("")])));
  };
};

// output/Node.Encoding/index.js
var ASCII = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var UTF8 = /* @__PURE__ */ function() {
  function UTF82() {
  }
  ;
  UTF82.value = new UTF82();
  return UTF82;
}();
var UTF16LE = /* @__PURE__ */ function() {
  function UTF16LE2() {
  }
  ;
  UTF16LE2.value = new UTF16LE2();
  return UTF16LE2;
}();
var UCS2 = /* @__PURE__ */ function() {
  function UCS22() {
  }
  ;
  UCS22.value = new UCS22();
  return UCS22;
}();
var Base64 = /* @__PURE__ */ function() {
  function Base642() {
  }
  ;
  Base642.value = new Base642();
  return Base642;
}();
var Base64Url = /* @__PURE__ */ function() {
  function Base64Url2() {
  }
  ;
  Base64Url2.value = new Base64Url2();
  return Base64Url2;
}();
var Latin1 = /* @__PURE__ */ function() {
  function Latin12() {
  }
  ;
  Latin12.value = new Latin12();
  return Latin12;
}();
var Binary = /* @__PURE__ */ function() {
  function Binary2() {
  }
  ;
  Binary2.value = new Binary2();
  return Binary2;
}();
var Hex = /* @__PURE__ */ function() {
  function Hex2() {
  }
  ;
  Hex2.value = new Hex2();
  return Hex2;
}();
var showEncoding = {
  show: function(v) {
    if (v instanceof ASCII) {
      return "ASCII";
    }
    ;
    if (v instanceof UTF8) {
      return "UTF8";
    }
    ;
    if (v instanceof UTF16LE) {
      return "UTF16LE";
    }
    ;
    if (v instanceof UCS2) {
      return "UCS2";
    }
    ;
    if (v instanceof Base64) {
      return "Base64";
    }
    ;
    if (v instanceof Base64Url) {
      return "Base64Url";
    }
    ;
    if (v instanceof Latin1) {
      return "Latin1";
    }
    ;
    if (v instanceof Binary) {
      return "Binary";
    }
    ;
    if (v instanceof Hex) {
      return "Hex";
    }
    ;
    throw new Error("Failed pattern match at Node.Encoding (line 22, column 1 - line 31, column 19): " + [v.constructor.name]);
  }
};
var encodingToNode = function(v) {
  if (v instanceof ASCII) {
    return "ascii";
  }
  ;
  if (v instanceof UTF8) {
    return "utf8";
  }
  ;
  if (v instanceof UTF16LE) {
    return "utf16le";
  }
  ;
  if (v instanceof UCS2) {
    return "ucs2";
  }
  ;
  if (v instanceof Base64) {
    return "base64";
  }
  ;
  if (v instanceof Base64Url) {
    return "base64url";
  }
  ;
  if (v instanceof Latin1) {
    return "latin1";
  }
  ;
  if (v instanceof Binary) {
    return "binary";
  }
  ;
  if (v instanceof Hex) {
    return "hex";
  }
  ;
  throw new Error("Failed pattern match at Node.Encoding (line 35, column 1 - line 35, column 37): " + [v.constructor.name]);
};

// output/Node.Stream/foreign.js
import stream from "node:stream";
var readChunkImpl = (useBuffer, useString, chunk) => {
  if (chunk instanceof Buffer) {
    return useBuffer(chunk);
  } else if (typeof chunk === "string") {
    return useString(chunk);
  } else {
    throw new Error(
      "Node.Stream.readChunkImpl: Unrecognised chunk type; expected String or Buffer, got: " + chunk
    );
  }
};
var pipeImpl = (r, w) => r.pipe(w);
var writeImpl = (w, buf) => w.write(buf);
var writeStringImpl = (w, str2, enc) => w.write(str2, enc);
var endImpl = (w) => w.end();
var destroyImpl = (w) => w.destroy();
var pipelineImpl = (src, transforms, dst, cb) => stream.pipeline([src, ...transforms, dst], cb);
var newPassThrough = () => new stream.PassThrough({ objectMode: false });

// output/Node.Buffer.Immutable/foreign.js
import { Buffer as Buffer2 } from "node:buffer";
var alloc = (size8) => Buffer2.alloc(size8);
var size4 = (buff) => buff.length;
var fromArrayBuffer = (ab) => Buffer2.from(ab);
var fromStringImpl2 = (str2, encoding) => Buffer2.from(str2, encoding);
var readImpl = (ty, offset, buf) => buf["read" + ty](offset);
var toStringImpl = (enc, buff) => buff.toString(enc);
var sliceImpl2 = (start, end4, buff) => buff.slice(start, end4);
var concatToLength = (buffs, totalLength) => Buffer2.concat(buffs, totalLength);

// output/Node.Buffer.Types/index.js
var UInt8 = /* @__PURE__ */ function() {
  function UInt82() {
  }
  ;
  UInt82.value = new UInt82();
  return UInt82;
}();
var UInt16LE = /* @__PURE__ */ function() {
  function UInt16LE2() {
  }
  ;
  UInt16LE2.value = new UInt16LE2();
  return UInt16LE2;
}();
var UInt16BE = /* @__PURE__ */ function() {
  function UInt16BE2() {
  }
  ;
  UInt16BE2.value = new UInt16BE2();
  return UInt16BE2;
}();
var UInt32LE = /* @__PURE__ */ function() {
  function UInt32LE2() {
  }
  ;
  UInt32LE2.value = new UInt32LE2();
  return UInt32LE2;
}();
var UInt32BE = /* @__PURE__ */ function() {
  function UInt32BE2() {
  }
  ;
  UInt32BE2.value = new UInt32BE2();
  return UInt32BE2;
}();
var Int8 = /* @__PURE__ */ function() {
  function Int82() {
  }
  ;
  Int82.value = new Int82();
  return Int82;
}();
var Int16LE = /* @__PURE__ */ function() {
  function Int16LE2() {
  }
  ;
  Int16LE2.value = new Int16LE2();
  return Int16LE2;
}();
var Int16BE = /* @__PURE__ */ function() {
  function Int16BE2() {
  }
  ;
  Int16BE2.value = new Int16BE2();
  return Int16BE2;
}();
var Int32LE = /* @__PURE__ */ function() {
  function Int32LE2() {
  }
  ;
  Int32LE2.value = new Int32LE2();
  return Int32LE2;
}();
var Int32BE = /* @__PURE__ */ function() {
  function Int32BE2() {
  }
  ;
  Int32BE2.value = new Int32BE2();
  return Int32BE2;
}();
var FloatLE = /* @__PURE__ */ function() {
  function FloatLE2() {
  }
  ;
  FloatLE2.value = new FloatLE2();
  return FloatLE2;
}();
var FloatBE = /* @__PURE__ */ function() {
  function FloatBE2() {
  }
  ;
  FloatBE2.value = new FloatBE2();
  return FloatBE2;
}();
var DoubleLE = /* @__PURE__ */ function() {
  function DoubleLE2() {
  }
  ;
  DoubleLE2.value = new DoubleLE2();
  return DoubleLE2;
}();
var DoubleBE = /* @__PURE__ */ function() {
  function DoubleBE2() {
  }
  ;
  DoubleBE2.value = new DoubleBE2();
  return DoubleBE2;
}();
var showBufferValueType = {
  show: function(v) {
    if (v instanceof UInt8) {
      return "UInt8";
    }
    ;
    if (v instanceof UInt16LE) {
      return "UInt16LE";
    }
    ;
    if (v instanceof UInt16BE) {
      return "UInt16BE";
    }
    ;
    if (v instanceof UInt32LE) {
      return "UInt32LE";
    }
    ;
    if (v instanceof UInt32BE) {
      return "UInt32BE";
    }
    ;
    if (v instanceof Int8) {
      return "Int8";
    }
    ;
    if (v instanceof Int16LE) {
      return "Int16LE";
    }
    ;
    if (v instanceof Int16BE) {
      return "Int16BE";
    }
    ;
    if (v instanceof Int32LE) {
      return "Int32LE";
    }
    ;
    if (v instanceof Int32BE) {
      return "Int32BE";
    }
    ;
    if (v instanceof FloatLE) {
      return "FloatLE";
    }
    ;
    if (v instanceof FloatBE) {
      return "FloatBE";
    }
    ;
    if (v instanceof DoubleLE) {
      return "DoubleLE";
    }
    ;
    if (v instanceof DoubleBE) {
      return "DoubleBE";
    }
    ;
    throw new Error("Failed pattern match at Node.Buffer.Types (line 33, column 1 - line 47, column 29): " + [v.constructor.name]);
  }
};

// output/Node.Buffer.Immutable/index.js
var show6 = /* @__PURE__ */ show(showBufferValueType);
var toString5 = function(enc) {
  return function(buf) {
    return toStringImpl(encodingToNode(enc), buf);
  };
};
var slice3 = function(start) {
  return function(end4) {
    return function(buf) {
      return sliceImpl2(start, end4, buf);
    };
  };
};
var read4 = function(ty) {
  return function(off) {
    return function(buf) {
      return readImpl(show6(ty), off, buf);
    };
  };
};
var fromString6 = function(str2) {
  return function(enc) {
    return fromStringImpl2(str2, encodingToNode(enc));
  };
};
var concat$prime = function(a) {
  return function(i) {
    return concatToLength(a, i);
  };
};

// output/Node.Buffer/index.js
var pure19 = /* @__PURE__ */ pure(applicativeEffect);
var map33 = /* @__PURE__ */ map(functorEffect);
var unsafeThaw2 = function($7) {
  return pure19($7);
};
var usingToImmutable = function(f) {
  return function(x) {
    return unsafeThaw2(f(x));
  };
};
var unsafeFreeze2 = function($8) {
  return pure19($8);
};
var usingFromImmutable = function(f) {
  return function(buf) {
    return map33(f)(unsafeFreeze2(buf));
  };
};
var toString6 = function(enc) {
  return usingFromImmutable(toString5(enc));
};
var slice4 = slice3;
var size5 = /* @__PURE__ */ usingFromImmutable(size4);
var read5 = function(t) {
  return function(o) {
    return usingFromImmutable(read4(t)(o));
  };
};
var fromString7 = function(s) {
  return usingToImmutable(fromString6(s));
};
var fromArrayBuffer2 = /* @__PURE__ */ usingToImmutable(fromArrayBuffer);
var concat$prime2 = function(arrs) {
  return function(n) {
    return function(v) {
      return concat$prime(arrs)(n);
    };
  };
};
var alloc2 = /* @__PURE__ */ usingToImmutable(alloc);
var create = alloc2;

// output/Node.Stream/index.js
var writeString = function(w) {
  return function(enc) {
    return function(str2) {
      return function() {
        return writeStringImpl(w, str2, encodingToNode(enc));
      };
    };
  };
};
var write3 = function(w) {
  return function(b) {
    return function() {
      return writeImpl(w, b);
    };
  };
};
var pipeline = function(src) {
  return function(transforms) {
    return function(dest) {
      return function(cb) {
        return function() {
          return pipelineImpl(src, transforms, dest, function(err) {
            return cb(toMaybe(err))();
          });
        };
      };
    };
  };
};
var pipe = function(r) {
  return function(w) {
    return function() {
      return pipeImpl(r, w);
    };
  };
};
var errorH = /* @__PURE__ */ function() {
  return new EventHandle("error", mkEffectFn1);
}();
var end = function(w) {
  return function() {
    return endImpl(w);
  };
};
var destroy = function(w) {
  return function() {
    return destroyImpl(w);
  };
};
var dataH = /* @__PURE__ */ function() {
  return new EventHandle("data", function(cb) {
    return function(chunk) {
      return readChunkImpl(mkEffectFn1(cb), function(v) {
        return $$throw("Got a String, not a Buffer. Stream encoding should not be set")();
      }, chunk);
    };
  });
}();

// output/Options.Applicative.BashCompletion/index.js
var pure20 = /* @__PURE__ */ pure(applicativeEffect);
var un7 = /* @__PURE__ */ un();
var map34 = /* @__PURE__ */ map(functorMaybe);
var map114 = /* @__PURE__ */ map(functorArray);
var runParserInfo2 = /* @__PURE__ */ runParserInfo(completionMonadP);
var fromFoldable17 = /* @__PURE__ */ fromFoldable6(foldableArray);
var identity19 = /* @__PURE__ */ identity(categoryFn);
var bind14 = /* @__PURE__ */ bind(bindMaybe);
var notEq5 = /* @__PURE__ */ notEq(argPolicyEq);
var map211 = /* @__PURE__ */ map(functorEffect);
var fold6 = /* @__PURE__ */ fold(foldableArray)(monoidArray);
var sequence2 = /* @__PURE__ */ sequence(traversableArray)(applicativeEffect);
var unLines2 = /* @__PURE__ */ unLines(foldableArray);
var alt6 = /* @__PURE__ */ alt(parserAlt);
var map35 = /* @__PURE__ */ map(parserFunctor);
var apply11 = /* @__PURE__ */ apply2(parserApply);
var append19 = /* @__PURE__ */ append(modSemigroup);
var $$long2 = /* @__PURE__ */ $$long(flagFieldsHasName);
var long1 = /* @__PURE__ */ $$long(optionFieldsHasName);
var value2 = /* @__PURE__ */ value(optionFieldsHasValue);
var pure110 = /* @__PURE__ */ pure(parserApplicative);
var fromFoldable18 = /* @__PURE__ */ fromFoldable(foldableList);
var Standard = /* @__PURE__ */ function() {
  function Standard2() {
  }
  ;
  Standard2.value = new Standard2();
  return Standard2;
}();
var Enriched = /* @__PURE__ */ function() {
  function Enriched2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Enriched2.create = function(value0) {
    return function(value12) {
      return new Enriched2(value0, value12);
    };
  };
  return Enriched2;
}();
var zshCompletionScript = function(prog) {
  return function(progn) {
    return pure20(["#compdef " + progn, "", "local request", "local completions", "local word", "local index=$((CURRENT - 1))", "", "request=(--bash-completion-enriched --bash-completion-index $index)", "for arg in ${words[@]}; do", "  request=(${request[@]} --bash-completion-word $arg)", "done", "", "IFS=$'\\n' completions=($( " + (prog + ' "${request[@]}" ))'), "", "for word in $completions; do", "  local -a parts", "", "  # Split the line at a tab if there is one.", "  IFS=$'\\t' parts=($( echo $word ))", "", "  if [[ -n $parts[2] ]]; then", '     if [[ $word[1] == "-" ]]; then', '       local desc=("$parts[1] ($parts[2])")', "       compadd -d desc -- $parts[1]", "     else", '       local desc=($(print -f  "%-019s -- %s" $parts[1] $parts[2]))', "       compadd -l -d desc -- $parts[1]", "     fi", "  else", "    compadd -f -- $word", "  fi", "done"]);
  };
};
var fishCompletionScript = function(prog) {
  return function(progn) {
    return pure20([" function _" + progn, "    set -l cl (commandline --tokenize --current-process)", "    # Hack around fish issue #3934", "    set -l cn (commandline --tokenize --cut-at-cursor --current-process)", "    set -l cn (count $cn)", "    set -l tmpline --bash-completion-enriched --bash-completion-index $cn", "    for arg in $cl", "      set tmpline $tmpline --bash-completion-word $arg", "    end", "    for opt in (" + (prog + " $tmpline)"), "      if test -d $opt", '        echo -E "$opt/"', "      else", '        echo -E "$opt"', "      end", "    end", "end", "", "complete --no-files --command " + (progn + (" --arguments '(_" + (progn + ")'")))]);
  };
};
var bashCompletionScript = function(prog) {
  return function(progn) {
    return pure20(["_" + (progn + "()"), "{", "    local CMDLINE", "    local IFS=$'\\n'", "    CMDLINE=(--bash-completion-index $COMP_CWORD)", "", "    for arg in ${COMP_WORDS[@]}; do", "        CMDLINE=(${CMDLINE[@]} --bash-completion-word $arg)", "    done", "", "    COMPREPLY=( $(" + (prog + ' "${CMDLINE[@]}") )'), "}", "", "complete -o filenames -F _" + (progn + (" " + progn))]);
  };
};
var arraySplitAt = function(idx) {
  return function(arr) {
    if (idx === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    return {
      init: slice(0)(idx)(arr),
      rest: slice(idx)(length(arr))(arr)
    };
  };
};
var bashCompletionQuery = function(pinfo) {
  return function(pprefs) {
    return function(richness) {
      return function(ws) {
        return function(i) {
          return function(v) {
            var v1 = arraySplitAt(i)(ws);
            var run_completer = function(c) {
              return un7(Completer)(c)(fromMaybe("")(head(v1.rest)));
            };
            var render_line = function(len) {
              return function(doc) {
                var v22 = map34(uncons2)(fromArray(lines2(displayS(renderPretty(1)(len)(doc)))));
                if (v22 instanceof Nothing) {
                  return "";
                }
                ;
                if (v22 instanceof Just && v22.value0.tail.length === 0) {
                  return v22.value0.head;
                }
                ;
                if (v22 instanceof Just) {
                  return v22.value0.head + "...";
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 162, column 27 - line 165, column 43): " + [v22.constructor.name]);
              };
            };
            var is_completion = function() {
              var v22 = head(v1.rest);
              if (v22 instanceof Just) {
                return startsWith(v22.value0);
              }
              ;
              if (v22 instanceof Nothing) {
                return $$const(true);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 175, column 7 - line 177, column 30): " + [v22.constructor.name]);
            }();
            var filter_names = filter(is_completion);
            var show_names = function() {
              var $129 = map114(showOption);
              return function($130) {
                return filter_names($129($130));
              };
            }();
            var compl = runParserInfo2(pinfo)(fromFoldable17(drop(1)(v1.init)));
            var add_opt_help = function(dictFunctor) {
              var map416 = map(dictFunctor);
              return function(opt) {
                if (richness instanceof Standard) {
                  return identity19;
                }
                ;
                if (richness instanceof Enriched) {
                  return map416(function(o) {
                    var h = un7(Chunk)(optHelp(opt));
                    return maybe(o)(function(h$prime) {
                      return o + ("	" + render_line(richness.value0)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 138, column 24 - line 143, column 79): " + [richness.constructor.name]);
              };
            };
            var add_opt_help1 = add_opt_help(functorArray);
            var add_cmd_help = function(dictFunctor) {
              var map416 = map(dictFunctor);
              return function(p) {
                if (richness instanceof Standard) {
                  return identity19;
                }
                ;
                if (richness instanceof Enriched) {
                  return map416(function(cmd) {
                    var h = bind14(p(cmd))(function() {
                      var $131 = un7(Chunk);
                      var $132 = un7(ParserInfo);
                      return function($133) {
                        return $131(function(v22) {
                          return v22.infoProgDesc;
                        }($132($133)));
                      };
                    }());
                    return maybe(cmd)(function(h$prime) {
                      return cmd + ("	" + render_line(richness.value1)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 148, column 22 - line 153, column 85): " + [richness.constructor.name]);
              };
            };
            var add_cmd_help1 = add_cmd_help(functorArray);
            var opt_completions = function(argPolicy) {
              return function(hinfo) {
                return function(opt) {
                  var v22 = un7(Option)(opt).optMain;
                  if (v22 instanceof OptReader) {
                    if (notEq5(argPolicy)(AllPositionals.value)) {
                      return pure20(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure20([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof FlagReader) {
                    if (notEq5(argPolicy)(AllPositionals.value)) {
                      return pure20(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure20([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof ArgReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure20([]);
                    }
                    ;
                    if (otherwise) {
                      return run_completer(un7(CReader)(v22.value0).crCompleter);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof CmdReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure20([]);
                    }
                    ;
                    if (otherwise) {
                      return pure20(add_cmd_help1(v22.value2)(filter_names(v22.value1)));
                    }
                    ;
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 113, column 43 - line 133, column 53): " + [v22.constructor.name]);
                };
              };
            };
            var list_options = function(a) {
              var $134 = map211(fold6);
              var $135 = mapParser(opt_completions(a));
              return function($136) {
                return $134(sequence2($135($136)));
              };
            };
            var v2 = runCompletion(compl)(pprefs);
            if (v2 instanceof Just && v2.value0 instanceof Left) {
              return runExists(function(p) {
                return list_options(v2.value0.value0.value1)(p);
              })(v2.value0.value0.value0.value0);
            }
            ;
            if (v2 instanceof Just && v2.value0 instanceof Right) {
              return run_completer(v2.value0.value0);
            }
            ;
            if (v2 instanceof Nothing) {
              return pure20([]);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 83, column 52 - line 89, column 15): " + [v2.constructor.name]);
          };
        };
      };
    };
  };
};
var bashCompletionParser = function(pinfo) {
  return function(pprefs) {
    var failure = function(opts) {
      return {
        execCompletion: function(progn) {
          return map211(unLines2)(opts(progn));
        }
      };
    };
    var complParser = alt6(map35(failure)(apply11(apply11(map35(bashCompletionQuery(pinfo)(pprefs))(alt6(apply11(apply11(flag$prime(Enriched.create)(append19($$long2("bash-completion-enriched"))(internal)))(option($$int2)(append19(append19(long1("bash-completion-option-desc-length"))(internal))(value2(40)))))(option($$int2)(append19(append19(long1("bash-completion-command-desc-length"))(internal))(value2(40)))))(pure110(Standard.value))))(map35(fromFoldable18)(many3(strOption(append19(long1("bash-completion-word"))(internal))))))(option($$int2)(append19(long1("bash-completion-index"))(internal)))))(alt6(map35(failure)(map35(bashCompletionScript)(strOption(append19(long1("bash-completion-script"))(internal)))))(alt6(map35(failure)(map35(fishCompletionScript)(strOption(append19(long1("fish-completion-script"))(internal)))))(map35(failure)(map35(zshCompletionScript)(strOption(append19(long1("zsh-completion-script"))(internal)))))));
    return complParser;
  };
};

// output/Options.Applicative.Help.Core/index.js
var over7 = /* @__PURE__ */ over()();
var mempty7 = /* @__PURE__ */ mempty(parserHelpMonoid);
var fold7 = /* @__PURE__ */ fold2(monoidArray);
var un8 = /* @__PURE__ */ un();
var chunkMonoid3 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var mempty13 = /* @__PURE__ */ mempty(chunkMonoid3);
var eq16 = /* @__PURE__ */ eq(optVisibilityEq);
var map36 = /* @__PURE__ */ map(functorArray);
var sort2 = /* @__PURE__ */ sort(optNameOrd);
var append9 = /* @__PURE__ */ append(/* @__PURE__ */ chunkSemigroup(docSemigroup));
var map115 = /* @__PURE__ */ map(chunkFunctor);
var listToChunk2 = /* @__PURE__ */ listToChunk(docMonoid);
var identity20 = /* @__PURE__ */ identity(categoryFn);
var map212 = /* @__PURE__ */ map(functorMaybe);
var discard4 = /* @__PURE__ */ discard(discardUnit)(bindMaybe);
var guard5 = /* @__PURE__ */ guard(alternativeMaybe);
var pure21 = /* @__PURE__ */ pure(applicativeMaybe);
var extractChunk3 = /* @__PURE__ */ extractChunk(docMonoid);
var bind15 = /* @__PURE__ */ bind(bindArray);
var pure111 = /* @__PURE__ */ pure(applicativeArray);
var mempty23 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidMaybe(semigroupString))(chunkMonoid3));
var append110 = /* @__PURE__ */ append(semigroupArray);
var eq23 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var OptDescStyle = function(x) {
  return x;
};
var usageHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: chunk
    };
  })(mempty7);
};
var suggestionsHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpUsage: v.helpUsage,
      helpSuggestions: chunk
    };
  })(mempty7);
};
var intersperse2 = function(sep3) {
  var $64 = mapWithIndex2(function(idx) {
    return function(e) {
      var $49 = idx === 0;
      if ($49) {
        return [e];
      }
      ;
      return [sep3, e];
    };
  });
  return function($65) {
    return fold7($64($65));
  };
};
var optDesc = function(pprefs) {
  return function(style) {
    return function(info4) {
      return function(opt) {
        var suffix2 = function() {
          if (un8(OptHelpInfo)(info4).hinfoMulti) {
            return stringChunk(un8(ParserPrefs)(pprefs).prefMultiSuffix);
          }
          ;
          if (otherwise) {
            return mempty13;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 58, column 7 - line 62, column 17): ");
        }();
        var show_opt = function() {
          if (un8(OptHelpInfo)(info4).hinfoDefault && !un8(OptDescStyle)(style).descOptional) {
            return false;
          }
          ;
          if (eq16(optVisibility(opt))(Hidden.value)) {
            return un8(OptDescStyle)(style).descHidden;
          }
          ;
          if (otherwise) {
            return eq16(optVisibility(opt))(Visible.value);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 51, column 7 - line 57, column 39): ");
        }();
        var ns = optionNames(un8(Option)(opt).optMain);
        var mv = stringChunk(optMetaVar(opt));
        var descs = map36(function($66) {
          return string2(showOption($66));
        })(sort2(ns));
        var render = function(chunk) {
          if (!show_opt) {
            return mempty13;
          }
          ;
          if (isEmpty6(chunk) || !un8(OptDescStyle)(style).descSurround) {
            return append9(chunk)(suffix2);
          }
          ;
          if (un8(OptHelpInfo)(info4).hinfoDefault) {
            return append9(map115(brackets)(chunk))(suffix2);
          }
          ;
          if ($$null(drop(1)(descs))) {
            return append9(chunk)(suffix2);
          }
          ;
          if (otherwise) {
            return append9(map115(parens)(chunk))(suffix2);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 63, column 7 - line 73, column 43): " + [chunk.constructor.name]);
        };
        var desc$prime = chunkBeside(listToChunk2(intersperse2(un8(OptDescStyle)(style).descSep)(descs)))(mv);
        return maybe(identity20)(map115)(optDescMod(opt))(render(desc$prime));
      };
    };
  };
};
var headerHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpHeader: chunk
    };
  })(mempty7);
};
var fullDesc = function(pprefs) {
  var style = {
    descSep: string2(","),
    descHidden: true,
    descOptional: true,
    descSurround: false
  };
  var doc = function(info4) {
    return function(opt) {
      var show_def = function(s) {
        return parens(appendWithSpace(string2("default:"))(string2(s)));
      };
      var n = optDesc(pprefs)(style)(info4)(opt);
      var hdef = map212(show_def)(optShowDefault(opt));
      var h = optHelp(opt);
      return discard4(guard5(!isEmpty6(n)))(function() {
        return discard4(guard5(!isEmpty6(h)))(function() {
          return pure21(new Tuple(extractChunk3(n), align(extractChunk3(chunkBeside(h)(hdef)))));
        });
      });
    };
  };
  var $67 = mapParser(doc);
  return function($68) {
    return tabulate(catMaybes($67($68)));
  };
};
var footerHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpFooter: chunk
    };
  })(mempty7);
};
var fold_tree = function(v) {
  if (v instanceof Leaf2) {
    return v.value0;
  }
  ;
  if (v instanceof MultNode) {
    return foldr2(function($69) {
      return chunkBesideOrBelow(fold_tree($69));
    })(mempty13)(v.value0);
  }
  ;
  if (v instanceof AltNode) {
    var alt_node = function(v1) {
      if (v1.length === 1) {
        return v1[0];
      }
      ;
      return map115(parens)(foldr2(chunked(function(x) {
        return function(y) {
          return appendWithSoftline(x)(appendWithSoftline($$char2("|"))(y));
        };
      }))(mempty13)(v1));
    };
    return alt_node(filter(function($70) {
      return !isEmpty6($70);
    })(map36(fold_tree)(v.value0)));
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 116, column 1 - line 116, column 46): " + [v.constructor.name]);
};
var errorHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpBody: v.helpBody,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpError: chunk
    };
  })(mempty7);
};
var cmdDesc = /* @__PURE__ */ function() {
  var desc = function(v) {
    return function(opt) {
      var v1 = un8(Option)(opt).optMain;
      if (v1 instanceof CmdReader) {
        return new Tuple(v1.value0, tabulate(bind15(reverse(v1.value1))(function(cmd) {
          return bind15(maybe([])(pure111)(map212(function() {
            var $71 = un8(ParserInfo);
            return function($72) {
              return function(v2) {
                return v2.infoProgDesc;
              }($71($72));
            };
          }())(v1.value2(cmd))))(function(d) {
            return pure111(new Tuple(string2(cmd), align(extractChunk3(d))));
          });
        })));
      }
      ;
      return mempty23;
    };
  };
  return mapParser(desc);
}();
var briefDesc$prime = function(showOptional) {
  return function(pprefs) {
    var style = {
      descSep: string2("|"),
      descHidden: false,
      descOptional: showOptional,
      descSurround: true
    };
    var $73 = treeMapParser(optDesc(pprefs)(style));
    return function($74) {
      return fold_tree($73($74));
    };
  };
};
var missingDesc = /* @__PURE__ */ briefDesc$prime(false);
var briefDesc = /* @__PURE__ */ briefDesc$prime(true);
var parserUsage = function(pprefs) {
  return function(p) {
    return function(progn) {
      return hsep([string2("Usage:"), string2(progn), align(extractChunk3(briefDesc(pprefs)(p)))]);
    };
  };
};
var bodyHelp = function(chunk) {
  return over7(ParserHelp)(function(v) {
    return {
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage,
      helpBody: chunk
    };
  })(mempty7);
};
var parserHelp = function(pprefs) {
  return function(p) {
    var with_title = function(title2) {
      return map115(function(v) {
        return appendWithLine(string2(title2))(v);
      });
    };
    var group_title = function(arr) {
      var v = uncons2(arr);
      return with_title(fromMaybe("Available commands:")(fst(v.head)))(vcatChunks(append110([snd(v.head)])(map36(snd)(v.tail))));
    };
    var cs = groupBy(on(eq23)(fst))(cmdDesc(p));
    return bodyHelp(vsepChunks(append110([with_title("Available options:")(fullDesc(pprefs)(p))])(map36(group_title)(cs))));
  };
};

// output/Data.Char/index.js
var toCharCode2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var fromCharCode3 = /* @__PURE__ */ toEnum(boundedEnumChar);

// output/Data.Function.Memoize/index.js
var bind16 = /* @__PURE__ */ bind(bindLazy);
var NatTrie = /* @__PURE__ */ function() {
  function NatTrie2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  NatTrie2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new NatTrie2(value0, value12, value22);
      };
    };
  };
  return NatTrie2;
}();
var tabulateNat = {
  tabulate: /* @__PURE__ */ function() {
    var tabulateImpl = function(f) {
      var walk2 = function(v) {
        return function(v1) {
          if (v instanceof Nil) {
            return v1.value0;
          }
          ;
          if (v instanceof Cons && !v.value0) {
            return bind16(v1.value1)(walk2(v.value1));
          }
          ;
          if (v instanceof Cons && v.value0) {
            return bind16(v1.value2)(walk2(v.value1));
          }
          ;
          throw new Error("Failed pattern match at Data.Function.Memoize (line 137, column 11 - line 137, column 64): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      var build3 = function(n) {
        return new NatTrie(defer2(function(v) {
          return f(n);
        }), defer2(function(v) {
          return build3(n * 2 | 0);
        }), defer2(function(v) {
          return build3((n * 2 | 0) + 1 | 0);
        }));
      };
      var trie = build3(0);
      var bits = function() {
        var bits$prime = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 === 0) {
                $tco_done = true;
                return v;
              }
              ;
              $tco_var_v = new Cons((v1 & 1) !== 0, v);
              $copy_v1 = v1 >>> 1;
              return;
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return bits$prime(Nil.value);
      }();
      var go = function(n) {
        return walk2(bits(n))(trie);
      };
      return go;
    };
    return tabulateImpl;
  }()
};
var tabulate2 = function(dict) {
  return dict.tabulate;
};
var tabulateTuple = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(dictTabulate1) {
    var tabulate4 = tabulate2(dictTabulate1);
    return {
      tabulate: function(f) {
        var f$prime = tabulate3(function(a) {
          return tabulate4(function(b) {
            return f(new Tuple(a, b));
          });
        });
        return function(v) {
          return bind16(f$prime(v.value0))(function(g) {
            return g(v.value1);
          });
        };
      }
    };
  };
};
var memoize = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(f) {
    var f1 = tabulate3(f);
    return function($141) {
      return force(f1($141));
    };
  };
};
var memoize2 = function(dictTabulate) {
  var tabulateTuple1 = tabulateTuple(dictTabulate);
  return function(dictTabulate1) {
    var memoize1 = memoize(tabulateTuple1(dictTabulate1));
    return function(f) {
      var f1 = memoize1(uncurry(f));
      return curry(f1);
    };
  };
};

// output/Options.Applicative.Help.Levenshtein/index.js
var $runtime_lazy10 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var memoize22 = /* @__PURE__ */ memoize2(tabulateNat)(tabulateNat);
var minimum3 = /* @__PURE__ */ minimum2(ordInt)(/* @__PURE__ */ foldable1NonEmpty(foldableArray));
var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();
var editDistance = function(dictEq) {
  var eq46 = eq(dictEq);
  return function(xs) {
    return function(ys) {
      var dist = function(v) {
        return function(v1) {
          if (v === 0) {
            return v1;
          }
          ;
          if (v1 === 0) {
            return v;
          }
          ;
          return minimum3(new NonEmpty($lazy_dist$prime(37)(v - 1 | 0)(v1) + 1 | 0, [$lazy_dist$prime(38)(v)(v1 - 1 | 0) + 1 | 0, function() {
            var $14 = eq46(unsafeIndex2(xs)(v - 1 | 0))(unsafeIndex2(ys)(v1 - 1 | 0));
            if ($14) {
              return $lazy_dist$prime(40)(v - 1 | 0)(v1 - 1 | 0);
            }
            ;
            return 1 + $lazy_dist$prime(41)(v - 1 | 0)(v1 - 1 | 0) | 0;
          }()]));
        };
      };
      var $lazy_dist$prime = $runtime_lazy10("dist'", "Options.Applicative.Help.Levenshtein", function() {
        return memoize22(function(a) {
          return function(b) {
            return dist(a)(b);
          };
        });
      });
      var dist$prime = $lazy_dist$prime(31);
      return dist$prime(length(xs))(length(ys));
    };
  };
};

// output/Options.Applicative.Extra/index.js
var un9 = /* @__PURE__ */ un();
var mempty8 = /* @__PURE__ */ mempty(parserHelpMonoid);
var pure25 = /* @__PURE__ */ pure(chunkApplicative);
var unWords2 = /* @__PURE__ */ unWords(foldableArray);
var append10 = /* @__PURE__ */ append(semigroupArray);
var map37 = /* @__PURE__ */ map(chunkFunctor);
var map116 = /* @__PURE__ */ map(functorArray);
var fold8 = /* @__PURE__ */ fold2(monoidArray);
var editDistance2 = /* @__PURE__ */ editDistance(eqChar);
var apply14 = /* @__PURE__ */ apply2(chunkApply);
var mempty14 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var fold13 = /* @__PURE__ */ fold2(parserHelpMonoid);
var append22 = /* @__PURE__ */ append(modSemigroup);
var metavar2 = /* @__PURE__ */ metavar(commandFieldsHasMetavar);
var over8 = /* @__PURE__ */ over()();
var apApplyFlipped2 = /* @__PURE__ */ apApplyFlipped(parserApply);
var map213 = /* @__PURE__ */ map(functorMaybe);
var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEffect);
var bind17 = /* @__PURE__ */ bind(bindMaybe);
var fromEnum8 = /* @__PURE__ */ fromEnum(boundedEnumExitCode);
var pure112 = /* @__PURE__ */ pure(applicativeEffect);
var bind18 = /* @__PURE__ */ bind(bindEffect);
var $$void9 = /* @__PURE__ */ $$void(functorEffect);
var alt7 = /* @__PURE__ */ alt(parserAlt);
var map38 = /* @__PURE__ */ map(parserFunctor);
var runParserInfo3 = /* @__PURE__ */ runParserInfo(pMonadP);
var fromFoldable19 = /* @__PURE__ */ fromFoldable6(foldableArray);
var map44 = /* @__PURE__ */ map(functorEffect);
var renderFailure = function(failure) {
  return function(progn) {
    var v = un9(ParserFailure)(failure)(progn);
    return new Tuple(renderHelp(v.value1.value1.value0)(v.value0), v.value1.value0);
  };
};
var parserFailure = function(pprefs) {
  return function(pinfo) {
    return function(msg) {
      return function(ctx) {
        var with_context = function(arr) {
          return function(i) {
            return function(f) {
              var v = head(arr);
              if (v instanceof Nothing) {
                return f([])(i);
              }
              ;
              if (v instanceof Just) {
                return runExists(function(i$prime) {
                  return f(contextNames(arr))(i$prime);
                })(v.value0.value1);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Extra (line 183, column 28 - line 185, column 73): " + [v.constructor.name]);
            };
          };
        };
        var usage_help = function(progn) {
          return function(names) {
            return function(v) {
              if (msg instanceof InfoMsg) {
                return mempty8;
              }
              ;
              return usageHelp(vcatChunks([pure25(parserUsage(pprefs)(v.infoParser)(unWords2(append10([progn])(names)))), map37(indent2(2))(v.infoProgDesc)]));
            };
          };
        };
        var suggestion_help = suggestionsHelp(function() {
          if (msg instanceof UnexpectedError) {
            var opt_completions = function(v) {
              return function(v1) {
                if (v1.optMain instanceof OptReader) {
                  return map116(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof FlagReader) {
                  return map116(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof ArgReader) {
                  return [];
                }
                ;
                if (v1.optMain instanceof CmdReader) {
                  if (v.hinfoUnreachableArgs) {
                    return [];
                  }
                  ;
                  if (otherwise) {
                    return v1.optMain.value1;
                  }
                  ;
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Extra (line 273, column 64 - line 280, column 37): " + [v1.optMain.constructor.name]);
              };
            };
            var possibles = fold8(runExists(function(zz) {
              return mapParser(opt_completions)(zz);
            })(msg.value1.value0));
            var isClose = function(a) {
              return on(editDistance2)(toCharArray)(a)(msg.value0) < 3;
            };
            var good2 = filter(isClose)(possibles);
            var prose = function() {
              var $81 = length(good2) < 2;
              if ($81) {
                return stringChunk("Did you mean this?");
              }
              ;
              return stringChunk("Did you mean one of these?");
            }();
            var suggestions = apply14(map37(appendWithLine)(prose))(map37(indent2(4))(vcatChunks(map116(stringChunk)(good2))));
            return suggestions;
          }
          ;
          return mempty14;
        }());
        var show_full_help = function() {
          if (msg instanceof ShowHelpText) {
            return true;
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return true;
          }
          ;
          return un9(ParserPrefs)(pprefs).prefShowHelpOnError;
        }();
        var exit_code = function() {
          if (msg instanceof ErrorMsg) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof MissingError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof UnexpectedError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ShowHelpText) {
            return Success.value;
          }
          ;
          if (msg instanceof InfoMsg) {
            return Success.value;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 171, column 17 - line 177, column 44): " + [msg.constructor.name]);
        }();
        var error_help = errorHelp(function() {
          if (msg instanceof ShowHelpText) {
            return mempty14;
          }
          ;
          if (msg instanceof ErrorMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof InfoMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return mempty14;
          }
          ;
          if (msg instanceof MissingError) {
            return runExists(function(x) {
              return chunkBeside(stringChunk("Missing:"))(missingDesc(pprefs)(x));
            })(msg.value1.value0);
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return stringChunk("The option `" + (msg.value0 + "` expects an argument."));
          }
          ;
          if (msg instanceof UnexpectedError) {
            var msg$prime = function() {
              var $105 = startsWith("-")(msg.value0);
              if ($105) {
                return "Invalid option `" + (msg.value0 + "'");
              }
              ;
              return "Invalid argument `" + (msg.value0 + "'");
            }();
            return stringChunk(msg$prime);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 196, column 30 - line 225, column 30): " + [msg.constructor.name]);
        }());
        var base_help = function(v) {
          var h = headerHelp(v.infoHeader);
          var f = footerHelp(v.infoFooter);
          if (show_full_help) {
            return fold13([h, f, parserHelp(pprefs)(v.infoParser)]);
          }
          ;
          return mempty8;
        };
        return function(progn) {
          var h = with_context(ctx)(pinfo)(function(names) {
            return function(pinfo$prime) {
              return fold13([base_help(pinfo$prime), usage_help(progn)(names)(pinfo$prime), suggestion_help, error_help]);
            };
          });
          return new Tuple(h, new Tuple(exit_code, new Tuple(un9(ParserPrefs)(pprefs).prefColumns, unit)));
        };
      };
    };
  };
};
var helper = /* @__PURE__ */ function() {
  return abortOption(ShowHelpText.value)(fold2(modMonoid)([$$long(optionFieldsHasName)("help"), $$short(optionFieldsHasName)("h"), help("Show this help text"), hidden]));
}();
var hsubparser = function(m) {
  var v = append22(metavar2("COMMAND"))(m);
  var v1 = mkCommand(m);
  var add_helper = over8(ParserInfo)(function(pinfo) {
    return {
      infoFailureCode: pinfo.infoFailureCode,
      infoFooter: pinfo.infoFooter,
      infoFullDesc: pinfo.infoFullDesc,
      infoHeader: pinfo.infoHeader,
      infoPolicy: pinfo.infoPolicy,
      infoProgDesc: pinfo.infoProgDesc,
      infoParser: apApplyFlipped2(pinfo.infoParser)(helper)
    };
  });
  var rdr = new CmdReader(v1.value0, v1.value1.value0, function() {
    var $143 = map213(add_helper);
    return function($144) {
      return $143(v1.value1.value1.value0($144));
    };
  }());
  return mkParser(v.value1)(v.value2)(rdr);
};
var getProgName = /* @__PURE__ */ mapFlipped3(argv)(function(args) {
  return fromMaybe("")(bind17(index(args)(1))(function(executablePath) {
    return last(split("/")(executablePath));
  }));
});
var getArgs = /* @__PURE__ */ mapFlipped3(argv)(/* @__PURE__ */ drop(2));
var exitWith = function(c) {
  return exit$prime(fromEnum8(c));
};
var exitSuccess = /* @__PURE__ */ function() {
  return exit$prime(fromEnum8(Success.value));
}();
var handleParseResult = function(v) {
  if (v instanceof Success2) {
    return pure112(v.value0);
  }
  ;
  if (v instanceof Failure) {
    return function __do3() {
      var progn = getProgName();
      var v1 = renderFailure(v.value0)(progn);
      var stream3 = function() {
        if (v1.value1 instanceof Success) {
          return stdout;
        }
        ;
        return stderr;
      }();
      $$void9(writeString(stream3)(UTF8.value)(v1.value0 + "\n"))();
      return exitWith(v1.value1)();
    };
  }
  ;
  if (v instanceof CompletionInvoked) {
    return function __do3() {
      var progn = getProgName();
      var msg = un9(CompletionResult)(v.value0).execCompletion(progn)();
      $$void9(writeString(stdout)(UTF8.value)(msg))();
      return exitSuccess();
    };
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Extra (line 110, column 1 - line 110, column 58): " + [v.constructor.name]);
};
var execParserPure = function(pprefs) {
  return function(pinfo) {
    return function(args) {
      var pinfo$prime = over8(ParserInfo)(function(i) {
        return {
          infoFailureCode: i.infoFailureCode,
          infoFooter: i.infoFooter,
          infoFullDesc: i.infoFullDesc,
          infoHeader: i.infoHeader,
          infoPolicy: i.infoPolicy,
          infoProgDesc: i.infoProgDesc,
          infoParser: alt7(map38(Left.create)(bashCompletionParser(pinfo)(pprefs)))(map38(Right.create)(i.infoParser))
        };
      })(pinfo);
      var p = runParserInfo3(pinfo$prime)(fromFoldable19(args));
      var v = runP(p)(pprefs);
      if (v.value0 instanceof Right && v.value0.value0 instanceof Right) {
        return new Success2(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Right && v.value0.value0 instanceof Left) {
        return new CompletionInvoked(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Left) {
        return new Failure(parserFailure(pprefs)(pinfo)(v.value0.value0)(v.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Extra (line 144, column 3 - line 147, column 73): " + [v.constructor.name]);
    };
  };
};
var customExecParser = function(pprefs) {
  return function(pinfo) {
    return bind18(map44(execParserPure(pprefs)(pinfo))(getArgs))(handleParseResult);
  };
};

// output/Record.Unsafe.Union/foreign.js
function unsafeUnionFn(r1, r2) {
  var copy = {};
  for (var k1 in r2) {
    if ({}.hasOwnProperty.call(r2, k1)) {
      copy[k1] = r2[k1];
    }
  }
  for (var k2 in r1) {
    if ({}.hasOwnProperty.call(r1, k2)) {
      copy[k2] = r1[k2];
    }
  }
  return copy;
}

// output/Record/index.js
var union5 = function() {
  return function(l) {
    return function(r) {
      return unsafeUnionFn(l, r);
    };
  };
};
var merge = function() {
  return function() {
    return function(l) {
      return function(r) {
        return unsafeUnionFn(l, r);
      };
    };
  };
};
var insert5 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function(l) {
        return function(a) {
          return function(r) {
            return unsafeSet(reflectSymbol2(l))(a)(r);
          };
        };
      };
    };
  };
};
var get3 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(l) {
      return function(r) {
        return unsafeGet(reflectSymbol2(l))(r);
      };
    };
  };
};
var $$delete5 = function(dictIsSymbol) {
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function(l) {
        return function(r) {
          return unsafeDelete(reflectSymbol2(l))(r);
        };
      };
    };
  };
};

// output/Record.Builder/foreign.js
function copyRecord(rec) {
  var copy = {};
  for (var key in rec) {
    if ({}.hasOwnProperty.call(rec, key)) {
      copy[key] = rec[key];
    }
  }
  return copy;
}
function unsafeInsert(l) {
  return function(a) {
    return function(rec) {
      rec[l] = a;
      return rec;
    };
  };
}

// output/Record.Builder/index.js
var semigroupoidBuilder = semigroupoidFn;
var insert6 = function() {
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol2 = reflectSymbol(dictIsSymbol);
      return function(l) {
        return function(a) {
          return function(r1) {
            return unsafeInsert(reflectSymbol2(l))(a)(r1);
          };
        };
      };
    };
  };
};
var categoryBuilder = categoryFn;
var build = function(v) {
  return function(r1) {
    return v(copyRecord(r1));
  };
};
var buildFromScratch = /* @__PURE__ */ flip(build)({});

// output/Optparse/index.js
var identity21 = /* @__PURE__ */ identity(categoryBuilder);
var map39 = /* @__PURE__ */ map(parserFunctor);
var apply15 = /* @__PURE__ */ apply2(parserApply);
var composeFlipped2 = /* @__PURE__ */ composeFlipped(semigroupoidBuilder);
var insert7 = /* @__PURE__ */ insert6()();
var buildRecordArgsNil = {
  buildRecordArgs: function(v) {
    return function(v1) {
      return new NilP(identity21);
    };
  }
};
var buildRecordArgs = function(dict) {
  return dict.buildRecordArgs;
};
var fromRecord = function() {
  return function(dictBuildRecordArgs) {
    var $19 = map39(buildFromScratch);
    var $20 = buildRecordArgs(dictBuildRecordArgs)($$Proxy.value);
    return function($21) {
      return $19($20($21));
    };
  };
};
var buildArgsCons = function(dictIsSymbol) {
  var insert111 = insert7(dictIsSymbol);
  var get6 = get3(dictIsSymbol)();
  return function() {
    return function() {
      return function() {
        return function(dictBuildRecordArgs) {
          var buildRecordArgs1 = buildRecordArgs(dictBuildRecordArgs);
          return {
            buildRecordArgs: function(v) {
              return function(rs) {
                return apply15(map39(function(a) {
                  return function(b) {
                    return composeFlipped2(insert111($$Proxy.value)(a))(b);
                  };
                })(get6($$Proxy.value)(rs)))(buildRecordArgs1($$Proxy.value)(rs));
              };
            }
          };
        };
      };
    };
  };
};

// output/Parsing/index.js
var $runtime_lazy11 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var unwrap8 = /* @__PURE__ */ unwrap();
var ParseState = /* @__PURE__ */ function() {
  function ParseState2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ParseState2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ParseState2(value0, value12, value22);
      };
    };
  };
  return ParseState2;
}();
var ParseError = /* @__PURE__ */ function() {
  function ParseError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseError2.create = function(value0) {
    return function(value12) {
      return new ParseError2(value0, value12);
    };
  };
  return ParseError2;
}();
var More = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Lift = /* @__PURE__ */ function() {
  function Lift2(value0) {
    this.value0 = value0;
  }
  ;
  Lift2.create = function(value0) {
    return new Lift2(value0);
  };
  return Lift2;
}();
var Stop = /* @__PURE__ */ function() {
  function Stop2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Stop2.create = function(value0) {
    return function(value12) {
      return new Stop2(value0, value12);
    };
  };
  return Stop2;
}();
var monadTransParserT = {
  lift: function(dictMonad) {
    var map154 = map(dictMonad.Bind1().Apply0().Functor0());
    return function(m) {
      return function(state1, v, lift$prime, v1, done) {
        return lift$prime(map154(function(a) {
          return function(v2) {
            return done(state1, a);
          };
        })(m));
      };
    };
  }
};
var lazyParserT = {
  defer: function(f) {
    var m = defer2(f);
    return function(state1, more, lift14, $$throw2, done) {
      var v = force(m);
      return v(state1, more, lift14, $$throw2, done);
    };
  }
};
var functorParserT = {
  map: function(f) {
    return function(v) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift14, $$throw2, function(state2, a) {
            return more(function(v2) {
              return done(state2, f(a));
            });
          });
        });
      };
    };
  }
};
var applyParserT = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v2) {
          return v(state1, more, lift14, $$throw2, function(state2, f) {
            return more(function(v3) {
              return v1(state2, more, lift14, $$throw2, function(state3, a) {
                return more(function(v4) {
                  return done(state3, f(a));
                });
              });
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var lift24 = /* @__PURE__ */ lift2(applyParserT);
var bindParserT = {
  bind: function(v) {
    return function(next2) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift14, $$throw2, function(state2, a) {
            return more(function(v2) {
              var v3 = next2(a);
              return v3(state2, more, lift14, $$throw2, done);
            });
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var bindFlipped5 = /* @__PURE__ */ bindFlipped(bindParserT);
var semigroupParserT = function(dictSemigroup) {
  return {
    append: lift24(append(dictSemigroup))
  };
};
var applicativeParserT = {
  pure: function(a) {
    return function(state1, v, v1, v2, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var pure26 = /* @__PURE__ */ pure(applicativeParserT);
var monadParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Bind1: function() {
    return bindParserT;
  }
};
var monadRecParserT = {
  tailRecM: function(next2) {
    return function(initArg) {
      return function(state1, more, lift14, $$throw2, done) {
        var $lazy_loop = $runtime_lazy11("loop", "Parsing", function() {
          return function(state2, arg, gas) {
            var v = next2(arg);
            return v(state2, more, lift14, $$throw2, function(state3, step3) {
              if (step3 instanceof Loop) {
                var $206 = gas === 0;
                if ($206) {
                  return more(function(v1) {
                    return $lazy_loop(277)(state3, step3.value0, 30);
                  });
                }
                ;
                return $lazy_loop(279)(state3, step3.value0, gas - 1 | 0);
              }
              ;
              if (step3 instanceof Done) {
                return done(state3, step3.value0);
              }
              ;
              throw new Error("Failed pattern match at Parsing (line 273, column 39 - line 281, column 43): " + [step3.constructor.name]);
            });
          };
        });
        var loop = $lazy_loop(270);
        return loop(state1, initArg, 30);
      };
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var monadThrowParseErrorParse = {
  throwError: function(err) {
    return function(state1, v, v1, $$throw2, v2) {
      return $$throw2(state1, err);
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var throwError3 = /* @__PURE__ */ throwError(monadThrowParseErrorParse);
var monoidParserT = function(dictMonoid) {
  var semigroupParserT1 = semigroupParserT(dictMonoid.Semigroup0());
  return {
    mempty: pure26(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupParserT1;
    }
  };
};
var altParserT = {
  alt: function(v) {
    return function(v1) {
      return function(v2, more, lift14, $$throw2, done) {
        return more(function(v3) {
          return v(new ParseState(v2.value0, v2.value1, false), more, lift14, function(v4, err) {
            return more(function(v5) {
              if (v4.value2) {
                return $$throw2(v4, err);
              }
              ;
              return v1(v2, more, lift14, $$throw2, done);
            });
          }, done);
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var stateParserT = function(k) {
  return function(state1, v, v1, v2, done) {
    var v3 = k(state1);
    return done(v3.value1, v3.value0);
  };
};
var runParserT$prime = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var map154 = map(Monad0.Bind1().Apply0().Functor0());
  var pure129 = pure(Monad0.Applicative0());
  var tailRecM8 = tailRecM(dictMonadRec);
  return function(state1) {
    return function(v) {
      var go = function($copy_step) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(step3) {
          var v1 = step3(unit);
          if (v1 instanceof More) {
            $copy_step = v1.value0;
            return;
          }
          ;
          if (v1 instanceof Lift) {
            $tco_done = true;
            return map154(Loop.create)(v1.value0);
          }
          ;
          if (v1 instanceof Stop) {
            $tco_done = true;
            return pure129(new Done(new Tuple(v1.value1, v1.value0)));
          }
          ;
          throw new Error("Failed pattern match at Parsing (line 152, column 13 - line 158, column 32): " + [v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_step);
        }
        ;
        return $tco_result;
      };
      return tailRecM8(go)(function(v1) {
        return v(state1, More.create, Lift.create, function(state2, err) {
          return new Stop(state2, new Left(err));
        }, function(state2, res) {
          return new Stop(state2, new Right(res));
        });
      });
    };
  };
};
var position = /* @__PURE__ */ stateParserT(function(v) {
  return new Tuple(v.value1, v);
});
var parseErrorPosition = function(v) {
  return v.value1;
};
var parseErrorMessage = function(v) {
  return v.value0;
};
var mapParserT = function(dictMonadRec) {
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(dictFunctor) {
    var map154 = map(dictFunctor);
    return function(f) {
      return function(p) {
        return function(state1, v, lift14, $$throw2, done) {
          return lift14(map154(function(v1) {
            return function(v2) {
              if (v1.value0 instanceof Left) {
                return $$throw2(v1.value1, v1.value0.value0);
              }
              ;
              if (v1.value0 instanceof Right) {
                return done(v1.value1, v1.value0.value0);
              }
              ;
              throw new Error("Failed pattern match at Parsing (line 192, column 13 - line 196, column 37): " + [v1.value0.constructor.name]);
            };
          })(f(runParserT$prime1(state1)(p))));
        };
      };
    };
  };
};
var initialPos = {
  index: 0,
  line: 1,
  column: 1
};
var runParserT = function(dictMonadRec) {
  var map154 = map(dictMonadRec.Monad0().Bind1().Apply0().Functor0());
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(s) {
    return function(p) {
      var initialState = new ParseState(s, initialPos, false);
      return map154(fst)(runParserT$prime1(initialState)(p));
    };
  };
};
var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
var runParser2 = function(s) {
  var $281 = runParserT1(s);
  return function($282) {
    return unwrap8($281($282));
  };
};
var getParserT = function(state1, v, v1, v2, done) {
  return done(state1, state1);
};
var failWithPosition = function(message3) {
  return function(pos2) {
    return throwError3(new ParseError(message3, pos2));
  };
};
var fail2 = function(message3) {
  return bindFlipped5(failWithPosition(message3))(position);
};
var plusParserT = {
  empty: /* @__PURE__ */ fail2("No alternative"),
  Alt0: function() {
    return altParserT;
  }
};
var alternativeParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Plus1: function() {
    return plusParserT;
  }
};

// output/Parsing.Combinators/index.js
var alt8 = /* @__PURE__ */ alt(altParserT);
var defer3 = /* @__PURE__ */ defer(lazyParserT);
var pure27 = /* @__PURE__ */ pure(applicativeParserT);
var map40 = /* @__PURE__ */ map(functorParserT);
var $$void10 = /* @__PURE__ */ $$void(functorParserT);
var empty12 = /* @__PURE__ */ empty(plusParserT);
var withLazyErrorMessage = function(p) {
  return function(msg) {
    return alt8(p)(defer3(function(v) {
      return fail2("Expected " + msg(unit));
    }));
  };
};
var withErrorMessage = function(p) {
  return function(msg) {
    return alt8(p)(fail2("Expected " + msg));
  };
};
var $$try4 = function(v) {
  return function(v1, more, lift10, $$throw2, done) {
    return v(v1, more, lift10, function(v2, err) {
      return $$throw2(new ParseState(v2.value0, v2.value1, v1.value2), err);
    }, done);
  };
};
var optional3 = function(p) {
  return alt8($$void10(p))(pure27(unit));
};
var option2 = function(a) {
  return function(p) {
    return alt8(p)(pure27(a));
  };
};
var optionMaybe = function(p) {
  return option2(Nothing.value)(map40(Just.create)(p));
};
var lookAhead = function(v) {
  return function(state1, more, lift10, $$throw2, done) {
    return v(state1, more, lift10, function(v1, err) {
      return $$throw2(state1, err);
    }, function(v1, res) {
      return done(state1, res);
    });
  };
};
var choice = function(dictFoldable) {
  var go = function(p1) {
    return function(v) {
      if (v instanceof Nothing) {
        return new Just(p1);
      }
      ;
      if (v instanceof Just) {
        return new Just(alt8(p1)(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Parsing.Combinators (line 358, column 11 - line 360, column 32): " + [v.constructor.name]);
    };
  };
  var $95 = fromMaybe(empty12);
  var $96 = foldr(dictFoldable)(go)(Nothing.value);
  return function($97) {
    return $95($96($97));
  };
};

// output/Parsing.Combinators.Array/index.js
var bind19 = /* @__PURE__ */ bind(bindParserT);
var tailRecM4 = /* @__PURE__ */ tailRecM(monadRecParserT);
var alt9 = /* @__PURE__ */ alt(altParserT);
var pure28 = /* @__PURE__ */ pure(applicativeParserT);
var fromFoldable20 = /* @__PURE__ */ fromFoldable(foldableList);
var manyTill_ = function(p) {
  return function(end4) {
    return bind19(flip(tailRecM4)(Nil.value)(function(xs) {
      return alt9(bind19(end4)(function(t) {
        return pure28(new Done(new Tuple(xs, t)));
      }))(bind19(p)(function(x) {
        return pure28(new Loop(new Cons(x, xs)));
      }));
    }))(function(v) {
      return pure28(new Tuple(reverse(fromFoldable20(v.value0)), v.value1));
    });
  };
};
var many4 = function(p) {
  return bind19(flip(tailRecM4)(Nil.value)(function(xs) {
    return alt9(bind19($$try4(p))(function(x) {
      return pure28(new Loop(new Cons(x, xs)));
    }))(pure28(new Done(xs)));
  }))(function(rlist) {
    return pure28(reverse(fromFoldable20(rlist)));
  });
};
var many1 = function(p) {
  return bind19(many4(p))(function(xs) {
    var v = fromArray(xs);
    if (v instanceof Nothing) {
      return fail2("Expected at least 1");
    }
    ;
    if (v instanceof Just) {
      return pure28(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Parsing.Combinators.Array (line 52, column 3 - line 54, column 25): " + [v.constructor.name]);
  });
};

// output/Parsing.String/index.js
var fromEnum9 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var mod4 = /* @__PURE__ */ mod(euclideanRingInt);
var fromJust8 = /* @__PURE__ */ fromJust();
var toEnum4 = /* @__PURE__ */ toEnum(boundedEnumChar);
var show7 = /* @__PURE__ */ show(showInt);
var show12 = /* @__PURE__ */ show(showString);
var show22 = /* @__PURE__ */ show(showChar);
var updatePosSingle = function(v) {
  return function(cp) {
    return function(after) {
      var v1 = fromEnum9(cp);
      if (v1 === 10) {
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 13) {
        var v2 = codePointAt(0)(after);
        if (v2 instanceof Just && fromEnum9(v2.value0) === 10) {
          return {
            index: v.index + 1 | 0,
            line: v.line,
            column: v.column
          };
        }
        ;
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 9) {
        return {
          index: v.index + 1 | 0,
          line: v.line,
          column: (v.column + 8 | 0) - mod4(v.column - 1 | 0)(8) | 0
        };
      }
      ;
      return {
        index: v.index + 1 | 0,
        line: v.line,
        column: v.column + 1 | 0
      };
    };
  };
};
var updatePosString = function($copy_pos) {
  return function($copy_before) {
    return function($copy_after) {
      var $tco_var_pos = $copy_pos;
      var $tco_var_before = $copy_before;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(pos2, before, after) {
        var v = uncons3(before);
        if (v instanceof Nothing) {
          $tco_done = true;
          return pos2;
        }
        ;
        if (v instanceof Just) {
          var newPos = function() {
            if ($$null2(v.value0.tail)) {
              return updatePosSingle(pos2)(v.value0.head)(after);
            }
            ;
            if (otherwise) {
              return updatePosSingle(pos2)(v.value0.head)(v.value0.tail);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 165, column 7 - line 167, column 52): ");
          }();
          $tco_var_pos = newPos;
          $tco_var_before = v.value0.tail;
          $copy_after = after;
          return;
        }
        ;
        throw new Error("Failed pattern match at Parsing.String (line 161, column 36 - line 168, column 38): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_pos, $tco_var_before, $copy_after);
      }
      ;
      return $tco_result;
    };
  };
};
var satisfy = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = uncons3(v.value0);
            if (v3 instanceof Nothing) {
              return $$throw2(v, new ParseError("Unexpected EOF", v.value1));
            }
            ;
            if (v3 instanceof Just) {
              var cp = fromEnum9(v3.value0.head);
              var $85 = cp < 0 || cp > 65535;
              if ($85) {
                return $$throw2(v, new ParseError("Expected Char", v.value1));
              }
              ;
              var ch = fromJust8(toEnum4(cp));
              var $86 = f(ch);
              if ($86) {
                return done(new ParseState(v3.value0.tail, updatePosSingle(v.value1)(v3.value0.head)(v3.value0.tail), true), ch);
              }
              ;
              return $$throw2(v, new ParseError("Predicate unsatisfied", v.value1));
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 114, column 7 - line 129, column 75): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var eof = /* @__PURE__ */ mkFn5(function(v) {
  return function(v1) {
    return function(v2) {
      return function($$throw2) {
        return function(done) {
          var $133 = $$null2(v.value0);
          if ($133) {
            return done(new ParseState(v.value0, v.value1, true), unit);
          }
          ;
          return $$throw2(v, new ParseError("Expected EOF", v.value1));
        };
      };
    };
  };
});
var consumeWith = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = f(v.value0);
            if (v3 instanceof Left) {
              return $$throw2(v, new ParseError(v3.value0, v.value1));
            }
            ;
            if (v3 instanceof Right) {
              return done(new ParseState(v3.value0.remainder, updatePosString(v.value1)(v3.value0.consumed)(v3.value0.remainder), !$$null2(v3.value0.consumed)), v3.value0.value);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 286, column 7 - line 290, column 121): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var string3 = function(str2) {
  return consumeWith(function(input) {
    var v = stripPrefix2(str2)(input);
    if (v instanceof Just) {
      return new Right({
        value: str2,
        consumed: str2,
        remainder: v.value0
      });
    }
    ;
    return new Left("Expected " + show12(str2));
  });
};
var takeN = function(n) {
  return consumeWith(function(input) {
    var v = splitAt3(n)(input);
    var $153 = length5(v.before) === n;
    if ($153) {
      return new Right({
        value: v.before,
        consumed: v.before,
        remainder: v.after
      });
    }
    ;
    return new Left("Could not take " + (show7(n) + " characters"));
  });
};
var $$char3 = function(c) {
  return withErrorMessage(satisfy(function(v) {
    return v === c;
  }))(show22(c));
};
var anyChar = /* @__PURE__ */ satisfy(/* @__PURE__ */ $$const(true));

// output/Data.CodePoint.Unicode.Internal/index.js
var unsafeIndex3 = /* @__PURE__ */ unsafeIndex();
var elemIndex2 = /* @__PURE__ */ elemIndex(eqInt);
var NUMCAT_LU = /* @__PURE__ */ function() {
  function NUMCAT_LU2() {
  }
  ;
  NUMCAT_LU2.value = new NUMCAT_LU2();
  return NUMCAT_LU2;
}();
var NUMCAT_LL = /* @__PURE__ */ function() {
  function NUMCAT_LL2() {
  }
  ;
  NUMCAT_LL2.value = new NUMCAT_LL2();
  return NUMCAT_LL2;
}();
var NUMCAT_LT = /* @__PURE__ */ function() {
  function NUMCAT_LT2() {
  }
  ;
  NUMCAT_LT2.value = new NUMCAT_LT2();
  return NUMCAT_LT2;
}();
var NUMCAT_LM = /* @__PURE__ */ function() {
  function NUMCAT_LM2() {
  }
  ;
  NUMCAT_LM2.value = new NUMCAT_LM2();
  return NUMCAT_LM2;
}();
var NUMCAT_LO = /* @__PURE__ */ function() {
  function NUMCAT_LO2() {
  }
  ;
  NUMCAT_LO2.value = new NUMCAT_LO2();
  return NUMCAT_LO2;
}();
var NUMCAT_MN = /* @__PURE__ */ function() {
  function NUMCAT_MN2() {
  }
  ;
  NUMCAT_MN2.value = new NUMCAT_MN2();
  return NUMCAT_MN2;
}();
var NUMCAT_MC = /* @__PURE__ */ function() {
  function NUMCAT_MC2() {
  }
  ;
  NUMCAT_MC2.value = new NUMCAT_MC2();
  return NUMCAT_MC2;
}();
var NUMCAT_ME = /* @__PURE__ */ function() {
  function NUMCAT_ME2() {
  }
  ;
  NUMCAT_ME2.value = new NUMCAT_ME2();
  return NUMCAT_ME2;
}();
var NUMCAT_ND = /* @__PURE__ */ function() {
  function NUMCAT_ND2() {
  }
  ;
  NUMCAT_ND2.value = new NUMCAT_ND2();
  return NUMCAT_ND2;
}();
var NUMCAT_NL = /* @__PURE__ */ function() {
  function NUMCAT_NL2() {
  }
  ;
  NUMCAT_NL2.value = new NUMCAT_NL2();
  return NUMCAT_NL2;
}();
var NUMCAT_NO = /* @__PURE__ */ function() {
  function NUMCAT_NO2() {
  }
  ;
  NUMCAT_NO2.value = new NUMCAT_NO2();
  return NUMCAT_NO2;
}();
var NUMCAT_PC = /* @__PURE__ */ function() {
  function NUMCAT_PC2() {
  }
  ;
  NUMCAT_PC2.value = new NUMCAT_PC2();
  return NUMCAT_PC2;
}();
var NUMCAT_PD = /* @__PURE__ */ function() {
  function NUMCAT_PD2() {
  }
  ;
  NUMCAT_PD2.value = new NUMCAT_PD2();
  return NUMCAT_PD2;
}();
var NUMCAT_PS = /* @__PURE__ */ function() {
  function NUMCAT_PS2() {
  }
  ;
  NUMCAT_PS2.value = new NUMCAT_PS2();
  return NUMCAT_PS2;
}();
var NUMCAT_PE = /* @__PURE__ */ function() {
  function NUMCAT_PE2() {
  }
  ;
  NUMCAT_PE2.value = new NUMCAT_PE2();
  return NUMCAT_PE2;
}();
var NUMCAT_PI = /* @__PURE__ */ function() {
  function NUMCAT_PI2() {
  }
  ;
  NUMCAT_PI2.value = new NUMCAT_PI2();
  return NUMCAT_PI2;
}();
var NUMCAT_PF = /* @__PURE__ */ function() {
  function NUMCAT_PF2() {
  }
  ;
  NUMCAT_PF2.value = new NUMCAT_PF2();
  return NUMCAT_PF2;
}();
var NUMCAT_PO = /* @__PURE__ */ function() {
  function NUMCAT_PO2() {
  }
  ;
  NUMCAT_PO2.value = new NUMCAT_PO2();
  return NUMCAT_PO2;
}();
var NUMCAT_SM = /* @__PURE__ */ function() {
  function NUMCAT_SM2() {
  }
  ;
  NUMCAT_SM2.value = new NUMCAT_SM2();
  return NUMCAT_SM2;
}();
var NUMCAT_SC = /* @__PURE__ */ function() {
  function NUMCAT_SC2() {
  }
  ;
  NUMCAT_SC2.value = new NUMCAT_SC2();
  return NUMCAT_SC2;
}();
var NUMCAT_SK = /* @__PURE__ */ function() {
  function NUMCAT_SK2() {
  }
  ;
  NUMCAT_SK2.value = new NUMCAT_SK2();
  return NUMCAT_SK2;
}();
var NUMCAT_SO = /* @__PURE__ */ function() {
  function NUMCAT_SO2() {
  }
  ;
  NUMCAT_SO2.value = new NUMCAT_SO2();
  return NUMCAT_SO2;
}();
var NUMCAT_ZS = /* @__PURE__ */ function() {
  function NUMCAT_ZS2() {
  }
  ;
  NUMCAT_ZS2.value = new NUMCAT_ZS2();
  return NUMCAT_ZS2;
}();
var NUMCAT_ZL = /* @__PURE__ */ function() {
  function NUMCAT_ZL2() {
  }
  ;
  NUMCAT_ZL2.value = new NUMCAT_ZL2();
  return NUMCAT_ZL2;
}();
var NUMCAT_ZP = /* @__PURE__ */ function() {
  function NUMCAT_ZP2() {
  }
  ;
  NUMCAT_ZP2.value = new NUMCAT_ZP2();
  return NUMCAT_ZP2;
}();
var NUMCAT_CC = /* @__PURE__ */ function() {
  function NUMCAT_CC2() {
  }
  ;
  NUMCAT_CC2.value = new NUMCAT_CC2();
  return NUMCAT_CC2;
}();
var NUMCAT_CF = /* @__PURE__ */ function() {
  function NUMCAT_CF2() {
  }
  ;
  NUMCAT_CF2.value = new NUMCAT_CF2();
  return NUMCAT_CF2;
}();
var NUMCAT_CS = /* @__PURE__ */ function() {
  function NUMCAT_CS2() {
  }
  ;
  NUMCAT_CS2.value = new NUMCAT_CS2();
  return NUMCAT_CS2;
}();
var NUMCAT_CO = /* @__PURE__ */ function() {
  function NUMCAT_CO2() {
  }
  ;
  NUMCAT_CO2.value = new NUMCAT_CO2();
  return NUMCAT_CO2;
}();
var NUMCAT_CN = /* @__PURE__ */ function() {
  function NUMCAT_CN2() {
  }
  ;
  NUMCAT_CN2.value = new NUMCAT_CN2();
  return NUMCAT_CN2;
}();
var numLat1Blocks = 63;
var numBlocks = 3396;
var gencatZS = 2;
var rule1 = /* @__PURE__ */ function() {
  return {
    category: gencatZS,
    unicodeCat: NUMCAT_ZS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatZP = 67108864;
var rule162 = /* @__PURE__ */ function() {
  return {
    category: gencatZP,
    unicodeCat: NUMCAT_ZP.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatZL = 33554432;
var rule161 = /* @__PURE__ */ function() {
  return {
    category: gencatZL,
    unicodeCat: NUMCAT_ZL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSO = 8192;
var rule13 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule170 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 1,
    updist: 0,
    lowdist: 26,
    titledist: 0
  };
}();
var rule171 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 1,
    updist: -26 | 0,
    lowdist: 0,
    titledist: -26 | 0
  };
}();
var gencatSM = 64;
var rule6 = /* @__PURE__ */ function() {
  return {
    category: gencatSM,
    unicodeCat: NUMCAT_SM.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSK = 1024;
var rule10 = /* @__PURE__ */ function() {
  return {
    category: gencatSK,
    unicodeCat: NUMCAT_SK.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSC = 8;
var rule3 = /* @__PURE__ */ function() {
  return {
    category: gencatSC,
    unicodeCat: NUMCAT_SC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPS = 16;
var rule4 = /* @__PURE__ */ function() {
  return {
    category: gencatPS,
    unicodeCat: NUMCAT_PS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPO = 4;
var rule2 = /* @__PURE__ */ function() {
  return {
    category: gencatPO,
    unicodeCat: NUMCAT_PO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPI = 32768;
var rule15 = /* @__PURE__ */ function() {
  return {
    category: gencatPI,
    unicodeCat: NUMCAT_PI.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPF = 262144;
var rule19 = /* @__PURE__ */ function() {
  return {
    category: gencatPF,
    unicodeCat: NUMCAT_PF.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPE = 32;
var rule5 = /* @__PURE__ */ function() {
  return {
    category: gencatPE,
    unicodeCat: NUMCAT_PE.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPD = 128;
var rule7 = /* @__PURE__ */ function() {
  return {
    category: gencatPD,
    unicodeCat: NUMCAT_PD.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPC = 2048;
var rule11 = /* @__PURE__ */ function() {
  return {
    category: gencatPC,
    unicodeCat: NUMCAT_PC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatNO = 131072;
var rule17 = /* @__PURE__ */ function() {
  return {
    category: gencatNO,
    unicodeCat: NUMCAT_NO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatNL = 16777216;
var rule128 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule168 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 1,
    updist: 0,
    lowdist: 16,
    titledist: 0
  };
}();
var rule169 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 1,
    updist: -16 | 0,
    lowdist: 0,
    titledist: -16 | 0
  };
}();
var gencatND = 256;
var rule8 = /* @__PURE__ */ function() {
  return {
    category: gencatND,
    unicodeCat: NUMCAT_ND.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatMN = 2097152;
var rule92 = /* @__PURE__ */ function() {
  return {
    category: gencatMN,
    unicodeCat: NUMCAT_MN.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule93 = /* @__PURE__ */ function() {
  return {
    category: gencatMN,
    unicodeCat: NUMCAT_MN.value,
    possible: 1,
    updist: 84,
    lowdist: 0,
    titledist: 84
  };
}();
var gencatME = 4194304;
var rule119 = /* @__PURE__ */ function() {
  return {
    category: gencatME,
    unicodeCat: NUMCAT_ME.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatMC = 8388608;
var rule124 = /* @__PURE__ */ function() {
  return {
    category: gencatMC,
    unicodeCat: NUMCAT_MC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLU = 512;
var nullrule = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_CN.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule104 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 8,
    titledist: 0
  };
}();
var rule107 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule115 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -60 | 0,
    titledist: 0
  };
}();
var rule117 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7 | 0,
    titledist: 0
  };
}();
var rule118 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 80,
    titledist: 0
  };
}();
var rule120 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 15,
    titledist: 0
  };
}();
var rule122 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 48,
    titledist: 0
  };
}();
var rule125 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 7264,
    titledist: 0
  };
}();
var rule127 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 38864,
    titledist: 0
  };
}();
var rule137 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -3008 | 0,
    titledist: 0
  };
}();
var rule142 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7615 | 0,
    titledist: 0
  };
}();
var rule144 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8 | 0,
    titledist: 0
  };
}();
var rule153 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -74 | 0,
    titledist: 0
  };
}();
var rule156 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -86 | 0,
    titledist: 0
  };
}();
var rule157 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -100 | 0,
    titledist: 0
  };
}();
var rule158 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -112 | 0,
    titledist: 0
  };
}();
var rule159 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -128 | 0,
    titledist: 0
  };
}();
var rule160 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -126 | 0,
    titledist: 0
  };
}();
var rule163 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7517 | 0,
    titledist: 0
  };
}();
var rule164 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8383 | 0,
    titledist: 0
  };
}();
var rule165 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8262 | 0,
    titledist: 0
  };
}();
var rule166 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 28,
    titledist: 0
  };
}();
var rule172 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10743 | 0,
    titledist: 0
  };
}();
var rule173 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -3814 | 0,
    titledist: 0
  };
}();
var rule174 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10727 | 0,
    titledist: 0
  };
}();
var rule177 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10780 | 0,
    titledist: 0
  };
}();
var rule178 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10749 | 0,
    titledist: 0
  };
}();
var rule179 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10783 | 0,
    titledist: 0
  };
}();
var rule180 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10782 | 0,
    titledist: 0
  };
}();
var rule181 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10815 | 0,
    titledist: 0
  };
}();
var rule183 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -35332 | 0,
    titledist: 0
  };
}();
var rule184 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42280 | 0,
    titledist: 0
  };
}();
var rule186 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42308 | 0,
    titledist: 0
  };
}();
var rule187 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42319 | 0,
    titledist: 0
  };
}();
var rule188 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42315 | 0,
    titledist: 0
  };
}();
var rule189 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42305 | 0,
    titledist: 0
  };
}();
var rule190 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42258 | 0,
    titledist: 0
  };
}();
var rule191 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42282 | 0,
    titledist: 0
  };
}();
var rule192 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42261 | 0,
    titledist: 0
  };
}();
var rule193 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 928,
    titledist: 0
  };
}();
var rule194 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -48 | 0,
    titledist: 0
  };
}();
var rule195 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42307 | 0,
    titledist: 0
  };
}();
var rule196 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -35384 | 0,
    titledist: 0
  };
}();
var rule201 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 40,
    titledist: 0
  };
}();
var rule203 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 34,
    titledist: 0
  };
}();
var rule22 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 1,
    titledist: 0
  };
}();
var rule24 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -199 | 0,
    titledist: 0
  };
}();
var rule26 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -121 | 0,
    titledist: 0
  };
}();
var rule29 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 210,
    titledist: 0
  };
}();
var rule30 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 206,
    titledist: 0
  };
}();
var rule31 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 205,
    titledist: 0
  };
}();
var rule32 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 79,
    titledist: 0
  };
}();
var rule33 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 202,
    titledist: 0
  };
}();
var rule34 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 203,
    titledist: 0
  };
}();
var rule35 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 207,
    titledist: 0
  };
}();
var rule37 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 211,
    titledist: 0
  };
}();
var rule38 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 209,
    titledist: 0
  };
}();
var rule40 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 213,
    titledist: 0
  };
}();
var rule42 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 214,
    titledist: 0
  };
}();
var rule43 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 218,
    titledist: 0
  };
}();
var rule44 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 217,
    titledist: 0
  };
}();
var rule45 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 219,
    titledist: 0
  };
}();
var rule47 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 2,
    titledist: 1
  };
}();
var rule51 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -97 | 0,
    titledist: 0
  };
}();
var rule52 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -56 | 0,
    titledist: 0
  };
}();
var rule53 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -130 | 0,
    titledist: 0
  };
}();
var rule54 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 10795,
    titledist: 0
  };
}();
var rule55 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -163 | 0,
    titledist: 0
  };
}();
var rule56 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 10792,
    titledist: 0
  };
}();
var rule58 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -195 | 0,
    titledist: 0
  };
}();
var rule59 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 69,
    titledist: 0
  };
}();
var rule60 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 71,
    titledist: 0
  };
}();
var rule9 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 32,
    titledist: 0
  };
}();
var rule94 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 116,
    titledist: 0
  };
}();
var rule95 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 38,
    titledist: 0
  };
}();
var rule96 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 37,
    titledist: 0
  };
}();
var rule97 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 64,
    titledist: 0
  };
}();
var rule98 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 63,
    titledist: 0
  };
}();
var gencatLT = 524288;
var rule151 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: 0,
    lowdist: -8 | 0,
    titledist: 0
  };
}();
var rule154 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: 0,
    lowdist: -9 | 0,
    titledist: 0
  };
}();
var rule48 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: -1 | 0,
    lowdist: 1,
    titledist: 0
  };
}();
var gencatLO = 16384;
var rule14 = /* @__PURE__ */ function() {
  return {
    category: gencatLO,
    unicodeCat: NUMCAT_LO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLM = 1048576;
var rule91 = /* @__PURE__ */ function() {
  return {
    category: gencatLM,
    unicodeCat: NUMCAT_LM.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLL = 4096;
var rule100 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -37 | 0,
    lowdist: 0,
    titledist: -37 | 0
  };
}();
var rule101 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -31 | 0,
    lowdist: 0,
    titledist: -31 | 0
  };
}();
var rule102 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -64 | 0,
    lowdist: 0,
    titledist: -64 | 0
  };
}();
var rule103 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -63 | 0,
    lowdist: 0,
    titledist: -63 | 0
  };
}();
var rule105 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -62 | 0,
    lowdist: 0,
    titledist: -62 | 0
  };
}();
var rule106 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -57 | 0,
    lowdist: 0,
    titledist: -57 | 0
  };
}();
var rule108 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -47 | 0,
    lowdist: 0,
    titledist: -47 | 0
  };
}();
var rule109 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -54 | 0,
    lowdist: 0,
    titledist: -54 | 0
  };
}();
var rule110 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -8 | 0,
    lowdist: 0,
    titledist: -8 | 0
  };
}();
var rule111 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -86 | 0,
    lowdist: 0,
    titledist: -86 | 0
  };
}();
var rule112 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -80 | 0,
    lowdist: 0,
    titledist: -80 | 0
  };
}();
var rule113 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 7,
    lowdist: 0,
    titledist: 7
  };
}();
var rule114 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -116 | 0,
    lowdist: 0,
    titledist: -116 | 0
  };
}();
var rule116 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -96 | 0,
    lowdist: 0,
    titledist: -96 | 0
  };
}();
var rule12 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -32 | 0,
    lowdist: 0,
    titledist: -32 | 0
  };
}();
var rule121 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -15 | 0,
    lowdist: 0,
    titledist: -15 | 0
  };
}();
var rule123 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -48 | 0,
    lowdist: 0,
    titledist: -48 | 0
  };
}();
var rule126 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 3008,
    lowdist: 0,
    titledist: 0
  };
}();
var rule129 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6254 | 0,
    lowdist: 0,
    titledist: -6254 | 0
  };
}();
var rule130 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6253 | 0,
    lowdist: 0,
    titledist: -6253 | 0
  };
}();
var rule131 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6244 | 0,
    lowdist: 0,
    titledist: -6244 | 0
  };
}();
var rule132 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6242 | 0,
    lowdist: 0,
    titledist: -6242 | 0
  };
}();
var rule133 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6243 | 0,
    lowdist: 0,
    titledist: -6243 | 0
  };
}();
var rule134 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6236 | 0,
    lowdist: 0,
    titledist: -6236 | 0
  };
}();
var rule135 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6181 | 0,
    lowdist: 0,
    titledist: -6181 | 0
  };
}();
var rule136 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35266,
    lowdist: 0,
    titledist: 35266
  };
}();
var rule138 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35332,
    lowdist: 0,
    titledist: 35332
  };
}();
var rule139 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 3814,
    lowdist: 0,
    titledist: 3814
  };
}();
var rule140 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35384,
    lowdist: 0,
    titledist: 35384
  };
}();
var rule141 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -59 | 0,
    lowdist: 0,
    titledist: -59 | 0
  };
}();
var rule143 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 8,
    lowdist: 0,
    titledist: 8
  };
}();
var rule145 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 74,
    lowdist: 0,
    titledist: 74
  };
}();
var rule146 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 86,
    lowdist: 0,
    titledist: 86
  };
}();
var rule147 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 100,
    lowdist: 0,
    titledist: 100
  };
}();
var rule148 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 128,
    lowdist: 0,
    titledist: 128
  };
}();
var rule149 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 112,
    lowdist: 0,
    titledist: 112
  };
}();
var rule150 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 126,
    lowdist: 0,
    titledist: 126
  };
}();
var rule152 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 9,
    lowdist: 0,
    titledist: 9
  };
}();
var rule155 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -7205 | 0,
    lowdist: 0,
    titledist: -7205 | 0
  };
}();
var rule167 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -28 | 0,
    lowdist: 0,
    titledist: -28 | 0
  };
}();
var rule175 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -10795 | 0,
    lowdist: 0,
    titledist: -10795 | 0
  };
}();
var rule176 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -10792 | 0,
    lowdist: 0,
    titledist: -10792 | 0
  };
}();
var rule18 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 743,
    lowdist: 0,
    titledist: 743
  };
}();
var rule182 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -7264 | 0,
    lowdist: 0,
    titledist: -7264 | 0
  };
}();
var rule185 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 48,
    lowdist: 0,
    titledist: 48
  };
}();
var rule197 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -928 | 0,
    lowdist: 0,
    titledist: -928 | 0
  };
}();
var rule198 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -38864 | 0,
    lowdist: 0,
    titledist: -38864 | 0
  };
}();
var rule20 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule202 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -40 | 0,
    lowdist: 0,
    titledist: -40 | 0
  };
}();
var rule204 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -34 | 0,
    lowdist: 0,
    titledist: -34 | 0
  };
}();
var rule21 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 121,
    lowdist: 0,
    titledist: 121
  };
}();
var rule23 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -1 | 0,
    lowdist: 0,
    titledist: -1 | 0
  };
}();
var rule25 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -232 | 0,
    lowdist: 0,
    titledist: -232 | 0
  };
}();
var rule27 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -300 | 0,
    lowdist: 0,
    titledist: -300 | 0
  };
}();
var rule28 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 195,
    lowdist: 0,
    titledist: 195
  };
}();
var rule36 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 97,
    lowdist: 0,
    titledist: 97
  };
}();
var rule39 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 163,
    lowdist: 0,
    titledist: 163
  };
}();
var rule41 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 130,
    lowdist: 0,
    titledist: 130
  };
}();
var rule46 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 56,
    lowdist: 0,
    titledist: 56
  };
}();
var rule49 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -2 | 0,
    lowdist: 0,
    titledist: -1 | 0
  };
}();
var rule50 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -79 | 0,
    lowdist: 0,
    titledist: -79 | 0
  };
}();
var rule57 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10815,
    lowdist: 0,
    titledist: 10815
  };
}();
var rule61 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10783,
    lowdist: 0,
    titledist: 10783
  };
}();
var rule62 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10780,
    lowdist: 0,
    titledist: 10780
  };
}();
var rule63 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10782,
    lowdist: 0,
    titledist: 10782
  };
}();
var rule64 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -210 | 0,
    lowdist: 0,
    titledist: -210 | 0
  };
}();
var rule65 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -206 | 0,
    lowdist: 0,
    titledist: -206 | 0
  };
}();
var rule66 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -205 | 0,
    lowdist: 0,
    titledist: -205 | 0
  };
}();
var rule67 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -202 | 0,
    lowdist: 0,
    titledist: -202 | 0
  };
}();
var rule68 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -203 | 0,
    lowdist: 0,
    titledist: -203 | 0
  };
}();
var rule69 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42319,
    lowdist: 0,
    titledist: 42319
  };
}();
var rule70 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42315,
    lowdist: 0,
    titledist: 42315
  };
}();
var rule71 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -207 | 0,
    lowdist: 0,
    titledist: -207 | 0
  };
}();
var rule72 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42280,
    lowdist: 0,
    titledist: 42280
  };
}();
var rule73 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42308,
    lowdist: 0,
    titledist: 42308
  };
}();
var rule74 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -209 | 0,
    lowdist: 0,
    titledist: -209 | 0
  };
}();
var rule75 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -211 | 0,
    lowdist: 0,
    titledist: -211 | 0
  };
}();
var rule76 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10743,
    lowdist: 0,
    titledist: 10743
  };
}();
var rule77 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42305,
    lowdist: 0,
    titledist: 42305
  };
}();
var rule78 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10749,
    lowdist: 0,
    titledist: 10749
  };
}();
var rule79 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -213 | 0,
    lowdist: 0,
    titledist: -213 | 0
  };
}();
var rule80 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -214 | 0,
    lowdist: 0,
    titledist: -214 | 0
  };
}();
var rule81 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10727,
    lowdist: 0,
    titledist: 10727
  };
}();
var rule82 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -218 | 0,
    lowdist: 0,
    titledist: -218 | 0
  };
}();
var rule83 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42307,
    lowdist: 0,
    titledist: 42307
  };
}();
var rule84 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42282,
    lowdist: 0,
    titledist: 42282
  };
}();
var rule85 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -69 | 0,
    lowdist: 0,
    titledist: -69 | 0
  };
}();
var rule86 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -217 | 0,
    lowdist: 0,
    titledist: -217 | 0
  };
}();
var rule87 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -71 | 0,
    lowdist: 0,
    titledist: -71 | 0
  };
}();
var rule88 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -219 | 0,
    lowdist: 0,
    titledist: -219 | 0
  };
}();
var rule89 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42261,
    lowdist: 0,
    titledist: 42261
  };
}();
var rule90 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42258,
    lowdist: 0,
    titledist: 42258
  };
}();
var rule99 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -38 | 0,
    lowdist: 0,
    titledist: -38 | 0
  };
}();
var gencatCS = 134217728;
var rule199 = /* @__PURE__ */ function() {
  return {
    category: gencatCS,
    unicodeCat: NUMCAT_CS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCO = 268435456;
var rule200 = /* @__PURE__ */ function() {
  return {
    category: gencatCO,
    unicodeCat: NUMCAT_CO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCF = 65536;
var rule16 = /* @__PURE__ */ function() {
  return {
    category: gencatCF,
    unicodeCat: NUMCAT_CF.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCC = 1;
var rule0 = /* @__PURE__ */ function() {
  return {
    category: gencatCC,
    unicodeCat: NUMCAT_CC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var bsearch = function(a) {
  return function(array2) {
    return function(size8) {
      return function(compare21) {
        var go = function($copy_i) {
          return function($copy_k) {
            var $tco_var_i = $copy_i;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(i, k) {
              if (i > k || i >= length(array2)) {
                $tco_done = true;
                return Nothing.value;
              }
              ;
              if (otherwise) {
                var j = floor2(toNumber(i + k | 0) / 2);
                var b = unsafeIndex3(array2)(j);
                var v = compare21(a)(b);
                if (v instanceof EQ) {
                  $tco_done = true;
                  return new Just(b);
                }
                ;
                if (v instanceof GT) {
                  $tco_var_i = j + 1 | 0;
                  $copy_k = k;
                  return;
                }
                ;
                $tco_var_i = i;
                $copy_k = j - 1 | 0;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5622, column 3 - line 5632, column 30): " + [i.constructor.name, k.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_i, $copy_k);
            }
            ;
            return $tco_result;
          };
        };
        return go(0)(size8);
      };
    };
  };
};
var blkCmp = function(v) {
  return function(v1) {
    if (v.start >= v1.start && v.start < (v1.start + v1.length | 0)) {
      return EQ.value;
    }
    ;
    if (v.start > v1.start) {
      return GT.value;
    }
    ;
    if (otherwise) {
      return LT.value;
    }
    ;
    throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5598, column 1 - line 5598, column 45): " + [v.constructor.name, v1.constructor.name]);
  };
};
var getRule = function(blocks) {
  return function(unichar) {
    return function(size8) {
      var key = {
        start: unichar,
        length: 1,
        convRule: nullrule
      };
      var maybeCharBlock = bsearch(key)(blocks)(size8)(blkCmp);
      if (maybeCharBlock instanceof Nothing) {
        return Nothing.value;
      }
      ;
      if (maybeCharBlock instanceof Just) {
        return new Just(maybeCharBlock.value0.convRule);
      }
      ;
      throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5612, column 5 - line 5614, column 60): " + [maybeCharBlock.constructor.name]);
    };
  };
};
var allchars = [{
  start: 0,
  length: 32,
  convRule: rule0
}, {
  start: 32,
  length: 1,
  convRule: rule1
}, {
  start: 33,
  length: 3,
  convRule: rule2
}, {
  start: 36,
  length: 1,
  convRule: rule3
}, {
  start: 37,
  length: 3,
  convRule: rule2
}, {
  start: 40,
  length: 1,
  convRule: rule4
}, {
  start: 41,
  length: 1,
  convRule: rule5
}, {
  start: 42,
  length: 1,
  convRule: rule2
}, {
  start: 43,
  length: 1,
  convRule: rule6
}, {
  start: 44,
  length: 1,
  convRule: rule2
}, {
  start: 45,
  length: 1,
  convRule: rule7
}, {
  start: 46,
  length: 2,
  convRule: rule2
}, {
  start: 48,
  length: 10,
  convRule: rule8
}, {
  start: 58,
  length: 2,
  convRule: rule2
}, {
  start: 60,
  length: 3,
  convRule: rule6
}, {
  start: 63,
  length: 2,
  convRule: rule2
}, {
  start: 65,
  length: 26,
  convRule: rule9
}, {
  start: 91,
  length: 1,
  convRule: rule4
}, {
  start: 92,
  length: 1,
  convRule: rule2
}, {
  start: 93,
  length: 1,
  convRule: rule5
}, {
  start: 94,
  length: 1,
  convRule: rule10
}, {
  start: 95,
  length: 1,
  convRule: rule11
}, {
  start: 96,
  length: 1,
  convRule: rule10
}, {
  start: 97,
  length: 26,
  convRule: rule12
}, {
  start: 123,
  length: 1,
  convRule: rule4
}, {
  start: 124,
  length: 1,
  convRule: rule6
}, {
  start: 125,
  length: 1,
  convRule: rule5
}, {
  start: 126,
  length: 1,
  convRule: rule6
}, {
  start: 127,
  length: 33,
  convRule: rule0
}, {
  start: 160,
  length: 1,
  convRule: rule1
}, {
  start: 161,
  length: 1,
  convRule: rule2
}, {
  start: 162,
  length: 4,
  convRule: rule3
}, {
  start: 166,
  length: 1,
  convRule: rule13
}, {
  start: 167,
  length: 1,
  convRule: rule2
}, {
  start: 168,
  length: 1,
  convRule: rule10
}, {
  start: 169,
  length: 1,
  convRule: rule13
}, {
  start: 170,
  length: 1,
  convRule: rule14
}, {
  start: 171,
  length: 1,
  convRule: rule15
}, {
  start: 172,
  length: 1,
  convRule: rule6
}, {
  start: 173,
  length: 1,
  convRule: rule16
}, {
  start: 174,
  length: 1,
  convRule: rule13
}, {
  start: 175,
  length: 1,
  convRule: rule10
}, {
  start: 176,
  length: 1,
  convRule: rule13
}, {
  start: 177,
  length: 1,
  convRule: rule6
}, {
  start: 178,
  length: 2,
  convRule: rule17
}, {
  start: 180,
  length: 1,
  convRule: rule10
}, {
  start: 181,
  length: 1,
  convRule: rule18
}, {
  start: 182,
  length: 2,
  convRule: rule2
}, {
  start: 184,
  length: 1,
  convRule: rule10
}, {
  start: 185,
  length: 1,
  convRule: rule17
}, {
  start: 186,
  length: 1,
  convRule: rule14
}, {
  start: 187,
  length: 1,
  convRule: rule19
}, {
  start: 188,
  length: 3,
  convRule: rule17
}, {
  start: 191,
  length: 1,
  convRule: rule2
}, {
  start: 192,
  length: 23,
  convRule: rule9
}, {
  start: 215,
  length: 1,
  convRule: rule6
}, {
  start: 216,
  length: 7,
  convRule: rule9
}, {
  start: 223,
  length: 1,
  convRule: rule20
}, {
  start: 224,
  length: 23,
  convRule: rule12
}, {
  start: 247,
  length: 1,
  convRule: rule6
}, {
  start: 248,
  length: 7,
  convRule: rule12
}, {
  start: 255,
  length: 1,
  convRule: rule21
}, {
  start: 256,
  length: 1,
  convRule: rule22
}, {
  start: 257,
  length: 1,
  convRule: rule23
}, {
  start: 258,
  length: 1,
  convRule: rule22
}, {
  start: 259,
  length: 1,
  convRule: rule23
}, {
  start: 260,
  length: 1,
  convRule: rule22
}, {
  start: 261,
  length: 1,
  convRule: rule23
}, {
  start: 262,
  length: 1,
  convRule: rule22
}, {
  start: 263,
  length: 1,
  convRule: rule23
}, {
  start: 264,
  length: 1,
  convRule: rule22
}, {
  start: 265,
  length: 1,
  convRule: rule23
}, {
  start: 266,
  length: 1,
  convRule: rule22
}, {
  start: 267,
  length: 1,
  convRule: rule23
}, {
  start: 268,
  length: 1,
  convRule: rule22
}, {
  start: 269,
  length: 1,
  convRule: rule23
}, {
  start: 270,
  length: 1,
  convRule: rule22
}, {
  start: 271,
  length: 1,
  convRule: rule23
}, {
  start: 272,
  length: 1,
  convRule: rule22
}, {
  start: 273,
  length: 1,
  convRule: rule23
}, {
  start: 274,
  length: 1,
  convRule: rule22
}, {
  start: 275,
  length: 1,
  convRule: rule23
}, {
  start: 276,
  length: 1,
  convRule: rule22
}, {
  start: 277,
  length: 1,
  convRule: rule23
}, {
  start: 278,
  length: 1,
  convRule: rule22
}, {
  start: 279,
  length: 1,
  convRule: rule23
}, {
  start: 280,
  length: 1,
  convRule: rule22
}, {
  start: 281,
  length: 1,
  convRule: rule23
}, {
  start: 282,
  length: 1,
  convRule: rule22
}, {
  start: 283,
  length: 1,
  convRule: rule23
}, {
  start: 284,
  length: 1,
  convRule: rule22
}, {
  start: 285,
  length: 1,
  convRule: rule23
}, {
  start: 286,
  length: 1,
  convRule: rule22
}, {
  start: 287,
  length: 1,
  convRule: rule23
}, {
  start: 288,
  length: 1,
  convRule: rule22
}, {
  start: 289,
  length: 1,
  convRule: rule23
}, {
  start: 290,
  length: 1,
  convRule: rule22
}, {
  start: 291,
  length: 1,
  convRule: rule23
}, {
  start: 292,
  length: 1,
  convRule: rule22
}, {
  start: 293,
  length: 1,
  convRule: rule23
}, {
  start: 294,
  length: 1,
  convRule: rule22
}, {
  start: 295,
  length: 1,
  convRule: rule23
}, {
  start: 296,
  length: 1,
  convRule: rule22
}, {
  start: 297,
  length: 1,
  convRule: rule23
}, {
  start: 298,
  length: 1,
  convRule: rule22
}, {
  start: 299,
  length: 1,
  convRule: rule23
}, {
  start: 300,
  length: 1,
  convRule: rule22
}, {
  start: 301,
  length: 1,
  convRule: rule23
}, {
  start: 302,
  length: 1,
  convRule: rule22
}, {
  start: 303,
  length: 1,
  convRule: rule23
}, {
  start: 304,
  length: 1,
  convRule: rule24
}, {
  start: 305,
  length: 1,
  convRule: rule25
}, {
  start: 306,
  length: 1,
  convRule: rule22
}, {
  start: 307,
  length: 1,
  convRule: rule23
}, {
  start: 308,
  length: 1,
  convRule: rule22
}, {
  start: 309,
  length: 1,
  convRule: rule23
}, {
  start: 310,
  length: 1,
  convRule: rule22
}, {
  start: 311,
  length: 1,
  convRule: rule23
}, {
  start: 312,
  length: 1,
  convRule: rule20
}, {
  start: 313,
  length: 1,
  convRule: rule22
}, {
  start: 314,
  length: 1,
  convRule: rule23
}, {
  start: 315,
  length: 1,
  convRule: rule22
}, {
  start: 316,
  length: 1,
  convRule: rule23
}, {
  start: 317,
  length: 1,
  convRule: rule22
}, {
  start: 318,
  length: 1,
  convRule: rule23
}, {
  start: 319,
  length: 1,
  convRule: rule22
}, {
  start: 320,
  length: 1,
  convRule: rule23
}, {
  start: 321,
  length: 1,
  convRule: rule22
}, {
  start: 322,
  length: 1,
  convRule: rule23
}, {
  start: 323,
  length: 1,
  convRule: rule22
}, {
  start: 324,
  length: 1,
  convRule: rule23
}, {
  start: 325,
  length: 1,
  convRule: rule22
}, {
  start: 326,
  length: 1,
  convRule: rule23
}, {
  start: 327,
  length: 1,
  convRule: rule22
}, {
  start: 328,
  length: 1,
  convRule: rule23
}, {
  start: 329,
  length: 1,
  convRule: rule20
}, {
  start: 330,
  length: 1,
  convRule: rule22
}, {
  start: 331,
  length: 1,
  convRule: rule23
}, {
  start: 332,
  length: 1,
  convRule: rule22
}, {
  start: 333,
  length: 1,
  convRule: rule23
}, {
  start: 334,
  length: 1,
  convRule: rule22
}, {
  start: 335,
  length: 1,
  convRule: rule23
}, {
  start: 336,
  length: 1,
  convRule: rule22
}, {
  start: 337,
  length: 1,
  convRule: rule23
}, {
  start: 338,
  length: 1,
  convRule: rule22
}, {
  start: 339,
  length: 1,
  convRule: rule23
}, {
  start: 340,
  length: 1,
  convRule: rule22
}, {
  start: 341,
  length: 1,
  convRule: rule23
}, {
  start: 342,
  length: 1,
  convRule: rule22
}, {
  start: 343,
  length: 1,
  convRule: rule23
}, {
  start: 344,
  length: 1,
  convRule: rule22
}, {
  start: 345,
  length: 1,
  convRule: rule23
}, {
  start: 346,
  length: 1,
  convRule: rule22
}, {
  start: 347,
  length: 1,
  convRule: rule23
}, {
  start: 348,
  length: 1,
  convRule: rule22
}, {
  start: 349,
  length: 1,
  convRule: rule23
}, {
  start: 350,
  length: 1,
  convRule: rule22
}, {
  start: 351,
  length: 1,
  convRule: rule23
}, {
  start: 352,
  length: 1,
  convRule: rule22
}, {
  start: 353,
  length: 1,
  convRule: rule23
}, {
  start: 354,
  length: 1,
  convRule: rule22
}, {
  start: 355,
  length: 1,
  convRule: rule23
}, {
  start: 356,
  length: 1,
  convRule: rule22
}, {
  start: 357,
  length: 1,
  convRule: rule23
}, {
  start: 358,
  length: 1,
  convRule: rule22
}, {
  start: 359,
  length: 1,
  convRule: rule23
}, {
  start: 360,
  length: 1,
  convRule: rule22
}, {
  start: 361,
  length: 1,
  convRule: rule23
}, {
  start: 362,
  length: 1,
  convRule: rule22
}, {
  start: 363,
  length: 1,
  convRule: rule23
}, {
  start: 364,
  length: 1,
  convRule: rule22
}, {
  start: 365,
  length: 1,
  convRule: rule23
}, {
  start: 366,
  length: 1,
  convRule: rule22
}, {
  start: 367,
  length: 1,
  convRule: rule23
}, {
  start: 368,
  length: 1,
  convRule: rule22
}, {
  start: 369,
  length: 1,
  convRule: rule23
}, {
  start: 370,
  length: 1,
  convRule: rule22
}, {
  start: 371,
  length: 1,
  convRule: rule23
}, {
  start: 372,
  length: 1,
  convRule: rule22
}, {
  start: 373,
  length: 1,
  convRule: rule23
}, {
  start: 374,
  length: 1,
  convRule: rule22
}, {
  start: 375,
  length: 1,
  convRule: rule23
}, {
  start: 376,
  length: 1,
  convRule: rule26
}, {
  start: 377,
  length: 1,
  convRule: rule22
}, {
  start: 378,
  length: 1,
  convRule: rule23
}, {
  start: 379,
  length: 1,
  convRule: rule22
}, {
  start: 380,
  length: 1,
  convRule: rule23
}, {
  start: 381,
  length: 1,
  convRule: rule22
}, {
  start: 382,
  length: 1,
  convRule: rule23
}, {
  start: 383,
  length: 1,
  convRule: rule27
}, {
  start: 384,
  length: 1,
  convRule: rule28
}, {
  start: 385,
  length: 1,
  convRule: rule29
}, {
  start: 386,
  length: 1,
  convRule: rule22
}, {
  start: 387,
  length: 1,
  convRule: rule23
}, {
  start: 388,
  length: 1,
  convRule: rule22
}, {
  start: 389,
  length: 1,
  convRule: rule23
}, {
  start: 390,
  length: 1,
  convRule: rule30
}, {
  start: 391,
  length: 1,
  convRule: rule22
}, {
  start: 392,
  length: 1,
  convRule: rule23
}, {
  start: 393,
  length: 2,
  convRule: rule31
}, {
  start: 395,
  length: 1,
  convRule: rule22
}, {
  start: 396,
  length: 1,
  convRule: rule23
}, {
  start: 397,
  length: 1,
  convRule: rule20
}, {
  start: 398,
  length: 1,
  convRule: rule32
}, {
  start: 399,
  length: 1,
  convRule: rule33
}, {
  start: 400,
  length: 1,
  convRule: rule34
}, {
  start: 401,
  length: 1,
  convRule: rule22
}, {
  start: 402,
  length: 1,
  convRule: rule23
}, {
  start: 403,
  length: 1,
  convRule: rule31
}, {
  start: 404,
  length: 1,
  convRule: rule35
}, {
  start: 405,
  length: 1,
  convRule: rule36
}, {
  start: 406,
  length: 1,
  convRule: rule37
}, {
  start: 407,
  length: 1,
  convRule: rule38
}, {
  start: 408,
  length: 1,
  convRule: rule22
}, {
  start: 409,
  length: 1,
  convRule: rule23
}, {
  start: 410,
  length: 1,
  convRule: rule39
}, {
  start: 411,
  length: 1,
  convRule: rule20
}, {
  start: 412,
  length: 1,
  convRule: rule37
}, {
  start: 413,
  length: 1,
  convRule: rule40
}, {
  start: 414,
  length: 1,
  convRule: rule41
}, {
  start: 415,
  length: 1,
  convRule: rule42
}, {
  start: 416,
  length: 1,
  convRule: rule22
}, {
  start: 417,
  length: 1,
  convRule: rule23
}, {
  start: 418,
  length: 1,
  convRule: rule22
}, {
  start: 419,
  length: 1,
  convRule: rule23
}, {
  start: 420,
  length: 1,
  convRule: rule22
}, {
  start: 421,
  length: 1,
  convRule: rule23
}, {
  start: 422,
  length: 1,
  convRule: rule43
}, {
  start: 423,
  length: 1,
  convRule: rule22
}, {
  start: 424,
  length: 1,
  convRule: rule23
}, {
  start: 425,
  length: 1,
  convRule: rule43
}, {
  start: 426,
  length: 2,
  convRule: rule20
}, {
  start: 428,
  length: 1,
  convRule: rule22
}, {
  start: 429,
  length: 1,
  convRule: rule23
}, {
  start: 430,
  length: 1,
  convRule: rule43
}, {
  start: 431,
  length: 1,
  convRule: rule22
}, {
  start: 432,
  length: 1,
  convRule: rule23
}, {
  start: 433,
  length: 2,
  convRule: rule44
}, {
  start: 435,
  length: 1,
  convRule: rule22
}, {
  start: 436,
  length: 1,
  convRule: rule23
}, {
  start: 437,
  length: 1,
  convRule: rule22
}, {
  start: 438,
  length: 1,
  convRule: rule23
}, {
  start: 439,
  length: 1,
  convRule: rule45
}, {
  start: 440,
  length: 1,
  convRule: rule22
}, {
  start: 441,
  length: 1,
  convRule: rule23
}, {
  start: 442,
  length: 1,
  convRule: rule20
}, {
  start: 443,
  length: 1,
  convRule: rule14
}, {
  start: 444,
  length: 1,
  convRule: rule22
}, {
  start: 445,
  length: 1,
  convRule: rule23
}, {
  start: 446,
  length: 1,
  convRule: rule20
}, {
  start: 447,
  length: 1,
  convRule: rule46
}, {
  start: 448,
  length: 4,
  convRule: rule14
}, {
  start: 452,
  length: 1,
  convRule: rule47
}, {
  start: 453,
  length: 1,
  convRule: rule48
}, {
  start: 454,
  length: 1,
  convRule: rule49
}, {
  start: 455,
  length: 1,
  convRule: rule47
}, {
  start: 456,
  length: 1,
  convRule: rule48
}, {
  start: 457,
  length: 1,
  convRule: rule49
}, {
  start: 458,
  length: 1,
  convRule: rule47
}, {
  start: 459,
  length: 1,
  convRule: rule48
}, {
  start: 460,
  length: 1,
  convRule: rule49
}, {
  start: 461,
  length: 1,
  convRule: rule22
}, {
  start: 462,
  length: 1,
  convRule: rule23
}, {
  start: 463,
  length: 1,
  convRule: rule22
}, {
  start: 464,
  length: 1,
  convRule: rule23
}, {
  start: 465,
  length: 1,
  convRule: rule22
}, {
  start: 466,
  length: 1,
  convRule: rule23
}, {
  start: 467,
  length: 1,
  convRule: rule22
}, {
  start: 468,
  length: 1,
  convRule: rule23
}, {
  start: 469,
  length: 1,
  convRule: rule22
}, {
  start: 470,
  length: 1,
  convRule: rule23
}, {
  start: 471,
  length: 1,
  convRule: rule22
}, {
  start: 472,
  length: 1,
  convRule: rule23
}, {
  start: 473,
  length: 1,
  convRule: rule22
}, {
  start: 474,
  length: 1,
  convRule: rule23
}, {
  start: 475,
  length: 1,
  convRule: rule22
}, {
  start: 476,
  length: 1,
  convRule: rule23
}, {
  start: 477,
  length: 1,
  convRule: rule50
}, {
  start: 478,
  length: 1,
  convRule: rule22
}, {
  start: 479,
  length: 1,
  convRule: rule23
}, {
  start: 480,
  length: 1,
  convRule: rule22
}, {
  start: 481,
  length: 1,
  convRule: rule23
}, {
  start: 482,
  length: 1,
  convRule: rule22
}, {
  start: 483,
  length: 1,
  convRule: rule23
}, {
  start: 484,
  length: 1,
  convRule: rule22
}, {
  start: 485,
  length: 1,
  convRule: rule23
}, {
  start: 486,
  length: 1,
  convRule: rule22
}, {
  start: 487,
  length: 1,
  convRule: rule23
}, {
  start: 488,
  length: 1,
  convRule: rule22
}, {
  start: 489,
  length: 1,
  convRule: rule23
}, {
  start: 490,
  length: 1,
  convRule: rule22
}, {
  start: 491,
  length: 1,
  convRule: rule23
}, {
  start: 492,
  length: 1,
  convRule: rule22
}, {
  start: 493,
  length: 1,
  convRule: rule23
}, {
  start: 494,
  length: 1,
  convRule: rule22
}, {
  start: 495,
  length: 1,
  convRule: rule23
}, {
  start: 496,
  length: 1,
  convRule: rule20
}, {
  start: 497,
  length: 1,
  convRule: rule47
}, {
  start: 498,
  length: 1,
  convRule: rule48
}, {
  start: 499,
  length: 1,
  convRule: rule49
}, {
  start: 500,
  length: 1,
  convRule: rule22
}, {
  start: 501,
  length: 1,
  convRule: rule23
}, {
  start: 502,
  length: 1,
  convRule: rule51
}, {
  start: 503,
  length: 1,
  convRule: rule52
}, {
  start: 504,
  length: 1,
  convRule: rule22
}, {
  start: 505,
  length: 1,
  convRule: rule23
}, {
  start: 506,
  length: 1,
  convRule: rule22
}, {
  start: 507,
  length: 1,
  convRule: rule23
}, {
  start: 508,
  length: 1,
  convRule: rule22
}, {
  start: 509,
  length: 1,
  convRule: rule23
}, {
  start: 510,
  length: 1,
  convRule: rule22
}, {
  start: 511,
  length: 1,
  convRule: rule23
}, {
  start: 512,
  length: 1,
  convRule: rule22
}, {
  start: 513,
  length: 1,
  convRule: rule23
}, {
  start: 514,
  length: 1,
  convRule: rule22
}, {
  start: 515,
  length: 1,
  convRule: rule23
}, {
  start: 516,
  length: 1,
  convRule: rule22
}, {
  start: 517,
  length: 1,
  convRule: rule23
}, {
  start: 518,
  length: 1,
  convRule: rule22
}, {
  start: 519,
  length: 1,
  convRule: rule23
}, {
  start: 520,
  length: 1,
  convRule: rule22
}, {
  start: 521,
  length: 1,
  convRule: rule23
}, {
  start: 522,
  length: 1,
  convRule: rule22
}, {
  start: 523,
  length: 1,
  convRule: rule23
}, {
  start: 524,
  length: 1,
  convRule: rule22
}, {
  start: 525,
  length: 1,
  convRule: rule23
}, {
  start: 526,
  length: 1,
  convRule: rule22
}, {
  start: 527,
  length: 1,
  convRule: rule23
}, {
  start: 528,
  length: 1,
  convRule: rule22
}, {
  start: 529,
  length: 1,
  convRule: rule23
}, {
  start: 530,
  length: 1,
  convRule: rule22
}, {
  start: 531,
  length: 1,
  convRule: rule23
}, {
  start: 532,
  length: 1,
  convRule: rule22
}, {
  start: 533,
  length: 1,
  convRule: rule23
}, {
  start: 534,
  length: 1,
  convRule: rule22
}, {
  start: 535,
  length: 1,
  convRule: rule23
}, {
  start: 536,
  length: 1,
  convRule: rule22
}, {
  start: 537,
  length: 1,
  convRule: rule23
}, {
  start: 538,
  length: 1,
  convRule: rule22
}, {
  start: 539,
  length: 1,
  convRule: rule23
}, {
  start: 540,
  length: 1,
  convRule: rule22
}, {
  start: 541,
  length: 1,
  convRule: rule23
}, {
  start: 542,
  length: 1,
  convRule: rule22
}, {
  start: 543,
  length: 1,
  convRule: rule23
}, {
  start: 544,
  length: 1,
  convRule: rule53
}, {
  start: 545,
  length: 1,
  convRule: rule20
}, {
  start: 546,
  length: 1,
  convRule: rule22
}, {
  start: 547,
  length: 1,
  convRule: rule23
}, {
  start: 548,
  length: 1,
  convRule: rule22
}, {
  start: 549,
  length: 1,
  convRule: rule23
}, {
  start: 550,
  length: 1,
  convRule: rule22
}, {
  start: 551,
  length: 1,
  convRule: rule23
}, {
  start: 552,
  length: 1,
  convRule: rule22
}, {
  start: 553,
  length: 1,
  convRule: rule23
}, {
  start: 554,
  length: 1,
  convRule: rule22
}, {
  start: 555,
  length: 1,
  convRule: rule23
}, {
  start: 556,
  length: 1,
  convRule: rule22
}, {
  start: 557,
  length: 1,
  convRule: rule23
}, {
  start: 558,
  length: 1,
  convRule: rule22
}, {
  start: 559,
  length: 1,
  convRule: rule23
}, {
  start: 560,
  length: 1,
  convRule: rule22
}, {
  start: 561,
  length: 1,
  convRule: rule23
}, {
  start: 562,
  length: 1,
  convRule: rule22
}, {
  start: 563,
  length: 1,
  convRule: rule23
}, {
  start: 564,
  length: 6,
  convRule: rule20
}, {
  start: 570,
  length: 1,
  convRule: rule54
}, {
  start: 571,
  length: 1,
  convRule: rule22
}, {
  start: 572,
  length: 1,
  convRule: rule23
}, {
  start: 573,
  length: 1,
  convRule: rule55
}, {
  start: 574,
  length: 1,
  convRule: rule56
}, {
  start: 575,
  length: 2,
  convRule: rule57
}, {
  start: 577,
  length: 1,
  convRule: rule22
}, {
  start: 578,
  length: 1,
  convRule: rule23
}, {
  start: 579,
  length: 1,
  convRule: rule58
}, {
  start: 580,
  length: 1,
  convRule: rule59
}, {
  start: 581,
  length: 1,
  convRule: rule60
}, {
  start: 582,
  length: 1,
  convRule: rule22
}, {
  start: 583,
  length: 1,
  convRule: rule23
}, {
  start: 584,
  length: 1,
  convRule: rule22
}, {
  start: 585,
  length: 1,
  convRule: rule23
}, {
  start: 586,
  length: 1,
  convRule: rule22
}, {
  start: 587,
  length: 1,
  convRule: rule23
}, {
  start: 588,
  length: 1,
  convRule: rule22
}, {
  start: 589,
  length: 1,
  convRule: rule23
}, {
  start: 590,
  length: 1,
  convRule: rule22
}, {
  start: 591,
  length: 1,
  convRule: rule23
}, {
  start: 592,
  length: 1,
  convRule: rule61
}, {
  start: 593,
  length: 1,
  convRule: rule62
}, {
  start: 594,
  length: 1,
  convRule: rule63
}, {
  start: 595,
  length: 1,
  convRule: rule64
}, {
  start: 596,
  length: 1,
  convRule: rule65
}, {
  start: 597,
  length: 1,
  convRule: rule20
}, {
  start: 598,
  length: 2,
  convRule: rule66
}, {
  start: 600,
  length: 1,
  convRule: rule20
}, {
  start: 601,
  length: 1,
  convRule: rule67
}, {
  start: 602,
  length: 1,
  convRule: rule20
}, {
  start: 603,
  length: 1,
  convRule: rule68
}, {
  start: 604,
  length: 1,
  convRule: rule69
}, {
  start: 605,
  length: 3,
  convRule: rule20
}, {
  start: 608,
  length: 1,
  convRule: rule66
}, {
  start: 609,
  length: 1,
  convRule: rule70
}, {
  start: 610,
  length: 1,
  convRule: rule20
}, {
  start: 611,
  length: 1,
  convRule: rule71
}, {
  start: 612,
  length: 1,
  convRule: rule20
}, {
  start: 613,
  length: 1,
  convRule: rule72
}, {
  start: 614,
  length: 1,
  convRule: rule73
}, {
  start: 615,
  length: 1,
  convRule: rule20
}, {
  start: 616,
  length: 1,
  convRule: rule74
}, {
  start: 617,
  length: 1,
  convRule: rule75
}, {
  start: 618,
  length: 1,
  convRule: rule73
}, {
  start: 619,
  length: 1,
  convRule: rule76
}, {
  start: 620,
  length: 1,
  convRule: rule77
}, {
  start: 621,
  length: 2,
  convRule: rule20
}, {
  start: 623,
  length: 1,
  convRule: rule75
}, {
  start: 624,
  length: 1,
  convRule: rule20
}, {
  start: 625,
  length: 1,
  convRule: rule78
}, {
  start: 626,
  length: 1,
  convRule: rule79
}, {
  start: 627,
  length: 2,
  convRule: rule20
}, {
  start: 629,
  length: 1,
  convRule: rule80
}, {
  start: 630,
  length: 7,
  convRule: rule20
}, {
  start: 637,
  length: 1,
  convRule: rule81
}, {
  start: 638,
  length: 2,
  convRule: rule20
}, {
  start: 640,
  length: 1,
  convRule: rule82
}, {
  start: 641,
  length: 1,
  convRule: rule20
}, {
  start: 642,
  length: 1,
  convRule: rule83
}, {
  start: 643,
  length: 1,
  convRule: rule82
}, {
  start: 644,
  length: 3,
  convRule: rule20
}, {
  start: 647,
  length: 1,
  convRule: rule84
}, {
  start: 648,
  length: 1,
  convRule: rule82
}, {
  start: 649,
  length: 1,
  convRule: rule85
}, {
  start: 650,
  length: 2,
  convRule: rule86
}, {
  start: 652,
  length: 1,
  convRule: rule87
}, {
  start: 653,
  length: 5,
  convRule: rule20
}, {
  start: 658,
  length: 1,
  convRule: rule88
}, {
  start: 659,
  length: 1,
  convRule: rule20
}, {
  start: 660,
  length: 1,
  convRule: rule14
}, {
  start: 661,
  length: 8,
  convRule: rule20
}, {
  start: 669,
  length: 1,
  convRule: rule89
}, {
  start: 670,
  length: 1,
  convRule: rule90
}, {
  start: 671,
  length: 17,
  convRule: rule20
}, {
  start: 688,
  length: 18,
  convRule: rule91
}, {
  start: 706,
  length: 4,
  convRule: rule10
}, {
  start: 710,
  length: 12,
  convRule: rule91
}, {
  start: 722,
  length: 14,
  convRule: rule10
}, {
  start: 736,
  length: 5,
  convRule: rule91
}, {
  start: 741,
  length: 7,
  convRule: rule10
}, {
  start: 748,
  length: 1,
  convRule: rule91
}, {
  start: 749,
  length: 1,
  convRule: rule10
}, {
  start: 750,
  length: 1,
  convRule: rule91
}, {
  start: 751,
  length: 17,
  convRule: rule10
}, {
  start: 768,
  length: 69,
  convRule: rule92
}, {
  start: 837,
  length: 1,
  convRule: rule93
}, {
  start: 838,
  length: 42,
  convRule: rule92
}, {
  start: 880,
  length: 1,
  convRule: rule22
}, {
  start: 881,
  length: 1,
  convRule: rule23
}, {
  start: 882,
  length: 1,
  convRule: rule22
}, {
  start: 883,
  length: 1,
  convRule: rule23
}, {
  start: 884,
  length: 1,
  convRule: rule91
}, {
  start: 885,
  length: 1,
  convRule: rule10
}, {
  start: 886,
  length: 1,
  convRule: rule22
}, {
  start: 887,
  length: 1,
  convRule: rule23
}, {
  start: 890,
  length: 1,
  convRule: rule91
}, {
  start: 891,
  length: 3,
  convRule: rule41
}, {
  start: 894,
  length: 1,
  convRule: rule2
}, {
  start: 895,
  length: 1,
  convRule: rule94
}, {
  start: 900,
  length: 2,
  convRule: rule10
}, {
  start: 902,
  length: 1,
  convRule: rule95
}, {
  start: 903,
  length: 1,
  convRule: rule2
}, {
  start: 904,
  length: 3,
  convRule: rule96
}, {
  start: 908,
  length: 1,
  convRule: rule97
}, {
  start: 910,
  length: 2,
  convRule: rule98
}, {
  start: 912,
  length: 1,
  convRule: rule20
}, {
  start: 913,
  length: 17,
  convRule: rule9
}, {
  start: 931,
  length: 9,
  convRule: rule9
}, {
  start: 940,
  length: 1,
  convRule: rule99
}, {
  start: 941,
  length: 3,
  convRule: rule100
}, {
  start: 944,
  length: 1,
  convRule: rule20
}, {
  start: 945,
  length: 17,
  convRule: rule12
}, {
  start: 962,
  length: 1,
  convRule: rule101
}, {
  start: 963,
  length: 9,
  convRule: rule12
}, {
  start: 972,
  length: 1,
  convRule: rule102
}, {
  start: 973,
  length: 2,
  convRule: rule103
}, {
  start: 975,
  length: 1,
  convRule: rule104
}, {
  start: 976,
  length: 1,
  convRule: rule105
}, {
  start: 977,
  length: 1,
  convRule: rule106
}, {
  start: 978,
  length: 3,
  convRule: rule107
}, {
  start: 981,
  length: 1,
  convRule: rule108
}, {
  start: 982,
  length: 1,
  convRule: rule109
}, {
  start: 983,
  length: 1,
  convRule: rule110
}, {
  start: 984,
  length: 1,
  convRule: rule22
}, {
  start: 985,
  length: 1,
  convRule: rule23
}, {
  start: 986,
  length: 1,
  convRule: rule22
}, {
  start: 987,
  length: 1,
  convRule: rule23
}, {
  start: 988,
  length: 1,
  convRule: rule22
}, {
  start: 989,
  length: 1,
  convRule: rule23
}, {
  start: 990,
  length: 1,
  convRule: rule22
}, {
  start: 991,
  length: 1,
  convRule: rule23
}, {
  start: 992,
  length: 1,
  convRule: rule22
}, {
  start: 993,
  length: 1,
  convRule: rule23
}, {
  start: 994,
  length: 1,
  convRule: rule22
}, {
  start: 995,
  length: 1,
  convRule: rule23
}, {
  start: 996,
  length: 1,
  convRule: rule22
}, {
  start: 997,
  length: 1,
  convRule: rule23
}, {
  start: 998,
  length: 1,
  convRule: rule22
}, {
  start: 999,
  length: 1,
  convRule: rule23
}, {
  start: 1e3,
  length: 1,
  convRule: rule22
}, {
  start: 1001,
  length: 1,
  convRule: rule23
}, {
  start: 1002,
  length: 1,
  convRule: rule22
}, {
  start: 1003,
  length: 1,
  convRule: rule23
}, {
  start: 1004,
  length: 1,
  convRule: rule22
}, {
  start: 1005,
  length: 1,
  convRule: rule23
}, {
  start: 1006,
  length: 1,
  convRule: rule22
}, {
  start: 1007,
  length: 1,
  convRule: rule23
}, {
  start: 1008,
  length: 1,
  convRule: rule111
}, {
  start: 1009,
  length: 1,
  convRule: rule112
}, {
  start: 1010,
  length: 1,
  convRule: rule113
}, {
  start: 1011,
  length: 1,
  convRule: rule114
}, {
  start: 1012,
  length: 1,
  convRule: rule115
}, {
  start: 1013,
  length: 1,
  convRule: rule116
}, {
  start: 1014,
  length: 1,
  convRule: rule6
}, {
  start: 1015,
  length: 1,
  convRule: rule22
}, {
  start: 1016,
  length: 1,
  convRule: rule23
}, {
  start: 1017,
  length: 1,
  convRule: rule117
}, {
  start: 1018,
  length: 1,
  convRule: rule22
}, {
  start: 1019,
  length: 1,
  convRule: rule23
}, {
  start: 1020,
  length: 1,
  convRule: rule20
}, {
  start: 1021,
  length: 3,
  convRule: rule53
}, {
  start: 1024,
  length: 16,
  convRule: rule118
}, {
  start: 1040,
  length: 32,
  convRule: rule9
}, {
  start: 1072,
  length: 32,
  convRule: rule12
}, {
  start: 1104,
  length: 16,
  convRule: rule112
}, {
  start: 1120,
  length: 1,
  convRule: rule22
}, {
  start: 1121,
  length: 1,
  convRule: rule23
}, {
  start: 1122,
  length: 1,
  convRule: rule22
}, {
  start: 1123,
  length: 1,
  convRule: rule23
}, {
  start: 1124,
  length: 1,
  convRule: rule22
}, {
  start: 1125,
  length: 1,
  convRule: rule23
}, {
  start: 1126,
  length: 1,
  convRule: rule22
}, {
  start: 1127,
  length: 1,
  convRule: rule23
}, {
  start: 1128,
  length: 1,
  convRule: rule22
}, {
  start: 1129,
  length: 1,
  convRule: rule23
}, {
  start: 1130,
  length: 1,
  convRule: rule22
}, {
  start: 1131,
  length: 1,
  convRule: rule23
}, {
  start: 1132,
  length: 1,
  convRule: rule22
}, {
  start: 1133,
  length: 1,
  convRule: rule23
}, {
  start: 1134,
  length: 1,
  convRule: rule22
}, {
  start: 1135,
  length: 1,
  convRule: rule23
}, {
  start: 1136,
  length: 1,
  convRule: rule22
}, {
  start: 1137,
  length: 1,
  convRule: rule23
}, {
  start: 1138,
  length: 1,
  convRule: rule22
}, {
  start: 1139,
  length: 1,
  convRule: rule23
}, {
  start: 1140,
  length: 1,
  convRule: rule22
}, {
  start: 1141,
  length: 1,
  convRule: rule23
}, {
  start: 1142,
  length: 1,
  convRule: rule22
}, {
  start: 1143,
  length: 1,
  convRule: rule23
}, {
  start: 1144,
  length: 1,
  convRule: rule22
}, {
  start: 1145,
  length: 1,
  convRule: rule23
}, {
  start: 1146,
  length: 1,
  convRule: rule22
}, {
  start: 1147,
  length: 1,
  convRule: rule23
}, {
  start: 1148,
  length: 1,
  convRule: rule22
}, {
  start: 1149,
  length: 1,
  convRule: rule23
}, {
  start: 1150,
  length: 1,
  convRule: rule22
}, {
  start: 1151,
  length: 1,
  convRule: rule23
}, {
  start: 1152,
  length: 1,
  convRule: rule22
}, {
  start: 1153,
  length: 1,
  convRule: rule23
}, {
  start: 1154,
  length: 1,
  convRule: rule13
}, {
  start: 1155,
  length: 5,
  convRule: rule92
}, {
  start: 1160,
  length: 2,
  convRule: rule119
}, {
  start: 1162,
  length: 1,
  convRule: rule22
}, {
  start: 1163,
  length: 1,
  convRule: rule23
}, {
  start: 1164,
  length: 1,
  convRule: rule22
}, {
  start: 1165,
  length: 1,
  convRule: rule23
}, {
  start: 1166,
  length: 1,
  convRule: rule22
}, {
  start: 1167,
  length: 1,
  convRule: rule23
}, {
  start: 1168,
  length: 1,
  convRule: rule22
}, {
  start: 1169,
  length: 1,
  convRule: rule23
}, {
  start: 1170,
  length: 1,
  convRule: rule22
}, {
  start: 1171,
  length: 1,
  convRule: rule23
}, {
  start: 1172,
  length: 1,
  convRule: rule22
}, {
  start: 1173,
  length: 1,
  convRule: rule23
}, {
  start: 1174,
  length: 1,
  convRule: rule22
}, {
  start: 1175,
  length: 1,
  convRule: rule23
}, {
  start: 1176,
  length: 1,
  convRule: rule22
}, {
  start: 1177,
  length: 1,
  convRule: rule23
}, {
  start: 1178,
  length: 1,
  convRule: rule22
}, {
  start: 1179,
  length: 1,
  convRule: rule23
}, {
  start: 1180,
  length: 1,
  convRule: rule22
}, {
  start: 1181,
  length: 1,
  convRule: rule23
}, {
  start: 1182,
  length: 1,
  convRule: rule22
}, {
  start: 1183,
  length: 1,
  convRule: rule23
}, {
  start: 1184,
  length: 1,
  convRule: rule22
}, {
  start: 1185,
  length: 1,
  convRule: rule23
}, {
  start: 1186,
  length: 1,
  convRule: rule22
}, {
  start: 1187,
  length: 1,
  convRule: rule23
}, {
  start: 1188,
  length: 1,
  convRule: rule22
}, {
  start: 1189,
  length: 1,
  convRule: rule23
}, {
  start: 1190,
  length: 1,
  convRule: rule22
}, {
  start: 1191,
  length: 1,
  convRule: rule23
}, {
  start: 1192,
  length: 1,
  convRule: rule22
}, {
  start: 1193,
  length: 1,
  convRule: rule23
}, {
  start: 1194,
  length: 1,
  convRule: rule22
}, {
  start: 1195,
  length: 1,
  convRule: rule23
}, {
  start: 1196,
  length: 1,
  convRule: rule22
}, {
  start: 1197,
  length: 1,
  convRule: rule23
}, {
  start: 1198,
  length: 1,
  convRule: rule22
}, {
  start: 1199,
  length: 1,
  convRule: rule23
}, {
  start: 1200,
  length: 1,
  convRule: rule22
}, {
  start: 1201,
  length: 1,
  convRule: rule23
}, {
  start: 1202,
  length: 1,
  convRule: rule22
}, {
  start: 1203,
  length: 1,
  convRule: rule23
}, {
  start: 1204,
  length: 1,
  convRule: rule22
}, {
  start: 1205,
  length: 1,
  convRule: rule23
}, {
  start: 1206,
  length: 1,
  convRule: rule22
}, {
  start: 1207,
  length: 1,
  convRule: rule23
}, {
  start: 1208,
  length: 1,
  convRule: rule22
}, {
  start: 1209,
  length: 1,
  convRule: rule23
}, {
  start: 1210,
  length: 1,
  convRule: rule22
}, {
  start: 1211,
  length: 1,
  convRule: rule23
}, {
  start: 1212,
  length: 1,
  convRule: rule22
}, {
  start: 1213,
  length: 1,
  convRule: rule23
}, {
  start: 1214,
  length: 1,
  convRule: rule22
}, {
  start: 1215,
  length: 1,
  convRule: rule23
}, {
  start: 1216,
  length: 1,
  convRule: rule120
}, {
  start: 1217,
  length: 1,
  convRule: rule22
}, {
  start: 1218,
  length: 1,
  convRule: rule23
}, {
  start: 1219,
  length: 1,
  convRule: rule22
}, {
  start: 1220,
  length: 1,
  convRule: rule23
}, {
  start: 1221,
  length: 1,
  convRule: rule22
}, {
  start: 1222,
  length: 1,
  convRule: rule23
}, {
  start: 1223,
  length: 1,
  convRule: rule22
}, {
  start: 1224,
  length: 1,
  convRule: rule23
}, {
  start: 1225,
  length: 1,
  convRule: rule22
}, {
  start: 1226,
  length: 1,
  convRule: rule23
}, {
  start: 1227,
  length: 1,
  convRule: rule22
}, {
  start: 1228,
  length: 1,
  convRule: rule23
}, {
  start: 1229,
  length: 1,
  convRule: rule22
}, {
  start: 1230,
  length: 1,
  convRule: rule23
}, {
  start: 1231,
  length: 1,
  convRule: rule121
}, {
  start: 1232,
  length: 1,
  convRule: rule22
}, {
  start: 1233,
  length: 1,
  convRule: rule23
}, {
  start: 1234,
  length: 1,
  convRule: rule22
}, {
  start: 1235,
  length: 1,
  convRule: rule23
}, {
  start: 1236,
  length: 1,
  convRule: rule22
}, {
  start: 1237,
  length: 1,
  convRule: rule23
}, {
  start: 1238,
  length: 1,
  convRule: rule22
}, {
  start: 1239,
  length: 1,
  convRule: rule23
}, {
  start: 1240,
  length: 1,
  convRule: rule22
}, {
  start: 1241,
  length: 1,
  convRule: rule23
}, {
  start: 1242,
  length: 1,
  convRule: rule22
}, {
  start: 1243,
  length: 1,
  convRule: rule23
}, {
  start: 1244,
  length: 1,
  convRule: rule22
}, {
  start: 1245,
  length: 1,
  convRule: rule23
}, {
  start: 1246,
  length: 1,
  convRule: rule22
}, {
  start: 1247,
  length: 1,
  convRule: rule23
}, {
  start: 1248,
  length: 1,
  convRule: rule22
}, {
  start: 1249,
  length: 1,
  convRule: rule23
}, {
  start: 1250,
  length: 1,
  convRule: rule22
}, {
  start: 1251,
  length: 1,
  convRule: rule23
}, {
  start: 1252,
  length: 1,
  convRule: rule22
}, {
  start: 1253,
  length: 1,
  convRule: rule23
}, {
  start: 1254,
  length: 1,
  convRule: rule22
}, {
  start: 1255,
  length: 1,
  convRule: rule23
}, {
  start: 1256,
  length: 1,
  convRule: rule22
}, {
  start: 1257,
  length: 1,
  convRule: rule23
}, {
  start: 1258,
  length: 1,
  convRule: rule22
}, {
  start: 1259,
  length: 1,
  convRule: rule23
}, {
  start: 1260,
  length: 1,
  convRule: rule22
}, {
  start: 1261,
  length: 1,
  convRule: rule23
}, {
  start: 1262,
  length: 1,
  convRule: rule22
}, {
  start: 1263,
  length: 1,
  convRule: rule23
}, {
  start: 1264,
  length: 1,
  convRule: rule22
}, {
  start: 1265,
  length: 1,
  convRule: rule23
}, {
  start: 1266,
  length: 1,
  convRule: rule22
}, {
  start: 1267,
  length: 1,
  convRule: rule23
}, {
  start: 1268,
  length: 1,
  convRule: rule22
}, {
  start: 1269,
  length: 1,
  convRule: rule23
}, {
  start: 1270,
  length: 1,
  convRule: rule22
}, {
  start: 1271,
  length: 1,
  convRule: rule23
}, {
  start: 1272,
  length: 1,
  convRule: rule22
}, {
  start: 1273,
  length: 1,
  convRule: rule23
}, {
  start: 1274,
  length: 1,
  convRule: rule22
}, {
  start: 1275,
  length: 1,
  convRule: rule23
}, {
  start: 1276,
  length: 1,
  convRule: rule22
}, {
  start: 1277,
  length: 1,
  convRule: rule23
}, {
  start: 1278,
  length: 1,
  convRule: rule22
}, {
  start: 1279,
  length: 1,
  convRule: rule23
}, {
  start: 1280,
  length: 1,
  convRule: rule22
}, {
  start: 1281,
  length: 1,
  convRule: rule23
}, {
  start: 1282,
  length: 1,
  convRule: rule22
}, {
  start: 1283,
  length: 1,
  convRule: rule23
}, {
  start: 1284,
  length: 1,
  convRule: rule22
}, {
  start: 1285,
  length: 1,
  convRule: rule23
}, {
  start: 1286,
  length: 1,
  convRule: rule22
}, {
  start: 1287,
  length: 1,
  convRule: rule23
}, {
  start: 1288,
  length: 1,
  convRule: rule22
}, {
  start: 1289,
  length: 1,
  convRule: rule23
}, {
  start: 1290,
  length: 1,
  convRule: rule22
}, {
  start: 1291,
  length: 1,
  convRule: rule23
}, {
  start: 1292,
  length: 1,
  convRule: rule22
}, {
  start: 1293,
  length: 1,
  convRule: rule23
}, {
  start: 1294,
  length: 1,
  convRule: rule22
}, {
  start: 1295,
  length: 1,
  convRule: rule23
}, {
  start: 1296,
  length: 1,
  convRule: rule22
}, {
  start: 1297,
  length: 1,
  convRule: rule23
}, {
  start: 1298,
  length: 1,
  convRule: rule22
}, {
  start: 1299,
  length: 1,
  convRule: rule23
}, {
  start: 1300,
  length: 1,
  convRule: rule22
}, {
  start: 1301,
  length: 1,
  convRule: rule23
}, {
  start: 1302,
  length: 1,
  convRule: rule22
}, {
  start: 1303,
  length: 1,
  convRule: rule23
}, {
  start: 1304,
  length: 1,
  convRule: rule22
}, {
  start: 1305,
  length: 1,
  convRule: rule23
}, {
  start: 1306,
  length: 1,
  convRule: rule22
}, {
  start: 1307,
  length: 1,
  convRule: rule23
}, {
  start: 1308,
  length: 1,
  convRule: rule22
}, {
  start: 1309,
  length: 1,
  convRule: rule23
}, {
  start: 1310,
  length: 1,
  convRule: rule22
}, {
  start: 1311,
  length: 1,
  convRule: rule23
}, {
  start: 1312,
  length: 1,
  convRule: rule22
}, {
  start: 1313,
  length: 1,
  convRule: rule23
}, {
  start: 1314,
  length: 1,
  convRule: rule22
}, {
  start: 1315,
  length: 1,
  convRule: rule23
}, {
  start: 1316,
  length: 1,
  convRule: rule22
}, {
  start: 1317,
  length: 1,
  convRule: rule23
}, {
  start: 1318,
  length: 1,
  convRule: rule22
}, {
  start: 1319,
  length: 1,
  convRule: rule23
}, {
  start: 1320,
  length: 1,
  convRule: rule22
}, {
  start: 1321,
  length: 1,
  convRule: rule23
}, {
  start: 1322,
  length: 1,
  convRule: rule22
}, {
  start: 1323,
  length: 1,
  convRule: rule23
}, {
  start: 1324,
  length: 1,
  convRule: rule22
}, {
  start: 1325,
  length: 1,
  convRule: rule23
}, {
  start: 1326,
  length: 1,
  convRule: rule22
}, {
  start: 1327,
  length: 1,
  convRule: rule23
}, {
  start: 1329,
  length: 38,
  convRule: rule122
}, {
  start: 1369,
  length: 1,
  convRule: rule91
}, {
  start: 1370,
  length: 6,
  convRule: rule2
}, {
  start: 1376,
  length: 1,
  convRule: rule20
}, {
  start: 1377,
  length: 38,
  convRule: rule123
}, {
  start: 1415,
  length: 2,
  convRule: rule20
}, {
  start: 1417,
  length: 1,
  convRule: rule2
}, {
  start: 1418,
  length: 1,
  convRule: rule7
}, {
  start: 1421,
  length: 2,
  convRule: rule13
}, {
  start: 1423,
  length: 1,
  convRule: rule3
}, {
  start: 1425,
  length: 45,
  convRule: rule92
}, {
  start: 1470,
  length: 1,
  convRule: rule7
}, {
  start: 1471,
  length: 1,
  convRule: rule92
}, {
  start: 1472,
  length: 1,
  convRule: rule2
}, {
  start: 1473,
  length: 2,
  convRule: rule92
}, {
  start: 1475,
  length: 1,
  convRule: rule2
}, {
  start: 1476,
  length: 2,
  convRule: rule92
}, {
  start: 1478,
  length: 1,
  convRule: rule2
}, {
  start: 1479,
  length: 1,
  convRule: rule92
}, {
  start: 1488,
  length: 27,
  convRule: rule14
}, {
  start: 1519,
  length: 4,
  convRule: rule14
}, {
  start: 1523,
  length: 2,
  convRule: rule2
}, {
  start: 1536,
  length: 6,
  convRule: rule16
}, {
  start: 1542,
  length: 3,
  convRule: rule6
}, {
  start: 1545,
  length: 2,
  convRule: rule2
}, {
  start: 1547,
  length: 1,
  convRule: rule3
}, {
  start: 1548,
  length: 2,
  convRule: rule2
}, {
  start: 1550,
  length: 2,
  convRule: rule13
}, {
  start: 1552,
  length: 11,
  convRule: rule92
}, {
  start: 1563,
  length: 1,
  convRule: rule2
}, {
  start: 1564,
  length: 1,
  convRule: rule16
}, {
  start: 1566,
  length: 2,
  convRule: rule2
}, {
  start: 1568,
  length: 32,
  convRule: rule14
}, {
  start: 1600,
  length: 1,
  convRule: rule91
}, {
  start: 1601,
  length: 10,
  convRule: rule14
}, {
  start: 1611,
  length: 21,
  convRule: rule92
}, {
  start: 1632,
  length: 10,
  convRule: rule8
}, {
  start: 1642,
  length: 4,
  convRule: rule2
}, {
  start: 1646,
  length: 2,
  convRule: rule14
}, {
  start: 1648,
  length: 1,
  convRule: rule92
}, {
  start: 1649,
  length: 99,
  convRule: rule14
}, {
  start: 1748,
  length: 1,
  convRule: rule2
}, {
  start: 1749,
  length: 1,
  convRule: rule14
}, {
  start: 1750,
  length: 7,
  convRule: rule92
}, {
  start: 1757,
  length: 1,
  convRule: rule16
}, {
  start: 1758,
  length: 1,
  convRule: rule13
}, {
  start: 1759,
  length: 6,
  convRule: rule92
}, {
  start: 1765,
  length: 2,
  convRule: rule91
}, {
  start: 1767,
  length: 2,
  convRule: rule92
}, {
  start: 1769,
  length: 1,
  convRule: rule13
}, {
  start: 1770,
  length: 4,
  convRule: rule92
}, {
  start: 1774,
  length: 2,
  convRule: rule14
}, {
  start: 1776,
  length: 10,
  convRule: rule8
}, {
  start: 1786,
  length: 3,
  convRule: rule14
}, {
  start: 1789,
  length: 2,
  convRule: rule13
}, {
  start: 1791,
  length: 1,
  convRule: rule14
}, {
  start: 1792,
  length: 14,
  convRule: rule2
}, {
  start: 1807,
  length: 1,
  convRule: rule16
}, {
  start: 1808,
  length: 1,
  convRule: rule14
}, {
  start: 1809,
  length: 1,
  convRule: rule92
}, {
  start: 1810,
  length: 30,
  convRule: rule14
}, {
  start: 1840,
  length: 27,
  convRule: rule92
}, {
  start: 1869,
  length: 89,
  convRule: rule14
}, {
  start: 1958,
  length: 11,
  convRule: rule92
}, {
  start: 1969,
  length: 1,
  convRule: rule14
}, {
  start: 1984,
  length: 10,
  convRule: rule8
}, {
  start: 1994,
  length: 33,
  convRule: rule14
}, {
  start: 2027,
  length: 9,
  convRule: rule92
}, {
  start: 2036,
  length: 2,
  convRule: rule91
}, {
  start: 2038,
  length: 1,
  convRule: rule13
}, {
  start: 2039,
  length: 3,
  convRule: rule2
}, {
  start: 2042,
  length: 1,
  convRule: rule91
}, {
  start: 2045,
  length: 1,
  convRule: rule92
}, {
  start: 2046,
  length: 2,
  convRule: rule3
}, {
  start: 2048,
  length: 22,
  convRule: rule14
}, {
  start: 2070,
  length: 4,
  convRule: rule92
}, {
  start: 2074,
  length: 1,
  convRule: rule91
}, {
  start: 2075,
  length: 9,
  convRule: rule92
}, {
  start: 2084,
  length: 1,
  convRule: rule91
}, {
  start: 2085,
  length: 3,
  convRule: rule92
}, {
  start: 2088,
  length: 1,
  convRule: rule91
}, {
  start: 2089,
  length: 5,
  convRule: rule92
}, {
  start: 2096,
  length: 15,
  convRule: rule2
}, {
  start: 2112,
  length: 25,
  convRule: rule14
}, {
  start: 2137,
  length: 3,
  convRule: rule92
}, {
  start: 2142,
  length: 1,
  convRule: rule2
}, {
  start: 2144,
  length: 11,
  convRule: rule14
}, {
  start: 2208,
  length: 21,
  convRule: rule14
}, {
  start: 2230,
  length: 18,
  convRule: rule14
}, {
  start: 2259,
  length: 15,
  convRule: rule92
}, {
  start: 2274,
  length: 1,
  convRule: rule16
}, {
  start: 2275,
  length: 32,
  convRule: rule92
}, {
  start: 2307,
  length: 1,
  convRule: rule124
}, {
  start: 2308,
  length: 54,
  convRule: rule14
}, {
  start: 2362,
  length: 1,
  convRule: rule92
}, {
  start: 2363,
  length: 1,
  convRule: rule124
}, {
  start: 2364,
  length: 1,
  convRule: rule92
}, {
  start: 2365,
  length: 1,
  convRule: rule14
}, {
  start: 2366,
  length: 3,
  convRule: rule124
}, {
  start: 2369,
  length: 8,
  convRule: rule92
}, {
  start: 2377,
  length: 4,
  convRule: rule124
}, {
  start: 2381,
  length: 1,
  convRule: rule92
}, {
  start: 2382,
  length: 2,
  convRule: rule124
}, {
  start: 2384,
  length: 1,
  convRule: rule14
}, {
  start: 2385,
  length: 7,
  convRule: rule92
}, {
  start: 2392,
  length: 10,
  convRule: rule14
}, {
  start: 2402,
  length: 2,
  convRule: rule92
}, {
  start: 2404,
  length: 2,
  convRule: rule2
}, {
  start: 2406,
  length: 10,
  convRule: rule8
}, {
  start: 2416,
  length: 1,
  convRule: rule2
}, {
  start: 2417,
  length: 1,
  convRule: rule91
}, {
  start: 2418,
  length: 15,
  convRule: rule14
}, {
  start: 2433,
  length: 1,
  convRule: rule92
}, {
  start: 2434,
  length: 2,
  convRule: rule124
}, {
  start: 2437,
  length: 8,
  convRule: rule14
}, {
  start: 2447,
  length: 2,
  convRule: rule14
}, {
  start: 2451,
  length: 22,
  convRule: rule14
}, {
  start: 2474,
  length: 7,
  convRule: rule14
}, {
  start: 2482,
  length: 1,
  convRule: rule14
}, {
  start: 2486,
  length: 4,
  convRule: rule14
}, {
  start: 2492,
  length: 1,
  convRule: rule92
}, {
  start: 2493,
  length: 1,
  convRule: rule14
}, {
  start: 2494,
  length: 3,
  convRule: rule124
}, {
  start: 2497,
  length: 4,
  convRule: rule92
}, {
  start: 2503,
  length: 2,
  convRule: rule124
}, {
  start: 2507,
  length: 2,
  convRule: rule124
}, {
  start: 2509,
  length: 1,
  convRule: rule92
}, {
  start: 2510,
  length: 1,
  convRule: rule14
}, {
  start: 2519,
  length: 1,
  convRule: rule124
}, {
  start: 2524,
  length: 2,
  convRule: rule14
}, {
  start: 2527,
  length: 3,
  convRule: rule14
}, {
  start: 2530,
  length: 2,
  convRule: rule92
}, {
  start: 2534,
  length: 10,
  convRule: rule8
}, {
  start: 2544,
  length: 2,
  convRule: rule14
}, {
  start: 2546,
  length: 2,
  convRule: rule3
}, {
  start: 2548,
  length: 6,
  convRule: rule17
}, {
  start: 2554,
  length: 1,
  convRule: rule13
}, {
  start: 2555,
  length: 1,
  convRule: rule3
}, {
  start: 2556,
  length: 1,
  convRule: rule14
}, {
  start: 2557,
  length: 1,
  convRule: rule2
}, {
  start: 2558,
  length: 1,
  convRule: rule92
}, {
  start: 2561,
  length: 2,
  convRule: rule92
}, {
  start: 2563,
  length: 1,
  convRule: rule124
}, {
  start: 2565,
  length: 6,
  convRule: rule14
}, {
  start: 2575,
  length: 2,
  convRule: rule14
}, {
  start: 2579,
  length: 22,
  convRule: rule14
}, {
  start: 2602,
  length: 7,
  convRule: rule14
}, {
  start: 2610,
  length: 2,
  convRule: rule14
}, {
  start: 2613,
  length: 2,
  convRule: rule14
}, {
  start: 2616,
  length: 2,
  convRule: rule14
}, {
  start: 2620,
  length: 1,
  convRule: rule92
}, {
  start: 2622,
  length: 3,
  convRule: rule124
}, {
  start: 2625,
  length: 2,
  convRule: rule92
}, {
  start: 2631,
  length: 2,
  convRule: rule92
}, {
  start: 2635,
  length: 3,
  convRule: rule92
}, {
  start: 2641,
  length: 1,
  convRule: rule92
}, {
  start: 2649,
  length: 4,
  convRule: rule14
}, {
  start: 2654,
  length: 1,
  convRule: rule14
}, {
  start: 2662,
  length: 10,
  convRule: rule8
}, {
  start: 2672,
  length: 2,
  convRule: rule92
}, {
  start: 2674,
  length: 3,
  convRule: rule14
}, {
  start: 2677,
  length: 1,
  convRule: rule92
}, {
  start: 2678,
  length: 1,
  convRule: rule2
}, {
  start: 2689,
  length: 2,
  convRule: rule92
}, {
  start: 2691,
  length: 1,
  convRule: rule124
}, {
  start: 2693,
  length: 9,
  convRule: rule14
}, {
  start: 2703,
  length: 3,
  convRule: rule14
}, {
  start: 2707,
  length: 22,
  convRule: rule14
}, {
  start: 2730,
  length: 7,
  convRule: rule14
}, {
  start: 2738,
  length: 2,
  convRule: rule14
}, {
  start: 2741,
  length: 5,
  convRule: rule14
}, {
  start: 2748,
  length: 1,
  convRule: rule92
}, {
  start: 2749,
  length: 1,
  convRule: rule14
}, {
  start: 2750,
  length: 3,
  convRule: rule124
}, {
  start: 2753,
  length: 5,
  convRule: rule92
}, {
  start: 2759,
  length: 2,
  convRule: rule92
}, {
  start: 2761,
  length: 1,
  convRule: rule124
}, {
  start: 2763,
  length: 2,
  convRule: rule124
}, {
  start: 2765,
  length: 1,
  convRule: rule92
}, {
  start: 2768,
  length: 1,
  convRule: rule14
}, {
  start: 2784,
  length: 2,
  convRule: rule14
}, {
  start: 2786,
  length: 2,
  convRule: rule92
}, {
  start: 2790,
  length: 10,
  convRule: rule8
}, {
  start: 2800,
  length: 1,
  convRule: rule2
}, {
  start: 2801,
  length: 1,
  convRule: rule3
}, {
  start: 2809,
  length: 1,
  convRule: rule14
}, {
  start: 2810,
  length: 6,
  convRule: rule92
}, {
  start: 2817,
  length: 1,
  convRule: rule92
}, {
  start: 2818,
  length: 2,
  convRule: rule124
}, {
  start: 2821,
  length: 8,
  convRule: rule14
}, {
  start: 2831,
  length: 2,
  convRule: rule14
}, {
  start: 2835,
  length: 22,
  convRule: rule14
}, {
  start: 2858,
  length: 7,
  convRule: rule14
}, {
  start: 2866,
  length: 2,
  convRule: rule14
}, {
  start: 2869,
  length: 5,
  convRule: rule14
}, {
  start: 2876,
  length: 1,
  convRule: rule92
}, {
  start: 2877,
  length: 1,
  convRule: rule14
}, {
  start: 2878,
  length: 1,
  convRule: rule124
}, {
  start: 2879,
  length: 1,
  convRule: rule92
}, {
  start: 2880,
  length: 1,
  convRule: rule124
}, {
  start: 2881,
  length: 4,
  convRule: rule92
}, {
  start: 2887,
  length: 2,
  convRule: rule124
}, {
  start: 2891,
  length: 2,
  convRule: rule124
}, {
  start: 2893,
  length: 1,
  convRule: rule92
}, {
  start: 2901,
  length: 2,
  convRule: rule92
}, {
  start: 2903,
  length: 1,
  convRule: rule124
}, {
  start: 2908,
  length: 2,
  convRule: rule14
}, {
  start: 2911,
  length: 3,
  convRule: rule14
}, {
  start: 2914,
  length: 2,
  convRule: rule92
}, {
  start: 2918,
  length: 10,
  convRule: rule8
}, {
  start: 2928,
  length: 1,
  convRule: rule13
}, {
  start: 2929,
  length: 1,
  convRule: rule14
}, {
  start: 2930,
  length: 6,
  convRule: rule17
}, {
  start: 2946,
  length: 1,
  convRule: rule92
}, {
  start: 2947,
  length: 1,
  convRule: rule14
}, {
  start: 2949,
  length: 6,
  convRule: rule14
}, {
  start: 2958,
  length: 3,
  convRule: rule14
}, {
  start: 2962,
  length: 4,
  convRule: rule14
}, {
  start: 2969,
  length: 2,
  convRule: rule14
}, {
  start: 2972,
  length: 1,
  convRule: rule14
}, {
  start: 2974,
  length: 2,
  convRule: rule14
}, {
  start: 2979,
  length: 2,
  convRule: rule14
}, {
  start: 2984,
  length: 3,
  convRule: rule14
}, {
  start: 2990,
  length: 12,
  convRule: rule14
}, {
  start: 3006,
  length: 2,
  convRule: rule124
}, {
  start: 3008,
  length: 1,
  convRule: rule92
}, {
  start: 3009,
  length: 2,
  convRule: rule124
}, {
  start: 3014,
  length: 3,
  convRule: rule124
}, {
  start: 3018,
  length: 3,
  convRule: rule124
}, {
  start: 3021,
  length: 1,
  convRule: rule92
}, {
  start: 3024,
  length: 1,
  convRule: rule14
}, {
  start: 3031,
  length: 1,
  convRule: rule124
}, {
  start: 3046,
  length: 10,
  convRule: rule8
}, {
  start: 3056,
  length: 3,
  convRule: rule17
}, {
  start: 3059,
  length: 6,
  convRule: rule13
}, {
  start: 3065,
  length: 1,
  convRule: rule3
}, {
  start: 3066,
  length: 1,
  convRule: rule13
}, {
  start: 3072,
  length: 1,
  convRule: rule92
}, {
  start: 3073,
  length: 3,
  convRule: rule124
}, {
  start: 3076,
  length: 1,
  convRule: rule92
}, {
  start: 3077,
  length: 8,
  convRule: rule14
}, {
  start: 3086,
  length: 3,
  convRule: rule14
}, {
  start: 3090,
  length: 23,
  convRule: rule14
}, {
  start: 3114,
  length: 16,
  convRule: rule14
}, {
  start: 3133,
  length: 1,
  convRule: rule14
}, {
  start: 3134,
  length: 3,
  convRule: rule92
}, {
  start: 3137,
  length: 4,
  convRule: rule124
}, {
  start: 3142,
  length: 3,
  convRule: rule92
}, {
  start: 3146,
  length: 4,
  convRule: rule92
}, {
  start: 3157,
  length: 2,
  convRule: rule92
}, {
  start: 3160,
  length: 3,
  convRule: rule14
}, {
  start: 3168,
  length: 2,
  convRule: rule14
}, {
  start: 3170,
  length: 2,
  convRule: rule92
}, {
  start: 3174,
  length: 10,
  convRule: rule8
}, {
  start: 3191,
  length: 1,
  convRule: rule2
}, {
  start: 3192,
  length: 7,
  convRule: rule17
}, {
  start: 3199,
  length: 1,
  convRule: rule13
}, {
  start: 3200,
  length: 1,
  convRule: rule14
}, {
  start: 3201,
  length: 1,
  convRule: rule92
}, {
  start: 3202,
  length: 2,
  convRule: rule124
}, {
  start: 3204,
  length: 1,
  convRule: rule2
}, {
  start: 3205,
  length: 8,
  convRule: rule14
}, {
  start: 3214,
  length: 3,
  convRule: rule14
}, {
  start: 3218,
  length: 23,
  convRule: rule14
}, {
  start: 3242,
  length: 10,
  convRule: rule14
}, {
  start: 3253,
  length: 5,
  convRule: rule14
}, {
  start: 3260,
  length: 1,
  convRule: rule92
}, {
  start: 3261,
  length: 1,
  convRule: rule14
}, {
  start: 3262,
  length: 1,
  convRule: rule124
}, {
  start: 3263,
  length: 1,
  convRule: rule92
}, {
  start: 3264,
  length: 5,
  convRule: rule124
}, {
  start: 3270,
  length: 1,
  convRule: rule92
}, {
  start: 3271,
  length: 2,
  convRule: rule124
}, {
  start: 3274,
  length: 2,
  convRule: rule124
}, {
  start: 3276,
  length: 2,
  convRule: rule92
}, {
  start: 3285,
  length: 2,
  convRule: rule124
}, {
  start: 3294,
  length: 1,
  convRule: rule14
}, {
  start: 3296,
  length: 2,
  convRule: rule14
}, {
  start: 3298,
  length: 2,
  convRule: rule92
}, {
  start: 3302,
  length: 10,
  convRule: rule8
}, {
  start: 3313,
  length: 2,
  convRule: rule14
}, {
  start: 3328,
  length: 2,
  convRule: rule92
}, {
  start: 3330,
  length: 2,
  convRule: rule124
}, {
  start: 3332,
  length: 9,
  convRule: rule14
}, {
  start: 3342,
  length: 3,
  convRule: rule14
}, {
  start: 3346,
  length: 41,
  convRule: rule14
}, {
  start: 3387,
  length: 2,
  convRule: rule92
}, {
  start: 3389,
  length: 1,
  convRule: rule14
}, {
  start: 3390,
  length: 3,
  convRule: rule124
}, {
  start: 3393,
  length: 4,
  convRule: rule92
}, {
  start: 3398,
  length: 3,
  convRule: rule124
}, {
  start: 3402,
  length: 3,
  convRule: rule124
}, {
  start: 3405,
  length: 1,
  convRule: rule92
}, {
  start: 3406,
  length: 1,
  convRule: rule14
}, {
  start: 3407,
  length: 1,
  convRule: rule13
}, {
  start: 3412,
  length: 3,
  convRule: rule14
}, {
  start: 3415,
  length: 1,
  convRule: rule124
}, {
  start: 3416,
  length: 7,
  convRule: rule17
}, {
  start: 3423,
  length: 3,
  convRule: rule14
}, {
  start: 3426,
  length: 2,
  convRule: rule92
}, {
  start: 3430,
  length: 10,
  convRule: rule8
}, {
  start: 3440,
  length: 9,
  convRule: rule17
}, {
  start: 3449,
  length: 1,
  convRule: rule13
}, {
  start: 3450,
  length: 6,
  convRule: rule14
}, {
  start: 3457,
  length: 1,
  convRule: rule92
}, {
  start: 3458,
  length: 2,
  convRule: rule124
}, {
  start: 3461,
  length: 18,
  convRule: rule14
}, {
  start: 3482,
  length: 24,
  convRule: rule14
}, {
  start: 3507,
  length: 9,
  convRule: rule14
}, {
  start: 3517,
  length: 1,
  convRule: rule14
}, {
  start: 3520,
  length: 7,
  convRule: rule14
}, {
  start: 3530,
  length: 1,
  convRule: rule92
}, {
  start: 3535,
  length: 3,
  convRule: rule124
}, {
  start: 3538,
  length: 3,
  convRule: rule92
}, {
  start: 3542,
  length: 1,
  convRule: rule92
}, {
  start: 3544,
  length: 8,
  convRule: rule124
}, {
  start: 3558,
  length: 10,
  convRule: rule8
}, {
  start: 3570,
  length: 2,
  convRule: rule124
}, {
  start: 3572,
  length: 1,
  convRule: rule2
}, {
  start: 3585,
  length: 48,
  convRule: rule14
}, {
  start: 3633,
  length: 1,
  convRule: rule92
}, {
  start: 3634,
  length: 2,
  convRule: rule14
}, {
  start: 3636,
  length: 7,
  convRule: rule92
}, {
  start: 3647,
  length: 1,
  convRule: rule3
}, {
  start: 3648,
  length: 6,
  convRule: rule14
}, {
  start: 3654,
  length: 1,
  convRule: rule91
}, {
  start: 3655,
  length: 8,
  convRule: rule92
}, {
  start: 3663,
  length: 1,
  convRule: rule2
}, {
  start: 3664,
  length: 10,
  convRule: rule8
}, {
  start: 3674,
  length: 2,
  convRule: rule2
}, {
  start: 3713,
  length: 2,
  convRule: rule14
}, {
  start: 3716,
  length: 1,
  convRule: rule14
}, {
  start: 3718,
  length: 5,
  convRule: rule14
}, {
  start: 3724,
  length: 24,
  convRule: rule14
}, {
  start: 3749,
  length: 1,
  convRule: rule14
}, {
  start: 3751,
  length: 10,
  convRule: rule14
}, {
  start: 3761,
  length: 1,
  convRule: rule92
}, {
  start: 3762,
  length: 2,
  convRule: rule14
}, {
  start: 3764,
  length: 9,
  convRule: rule92
}, {
  start: 3773,
  length: 1,
  convRule: rule14
}, {
  start: 3776,
  length: 5,
  convRule: rule14
}, {
  start: 3782,
  length: 1,
  convRule: rule91
}, {
  start: 3784,
  length: 6,
  convRule: rule92
}, {
  start: 3792,
  length: 10,
  convRule: rule8
}, {
  start: 3804,
  length: 4,
  convRule: rule14
}, {
  start: 3840,
  length: 1,
  convRule: rule14
}, {
  start: 3841,
  length: 3,
  convRule: rule13
}, {
  start: 3844,
  length: 15,
  convRule: rule2
}, {
  start: 3859,
  length: 1,
  convRule: rule13
}, {
  start: 3860,
  length: 1,
  convRule: rule2
}, {
  start: 3861,
  length: 3,
  convRule: rule13
}, {
  start: 3864,
  length: 2,
  convRule: rule92
}, {
  start: 3866,
  length: 6,
  convRule: rule13
}, {
  start: 3872,
  length: 10,
  convRule: rule8
}, {
  start: 3882,
  length: 10,
  convRule: rule17
}, {
  start: 3892,
  length: 1,
  convRule: rule13
}, {
  start: 3893,
  length: 1,
  convRule: rule92
}, {
  start: 3894,
  length: 1,
  convRule: rule13
}, {
  start: 3895,
  length: 1,
  convRule: rule92
}, {
  start: 3896,
  length: 1,
  convRule: rule13
}, {
  start: 3897,
  length: 1,
  convRule: rule92
}, {
  start: 3898,
  length: 1,
  convRule: rule4
}, {
  start: 3899,
  length: 1,
  convRule: rule5
}, {
  start: 3900,
  length: 1,
  convRule: rule4
}, {
  start: 3901,
  length: 1,
  convRule: rule5
}, {
  start: 3902,
  length: 2,
  convRule: rule124
}, {
  start: 3904,
  length: 8,
  convRule: rule14
}, {
  start: 3913,
  length: 36,
  convRule: rule14
}, {
  start: 3953,
  length: 14,
  convRule: rule92
}, {
  start: 3967,
  length: 1,
  convRule: rule124
}, {
  start: 3968,
  length: 5,
  convRule: rule92
}, {
  start: 3973,
  length: 1,
  convRule: rule2
}, {
  start: 3974,
  length: 2,
  convRule: rule92
}, {
  start: 3976,
  length: 5,
  convRule: rule14
}, {
  start: 3981,
  length: 11,
  convRule: rule92
}, {
  start: 3993,
  length: 36,
  convRule: rule92
}, {
  start: 4030,
  length: 8,
  convRule: rule13
}, {
  start: 4038,
  length: 1,
  convRule: rule92
}, {
  start: 4039,
  length: 6,
  convRule: rule13
}, {
  start: 4046,
  length: 2,
  convRule: rule13
}, {
  start: 4048,
  length: 5,
  convRule: rule2
}, {
  start: 4053,
  length: 4,
  convRule: rule13
}, {
  start: 4057,
  length: 2,
  convRule: rule2
}, {
  start: 4096,
  length: 43,
  convRule: rule14
}, {
  start: 4139,
  length: 2,
  convRule: rule124
}, {
  start: 4141,
  length: 4,
  convRule: rule92
}, {
  start: 4145,
  length: 1,
  convRule: rule124
}, {
  start: 4146,
  length: 6,
  convRule: rule92
}, {
  start: 4152,
  length: 1,
  convRule: rule124
}, {
  start: 4153,
  length: 2,
  convRule: rule92
}, {
  start: 4155,
  length: 2,
  convRule: rule124
}, {
  start: 4157,
  length: 2,
  convRule: rule92
}, {
  start: 4159,
  length: 1,
  convRule: rule14
}, {
  start: 4160,
  length: 10,
  convRule: rule8
}, {
  start: 4170,
  length: 6,
  convRule: rule2
}, {
  start: 4176,
  length: 6,
  convRule: rule14
}, {
  start: 4182,
  length: 2,
  convRule: rule124
}, {
  start: 4184,
  length: 2,
  convRule: rule92
}, {
  start: 4186,
  length: 4,
  convRule: rule14
}, {
  start: 4190,
  length: 3,
  convRule: rule92
}, {
  start: 4193,
  length: 1,
  convRule: rule14
}, {
  start: 4194,
  length: 3,
  convRule: rule124
}, {
  start: 4197,
  length: 2,
  convRule: rule14
}, {
  start: 4199,
  length: 7,
  convRule: rule124
}, {
  start: 4206,
  length: 3,
  convRule: rule14
}, {
  start: 4209,
  length: 4,
  convRule: rule92
}, {
  start: 4213,
  length: 13,
  convRule: rule14
}, {
  start: 4226,
  length: 1,
  convRule: rule92
}, {
  start: 4227,
  length: 2,
  convRule: rule124
}, {
  start: 4229,
  length: 2,
  convRule: rule92
}, {
  start: 4231,
  length: 6,
  convRule: rule124
}, {
  start: 4237,
  length: 1,
  convRule: rule92
}, {
  start: 4238,
  length: 1,
  convRule: rule14
}, {
  start: 4239,
  length: 1,
  convRule: rule124
}, {
  start: 4240,
  length: 10,
  convRule: rule8
}, {
  start: 4250,
  length: 3,
  convRule: rule124
}, {
  start: 4253,
  length: 1,
  convRule: rule92
}, {
  start: 4254,
  length: 2,
  convRule: rule13
}, {
  start: 4256,
  length: 38,
  convRule: rule125
}, {
  start: 4295,
  length: 1,
  convRule: rule125
}, {
  start: 4301,
  length: 1,
  convRule: rule125
}, {
  start: 4304,
  length: 43,
  convRule: rule126
}, {
  start: 4347,
  length: 1,
  convRule: rule2
}, {
  start: 4348,
  length: 1,
  convRule: rule91
}, {
  start: 4349,
  length: 3,
  convRule: rule126
}, {
  start: 4352,
  length: 329,
  convRule: rule14
}, {
  start: 4682,
  length: 4,
  convRule: rule14
}, {
  start: 4688,
  length: 7,
  convRule: rule14
}, {
  start: 4696,
  length: 1,
  convRule: rule14
}, {
  start: 4698,
  length: 4,
  convRule: rule14
}, {
  start: 4704,
  length: 41,
  convRule: rule14
}, {
  start: 4746,
  length: 4,
  convRule: rule14
}, {
  start: 4752,
  length: 33,
  convRule: rule14
}, {
  start: 4786,
  length: 4,
  convRule: rule14
}, {
  start: 4792,
  length: 7,
  convRule: rule14
}, {
  start: 4800,
  length: 1,
  convRule: rule14
}, {
  start: 4802,
  length: 4,
  convRule: rule14
}, {
  start: 4808,
  length: 15,
  convRule: rule14
}, {
  start: 4824,
  length: 57,
  convRule: rule14
}, {
  start: 4882,
  length: 4,
  convRule: rule14
}, {
  start: 4888,
  length: 67,
  convRule: rule14
}, {
  start: 4957,
  length: 3,
  convRule: rule92
}, {
  start: 4960,
  length: 9,
  convRule: rule2
}, {
  start: 4969,
  length: 20,
  convRule: rule17
}, {
  start: 4992,
  length: 16,
  convRule: rule14
}, {
  start: 5008,
  length: 10,
  convRule: rule13
}, {
  start: 5024,
  length: 80,
  convRule: rule127
}, {
  start: 5104,
  length: 6,
  convRule: rule104
}, {
  start: 5112,
  length: 6,
  convRule: rule110
}, {
  start: 5120,
  length: 1,
  convRule: rule7
}, {
  start: 5121,
  length: 620,
  convRule: rule14
}, {
  start: 5741,
  length: 1,
  convRule: rule13
}, {
  start: 5742,
  length: 1,
  convRule: rule2
}, {
  start: 5743,
  length: 17,
  convRule: rule14
}, {
  start: 5760,
  length: 1,
  convRule: rule1
}, {
  start: 5761,
  length: 26,
  convRule: rule14
}, {
  start: 5787,
  length: 1,
  convRule: rule4
}, {
  start: 5788,
  length: 1,
  convRule: rule5
}, {
  start: 5792,
  length: 75,
  convRule: rule14
}, {
  start: 5867,
  length: 3,
  convRule: rule2
}, {
  start: 5870,
  length: 3,
  convRule: rule128
}, {
  start: 5873,
  length: 8,
  convRule: rule14
}, {
  start: 5888,
  length: 13,
  convRule: rule14
}, {
  start: 5902,
  length: 4,
  convRule: rule14
}, {
  start: 5906,
  length: 3,
  convRule: rule92
}, {
  start: 5920,
  length: 18,
  convRule: rule14
}, {
  start: 5938,
  length: 3,
  convRule: rule92
}, {
  start: 5941,
  length: 2,
  convRule: rule2
}, {
  start: 5952,
  length: 18,
  convRule: rule14
}, {
  start: 5970,
  length: 2,
  convRule: rule92
}, {
  start: 5984,
  length: 13,
  convRule: rule14
}, {
  start: 5998,
  length: 3,
  convRule: rule14
}, {
  start: 6002,
  length: 2,
  convRule: rule92
}, {
  start: 6016,
  length: 52,
  convRule: rule14
}, {
  start: 6068,
  length: 2,
  convRule: rule92
}, {
  start: 6070,
  length: 1,
  convRule: rule124
}, {
  start: 6071,
  length: 7,
  convRule: rule92
}, {
  start: 6078,
  length: 8,
  convRule: rule124
}, {
  start: 6086,
  length: 1,
  convRule: rule92
}, {
  start: 6087,
  length: 2,
  convRule: rule124
}, {
  start: 6089,
  length: 11,
  convRule: rule92
}, {
  start: 6100,
  length: 3,
  convRule: rule2
}, {
  start: 6103,
  length: 1,
  convRule: rule91
}, {
  start: 6104,
  length: 3,
  convRule: rule2
}, {
  start: 6107,
  length: 1,
  convRule: rule3
}, {
  start: 6108,
  length: 1,
  convRule: rule14
}, {
  start: 6109,
  length: 1,
  convRule: rule92
}, {
  start: 6112,
  length: 10,
  convRule: rule8
}, {
  start: 6128,
  length: 10,
  convRule: rule17
}, {
  start: 6144,
  length: 6,
  convRule: rule2
}, {
  start: 6150,
  length: 1,
  convRule: rule7
}, {
  start: 6151,
  length: 4,
  convRule: rule2
}, {
  start: 6155,
  length: 3,
  convRule: rule92
}, {
  start: 6158,
  length: 1,
  convRule: rule16
}, {
  start: 6160,
  length: 10,
  convRule: rule8
}, {
  start: 6176,
  length: 35,
  convRule: rule14
}, {
  start: 6211,
  length: 1,
  convRule: rule91
}, {
  start: 6212,
  length: 53,
  convRule: rule14
}, {
  start: 6272,
  length: 5,
  convRule: rule14
}, {
  start: 6277,
  length: 2,
  convRule: rule92
}, {
  start: 6279,
  length: 34,
  convRule: rule14
}, {
  start: 6313,
  length: 1,
  convRule: rule92
}, {
  start: 6314,
  length: 1,
  convRule: rule14
}, {
  start: 6320,
  length: 70,
  convRule: rule14
}, {
  start: 6400,
  length: 31,
  convRule: rule14
}, {
  start: 6432,
  length: 3,
  convRule: rule92
}, {
  start: 6435,
  length: 4,
  convRule: rule124
}, {
  start: 6439,
  length: 2,
  convRule: rule92
}, {
  start: 6441,
  length: 3,
  convRule: rule124
}, {
  start: 6448,
  length: 2,
  convRule: rule124
}, {
  start: 6450,
  length: 1,
  convRule: rule92
}, {
  start: 6451,
  length: 6,
  convRule: rule124
}, {
  start: 6457,
  length: 3,
  convRule: rule92
}, {
  start: 6464,
  length: 1,
  convRule: rule13
}, {
  start: 6468,
  length: 2,
  convRule: rule2
}, {
  start: 6470,
  length: 10,
  convRule: rule8
}, {
  start: 6480,
  length: 30,
  convRule: rule14
}, {
  start: 6512,
  length: 5,
  convRule: rule14
}, {
  start: 6528,
  length: 44,
  convRule: rule14
}, {
  start: 6576,
  length: 26,
  convRule: rule14
}, {
  start: 6608,
  length: 10,
  convRule: rule8
}, {
  start: 6618,
  length: 1,
  convRule: rule17
}, {
  start: 6622,
  length: 34,
  convRule: rule13
}, {
  start: 6656,
  length: 23,
  convRule: rule14
}, {
  start: 6679,
  length: 2,
  convRule: rule92
}, {
  start: 6681,
  length: 2,
  convRule: rule124
}, {
  start: 6683,
  length: 1,
  convRule: rule92
}, {
  start: 6686,
  length: 2,
  convRule: rule2
}, {
  start: 6688,
  length: 53,
  convRule: rule14
}, {
  start: 6741,
  length: 1,
  convRule: rule124
}, {
  start: 6742,
  length: 1,
  convRule: rule92
}, {
  start: 6743,
  length: 1,
  convRule: rule124
}, {
  start: 6744,
  length: 7,
  convRule: rule92
}, {
  start: 6752,
  length: 1,
  convRule: rule92
}, {
  start: 6753,
  length: 1,
  convRule: rule124
}, {
  start: 6754,
  length: 1,
  convRule: rule92
}, {
  start: 6755,
  length: 2,
  convRule: rule124
}, {
  start: 6757,
  length: 8,
  convRule: rule92
}, {
  start: 6765,
  length: 6,
  convRule: rule124
}, {
  start: 6771,
  length: 10,
  convRule: rule92
}, {
  start: 6783,
  length: 1,
  convRule: rule92
}, {
  start: 6784,
  length: 10,
  convRule: rule8
}, {
  start: 6800,
  length: 10,
  convRule: rule8
}, {
  start: 6816,
  length: 7,
  convRule: rule2
}, {
  start: 6823,
  length: 1,
  convRule: rule91
}, {
  start: 6824,
  length: 6,
  convRule: rule2
}, {
  start: 6832,
  length: 14,
  convRule: rule92
}, {
  start: 6846,
  length: 1,
  convRule: rule119
}, {
  start: 6847,
  length: 2,
  convRule: rule92
}, {
  start: 6912,
  length: 4,
  convRule: rule92
}, {
  start: 6916,
  length: 1,
  convRule: rule124
}, {
  start: 6917,
  length: 47,
  convRule: rule14
}, {
  start: 6964,
  length: 1,
  convRule: rule92
}, {
  start: 6965,
  length: 1,
  convRule: rule124
}, {
  start: 6966,
  length: 5,
  convRule: rule92
}, {
  start: 6971,
  length: 1,
  convRule: rule124
}, {
  start: 6972,
  length: 1,
  convRule: rule92
}, {
  start: 6973,
  length: 5,
  convRule: rule124
}, {
  start: 6978,
  length: 1,
  convRule: rule92
}, {
  start: 6979,
  length: 2,
  convRule: rule124
}, {
  start: 6981,
  length: 7,
  convRule: rule14
}, {
  start: 6992,
  length: 10,
  convRule: rule8
}, {
  start: 7002,
  length: 7,
  convRule: rule2
}, {
  start: 7009,
  length: 10,
  convRule: rule13
}, {
  start: 7019,
  length: 9,
  convRule: rule92
}, {
  start: 7028,
  length: 9,
  convRule: rule13
}, {
  start: 7040,
  length: 2,
  convRule: rule92
}, {
  start: 7042,
  length: 1,
  convRule: rule124
}, {
  start: 7043,
  length: 30,
  convRule: rule14
}, {
  start: 7073,
  length: 1,
  convRule: rule124
}, {
  start: 7074,
  length: 4,
  convRule: rule92
}, {
  start: 7078,
  length: 2,
  convRule: rule124
}, {
  start: 7080,
  length: 2,
  convRule: rule92
}, {
  start: 7082,
  length: 1,
  convRule: rule124
}, {
  start: 7083,
  length: 3,
  convRule: rule92
}, {
  start: 7086,
  length: 2,
  convRule: rule14
}, {
  start: 7088,
  length: 10,
  convRule: rule8
}, {
  start: 7098,
  length: 44,
  convRule: rule14
}, {
  start: 7142,
  length: 1,
  convRule: rule92
}, {
  start: 7143,
  length: 1,
  convRule: rule124
}, {
  start: 7144,
  length: 2,
  convRule: rule92
}, {
  start: 7146,
  length: 3,
  convRule: rule124
}, {
  start: 7149,
  length: 1,
  convRule: rule92
}, {
  start: 7150,
  length: 1,
  convRule: rule124
}, {
  start: 7151,
  length: 3,
  convRule: rule92
}, {
  start: 7154,
  length: 2,
  convRule: rule124
}, {
  start: 7164,
  length: 4,
  convRule: rule2
}, {
  start: 7168,
  length: 36,
  convRule: rule14
}, {
  start: 7204,
  length: 8,
  convRule: rule124
}, {
  start: 7212,
  length: 8,
  convRule: rule92
}, {
  start: 7220,
  length: 2,
  convRule: rule124
}, {
  start: 7222,
  length: 2,
  convRule: rule92
}, {
  start: 7227,
  length: 5,
  convRule: rule2
}, {
  start: 7232,
  length: 10,
  convRule: rule8
}, {
  start: 7245,
  length: 3,
  convRule: rule14
}, {
  start: 7248,
  length: 10,
  convRule: rule8
}, {
  start: 7258,
  length: 30,
  convRule: rule14
}, {
  start: 7288,
  length: 6,
  convRule: rule91
}, {
  start: 7294,
  length: 2,
  convRule: rule2
}, {
  start: 7296,
  length: 1,
  convRule: rule129
}, {
  start: 7297,
  length: 1,
  convRule: rule130
}, {
  start: 7298,
  length: 1,
  convRule: rule131
}, {
  start: 7299,
  length: 2,
  convRule: rule132
}, {
  start: 7301,
  length: 1,
  convRule: rule133
}, {
  start: 7302,
  length: 1,
  convRule: rule134
}, {
  start: 7303,
  length: 1,
  convRule: rule135
}, {
  start: 7304,
  length: 1,
  convRule: rule136
}, {
  start: 7312,
  length: 43,
  convRule: rule137
}, {
  start: 7357,
  length: 3,
  convRule: rule137
}, {
  start: 7360,
  length: 8,
  convRule: rule2
}, {
  start: 7376,
  length: 3,
  convRule: rule92
}, {
  start: 7379,
  length: 1,
  convRule: rule2
}, {
  start: 7380,
  length: 13,
  convRule: rule92
}, {
  start: 7393,
  length: 1,
  convRule: rule124
}, {
  start: 7394,
  length: 7,
  convRule: rule92
}, {
  start: 7401,
  length: 4,
  convRule: rule14
}, {
  start: 7405,
  length: 1,
  convRule: rule92
}, {
  start: 7406,
  length: 6,
  convRule: rule14
}, {
  start: 7412,
  length: 1,
  convRule: rule92
}, {
  start: 7413,
  length: 2,
  convRule: rule14
}, {
  start: 7415,
  length: 1,
  convRule: rule124
}, {
  start: 7416,
  length: 2,
  convRule: rule92
}, {
  start: 7418,
  length: 1,
  convRule: rule14
}, {
  start: 7424,
  length: 44,
  convRule: rule20
}, {
  start: 7468,
  length: 63,
  convRule: rule91
}, {
  start: 7531,
  length: 13,
  convRule: rule20
}, {
  start: 7544,
  length: 1,
  convRule: rule91
}, {
  start: 7545,
  length: 1,
  convRule: rule138
}, {
  start: 7546,
  length: 3,
  convRule: rule20
}, {
  start: 7549,
  length: 1,
  convRule: rule139
}, {
  start: 7550,
  length: 16,
  convRule: rule20
}, {
  start: 7566,
  length: 1,
  convRule: rule140
}, {
  start: 7567,
  length: 12,
  convRule: rule20
}, {
  start: 7579,
  length: 37,
  convRule: rule91
}, {
  start: 7616,
  length: 58,
  convRule: rule92
}, {
  start: 7675,
  length: 5,
  convRule: rule92
}, {
  start: 7680,
  length: 1,
  convRule: rule22
}, {
  start: 7681,
  length: 1,
  convRule: rule23
}, {
  start: 7682,
  length: 1,
  convRule: rule22
}, {
  start: 7683,
  length: 1,
  convRule: rule23
}, {
  start: 7684,
  length: 1,
  convRule: rule22
}, {
  start: 7685,
  length: 1,
  convRule: rule23
}, {
  start: 7686,
  length: 1,
  convRule: rule22
}, {
  start: 7687,
  length: 1,
  convRule: rule23
}, {
  start: 7688,
  length: 1,
  convRule: rule22
}, {
  start: 7689,
  length: 1,
  convRule: rule23
}, {
  start: 7690,
  length: 1,
  convRule: rule22
}, {
  start: 7691,
  length: 1,
  convRule: rule23
}, {
  start: 7692,
  length: 1,
  convRule: rule22
}, {
  start: 7693,
  length: 1,
  convRule: rule23
}, {
  start: 7694,
  length: 1,
  convRule: rule22
}, {
  start: 7695,
  length: 1,
  convRule: rule23
}, {
  start: 7696,
  length: 1,
  convRule: rule22
}, {
  start: 7697,
  length: 1,
  convRule: rule23
}, {
  start: 7698,
  length: 1,
  convRule: rule22
}, {
  start: 7699,
  length: 1,
  convRule: rule23
}, {
  start: 7700,
  length: 1,
  convRule: rule22
}, {
  start: 7701,
  length: 1,
  convRule: rule23
}, {
  start: 7702,
  length: 1,
  convRule: rule22
}, {
  start: 7703,
  length: 1,
  convRule: rule23
}, {
  start: 7704,
  length: 1,
  convRule: rule22
}, {
  start: 7705,
  length: 1,
  convRule: rule23
}, {
  start: 7706,
  length: 1,
  convRule: rule22
}, {
  start: 7707,
  length: 1,
  convRule: rule23
}, {
  start: 7708,
  length: 1,
  convRule: rule22
}, {
  start: 7709,
  length: 1,
  convRule: rule23
}, {
  start: 7710,
  length: 1,
  convRule: rule22
}, {
  start: 7711,
  length: 1,
  convRule: rule23
}, {
  start: 7712,
  length: 1,
  convRule: rule22
}, {
  start: 7713,
  length: 1,
  convRule: rule23
}, {
  start: 7714,
  length: 1,
  convRule: rule22
}, {
  start: 7715,
  length: 1,
  convRule: rule23
}, {
  start: 7716,
  length: 1,
  convRule: rule22
}, {
  start: 7717,
  length: 1,
  convRule: rule23
}, {
  start: 7718,
  length: 1,
  convRule: rule22
}, {
  start: 7719,
  length: 1,
  convRule: rule23
}, {
  start: 7720,
  length: 1,
  convRule: rule22
}, {
  start: 7721,
  length: 1,
  convRule: rule23
}, {
  start: 7722,
  length: 1,
  convRule: rule22
}, {
  start: 7723,
  length: 1,
  convRule: rule23
}, {
  start: 7724,
  length: 1,
  convRule: rule22
}, {
  start: 7725,
  length: 1,
  convRule: rule23
}, {
  start: 7726,
  length: 1,
  convRule: rule22
}, {
  start: 7727,
  length: 1,
  convRule: rule23
}, {
  start: 7728,
  length: 1,
  convRule: rule22
}, {
  start: 7729,
  length: 1,
  convRule: rule23
}, {
  start: 7730,
  length: 1,
  convRule: rule22
}, {
  start: 7731,
  length: 1,
  convRule: rule23
}, {
  start: 7732,
  length: 1,
  convRule: rule22
}, {
  start: 7733,
  length: 1,
  convRule: rule23
}, {
  start: 7734,
  length: 1,
  convRule: rule22
}, {
  start: 7735,
  length: 1,
  convRule: rule23
}, {
  start: 7736,
  length: 1,
  convRule: rule22
}, {
  start: 7737,
  length: 1,
  convRule: rule23
}, {
  start: 7738,
  length: 1,
  convRule: rule22
}, {
  start: 7739,
  length: 1,
  convRule: rule23
}, {
  start: 7740,
  length: 1,
  convRule: rule22
}, {
  start: 7741,
  length: 1,
  convRule: rule23
}, {
  start: 7742,
  length: 1,
  convRule: rule22
}, {
  start: 7743,
  length: 1,
  convRule: rule23
}, {
  start: 7744,
  length: 1,
  convRule: rule22
}, {
  start: 7745,
  length: 1,
  convRule: rule23
}, {
  start: 7746,
  length: 1,
  convRule: rule22
}, {
  start: 7747,
  length: 1,
  convRule: rule23
}, {
  start: 7748,
  length: 1,
  convRule: rule22
}, {
  start: 7749,
  length: 1,
  convRule: rule23
}, {
  start: 7750,
  length: 1,
  convRule: rule22
}, {
  start: 7751,
  length: 1,
  convRule: rule23
}, {
  start: 7752,
  length: 1,
  convRule: rule22
}, {
  start: 7753,
  length: 1,
  convRule: rule23
}, {
  start: 7754,
  length: 1,
  convRule: rule22
}, {
  start: 7755,
  length: 1,
  convRule: rule23
}, {
  start: 7756,
  length: 1,
  convRule: rule22
}, {
  start: 7757,
  length: 1,
  convRule: rule23
}, {
  start: 7758,
  length: 1,
  convRule: rule22
}, {
  start: 7759,
  length: 1,
  convRule: rule23
}, {
  start: 7760,
  length: 1,
  convRule: rule22
}, {
  start: 7761,
  length: 1,
  convRule: rule23
}, {
  start: 7762,
  length: 1,
  convRule: rule22
}, {
  start: 7763,
  length: 1,
  convRule: rule23
}, {
  start: 7764,
  length: 1,
  convRule: rule22
}, {
  start: 7765,
  length: 1,
  convRule: rule23
}, {
  start: 7766,
  length: 1,
  convRule: rule22
}, {
  start: 7767,
  length: 1,
  convRule: rule23
}, {
  start: 7768,
  length: 1,
  convRule: rule22
}, {
  start: 7769,
  length: 1,
  convRule: rule23
}, {
  start: 7770,
  length: 1,
  convRule: rule22
}, {
  start: 7771,
  length: 1,
  convRule: rule23
}, {
  start: 7772,
  length: 1,
  convRule: rule22
}, {
  start: 7773,
  length: 1,
  convRule: rule23
}, {
  start: 7774,
  length: 1,
  convRule: rule22
}, {
  start: 7775,
  length: 1,
  convRule: rule23
}, {
  start: 7776,
  length: 1,
  convRule: rule22
}, {
  start: 7777,
  length: 1,
  convRule: rule23
}, {
  start: 7778,
  length: 1,
  convRule: rule22
}, {
  start: 7779,
  length: 1,
  convRule: rule23
}, {
  start: 7780,
  length: 1,
  convRule: rule22
}, {
  start: 7781,
  length: 1,
  convRule: rule23
}, {
  start: 7782,
  length: 1,
  convRule: rule22
}, {
  start: 7783,
  length: 1,
  convRule: rule23
}, {
  start: 7784,
  length: 1,
  convRule: rule22
}, {
  start: 7785,
  length: 1,
  convRule: rule23
}, {
  start: 7786,
  length: 1,
  convRule: rule22
}, {
  start: 7787,
  length: 1,
  convRule: rule23
}, {
  start: 7788,
  length: 1,
  convRule: rule22
}, {
  start: 7789,
  length: 1,
  convRule: rule23
}, {
  start: 7790,
  length: 1,
  convRule: rule22
}, {
  start: 7791,
  length: 1,
  convRule: rule23
}, {
  start: 7792,
  length: 1,
  convRule: rule22
}, {
  start: 7793,
  length: 1,
  convRule: rule23
}, {
  start: 7794,
  length: 1,
  convRule: rule22
}, {
  start: 7795,
  length: 1,
  convRule: rule23
}, {
  start: 7796,
  length: 1,
  convRule: rule22
}, {
  start: 7797,
  length: 1,
  convRule: rule23
}, {
  start: 7798,
  length: 1,
  convRule: rule22
}, {
  start: 7799,
  length: 1,
  convRule: rule23
}, {
  start: 7800,
  length: 1,
  convRule: rule22
}, {
  start: 7801,
  length: 1,
  convRule: rule23
}, {
  start: 7802,
  length: 1,
  convRule: rule22
}, {
  start: 7803,
  length: 1,
  convRule: rule23
}, {
  start: 7804,
  length: 1,
  convRule: rule22
}, {
  start: 7805,
  length: 1,
  convRule: rule23
}, {
  start: 7806,
  length: 1,
  convRule: rule22
}, {
  start: 7807,
  length: 1,
  convRule: rule23
}, {
  start: 7808,
  length: 1,
  convRule: rule22
}, {
  start: 7809,
  length: 1,
  convRule: rule23
}, {
  start: 7810,
  length: 1,
  convRule: rule22
}, {
  start: 7811,
  length: 1,
  convRule: rule23
}, {
  start: 7812,
  length: 1,
  convRule: rule22
}, {
  start: 7813,
  length: 1,
  convRule: rule23
}, {
  start: 7814,
  length: 1,
  convRule: rule22
}, {
  start: 7815,
  length: 1,
  convRule: rule23
}, {
  start: 7816,
  length: 1,
  convRule: rule22
}, {
  start: 7817,
  length: 1,
  convRule: rule23
}, {
  start: 7818,
  length: 1,
  convRule: rule22
}, {
  start: 7819,
  length: 1,
  convRule: rule23
}, {
  start: 7820,
  length: 1,
  convRule: rule22
}, {
  start: 7821,
  length: 1,
  convRule: rule23
}, {
  start: 7822,
  length: 1,
  convRule: rule22
}, {
  start: 7823,
  length: 1,
  convRule: rule23
}, {
  start: 7824,
  length: 1,
  convRule: rule22
}, {
  start: 7825,
  length: 1,
  convRule: rule23
}, {
  start: 7826,
  length: 1,
  convRule: rule22
}, {
  start: 7827,
  length: 1,
  convRule: rule23
}, {
  start: 7828,
  length: 1,
  convRule: rule22
}, {
  start: 7829,
  length: 1,
  convRule: rule23
}, {
  start: 7830,
  length: 5,
  convRule: rule20
}, {
  start: 7835,
  length: 1,
  convRule: rule141
}, {
  start: 7836,
  length: 2,
  convRule: rule20
}, {
  start: 7838,
  length: 1,
  convRule: rule142
}, {
  start: 7839,
  length: 1,
  convRule: rule20
}, {
  start: 7840,
  length: 1,
  convRule: rule22
}, {
  start: 7841,
  length: 1,
  convRule: rule23
}, {
  start: 7842,
  length: 1,
  convRule: rule22
}, {
  start: 7843,
  length: 1,
  convRule: rule23
}, {
  start: 7844,
  length: 1,
  convRule: rule22
}, {
  start: 7845,
  length: 1,
  convRule: rule23
}, {
  start: 7846,
  length: 1,
  convRule: rule22
}, {
  start: 7847,
  length: 1,
  convRule: rule23
}, {
  start: 7848,
  length: 1,
  convRule: rule22
}, {
  start: 7849,
  length: 1,
  convRule: rule23
}, {
  start: 7850,
  length: 1,
  convRule: rule22
}, {
  start: 7851,
  length: 1,
  convRule: rule23
}, {
  start: 7852,
  length: 1,
  convRule: rule22
}, {
  start: 7853,
  length: 1,
  convRule: rule23
}, {
  start: 7854,
  length: 1,
  convRule: rule22
}, {
  start: 7855,
  length: 1,
  convRule: rule23
}, {
  start: 7856,
  length: 1,
  convRule: rule22
}, {
  start: 7857,
  length: 1,
  convRule: rule23
}, {
  start: 7858,
  length: 1,
  convRule: rule22
}, {
  start: 7859,
  length: 1,
  convRule: rule23
}, {
  start: 7860,
  length: 1,
  convRule: rule22
}, {
  start: 7861,
  length: 1,
  convRule: rule23
}, {
  start: 7862,
  length: 1,
  convRule: rule22
}, {
  start: 7863,
  length: 1,
  convRule: rule23
}, {
  start: 7864,
  length: 1,
  convRule: rule22
}, {
  start: 7865,
  length: 1,
  convRule: rule23
}, {
  start: 7866,
  length: 1,
  convRule: rule22
}, {
  start: 7867,
  length: 1,
  convRule: rule23
}, {
  start: 7868,
  length: 1,
  convRule: rule22
}, {
  start: 7869,
  length: 1,
  convRule: rule23
}, {
  start: 7870,
  length: 1,
  convRule: rule22
}, {
  start: 7871,
  length: 1,
  convRule: rule23
}, {
  start: 7872,
  length: 1,
  convRule: rule22
}, {
  start: 7873,
  length: 1,
  convRule: rule23
}, {
  start: 7874,
  length: 1,
  convRule: rule22
}, {
  start: 7875,
  length: 1,
  convRule: rule23
}, {
  start: 7876,
  length: 1,
  convRule: rule22
}, {
  start: 7877,
  length: 1,
  convRule: rule23
}, {
  start: 7878,
  length: 1,
  convRule: rule22
}, {
  start: 7879,
  length: 1,
  convRule: rule23
}, {
  start: 7880,
  length: 1,
  convRule: rule22
}, {
  start: 7881,
  length: 1,
  convRule: rule23
}, {
  start: 7882,
  length: 1,
  convRule: rule22
}, {
  start: 7883,
  length: 1,
  convRule: rule23
}, {
  start: 7884,
  length: 1,
  convRule: rule22
}, {
  start: 7885,
  length: 1,
  convRule: rule23
}, {
  start: 7886,
  length: 1,
  convRule: rule22
}, {
  start: 7887,
  length: 1,
  convRule: rule23
}, {
  start: 7888,
  length: 1,
  convRule: rule22
}, {
  start: 7889,
  length: 1,
  convRule: rule23
}, {
  start: 7890,
  length: 1,
  convRule: rule22
}, {
  start: 7891,
  length: 1,
  convRule: rule23
}, {
  start: 7892,
  length: 1,
  convRule: rule22
}, {
  start: 7893,
  length: 1,
  convRule: rule23
}, {
  start: 7894,
  length: 1,
  convRule: rule22
}, {
  start: 7895,
  length: 1,
  convRule: rule23
}, {
  start: 7896,
  length: 1,
  convRule: rule22
}, {
  start: 7897,
  length: 1,
  convRule: rule23
}, {
  start: 7898,
  length: 1,
  convRule: rule22
}, {
  start: 7899,
  length: 1,
  convRule: rule23
}, {
  start: 7900,
  length: 1,
  convRule: rule22
}, {
  start: 7901,
  length: 1,
  convRule: rule23
}, {
  start: 7902,
  length: 1,
  convRule: rule22
}, {
  start: 7903,
  length: 1,
  convRule: rule23
}, {
  start: 7904,
  length: 1,
  convRule: rule22
}, {
  start: 7905,
  length: 1,
  convRule: rule23
}, {
  start: 7906,
  length: 1,
  convRule: rule22
}, {
  start: 7907,
  length: 1,
  convRule: rule23
}, {
  start: 7908,
  length: 1,
  convRule: rule22
}, {
  start: 7909,
  length: 1,
  convRule: rule23
}, {
  start: 7910,
  length: 1,
  convRule: rule22
}, {
  start: 7911,
  length: 1,
  convRule: rule23
}, {
  start: 7912,
  length: 1,
  convRule: rule22
}, {
  start: 7913,
  length: 1,
  convRule: rule23
}, {
  start: 7914,
  length: 1,
  convRule: rule22
}, {
  start: 7915,
  length: 1,
  convRule: rule23
}, {
  start: 7916,
  length: 1,
  convRule: rule22
}, {
  start: 7917,
  length: 1,
  convRule: rule23
}, {
  start: 7918,
  length: 1,
  convRule: rule22
}, {
  start: 7919,
  length: 1,
  convRule: rule23
}, {
  start: 7920,
  length: 1,
  convRule: rule22
}, {
  start: 7921,
  length: 1,
  convRule: rule23
}, {
  start: 7922,
  length: 1,
  convRule: rule22
}, {
  start: 7923,
  length: 1,
  convRule: rule23
}, {
  start: 7924,
  length: 1,
  convRule: rule22
}, {
  start: 7925,
  length: 1,
  convRule: rule23
}, {
  start: 7926,
  length: 1,
  convRule: rule22
}, {
  start: 7927,
  length: 1,
  convRule: rule23
}, {
  start: 7928,
  length: 1,
  convRule: rule22
}, {
  start: 7929,
  length: 1,
  convRule: rule23
}, {
  start: 7930,
  length: 1,
  convRule: rule22
}, {
  start: 7931,
  length: 1,
  convRule: rule23
}, {
  start: 7932,
  length: 1,
  convRule: rule22
}, {
  start: 7933,
  length: 1,
  convRule: rule23
}, {
  start: 7934,
  length: 1,
  convRule: rule22
}, {
  start: 7935,
  length: 1,
  convRule: rule23
}, {
  start: 7936,
  length: 8,
  convRule: rule143
}, {
  start: 7944,
  length: 8,
  convRule: rule144
}, {
  start: 7952,
  length: 6,
  convRule: rule143
}, {
  start: 7960,
  length: 6,
  convRule: rule144
}, {
  start: 7968,
  length: 8,
  convRule: rule143
}, {
  start: 7976,
  length: 8,
  convRule: rule144
}, {
  start: 7984,
  length: 8,
  convRule: rule143
}, {
  start: 7992,
  length: 8,
  convRule: rule144
}, {
  start: 8e3,
  length: 6,
  convRule: rule143
}, {
  start: 8008,
  length: 6,
  convRule: rule144
}, {
  start: 8016,
  length: 1,
  convRule: rule20
}, {
  start: 8017,
  length: 1,
  convRule: rule143
}, {
  start: 8018,
  length: 1,
  convRule: rule20
}, {
  start: 8019,
  length: 1,
  convRule: rule143
}, {
  start: 8020,
  length: 1,
  convRule: rule20
}, {
  start: 8021,
  length: 1,
  convRule: rule143
}, {
  start: 8022,
  length: 1,
  convRule: rule20
}, {
  start: 8023,
  length: 1,
  convRule: rule143
}, {
  start: 8025,
  length: 1,
  convRule: rule144
}, {
  start: 8027,
  length: 1,
  convRule: rule144
}, {
  start: 8029,
  length: 1,
  convRule: rule144
}, {
  start: 8031,
  length: 1,
  convRule: rule144
}, {
  start: 8032,
  length: 8,
  convRule: rule143
}, {
  start: 8040,
  length: 8,
  convRule: rule144
}, {
  start: 8048,
  length: 2,
  convRule: rule145
}, {
  start: 8050,
  length: 4,
  convRule: rule146
}, {
  start: 8054,
  length: 2,
  convRule: rule147
}, {
  start: 8056,
  length: 2,
  convRule: rule148
}, {
  start: 8058,
  length: 2,
  convRule: rule149
}, {
  start: 8060,
  length: 2,
  convRule: rule150
}, {
  start: 8064,
  length: 8,
  convRule: rule143
}, {
  start: 8072,
  length: 8,
  convRule: rule151
}, {
  start: 8080,
  length: 8,
  convRule: rule143
}, {
  start: 8088,
  length: 8,
  convRule: rule151
}, {
  start: 8096,
  length: 8,
  convRule: rule143
}, {
  start: 8104,
  length: 8,
  convRule: rule151
}, {
  start: 8112,
  length: 2,
  convRule: rule143
}, {
  start: 8114,
  length: 1,
  convRule: rule20
}, {
  start: 8115,
  length: 1,
  convRule: rule152
}, {
  start: 8116,
  length: 1,
  convRule: rule20
}, {
  start: 8118,
  length: 2,
  convRule: rule20
}, {
  start: 8120,
  length: 2,
  convRule: rule144
}, {
  start: 8122,
  length: 2,
  convRule: rule153
}, {
  start: 8124,
  length: 1,
  convRule: rule154
}, {
  start: 8125,
  length: 1,
  convRule: rule10
}, {
  start: 8126,
  length: 1,
  convRule: rule155
}, {
  start: 8127,
  length: 3,
  convRule: rule10
}, {
  start: 8130,
  length: 1,
  convRule: rule20
}, {
  start: 8131,
  length: 1,
  convRule: rule152
}, {
  start: 8132,
  length: 1,
  convRule: rule20
}, {
  start: 8134,
  length: 2,
  convRule: rule20
}, {
  start: 8136,
  length: 4,
  convRule: rule156
}, {
  start: 8140,
  length: 1,
  convRule: rule154
}, {
  start: 8141,
  length: 3,
  convRule: rule10
}, {
  start: 8144,
  length: 2,
  convRule: rule143
}, {
  start: 8146,
  length: 2,
  convRule: rule20
}, {
  start: 8150,
  length: 2,
  convRule: rule20
}, {
  start: 8152,
  length: 2,
  convRule: rule144
}, {
  start: 8154,
  length: 2,
  convRule: rule157
}, {
  start: 8157,
  length: 3,
  convRule: rule10
}, {
  start: 8160,
  length: 2,
  convRule: rule143
}, {
  start: 8162,
  length: 3,
  convRule: rule20
}, {
  start: 8165,
  length: 1,
  convRule: rule113
}, {
  start: 8166,
  length: 2,
  convRule: rule20
}, {
  start: 8168,
  length: 2,
  convRule: rule144
}, {
  start: 8170,
  length: 2,
  convRule: rule158
}, {
  start: 8172,
  length: 1,
  convRule: rule117
}, {
  start: 8173,
  length: 3,
  convRule: rule10
}, {
  start: 8178,
  length: 1,
  convRule: rule20
}, {
  start: 8179,
  length: 1,
  convRule: rule152
}, {
  start: 8180,
  length: 1,
  convRule: rule20
}, {
  start: 8182,
  length: 2,
  convRule: rule20
}, {
  start: 8184,
  length: 2,
  convRule: rule159
}, {
  start: 8186,
  length: 2,
  convRule: rule160
}, {
  start: 8188,
  length: 1,
  convRule: rule154
}, {
  start: 8189,
  length: 2,
  convRule: rule10
}, {
  start: 8192,
  length: 11,
  convRule: rule1
}, {
  start: 8203,
  length: 5,
  convRule: rule16
}, {
  start: 8208,
  length: 6,
  convRule: rule7
}, {
  start: 8214,
  length: 2,
  convRule: rule2
}, {
  start: 8216,
  length: 1,
  convRule: rule15
}, {
  start: 8217,
  length: 1,
  convRule: rule19
}, {
  start: 8218,
  length: 1,
  convRule: rule4
}, {
  start: 8219,
  length: 2,
  convRule: rule15
}, {
  start: 8221,
  length: 1,
  convRule: rule19
}, {
  start: 8222,
  length: 1,
  convRule: rule4
}, {
  start: 8223,
  length: 1,
  convRule: rule15
}, {
  start: 8224,
  length: 8,
  convRule: rule2
}, {
  start: 8232,
  length: 1,
  convRule: rule161
}, {
  start: 8233,
  length: 1,
  convRule: rule162
}, {
  start: 8234,
  length: 5,
  convRule: rule16
}, {
  start: 8239,
  length: 1,
  convRule: rule1
}, {
  start: 8240,
  length: 9,
  convRule: rule2
}, {
  start: 8249,
  length: 1,
  convRule: rule15
}, {
  start: 8250,
  length: 1,
  convRule: rule19
}, {
  start: 8251,
  length: 4,
  convRule: rule2
}, {
  start: 8255,
  length: 2,
  convRule: rule11
}, {
  start: 8257,
  length: 3,
  convRule: rule2
}, {
  start: 8260,
  length: 1,
  convRule: rule6
}, {
  start: 8261,
  length: 1,
  convRule: rule4
}, {
  start: 8262,
  length: 1,
  convRule: rule5
}, {
  start: 8263,
  length: 11,
  convRule: rule2
}, {
  start: 8274,
  length: 1,
  convRule: rule6
}, {
  start: 8275,
  length: 1,
  convRule: rule2
}, {
  start: 8276,
  length: 1,
  convRule: rule11
}, {
  start: 8277,
  length: 10,
  convRule: rule2
}, {
  start: 8287,
  length: 1,
  convRule: rule1
}, {
  start: 8288,
  length: 5,
  convRule: rule16
}, {
  start: 8294,
  length: 10,
  convRule: rule16
}, {
  start: 8304,
  length: 1,
  convRule: rule17
}, {
  start: 8305,
  length: 1,
  convRule: rule91
}, {
  start: 8308,
  length: 6,
  convRule: rule17
}, {
  start: 8314,
  length: 3,
  convRule: rule6
}, {
  start: 8317,
  length: 1,
  convRule: rule4
}, {
  start: 8318,
  length: 1,
  convRule: rule5
}, {
  start: 8319,
  length: 1,
  convRule: rule91
}, {
  start: 8320,
  length: 10,
  convRule: rule17
}, {
  start: 8330,
  length: 3,
  convRule: rule6
}, {
  start: 8333,
  length: 1,
  convRule: rule4
}, {
  start: 8334,
  length: 1,
  convRule: rule5
}, {
  start: 8336,
  length: 13,
  convRule: rule91
}, {
  start: 8352,
  length: 32,
  convRule: rule3
}, {
  start: 8400,
  length: 13,
  convRule: rule92
}, {
  start: 8413,
  length: 4,
  convRule: rule119
}, {
  start: 8417,
  length: 1,
  convRule: rule92
}, {
  start: 8418,
  length: 3,
  convRule: rule119
}, {
  start: 8421,
  length: 12,
  convRule: rule92
}, {
  start: 8448,
  length: 2,
  convRule: rule13
}, {
  start: 8450,
  length: 1,
  convRule: rule107
}, {
  start: 8451,
  length: 4,
  convRule: rule13
}, {
  start: 8455,
  length: 1,
  convRule: rule107
}, {
  start: 8456,
  length: 2,
  convRule: rule13
}, {
  start: 8458,
  length: 1,
  convRule: rule20
}, {
  start: 8459,
  length: 3,
  convRule: rule107
}, {
  start: 8462,
  length: 2,
  convRule: rule20
}, {
  start: 8464,
  length: 3,
  convRule: rule107
}, {
  start: 8467,
  length: 1,
  convRule: rule20
}, {
  start: 8468,
  length: 1,
  convRule: rule13
}, {
  start: 8469,
  length: 1,
  convRule: rule107
}, {
  start: 8470,
  length: 2,
  convRule: rule13
}, {
  start: 8472,
  length: 1,
  convRule: rule6
}, {
  start: 8473,
  length: 5,
  convRule: rule107
}, {
  start: 8478,
  length: 6,
  convRule: rule13
}, {
  start: 8484,
  length: 1,
  convRule: rule107
}, {
  start: 8485,
  length: 1,
  convRule: rule13
}, {
  start: 8486,
  length: 1,
  convRule: rule163
}, {
  start: 8487,
  length: 1,
  convRule: rule13
}, {
  start: 8488,
  length: 1,
  convRule: rule107
}, {
  start: 8489,
  length: 1,
  convRule: rule13
}, {
  start: 8490,
  length: 1,
  convRule: rule164
}, {
  start: 8491,
  length: 1,
  convRule: rule165
}, {
  start: 8492,
  length: 2,
  convRule: rule107
}, {
  start: 8494,
  length: 1,
  convRule: rule13
}, {
  start: 8495,
  length: 1,
  convRule: rule20
}, {
  start: 8496,
  length: 2,
  convRule: rule107
}, {
  start: 8498,
  length: 1,
  convRule: rule166
}, {
  start: 8499,
  length: 1,
  convRule: rule107
}, {
  start: 8500,
  length: 1,
  convRule: rule20
}, {
  start: 8501,
  length: 4,
  convRule: rule14
}, {
  start: 8505,
  length: 1,
  convRule: rule20
}, {
  start: 8506,
  length: 2,
  convRule: rule13
}, {
  start: 8508,
  length: 2,
  convRule: rule20
}, {
  start: 8510,
  length: 2,
  convRule: rule107
}, {
  start: 8512,
  length: 5,
  convRule: rule6
}, {
  start: 8517,
  length: 1,
  convRule: rule107
}, {
  start: 8518,
  length: 4,
  convRule: rule20
}, {
  start: 8522,
  length: 1,
  convRule: rule13
}, {
  start: 8523,
  length: 1,
  convRule: rule6
}, {
  start: 8524,
  length: 2,
  convRule: rule13
}, {
  start: 8526,
  length: 1,
  convRule: rule167
}, {
  start: 8527,
  length: 1,
  convRule: rule13
}, {
  start: 8528,
  length: 16,
  convRule: rule17
}, {
  start: 8544,
  length: 16,
  convRule: rule168
}, {
  start: 8560,
  length: 16,
  convRule: rule169
}, {
  start: 8576,
  length: 3,
  convRule: rule128
}, {
  start: 8579,
  length: 1,
  convRule: rule22
}, {
  start: 8580,
  length: 1,
  convRule: rule23
}, {
  start: 8581,
  length: 4,
  convRule: rule128
}, {
  start: 8585,
  length: 1,
  convRule: rule17
}, {
  start: 8586,
  length: 2,
  convRule: rule13
}, {
  start: 8592,
  length: 5,
  convRule: rule6
}, {
  start: 8597,
  length: 5,
  convRule: rule13
}, {
  start: 8602,
  length: 2,
  convRule: rule6
}, {
  start: 8604,
  length: 4,
  convRule: rule13
}, {
  start: 8608,
  length: 1,
  convRule: rule6
}, {
  start: 8609,
  length: 2,
  convRule: rule13
}, {
  start: 8611,
  length: 1,
  convRule: rule6
}, {
  start: 8612,
  length: 2,
  convRule: rule13
}, {
  start: 8614,
  length: 1,
  convRule: rule6
}, {
  start: 8615,
  length: 7,
  convRule: rule13
}, {
  start: 8622,
  length: 1,
  convRule: rule6
}, {
  start: 8623,
  length: 31,
  convRule: rule13
}, {
  start: 8654,
  length: 2,
  convRule: rule6
}, {
  start: 8656,
  length: 2,
  convRule: rule13
}, {
  start: 8658,
  length: 1,
  convRule: rule6
}, {
  start: 8659,
  length: 1,
  convRule: rule13
}, {
  start: 8660,
  length: 1,
  convRule: rule6
}, {
  start: 8661,
  length: 31,
  convRule: rule13
}, {
  start: 8692,
  length: 268,
  convRule: rule6
}, {
  start: 8960,
  length: 8,
  convRule: rule13
}, {
  start: 8968,
  length: 1,
  convRule: rule4
}, {
  start: 8969,
  length: 1,
  convRule: rule5
}, {
  start: 8970,
  length: 1,
  convRule: rule4
}, {
  start: 8971,
  length: 1,
  convRule: rule5
}, {
  start: 8972,
  length: 20,
  convRule: rule13
}, {
  start: 8992,
  length: 2,
  convRule: rule6
}, {
  start: 8994,
  length: 7,
  convRule: rule13
}, {
  start: 9001,
  length: 1,
  convRule: rule4
}, {
  start: 9002,
  length: 1,
  convRule: rule5
}, {
  start: 9003,
  length: 81,
  convRule: rule13
}, {
  start: 9084,
  length: 1,
  convRule: rule6
}, {
  start: 9085,
  length: 30,
  convRule: rule13
}, {
  start: 9115,
  length: 25,
  convRule: rule6
}, {
  start: 9140,
  length: 40,
  convRule: rule13
}, {
  start: 9180,
  length: 6,
  convRule: rule6
}, {
  start: 9186,
  length: 69,
  convRule: rule13
}, {
  start: 9280,
  length: 11,
  convRule: rule13
}, {
  start: 9312,
  length: 60,
  convRule: rule17
}, {
  start: 9372,
  length: 26,
  convRule: rule13
}, {
  start: 9398,
  length: 26,
  convRule: rule170
}, {
  start: 9424,
  length: 26,
  convRule: rule171
}, {
  start: 9450,
  length: 22,
  convRule: rule17
}, {
  start: 9472,
  length: 183,
  convRule: rule13
}, {
  start: 9655,
  length: 1,
  convRule: rule6
}, {
  start: 9656,
  length: 9,
  convRule: rule13
}, {
  start: 9665,
  length: 1,
  convRule: rule6
}, {
  start: 9666,
  length: 54,
  convRule: rule13
}, {
  start: 9720,
  length: 8,
  convRule: rule6
}, {
  start: 9728,
  length: 111,
  convRule: rule13
}, {
  start: 9839,
  length: 1,
  convRule: rule6
}, {
  start: 9840,
  length: 248,
  convRule: rule13
}, {
  start: 10088,
  length: 1,
  convRule: rule4
}, {
  start: 10089,
  length: 1,
  convRule: rule5
}, {
  start: 10090,
  length: 1,
  convRule: rule4
}, {
  start: 10091,
  length: 1,
  convRule: rule5
}, {
  start: 10092,
  length: 1,
  convRule: rule4
}, {
  start: 10093,
  length: 1,
  convRule: rule5
}, {
  start: 10094,
  length: 1,
  convRule: rule4
}, {
  start: 10095,
  length: 1,
  convRule: rule5
}, {
  start: 10096,
  length: 1,
  convRule: rule4
}, {
  start: 10097,
  length: 1,
  convRule: rule5
}, {
  start: 10098,
  length: 1,
  convRule: rule4
}, {
  start: 10099,
  length: 1,
  convRule: rule5
}, {
  start: 10100,
  length: 1,
  convRule: rule4
}, {
  start: 10101,
  length: 1,
  convRule: rule5
}, {
  start: 10102,
  length: 30,
  convRule: rule17
}, {
  start: 10132,
  length: 44,
  convRule: rule13
}, {
  start: 10176,
  length: 5,
  convRule: rule6
}, {
  start: 10181,
  length: 1,
  convRule: rule4
}, {
  start: 10182,
  length: 1,
  convRule: rule5
}, {
  start: 10183,
  length: 31,
  convRule: rule6
}, {
  start: 10214,
  length: 1,
  convRule: rule4
}, {
  start: 10215,
  length: 1,
  convRule: rule5
}, {
  start: 10216,
  length: 1,
  convRule: rule4
}, {
  start: 10217,
  length: 1,
  convRule: rule5
}, {
  start: 10218,
  length: 1,
  convRule: rule4
}, {
  start: 10219,
  length: 1,
  convRule: rule5
}, {
  start: 10220,
  length: 1,
  convRule: rule4
}, {
  start: 10221,
  length: 1,
  convRule: rule5
}, {
  start: 10222,
  length: 1,
  convRule: rule4
}, {
  start: 10223,
  length: 1,
  convRule: rule5
}, {
  start: 10224,
  length: 16,
  convRule: rule6
}, {
  start: 10240,
  length: 256,
  convRule: rule13
}, {
  start: 10496,
  length: 131,
  convRule: rule6
}, {
  start: 10627,
  length: 1,
  convRule: rule4
}, {
  start: 10628,
  length: 1,
  convRule: rule5
}, {
  start: 10629,
  length: 1,
  convRule: rule4
}, {
  start: 10630,
  length: 1,
  convRule: rule5
}, {
  start: 10631,
  length: 1,
  convRule: rule4
}, {
  start: 10632,
  length: 1,
  convRule: rule5
}, {
  start: 10633,
  length: 1,
  convRule: rule4
}, {
  start: 10634,
  length: 1,
  convRule: rule5
}, {
  start: 10635,
  length: 1,
  convRule: rule4
}, {
  start: 10636,
  length: 1,
  convRule: rule5
}, {
  start: 10637,
  length: 1,
  convRule: rule4
}, {
  start: 10638,
  length: 1,
  convRule: rule5
}, {
  start: 10639,
  length: 1,
  convRule: rule4
}, {
  start: 10640,
  length: 1,
  convRule: rule5
}, {
  start: 10641,
  length: 1,
  convRule: rule4
}, {
  start: 10642,
  length: 1,
  convRule: rule5
}, {
  start: 10643,
  length: 1,
  convRule: rule4
}, {
  start: 10644,
  length: 1,
  convRule: rule5
}, {
  start: 10645,
  length: 1,
  convRule: rule4
}, {
  start: 10646,
  length: 1,
  convRule: rule5
}, {
  start: 10647,
  length: 1,
  convRule: rule4
}, {
  start: 10648,
  length: 1,
  convRule: rule5
}, {
  start: 10649,
  length: 63,
  convRule: rule6
}, {
  start: 10712,
  length: 1,
  convRule: rule4
}, {
  start: 10713,
  length: 1,
  convRule: rule5
}, {
  start: 10714,
  length: 1,
  convRule: rule4
}, {
  start: 10715,
  length: 1,
  convRule: rule5
}, {
  start: 10716,
  length: 32,
  convRule: rule6
}, {
  start: 10748,
  length: 1,
  convRule: rule4
}, {
  start: 10749,
  length: 1,
  convRule: rule5
}, {
  start: 10750,
  length: 258,
  convRule: rule6
}, {
  start: 11008,
  length: 48,
  convRule: rule13
}, {
  start: 11056,
  length: 21,
  convRule: rule6
}, {
  start: 11077,
  length: 2,
  convRule: rule13
}, {
  start: 11079,
  length: 6,
  convRule: rule6
}, {
  start: 11085,
  length: 39,
  convRule: rule13
}, {
  start: 11126,
  length: 32,
  convRule: rule13
}, {
  start: 11159,
  length: 105,
  convRule: rule13
}, {
  start: 11264,
  length: 47,
  convRule: rule122
}, {
  start: 11312,
  length: 47,
  convRule: rule123
}, {
  start: 11360,
  length: 1,
  convRule: rule22
}, {
  start: 11361,
  length: 1,
  convRule: rule23
}, {
  start: 11362,
  length: 1,
  convRule: rule172
}, {
  start: 11363,
  length: 1,
  convRule: rule173
}, {
  start: 11364,
  length: 1,
  convRule: rule174
}, {
  start: 11365,
  length: 1,
  convRule: rule175
}, {
  start: 11366,
  length: 1,
  convRule: rule176
}, {
  start: 11367,
  length: 1,
  convRule: rule22
}, {
  start: 11368,
  length: 1,
  convRule: rule23
}, {
  start: 11369,
  length: 1,
  convRule: rule22
}, {
  start: 11370,
  length: 1,
  convRule: rule23
}, {
  start: 11371,
  length: 1,
  convRule: rule22
}, {
  start: 11372,
  length: 1,
  convRule: rule23
}, {
  start: 11373,
  length: 1,
  convRule: rule177
}, {
  start: 11374,
  length: 1,
  convRule: rule178
}, {
  start: 11375,
  length: 1,
  convRule: rule179
}, {
  start: 11376,
  length: 1,
  convRule: rule180
}, {
  start: 11377,
  length: 1,
  convRule: rule20
}, {
  start: 11378,
  length: 1,
  convRule: rule22
}, {
  start: 11379,
  length: 1,
  convRule: rule23
}, {
  start: 11380,
  length: 1,
  convRule: rule20
}, {
  start: 11381,
  length: 1,
  convRule: rule22
}, {
  start: 11382,
  length: 1,
  convRule: rule23
}, {
  start: 11383,
  length: 5,
  convRule: rule20
}, {
  start: 11388,
  length: 2,
  convRule: rule91
}, {
  start: 11390,
  length: 2,
  convRule: rule181
}, {
  start: 11392,
  length: 1,
  convRule: rule22
}, {
  start: 11393,
  length: 1,
  convRule: rule23
}, {
  start: 11394,
  length: 1,
  convRule: rule22
}, {
  start: 11395,
  length: 1,
  convRule: rule23
}, {
  start: 11396,
  length: 1,
  convRule: rule22
}, {
  start: 11397,
  length: 1,
  convRule: rule23
}, {
  start: 11398,
  length: 1,
  convRule: rule22
}, {
  start: 11399,
  length: 1,
  convRule: rule23
}, {
  start: 11400,
  length: 1,
  convRule: rule22
}, {
  start: 11401,
  length: 1,
  convRule: rule23
}, {
  start: 11402,
  length: 1,
  convRule: rule22
}, {
  start: 11403,
  length: 1,
  convRule: rule23
}, {
  start: 11404,
  length: 1,
  convRule: rule22
}, {
  start: 11405,
  length: 1,
  convRule: rule23
}, {
  start: 11406,
  length: 1,
  convRule: rule22
}, {
  start: 11407,
  length: 1,
  convRule: rule23
}, {
  start: 11408,
  length: 1,
  convRule: rule22
}, {
  start: 11409,
  length: 1,
  convRule: rule23
}, {
  start: 11410,
  length: 1,
  convRule: rule22
}, {
  start: 11411,
  length: 1,
  convRule: rule23
}, {
  start: 11412,
  length: 1,
  convRule: rule22
}, {
  start: 11413,
  length: 1,
  convRule: rule23
}, {
  start: 11414,
  length: 1,
  convRule: rule22
}, {
  start: 11415,
  length: 1,
  convRule: rule23
}, {
  start: 11416,
  length: 1,
  convRule: rule22
}, {
  start: 11417,
  length: 1,
  convRule: rule23
}, {
  start: 11418,
  length: 1,
  convRule: rule22
}, {
  start: 11419,
  length: 1,
  convRule: rule23
}, {
  start: 11420,
  length: 1,
  convRule: rule22
}, {
  start: 11421,
  length: 1,
  convRule: rule23
}, {
  start: 11422,
  length: 1,
  convRule: rule22
}, {
  start: 11423,
  length: 1,
  convRule: rule23
}, {
  start: 11424,
  length: 1,
  convRule: rule22
}, {
  start: 11425,
  length: 1,
  convRule: rule23
}, {
  start: 11426,
  length: 1,
  convRule: rule22
}, {
  start: 11427,
  length: 1,
  convRule: rule23
}, {
  start: 11428,
  length: 1,
  convRule: rule22
}, {
  start: 11429,
  length: 1,
  convRule: rule23
}, {
  start: 11430,
  length: 1,
  convRule: rule22
}, {
  start: 11431,
  length: 1,
  convRule: rule23
}, {
  start: 11432,
  length: 1,
  convRule: rule22
}, {
  start: 11433,
  length: 1,
  convRule: rule23
}, {
  start: 11434,
  length: 1,
  convRule: rule22
}, {
  start: 11435,
  length: 1,
  convRule: rule23
}, {
  start: 11436,
  length: 1,
  convRule: rule22
}, {
  start: 11437,
  length: 1,
  convRule: rule23
}, {
  start: 11438,
  length: 1,
  convRule: rule22
}, {
  start: 11439,
  length: 1,
  convRule: rule23
}, {
  start: 11440,
  length: 1,
  convRule: rule22
}, {
  start: 11441,
  length: 1,
  convRule: rule23
}, {
  start: 11442,
  length: 1,
  convRule: rule22
}, {
  start: 11443,
  length: 1,
  convRule: rule23
}, {
  start: 11444,
  length: 1,
  convRule: rule22
}, {
  start: 11445,
  length: 1,
  convRule: rule23
}, {
  start: 11446,
  length: 1,
  convRule: rule22
}, {
  start: 11447,
  length: 1,
  convRule: rule23
}, {
  start: 11448,
  length: 1,
  convRule: rule22
}, {
  start: 11449,
  length: 1,
  convRule: rule23
}, {
  start: 11450,
  length: 1,
  convRule: rule22
}, {
  start: 11451,
  length: 1,
  convRule: rule23
}, {
  start: 11452,
  length: 1,
  convRule: rule22
}, {
  start: 11453,
  length: 1,
  convRule: rule23
}, {
  start: 11454,
  length: 1,
  convRule: rule22
}, {
  start: 11455,
  length: 1,
  convRule: rule23
}, {
  start: 11456,
  length: 1,
  convRule: rule22
}, {
  start: 11457,
  length: 1,
  convRule: rule23
}, {
  start: 11458,
  length: 1,
  convRule: rule22
}, {
  start: 11459,
  length: 1,
  convRule: rule23
}, {
  start: 11460,
  length: 1,
  convRule: rule22
}, {
  start: 11461,
  length: 1,
  convRule: rule23
}, {
  start: 11462,
  length: 1,
  convRule: rule22
}, {
  start: 11463,
  length: 1,
  convRule: rule23
}, {
  start: 11464,
  length: 1,
  convRule: rule22
}, {
  start: 11465,
  length: 1,
  convRule: rule23
}, {
  start: 11466,
  length: 1,
  convRule: rule22
}, {
  start: 11467,
  length: 1,
  convRule: rule23
}, {
  start: 11468,
  length: 1,
  convRule: rule22
}, {
  start: 11469,
  length: 1,
  convRule: rule23
}, {
  start: 11470,
  length: 1,
  convRule: rule22
}, {
  start: 11471,
  length: 1,
  convRule: rule23
}, {
  start: 11472,
  length: 1,
  convRule: rule22
}, {
  start: 11473,
  length: 1,
  convRule: rule23
}, {
  start: 11474,
  length: 1,
  convRule: rule22
}, {
  start: 11475,
  length: 1,
  convRule: rule23
}, {
  start: 11476,
  length: 1,
  convRule: rule22
}, {
  start: 11477,
  length: 1,
  convRule: rule23
}, {
  start: 11478,
  length: 1,
  convRule: rule22
}, {
  start: 11479,
  length: 1,
  convRule: rule23
}, {
  start: 11480,
  length: 1,
  convRule: rule22
}, {
  start: 11481,
  length: 1,
  convRule: rule23
}, {
  start: 11482,
  length: 1,
  convRule: rule22
}, {
  start: 11483,
  length: 1,
  convRule: rule23
}, {
  start: 11484,
  length: 1,
  convRule: rule22
}, {
  start: 11485,
  length: 1,
  convRule: rule23
}, {
  start: 11486,
  length: 1,
  convRule: rule22
}, {
  start: 11487,
  length: 1,
  convRule: rule23
}, {
  start: 11488,
  length: 1,
  convRule: rule22
}, {
  start: 11489,
  length: 1,
  convRule: rule23
}, {
  start: 11490,
  length: 1,
  convRule: rule22
}, {
  start: 11491,
  length: 1,
  convRule: rule23
}, {
  start: 11492,
  length: 1,
  convRule: rule20
}, {
  start: 11493,
  length: 6,
  convRule: rule13
}, {
  start: 11499,
  length: 1,
  convRule: rule22
}, {
  start: 11500,
  length: 1,
  convRule: rule23
}, {
  start: 11501,
  length: 1,
  convRule: rule22
}, {
  start: 11502,
  length: 1,
  convRule: rule23
}, {
  start: 11503,
  length: 3,
  convRule: rule92
}, {
  start: 11506,
  length: 1,
  convRule: rule22
}, {
  start: 11507,
  length: 1,
  convRule: rule23
}, {
  start: 11513,
  length: 4,
  convRule: rule2
}, {
  start: 11517,
  length: 1,
  convRule: rule17
}, {
  start: 11518,
  length: 2,
  convRule: rule2
}, {
  start: 11520,
  length: 38,
  convRule: rule182
}, {
  start: 11559,
  length: 1,
  convRule: rule182
}, {
  start: 11565,
  length: 1,
  convRule: rule182
}, {
  start: 11568,
  length: 56,
  convRule: rule14
}, {
  start: 11631,
  length: 1,
  convRule: rule91
}, {
  start: 11632,
  length: 1,
  convRule: rule2
}, {
  start: 11647,
  length: 1,
  convRule: rule92
}, {
  start: 11648,
  length: 23,
  convRule: rule14
}, {
  start: 11680,
  length: 7,
  convRule: rule14
}, {
  start: 11688,
  length: 7,
  convRule: rule14
}, {
  start: 11696,
  length: 7,
  convRule: rule14
}, {
  start: 11704,
  length: 7,
  convRule: rule14
}, {
  start: 11712,
  length: 7,
  convRule: rule14
}, {
  start: 11720,
  length: 7,
  convRule: rule14
}, {
  start: 11728,
  length: 7,
  convRule: rule14
}, {
  start: 11736,
  length: 7,
  convRule: rule14
}, {
  start: 11744,
  length: 32,
  convRule: rule92
}, {
  start: 11776,
  length: 2,
  convRule: rule2
}, {
  start: 11778,
  length: 1,
  convRule: rule15
}, {
  start: 11779,
  length: 1,
  convRule: rule19
}, {
  start: 11780,
  length: 1,
  convRule: rule15
}, {
  start: 11781,
  length: 1,
  convRule: rule19
}, {
  start: 11782,
  length: 3,
  convRule: rule2
}, {
  start: 11785,
  length: 1,
  convRule: rule15
}, {
  start: 11786,
  length: 1,
  convRule: rule19
}, {
  start: 11787,
  length: 1,
  convRule: rule2
}, {
  start: 11788,
  length: 1,
  convRule: rule15
}, {
  start: 11789,
  length: 1,
  convRule: rule19
}, {
  start: 11790,
  length: 9,
  convRule: rule2
}, {
  start: 11799,
  length: 1,
  convRule: rule7
}, {
  start: 11800,
  length: 2,
  convRule: rule2
}, {
  start: 11802,
  length: 1,
  convRule: rule7
}, {
  start: 11803,
  length: 1,
  convRule: rule2
}, {
  start: 11804,
  length: 1,
  convRule: rule15
}, {
  start: 11805,
  length: 1,
  convRule: rule19
}, {
  start: 11806,
  length: 2,
  convRule: rule2
}, {
  start: 11808,
  length: 1,
  convRule: rule15
}, {
  start: 11809,
  length: 1,
  convRule: rule19
}, {
  start: 11810,
  length: 1,
  convRule: rule4
}, {
  start: 11811,
  length: 1,
  convRule: rule5
}, {
  start: 11812,
  length: 1,
  convRule: rule4
}, {
  start: 11813,
  length: 1,
  convRule: rule5
}, {
  start: 11814,
  length: 1,
  convRule: rule4
}, {
  start: 11815,
  length: 1,
  convRule: rule5
}, {
  start: 11816,
  length: 1,
  convRule: rule4
}, {
  start: 11817,
  length: 1,
  convRule: rule5
}, {
  start: 11818,
  length: 5,
  convRule: rule2
}, {
  start: 11823,
  length: 1,
  convRule: rule91
}, {
  start: 11824,
  length: 10,
  convRule: rule2
}, {
  start: 11834,
  length: 2,
  convRule: rule7
}, {
  start: 11836,
  length: 4,
  convRule: rule2
}, {
  start: 11840,
  length: 1,
  convRule: rule7
}, {
  start: 11841,
  length: 1,
  convRule: rule2
}, {
  start: 11842,
  length: 1,
  convRule: rule4
}, {
  start: 11843,
  length: 13,
  convRule: rule2
}, {
  start: 11856,
  length: 2,
  convRule: rule13
}, {
  start: 11858,
  length: 1,
  convRule: rule2
}, {
  start: 11904,
  length: 26,
  convRule: rule13
}, {
  start: 11931,
  length: 89,
  convRule: rule13
}, {
  start: 12032,
  length: 214,
  convRule: rule13
}, {
  start: 12272,
  length: 12,
  convRule: rule13
}, {
  start: 12288,
  length: 1,
  convRule: rule1
}, {
  start: 12289,
  length: 3,
  convRule: rule2
}, {
  start: 12292,
  length: 1,
  convRule: rule13
}, {
  start: 12293,
  length: 1,
  convRule: rule91
}, {
  start: 12294,
  length: 1,
  convRule: rule14
}, {
  start: 12295,
  length: 1,
  convRule: rule128
}, {
  start: 12296,
  length: 1,
  convRule: rule4
}, {
  start: 12297,
  length: 1,
  convRule: rule5
}, {
  start: 12298,
  length: 1,
  convRule: rule4
}, {
  start: 12299,
  length: 1,
  convRule: rule5
}, {
  start: 12300,
  length: 1,
  convRule: rule4
}, {
  start: 12301,
  length: 1,
  convRule: rule5
}, {
  start: 12302,
  length: 1,
  convRule: rule4
}, {
  start: 12303,
  length: 1,
  convRule: rule5
}, {
  start: 12304,
  length: 1,
  convRule: rule4
}, {
  start: 12305,
  length: 1,
  convRule: rule5
}, {
  start: 12306,
  length: 2,
  convRule: rule13
}, {
  start: 12308,
  length: 1,
  convRule: rule4
}, {
  start: 12309,
  length: 1,
  convRule: rule5
}, {
  start: 12310,
  length: 1,
  convRule: rule4
}, {
  start: 12311,
  length: 1,
  convRule: rule5
}, {
  start: 12312,
  length: 1,
  convRule: rule4
}, {
  start: 12313,
  length: 1,
  convRule: rule5
}, {
  start: 12314,
  length: 1,
  convRule: rule4
}, {
  start: 12315,
  length: 1,
  convRule: rule5
}, {
  start: 12316,
  length: 1,
  convRule: rule7
}, {
  start: 12317,
  length: 1,
  convRule: rule4
}, {
  start: 12318,
  length: 2,
  convRule: rule5
}, {
  start: 12320,
  length: 1,
  convRule: rule13
}, {
  start: 12321,
  length: 9,
  convRule: rule128
}, {
  start: 12330,
  length: 4,
  convRule: rule92
}, {
  start: 12334,
  length: 2,
  convRule: rule124
}, {
  start: 12336,
  length: 1,
  convRule: rule7
}, {
  start: 12337,
  length: 5,
  convRule: rule91
}, {
  start: 12342,
  length: 2,
  convRule: rule13
}, {
  start: 12344,
  length: 3,
  convRule: rule128
}, {
  start: 12347,
  length: 1,
  convRule: rule91
}, {
  start: 12348,
  length: 1,
  convRule: rule14
}, {
  start: 12349,
  length: 1,
  convRule: rule2
}, {
  start: 12350,
  length: 2,
  convRule: rule13
}, {
  start: 12353,
  length: 86,
  convRule: rule14
}, {
  start: 12441,
  length: 2,
  convRule: rule92
}, {
  start: 12443,
  length: 2,
  convRule: rule10
}, {
  start: 12445,
  length: 2,
  convRule: rule91
}, {
  start: 12447,
  length: 1,
  convRule: rule14
}, {
  start: 12448,
  length: 1,
  convRule: rule7
}, {
  start: 12449,
  length: 90,
  convRule: rule14
}, {
  start: 12539,
  length: 1,
  convRule: rule2
}, {
  start: 12540,
  length: 3,
  convRule: rule91
}, {
  start: 12543,
  length: 1,
  convRule: rule14
}, {
  start: 12549,
  length: 43,
  convRule: rule14
}, {
  start: 12593,
  length: 94,
  convRule: rule14
}, {
  start: 12688,
  length: 2,
  convRule: rule13
}, {
  start: 12690,
  length: 4,
  convRule: rule17
}, {
  start: 12694,
  length: 10,
  convRule: rule13
}, {
  start: 12704,
  length: 32,
  convRule: rule14
}, {
  start: 12736,
  length: 36,
  convRule: rule13
}, {
  start: 12784,
  length: 16,
  convRule: rule14
}, {
  start: 12800,
  length: 31,
  convRule: rule13
}, {
  start: 12832,
  length: 10,
  convRule: rule17
}, {
  start: 12842,
  length: 30,
  convRule: rule13
}, {
  start: 12872,
  length: 8,
  convRule: rule17
}, {
  start: 12880,
  length: 1,
  convRule: rule13
}, {
  start: 12881,
  length: 15,
  convRule: rule17
}, {
  start: 12896,
  length: 32,
  convRule: rule13
}, {
  start: 12928,
  length: 10,
  convRule: rule17
}, {
  start: 12938,
  length: 39,
  convRule: rule13
}, {
  start: 12977,
  length: 15,
  convRule: rule17
}, {
  start: 12992,
  length: 320,
  convRule: rule13
}, {
  start: 13312,
  length: 6592,
  convRule: rule14
}, {
  start: 19904,
  length: 64,
  convRule: rule13
}, {
  start: 19968,
  length: 20989,
  convRule: rule14
}, {
  start: 40960,
  length: 21,
  convRule: rule14
}, {
  start: 40981,
  length: 1,
  convRule: rule91
}, {
  start: 40982,
  length: 1143,
  convRule: rule14
}, {
  start: 42128,
  length: 55,
  convRule: rule13
}, {
  start: 42192,
  length: 40,
  convRule: rule14
}, {
  start: 42232,
  length: 6,
  convRule: rule91
}, {
  start: 42238,
  length: 2,
  convRule: rule2
}, {
  start: 42240,
  length: 268,
  convRule: rule14
}, {
  start: 42508,
  length: 1,
  convRule: rule91
}, {
  start: 42509,
  length: 3,
  convRule: rule2
}, {
  start: 42512,
  length: 16,
  convRule: rule14
}, {
  start: 42528,
  length: 10,
  convRule: rule8
}, {
  start: 42538,
  length: 2,
  convRule: rule14
}, {
  start: 42560,
  length: 1,
  convRule: rule22
}, {
  start: 42561,
  length: 1,
  convRule: rule23
}, {
  start: 42562,
  length: 1,
  convRule: rule22
}, {
  start: 42563,
  length: 1,
  convRule: rule23
}, {
  start: 42564,
  length: 1,
  convRule: rule22
}, {
  start: 42565,
  length: 1,
  convRule: rule23
}, {
  start: 42566,
  length: 1,
  convRule: rule22
}, {
  start: 42567,
  length: 1,
  convRule: rule23
}, {
  start: 42568,
  length: 1,
  convRule: rule22
}, {
  start: 42569,
  length: 1,
  convRule: rule23
}, {
  start: 42570,
  length: 1,
  convRule: rule22
}, {
  start: 42571,
  length: 1,
  convRule: rule23
}, {
  start: 42572,
  length: 1,
  convRule: rule22
}, {
  start: 42573,
  length: 1,
  convRule: rule23
}, {
  start: 42574,
  length: 1,
  convRule: rule22
}, {
  start: 42575,
  length: 1,
  convRule: rule23
}, {
  start: 42576,
  length: 1,
  convRule: rule22
}, {
  start: 42577,
  length: 1,
  convRule: rule23
}, {
  start: 42578,
  length: 1,
  convRule: rule22
}, {
  start: 42579,
  length: 1,
  convRule: rule23
}, {
  start: 42580,
  length: 1,
  convRule: rule22
}, {
  start: 42581,
  length: 1,
  convRule: rule23
}, {
  start: 42582,
  length: 1,
  convRule: rule22
}, {
  start: 42583,
  length: 1,
  convRule: rule23
}, {
  start: 42584,
  length: 1,
  convRule: rule22
}, {
  start: 42585,
  length: 1,
  convRule: rule23
}, {
  start: 42586,
  length: 1,
  convRule: rule22
}, {
  start: 42587,
  length: 1,
  convRule: rule23
}, {
  start: 42588,
  length: 1,
  convRule: rule22
}, {
  start: 42589,
  length: 1,
  convRule: rule23
}, {
  start: 42590,
  length: 1,
  convRule: rule22
}, {
  start: 42591,
  length: 1,
  convRule: rule23
}, {
  start: 42592,
  length: 1,
  convRule: rule22
}, {
  start: 42593,
  length: 1,
  convRule: rule23
}, {
  start: 42594,
  length: 1,
  convRule: rule22
}, {
  start: 42595,
  length: 1,
  convRule: rule23
}, {
  start: 42596,
  length: 1,
  convRule: rule22
}, {
  start: 42597,
  length: 1,
  convRule: rule23
}, {
  start: 42598,
  length: 1,
  convRule: rule22
}, {
  start: 42599,
  length: 1,
  convRule: rule23
}, {
  start: 42600,
  length: 1,
  convRule: rule22
}, {
  start: 42601,
  length: 1,
  convRule: rule23
}, {
  start: 42602,
  length: 1,
  convRule: rule22
}, {
  start: 42603,
  length: 1,
  convRule: rule23
}, {
  start: 42604,
  length: 1,
  convRule: rule22
}, {
  start: 42605,
  length: 1,
  convRule: rule23
}, {
  start: 42606,
  length: 1,
  convRule: rule14
}, {
  start: 42607,
  length: 1,
  convRule: rule92
}, {
  start: 42608,
  length: 3,
  convRule: rule119
}, {
  start: 42611,
  length: 1,
  convRule: rule2
}, {
  start: 42612,
  length: 10,
  convRule: rule92
}, {
  start: 42622,
  length: 1,
  convRule: rule2
}, {
  start: 42623,
  length: 1,
  convRule: rule91
}, {
  start: 42624,
  length: 1,
  convRule: rule22
}, {
  start: 42625,
  length: 1,
  convRule: rule23
}, {
  start: 42626,
  length: 1,
  convRule: rule22
}, {
  start: 42627,
  length: 1,
  convRule: rule23
}, {
  start: 42628,
  length: 1,
  convRule: rule22
}, {
  start: 42629,
  length: 1,
  convRule: rule23
}, {
  start: 42630,
  length: 1,
  convRule: rule22
}, {
  start: 42631,
  length: 1,
  convRule: rule23
}, {
  start: 42632,
  length: 1,
  convRule: rule22
}, {
  start: 42633,
  length: 1,
  convRule: rule23
}, {
  start: 42634,
  length: 1,
  convRule: rule22
}, {
  start: 42635,
  length: 1,
  convRule: rule23
}, {
  start: 42636,
  length: 1,
  convRule: rule22
}, {
  start: 42637,
  length: 1,
  convRule: rule23
}, {
  start: 42638,
  length: 1,
  convRule: rule22
}, {
  start: 42639,
  length: 1,
  convRule: rule23
}, {
  start: 42640,
  length: 1,
  convRule: rule22
}, {
  start: 42641,
  length: 1,
  convRule: rule23
}, {
  start: 42642,
  length: 1,
  convRule: rule22
}, {
  start: 42643,
  length: 1,
  convRule: rule23
}, {
  start: 42644,
  length: 1,
  convRule: rule22
}, {
  start: 42645,
  length: 1,
  convRule: rule23
}, {
  start: 42646,
  length: 1,
  convRule: rule22
}, {
  start: 42647,
  length: 1,
  convRule: rule23
}, {
  start: 42648,
  length: 1,
  convRule: rule22
}, {
  start: 42649,
  length: 1,
  convRule: rule23
}, {
  start: 42650,
  length: 1,
  convRule: rule22
}, {
  start: 42651,
  length: 1,
  convRule: rule23
}, {
  start: 42652,
  length: 2,
  convRule: rule91
}, {
  start: 42654,
  length: 2,
  convRule: rule92
}, {
  start: 42656,
  length: 70,
  convRule: rule14
}, {
  start: 42726,
  length: 10,
  convRule: rule128
}, {
  start: 42736,
  length: 2,
  convRule: rule92
}, {
  start: 42738,
  length: 6,
  convRule: rule2
}, {
  start: 42752,
  length: 23,
  convRule: rule10
}, {
  start: 42775,
  length: 9,
  convRule: rule91
}, {
  start: 42784,
  length: 2,
  convRule: rule10
}, {
  start: 42786,
  length: 1,
  convRule: rule22
}, {
  start: 42787,
  length: 1,
  convRule: rule23
}, {
  start: 42788,
  length: 1,
  convRule: rule22
}, {
  start: 42789,
  length: 1,
  convRule: rule23
}, {
  start: 42790,
  length: 1,
  convRule: rule22
}, {
  start: 42791,
  length: 1,
  convRule: rule23
}, {
  start: 42792,
  length: 1,
  convRule: rule22
}, {
  start: 42793,
  length: 1,
  convRule: rule23
}, {
  start: 42794,
  length: 1,
  convRule: rule22
}, {
  start: 42795,
  length: 1,
  convRule: rule23
}, {
  start: 42796,
  length: 1,
  convRule: rule22
}, {
  start: 42797,
  length: 1,
  convRule: rule23
}, {
  start: 42798,
  length: 1,
  convRule: rule22
}, {
  start: 42799,
  length: 1,
  convRule: rule23
}, {
  start: 42800,
  length: 2,
  convRule: rule20
}, {
  start: 42802,
  length: 1,
  convRule: rule22
}, {
  start: 42803,
  length: 1,
  convRule: rule23
}, {
  start: 42804,
  length: 1,
  convRule: rule22
}, {
  start: 42805,
  length: 1,
  convRule: rule23
}, {
  start: 42806,
  length: 1,
  convRule: rule22
}, {
  start: 42807,
  length: 1,
  convRule: rule23
}, {
  start: 42808,
  length: 1,
  convRule: rule22
}, {
  start: 42809,
  length: 1,
  convRule: rule23
}, {
  start: 42810,
  length: 1,
  convRule: rule22
}, {
  start: 42811,
  length: 1,
  convRule: rule23
}, {
  start: 42812,
  length: 1,
  convRule: rule22
}, {
  start: 42813,
  length: 1,
  convRule: rule23
}, {
  start: 42814,
  length: 1,
  convRule: rule22
}, {
  start: 42815,
  length: 1,
  convRule: rule23
}, {
  start: 42816,
  length: 1,
  convRule: rule22
}, {
  start: 42817,
  length: 1,
  convRule: rule23
}, {
  start: 42818,
  length: 1,
  convRule: rule22
}, {
  start: 42819,
  length: 1,
  convRule: rule23
}, {
  start: 42820,
  length: 1,
  convRule: rule22
}, {
  start: 42821,
  length: 1,
  convRule: rule23
}, {
  start: 42822,
  length: 1,
  convRule: rule22
}, {
  start: 42823,
  length: 1,
  convRule: rule23
}, {
  start: 42824,
  length: 1,
  convRule: rule22
}, {
  start: 42825,
  length: 1,
  convRule: rule23
}, {
  start: 42826,
  length: 1,
  convRule: rule22
}, {
  start: 42827,
  length: 1,
  convRule: rule23
}, {
  start: 42828,
  length: 1,
  convRule: rule22
}, {
  start: 42829,
  length: 1,
  convRule: rule23
}, {
  start: 42830,
  length: 1,
  convRule: rule22
}, {
  start: 42831,
  length: 1,
  convRule: rule23
}, {
  start: 42832,
  length: 1,
  convRule: rule22
}, {
  start: 42833,
  length: 1,
  convRule: rule23
}, {
  start: 42834,
  length: 1,
  convRule: rule22
}, {
  start: 42835,
  length: 1,
  convRule: rule23
}, {
  start: 42836,
  length: 1,
  convRule: rule22
}, {
  start: 42837,
  length: 1,
  convRule: rule23
}, {
  start: 42838,
  length: 1,
  convRule: rule22
}, {
  start: 42839,
  length: 1,
  convRule: rule23
}, {
  start: 42840,
  length: 1,
  convRule: rule22
}, {
  start: 42841,
  length: 1,
  convRule: rule23
}, {
  start: 42842,
  length: 1,
  convRule: rule22
}, {
  start: 42843,
  length: 1,
  convRule: rule23
}, {
  start: 42844,
  length: 1,
  convRule: rule22
}, {
  start: 42845,
  length: 1,
  convRule: rule23
}, {
  start: 42846,
  length: 1,
  convRule: rule22
}, {
  start: 42847,
  length: 1,
  convRule: rule23
}, {
  start: 42848,
  length: 1,
  convRule: rule22
}, {
  start: 42849,
  length: 1,
  convRule: rule23
}, {
  start: 42850,
  length: 1,
  convRule: rule22
}, {
  start: 42851,
  length: 1,
  convRule: rule23
}, {
  start: 42852,
  length: 1,
  convRule: rule22
}, {
  start: 42853,
  length: 1,
  convRule: rule23
}, {
  start: 42854,
  length: 1,
  convRule: rule22
}, {
  start: 42855,
  length: 1,
  convRule: rule23
}, {
  start: 42856,
  length: 1,
  convRule: rule22
}, {
  start: 42857,
  length: 1,
  convRule: rule23
}, {
  start: 42858,
  length: 1,
  convRule: rule22
}, {
  start: 42859,
  length: 1,
  convRule: rule23
}, {
  start: 42860,
  length: 1,
  convRule: rule22
}, {
  start: 42861,
  length: 1,
  convRule: rule23
}, {
  start: 42862,
  length: 1,
  convRule: rule22
}, {
  start: 42863,
  length: 1,
  convRule: rule23
}, {
  start: 42864,
  length: 1,
  convRule: rule91
}, {
  start: 42865,
  length: 8,
  convRule: rule20
}, {
  start: 42873,
  length: 1,
  convRule: rule22
}, {
  start: 42874,
  length: 1,
  convRule: rule23
}, {
  start: 42875,
  length: 1,
  convRule: rule22
}, {
  start: 42876,
  length: 1,
  convRule: rule23
}, {
  start: 42877,
  length: 1,
  convRule: rule183
}, {
  start: 42878,
  length: 1,
  convRule: rule22
}, {
  start: 42879,
  length: 1,
  convRule: rule23
}, {
  start: 42880,
  length: 1,
  convRule: rule22
}, {
  start: 42881,
  length: 1,
  convRule: rule23
}, {
  start: 42882,
  length: 1,
  convRule: rule22
}, {
  start: 42883,
  length: 1,
  convRule: rule23
}, {
  start: 42884,
  length: 1,
  convRule: rule22
}, {
  start: 42885,
  length: 1,
  convRule: rule23
}, {
  start: 42886,
  length: 1,
  convRule: rule22
}, {
  start: 42887,
  length: 1,
  convRule: rule23
}, {
  start: 42888,
  length: 1,
  convRule: rule91
}, {
  start: 42889,
  length: 2,
  convRule: rule10
}, {
  start: 42891,
  length: 1,
  convRule: rule22
}, {
  start: 42892,
  length: 1,
  convRule: rule23
}, {
  start: 42893,
  length: 1,
  convRule: rule184
}, {
  start: 42894,
  length: 1,
  convRule: rule20
}, {
  start: 42895,
  length: 1,
  convRule: rule14
}, {
  start: 42896,
  length: 1,
  convRule: rule22
}, {
  start: 42897,
  length: 1,
  convRule: rule23
}, {
  start: 42898,
  length: 1,
  convRule: rule22
}, {
  start: 42899,
  length: 1,
  convRule: rule23
}, {
  start: 42900,
  length: 1,
  convRule: rule185
}, {
  start: 42901,
  length: 1,
  convRule: rule20
}, {
  start: 42902,
  length: 1,
  convRule: rule22
}, {
  start: 42903,
  length: 1,
  convRule: rule23
}, {
  start: 42904,
  length: 1,
  convRule: rule22
}, {
  start: 42905,
  length: 1,
  convRule: rule23
}, {
  start: 42906,
  length: 1,
  convRule: rule22
}, {
  start: 42907,
  length: 1,
  convRule: rule23
}, {
  start: 42908,
  length: 1,
  convRule: rule22
}, {
  start: 42909,
  length: 1,
  convRule: rule23
}, {
  start: 42910,
  length: 1,
  convRule: rule22
}, {
  start: 42911,
  length: 1,
  convRule: rule23
}, {
  start: 42912,
  length: 1,
  convRule: rule22
}, {
  start: 42913,
  length: 1,
  convRule: rule23
}, {
  start: 42914,
  length: 1,
  convRule: rule22
}, {
  start: 42915,
  length: 1,
  convRule: rule23
}, {
  start: 42916,
  length: 1,
  convRule: rule22
}, {
  start: 42917,
  length: 1,
  convRule: rule23
}, {
  start: 42918,
  length: 1,
  convRule: rule22
}, {
  start: 42919,
  length: 1,
  convRule: rule23
}, {
  start: 42920,
  length: 1,
  convRule: rule22
}, {
  start: 42921,
  length: 1,
  convRule: rule23
}, {
  start: 42922,
  length: 1,
  convRule: rule186
}, {
  start: 42923,
  length: 1,
  convRule: rule187
}, {
  start: 42924,
  length: 1,
  convRule: rule188
}, {
  start: 42925,
  length: 1,
  convRule: rule189
}, {
  start: 42926,
  length: 1,
  convRule: rule186
}, {
  start: 42927,
  length: 1,
  convRule: rule20
}, {
  start: 42928,
  length: 1,
  convRule: rule190
}, {
  start: 42929,
  length: 1,
  convRule: rule191
}, {
  start: 42930,
  length: 1,
  convRule: rule192
}, {
  start: 42931,
  length: 1,
  convRule: rule193
}, {
  start: 42932,
  length: 1,
  convRule: rule22
}, {
  start: 42933,
  length: 1,
  convRule: rule23
}, {
  start: 42934,
  length: 1,
  convRule: rule22
}, {
  start: 42935,
  length: 1,
  convRule: rule23
}, {
  start: 42936,
  length: 1,
  convRule: rule22
}, {
  start: 42937,
  length: 1,
  convRule: rule23
}, {
  start: 42938,
  length: 1,
  convRule: rule22
}, {
  start: 42939,
  length: 1,
  convRule: rule23
}, {
  start: 42940,
  length: 1,
  convRule: rule22
}, {
  start: 42941,
  length: 1,
  convRule: rule23
}, {
  start: 42942,
  length: 1,
  convRule: rule22
}, {
  start: 42943,
  length: 1,
  convRule: rule23
}, {
  start: 42946,
  length: 1,
  convRule: rule22
}, {
  start: 42947,
  length: 1,
  convRule: rule23
}, {
  start: 42948,
  length: 1,
  convRule: rule194
}, {
  start: 42949,
  length: 1,
  convRule: rule195
}, {
  start: 42950,
  length: 1,
  convRule: rule196
}, {
  start: 42951,
  length: 1,
  convRule: rule22
}, {
  start: 42952,
  length: 1,
  convRule: rule23
}, {
  start: 42953,
  length: 1,
  convRule: rule22
}, {
  start: 42954,
  length: 1,
  convRule: rule23
}, {
  start: 42997,
  length: 1,
  convRule: rule22
}, {
  start: 42998,
  length: 1,
  convRule: rule23
}, {
  start: 42999,
  length: 1,
  convRule: rule14
}, {
  start: 43e3,
  length: 2,
  convRule: rule91
}, {
  start: 43002,
  length: 1,
  convRule: rule20
}, {
  start: 43003,
  length: 7,
  convRule: rule14
}, {
  start: 43010,
  length: 1,
  convRule: rule92
}, {
  start: 43011,
  length: 3,
  convRule: rule14
}, {
  start: 43014,
  length: 1,
  convRule: rule92
}, {
  start: 43015,
  length: 4,
  convRule: rule14
}, {
  start: 43019,
  length: 1,
  convRule: rule92
}, {
  start: 43020,
  length: 23,
  convRule: rule14
}, {
  start: 43043,
  length: 2,
  convRule: rule124
}, {
  start: 43045,
  length: 2,
  convRule: rule92
}, {
  start: 43047,
  length: 1,
  convRule: rule124
}, {
  start: 43048,
  length: 4,
  convRule: rule13
}, {
  start: 43052,
  length: 1,
  convRule: rule92
}, {
  start: 43056,
  length: 6,
  convRule: rule17
}, {
  start: 43062,
  length: 2,
  convRule: rule13
}, {
  start: 43064,
  length: 1,
  convRule: rule3
}, {
  start: 43065,
  length: 1,
  convRule: rule13
}, {
  start: 43072,
  length: 52,
  convRule: rule14
}, {
  start: 43124,
  length: 4,
  convRule: rule2
}, {
  start: 43136,
  length: 2,
  convRule: rule124
}, {
  start: 43138,
  length: 50,
  convRule: rule14
}, {
  start: 43188,
  length: 16,
  convRule: rule124
}, {
  start: 43204,
  length: 2,
  convRule: rule92
}, {
  start: 43214,
  length: 2,
  convRule: rule2
}, {
  start: 43216,
  length: 10,
  convRule: rule8
}, {
  start: 43232,
  length: 18,
  convRule: rule92
}, {
  start: 43250,
  length: 6,
  convRule: rule14
}, {
  start: 43256,
  length: 3,
  convRule: rule2
}, {
  start: 43259,
  length: 1,
  convRule: rule14
}, {
  start: 43260,
  length: 1,
  convRule: rule2
}, {
  start: 43261,
  length: 2,
  convRule: rule14
}, {
  start: 43263,
  length: 1,
  convRule: rule92
}, {
  start: 43264,
  length: 10,
  convRule: rule8
}, {
  start: 43274,
  length: 28,
  convRule: rule14
}, {
  start: 43302,
  length: 8,
  convRule: rule92
}, {
  start: 43310,
  length: 2,
  convRule: rule2
}, {
  start: 43312,
  length: 23,
  convRule: rule14
}, {
  start: 43335,
  length: 11,
  convRule: rule92
}, {
  start: 43346,
  length: 2,
  convRule: rule124
}, {
  start: 43359,
  length: 1,
  convRule: rule2
}, {
  start: 43360,
  length: 29,
  convRule: rule14
}, {
  start: 43392,
  length: 3,
  convRule: rule92
}, {
  start: 43395,
  length: 1,
  convRule: rule124
}, {
  start: 43396,
  length: 47,
  convRule: rule14
}, {
  start: 43443,
  length: 1,
  convRule: rule92
}, {
  start: 43444,
  length: 2,
  convRule: rule124
}, {
  start: 43446,
  length: 4,
  convRule: rule92
}, {
  start: 43450,
  length: 2,
  convRule: rule124
}, {
  start: 43452,
  length: 2,
  convRule: rule92
}, {
  start: 43454,
  length: 3,
  convRule: rule124
}, {
  start: 43457,
  length: 13,
  convRule: rule2
}, {
  start: 43471,
  length: 1,
  convRule: rule91
}, {
  start: 43472,
  length: 10,
  convRule: rule8
}, {
  start: 43486,
  length: 2,
  convRule: rule2
}, {
  start: 43488,
  length: 5,
  convRule: rule14
}, {
  start: 43493,
  length: 1,
  convRule: rule92
}, {
  start: 43494,
  length: 1,
  convRule: rule91
}, {
  start: 43495,
  length: 9,
  convRule: rule14
}, {
  start: 43504,
  length: 10,
  convRule: rule8
}, {
  start: 43514,
  length: 5,
  convRule: rule14
}, {
  start: 43520,
  length: 41,
  convRule: rule14
}, {
  start: 43561,
  length: 6,
  convRule: rule92
}, {
  start: 43567,
  length: 2,
  convRule: rule124
}, {
  start: 43569,
  length: 2,
  convRule: rule92
}, {
  start: 43571,
  length: 2,
  convRule: rule124
}, {
  start: 43573,
  length: 2,
  convRule: rule92
}, {
  start: 43584,
  length: 3,
  convRule: rule14
}, {
  start: 43587,
  length: 1,
  convRule: rule92
}, {
  start: 43588,
  length: 8,
  convRule: rule14
}, {
  start: 43596,
  length: 1,
  convRule: rule92
}, {
  start: 43597,
  length: 1,
  convRule: rule124
}, {
  start: 43600,
  length: 10,
  convRule: rule8
}, {
  start: 43612,
  length: 4,
  convRule: rule2
}, {
  start: 43616,
  length: 16,
  convRule: rule14
}, {
  start: 43632,
  length: 1,
  convRule: rule91
}, {
  start: 43633,
  length: 6,
  convRule: rule14
}, {
  start: 43639,
  length: 3,
  convRule: rule13
}, {
  start: 43642,
  length: 1,
  convRule: rule14
}, {
  start: 43643,
  length: 1,
  convRule: rule124
}, {
  start: 43644,
  length: 1,
  convRule: rule92
}, {
  start: 43645,
  length: 1,
  convRule: rule124
}, {
  start: 43646,
  length: 50,
  convRule: rule14
}, {
  start: 43696,
  length: 1,
  convRule: rule92
}, {
  start: 43697,
  length: 1,
  convRule: rule14
}, {
  start: 43698,
  length: 3,
  convRule: rule92
}, {
  start: 43701,
  length: 2,
  convRule: rule14
}, {
  start: 43703,
  length: 2,
  convRule: rule92
}, {
  start: 43705,
  length: 5,
  convRule: rule14
}, {
  start: 43710,
  length: 2,
  convRule: rule92
}, {
  start: 43712,
  length: 1,
  convRule: rule14
}, {
  start: 43713,
  length: 1,
  convRule: rule92
}, {
  start: 43714,
  length: 1,
  convRule: rule14
}, {
  start: 43739,
  length: 2,
  convRule: rule14
}, {
  start: 43741,
  length: 1,
  convRule: rule91
}, {
  start: 43742,
  length: 2,
  convRule: rule2
}, {
  start: 43744,
  length: 11,
  convRule: rule14
}, {
  start: 43755,
  length: 1,
  convRule: rule124
}, {
  start: 43756,
  length: 2,
  convRule: rule92
}, {
  start: 43758,
  length: 2,
  convRule: rule124
}, {
  start: 43760,
  length: 2,
  convRule: rule2
}, {
  start: 43762,
  length: 1,
  convRule: rule14
}, {
  start: 43763,
  length: 2,
  convRule: rule91
}, {
  start: 43765,
  length: 1,
  convRule: rule124
}, {
  start: 43766,
  length: 1,
  convRule: rule92
}, {
  start: 43777,
  length: 6,
  convRule: rule14
}, {
  start: 43785,
  length: 6,
  convRule: rule14
}, {
  start: 43793,
  length: 6,
  convRule: rule14
}, {
  start: 43808,
  length: 7,
  convRule: rule14
}, {
  start: 43816,
  length: 7,
  convRule: rule14
}, {
  start: 43824,
  length: 35,
  convRule: rule20
}, {
  start: 43859,
  length: 1,
  convRule: rule197
}, {
  start: 43860,
  length: 7,
  convRule: rule20
}, {
  start: 43867,
  length: 1,
  convRule: rule10
}, {
  start: 43868,
  length: 4,
  convRule: rule91
}, {
  start: 43872,
  length: 9,
  convRule: rule20
}, {
  start: 43881,
  length: 1,
  convRule: rule91
}, {
  start: 43882,
  length: 2,
  convRule: rule10
}, {
  start: 43888,
  length: 80,
  convRule: rule198
}, {
  start: 43968,
  length: 35,
  convRule: rule14
}, {
  start: 44003,
  length: 2,
  convRule: rule124
}, {
  start: 44005,
  length: 1,
  convRule: rule92
}, {
  start: 44006,
  length: 2,
  convRule: rule124
}, {
  start: 44008,
  length: 1,
  convRule: rule92
}, {
  start: 44009,
  length: 2,
  convRule: rule124
}, {
  start: 44011,
  length: 1,
  convRule: rule2
}, {
  start: 44012,
  length: 1,
  convRule: rule124
}, {
  start: 44013,
  length: 1,
  convRule: rule92
}, {
  start: 44016,
  length: 10,
  convRule: rule8
}, {
  start: 44032,
  length: 11172,
  convRule: rule14
}, {
  start: 55216,
  length: 23,
  convRule: rule14
}, {
  start: 55243,
  length: 49,
  convRule: rule14
}, {
  start: 55296,
  length: 896,
  convRule: rule199
}, {
  start: 56192,
  length: 128,
  convRule: rule199
}, {
  start: 56320,
  length: 1024,
  convRule: rule199
}, {
  start: 57344,
  length: 6400,
  convRule: rule200
}, {
  start: 63744,
  length: 366,
  convRule: rule14
}, {
  start: 64112,
  length: 106,
  convRule: rule14
}, {
  start: 64256,
  length: 7,
  convRule: rule20
}, {
  start: 64275,
  length: 5,
  convRule: rule20
}, {
  start: 64285,
  length: 1,
  convRule: rule14
}, {
  start: 64286,
  length: 1,
  convRule: rule92
}, {
  start: 64287,
  length: 10,
  convRule: rule14
}, {
  start: 64297,
  length: 1,
  convRule: rule6
}, {
  start: 64298,
  length: 13,
  convRule: rule14
}, {
  start: 64312,
  length: 5,
  convRule: rule14
}, {
  start: 64318,
  length: 1,
  convRule: rule14
}, {
  start: 64320,
  length: 2,
  convRule: rule14
}, {
  start: 64323,
  length: 2,
  convRule: rule14
}, {
  start: 64326,
  length: 108,
  convRule: rule14
}, {
  start: 64434,
  length: 16,
  convRule: rule10
}, {
  start: 64467,
  length: 363,
  convRule: rule14
}, {
  start: 64830,
  length: 1,
  convRule: rule5
}, {
  start: 64831,
  length: 1,
  convRule: rule4
}, {
  start: 64848,
  length: 64,
  convRule: rule14
}, {
  start: 64914,
  length: 54,
  convRule: rule14
}, {
  start: 65008,
  length: 12,
  convRule: rule14
}, {
  start: 65020,
  length: 1,
  convRule: rule3
}, {
  start: 65021,
  length: 1,
  convRule: rule13
}, {
  start: 65024,
  length: 16,
  convRule: rule92
}, {
  start: 65040,
  length: 7,
  convRule: rule2
}, {
  start: 65047,
  length: 1,
  convRule: rule4
}, {
  start: 65048,
  length: 1,
  convRule: rule5
}, {
  start: 65049,
  length: 1,
  convRule: rule2
}, {
  start: 65056,
  length: 16,
  convRule: rule92
}, {
  start: 65072,
  length: 1,
  convRule: rule2
}, {
  start: 65073,
  length: 2,
  convRule: rule7
}, {
  start: 65075,
  length: 2,
  convRule: rule11
}, {
  start: 65077,
  length: 1,
  convRule: rule4
}, {
  start: 65078,
  length: 1,
  convRule: rule5
}, {
  start: 65079,
  length: 1,
  convRule: rule4
}, {
  start: 65080,
  length: 1,
  convRule: rule5
}, {
  start: 65081,
  length: 1,
  convRule: rule4
}, {
  start: 65082,
  length: 1,
  convRule: rule5
}, {
  start: 65083,
  length: 1,
  convRule: rule4
}, {
  start: 65084,
  length: 1,
  convRule: rule5
}, {
  start: 65085,
  length: 1,
  convRule: rule4
}, {
  start: 65086,
  length: 1,
  convRule: rule5
}, {
  start: 65087,
  length: 1,
  convRule: rule4
}, {
  start: 65088,
  length: 1,
  convRule: rule5
}, {
  start: 65089,
  length: 1,
  convRule: rule4
}, {
  start: 65090,
  length: 1,
  convRule: rule5
}, {
  start: 65091,
  length: 1,
  convRule: rule4
}, {
  start: 65092,
  length: 1,
  convRule: rule5
}, {
  start: 65093,
  length: 2,
  convRule: rule2
}, {
  start: 65095,
  length: 1,
  convRule: rule4
}, {
  start: 65096,
  length: 1,
  convRule: rule5
}, {
  start: 65097,
  length: 4,
  convRule: rule2
}, {
  start: 65101,
  length: 3,
  convRule: rule11
}, {
  start: 65104,
  length: 3,
  convRule: rule2
}, {
  start: 65108,
  length: 4,
  convRule: rule2
}, {
  start: 65112,
  length: 1,
  convRule: rule7
}, {
  start: 65113,
  length: 1,
  convRule: rule4
}, {
  start: 65114,
  length: 1,
  convRule: rule5
}, {
  start: 65115,
  length: 1,
  convRule: rule4
}, {
  start: 65116,
  length: 1,
  convRule: rule5
}, {
  start: 65117,
  length: 1,
  convRule: rule4
}, {
  start: 65118,
  length: 1,
  convRule: rule5
}, {
  start: 65119,
  length: 3,
  convRule: rule2
}, {
  start: 65122,
  length: 1,
  convRule: rule6
}, {
  start: 65123,
  length: 1,
  convRule: rule7
}, {
  start: 65124,
  length: 3,
  convRule: rule6
}, {
  start: 65128,
  length: 1,
  convRule: rule2
}, {
  start: 65129,
  length: 1,
  convRule: rule3
}, {
  start: 65130,
  length: 2,
  convRule: rule2
}, {
  start: 65136,
  length: 5,
  convRule: rule14
}, {
  start: 65142,
  length: 135,
  convRule: rule14
}, {
  start: 65279,
  length: 1,
  convRule: rule16
}, {
  start: 65281,
  length: 3,
  convRule: rule2
}, {
  start: 65284,
  length: 1,
  convRule: rule3
}, {
  start: 65285,
  length: 3,
  convRule: rule2
}, {
  start: 65288,
  length: 1,
  convRule: rule4
}, {
  start: 65289,
  length: 1,
  convRule: rule5
}, {
  start: 65290,
  length: 1,
  convRule: rule2
}, {
  start: 65291,
  length: 1,
  convRule: rule6
}, {
  start: 65292,
  length: 1,
  convRule: rule2
}, {
  start: 65293,
  length: 1,
  convRule: rule7
}, {
  start: 65294,
  length: 2,
  convRule: rule2
}, {
  start: 65296,
  length: 10,
  convRule: rule8
}, {
  start: 65306,
  length: 2,
  convRule: rule2
}, {
  start: 65308,
  length: 3,
  convRule: rule6
}, {
  start: 65311,
  length: 2,
  convRule: rule2
}, {
  start: 65313,
  length: 26,
  convRule: rule9
}, {
  start: 65339,
  length: 1,
  convRule: rule4
}, {
  start: 65340,
  length: 1,
  convRule: rule2
}, {
  start: 65341,
  length: 1,
  convRule: rule5
}, {
  start: 65342,
  length: 1,
  convRule: rule10
}, {
  start: 65343,
  length: 1,
  convRule: rule11
}, {
  start: 65344,
  length: 1,
  convRule: rule10
}, {
  start: 65345,
  length: 26,
  convRule: rule12
}, {
  start: 65371,
  length: 1,
  convRule: rule4
}, {
  start: 65372,
  length: 1,
  convRule: rule6
}, {
  start: 65373,
  length: 1,
  convRule: rule5
}, {
  start: 65374,
  length: 1,
  convRule: rule6
}, {
  start: 65375,
  length: 1,
  convRule: rule4
}, {
  start: 65376,
  length: 1,
  convRule: rule5
}, {
  start: 65377,
  length: 1,
  convRule: rule2
}, {
  start: 65378,
  length: 1,
  convRule: rule4
}, {
  start: 65379,
  length: 1,
  convRule: rule5
}, {
  start: 65380,
  length: 2,
  convRule: rule2
}, {
  start: 65382,
  length: 10,
  convRule: rule14
}, {
  start: 65392,
  length: 1,
  convRule: rule91
}, {
  start: 65393,
  length: 45,
  convRule: rule14
}, {
  start: 65438,
  length: 2,
  convRule: rule91
}, {
  start: 65440,
  length: 31,
  convRule: rule14
}, {
  start: 65474,
  length: 6,
  convRule: rule14
}, {
  start: 65482,
  length: 6,
  convRule: rule14
}, {
  start: 65490,
  length: 6,
  convRule: rule14
}, {
  start: 65498,
  length: 3,
  convRule: rule14
}, {
  start: 65504,
  length: 2,
  convRule: rule3
}, {
  start: 65506,
  length: 1,
  convRule: rule6
}, {
  start: 65507,
  length: 1,
  convRule: rule10
}, {
  start: 65508,
  length: 1,
  convRule: rule13
}, {
  start: 65509,
  length: 2,
  convRule: rule3
}, {
  start: 65512,
  length: 1,
  convRule: rule13
}, {
  start: 65513,
  length: 4,
  convRule: rule6
}, {
  start: 65517,
  length: 2,
  convRule: rule13
}, {
  start: 65529,
  length: 3,
  convRule: rule16
}, {
  start: 65532,
  length: 2,
  convRule: rule13
}, {
  start: 65536,
  length: 12,
  convRule: rule14
}, {
  start: 65549,
  length: 26,
  convRule: rule14
}, {
  start: 65576,
  length: 19,
  convRule: rule14
}, {
  start: 65596,
  length: 2,
  convRule: rule14
}, {
  start: 65599,
  length: 15,
  convRule: rule14
}, {
  start: 65616,
  length: 14,
  convRule: rule14
}, {
  start: 65664,
  length: 123,
  convRule: rule14
}, {
  start: 65792,
  length: 3,
  convRule: rule2
}, {
  start: 65799,
  length: 45,
  convRule: rule17
}, {
  start: 65847,
  length: 9,
  convRule: rule13
}, {
  start: 65856,
  length: 53,
  convRule: rule128
}, {
  start: 65909,
  length: 4,
  convRule: rule17
}, {
  start: 65913,
  length: 17,
  convRule: rule13
}, {
  start: 65930,
  length: 2,
  convRule: rule17
}, {
  start: 65932,
  length: 3,
  convRule: rule13
}, {
  start: 65936,
  length: 13,
  convRule: rule13
}, {
  start: 65952,
  length: 1,
  convRule: rule13
}, {
  start: 66e3,
  length: 45,
  convRule: rule13
}, {
  start: 66045,
  length: 1,
  convRule: rule92
}, {
  start: 66176,
  length: 29,
  convRule: rule14
}, {
  start: 66208,
  length: 49,
  convRule: rule14
}, {
  start: 66272,
  length: 1,
  convRule: rule92
}, {
  start: 66273,
  length: 27,
  convRule: rule17
}, {
  start: 66304,
  length: 32,
  convRule: rule14
}, {
  start: 66336,
  length: 4,
  convRule: rule17
}, {
  start: 66349,
  length: 20,
  convRule: rule14
}, {
  start: 66369,
  length: 1,
  convRule: rule128
}, {
  start: 66370,
  length: 8,
  convRule: rule14
}, {
  start: 66378,
  length: 1,
  convRule: rule128
}, {
  start: 66384,
  length: 38,
  convRule: rule14
}, {
  start: 66422,
  length: 5,
  convRule: rule92
}, {
  start: 66432,
  length: 30,
  convRule: rule14
}, {
  start: 66463,
  length: 1,
  convRule: rule2
}, {
  start: 66464,
  length: 36,
  convRule: rule14
}, {
  start: 66504,
  length: 8,
  convRule: rule14
}, {
  start: 66512,
  length: 1,
  convRule: rule2
}, {
  start: 66513,
  length: 5,
  convRule: rule128
}, {
  start: 66560,
  length: 40,
  convRule: rule201
}, {
  start: 66600,
  length: 40,
  convRule: rule202
}, {
  start: 66640,
  length: 78,
  convRule: rule14
}, {
  start: 66720,
  length: 10,
  convRule: rule8
}, {
  start: 66736,
  length: 36,
  convRule: rule201
}, {
  start: 66776,
  length: 36,
  convRule: rule202
}, {
  start: 66816,
  length: 40,
  convRule: rule14
}, {
  start: 66864,
  length: 52,
  convRule: rule14
}, {
  start: 66927,
  length: 1,
  convRule: rule2
}, {
  start: 67072,
  length: 311,
  convRule: rule14
}, {
  start: 67392,
  length: 22,
  convRule: rule14
}, {
  start: 67424,
  length: 8,
  convRule: rule14
}, {
  start: 67584,
  length: 6,
  convRule: rule14
}, {
  start: 67592,
  length: 1,
  convRule: rule14
}, {
  start: 67594,
  length: 44,
  convRule: rule14
}, {
  start: 67639,
  length: 2,
  convRule: rule14
}, {
  start: 67644,
  length: 1,
  convRule: rule14
}, {
  start: 67647,
  length: 23,
  convRule: rule14
}, {
  start: 67671,
  length: 1,
  convRule: rule2
}, {
  start: 67672,
  length: 8,
  convRule: rule17
}, {
  start: 67680,
  length: 23,
  convRule: rule14
}, {
  start: 67703,
  length: 2,
  convRule: rule13
}, {
  start: 67705,
  length: 7,
  convRule: rule17
}, {
  start: 67712,
  length: 31,
  convRule: rule14
}, {
  start: 67751,
  length: 9,
  convRule: rule17
}, {
  start: 67808,
  length: 19,
  convRule: rule14
}, {
  start: 67828,
  length: 2,
  convRule: rule14
}, {
  start: 67835,
  length: 5,
  convRule: rule17
}, {
  start: 67840,
  length: 22,
  convRule: rule14
}, {
  start: 67862,
  length: 6,
  convRule: rule17
}, {
  start: 67871,
  length: 1,
  convRule: rule2
}, {
  start: 67872,
  length: 26,
  convRule: rule14
}, {
  start: 67903,
  length: 1,
  convRule: rule2
}, {
  start: 67968,
  length: 56,
  convRule: rule14
}, {
  start: 68028,
  length: 2,
  convRule: rule17
}, {
  start: 68030,
  length: 2,
  convRule: rule14
}, {
  start: 68032,
  length: 16,
  convRule: rule17
}, {
  start: 68050,
  length: 46,
  convRule: rule17
}, {
  start: 68096,
  length: 1,
  convRule: rule14
}, {
  start: 68097,
  length: 3,
  convRule: rule92
}, {
  start: 68101,
  length: 2,
  convRule: rule92
}, {
  start: 68108,
  length: 4,
  convRule: rule92
}, {
  start: 68112,
  length: 4,
  convRule: rule14
}, {
  start: 68117,
  length: 3,
  convRule: rule14
}, {
  start: 68121,
  length: 29,
  convRule: rule14
}, {
  start: 68152,
  length: 3,
  convRule: rule92
}, {
  start: 68159,
  length: 1,
  convRule: rule92
}, {
  start: 68160,
  length: 9,
  convRule: rule17
}, {
  start: 68176,
  length: 9,
  convRule: rule2
}, {
  start: 68192,
  length: 29,
  convRule: rule14
}, {
  start: 68221,
  length: 2,
  convRule: rule17
}, {
  start: 68223,
  length: 1,
  convRule: rule2
}, {
  start: 68224,
  length: 29,
  convRule: rule14
}, {
  start: 68253,
  length: 3,
  convRule: rule17
}, {
  start: 68288,
  length: 8,
  convRule: rule14
}, {
  start: 68296,
  length: 1,
  convRule: rule13
}, {
  start: 68297,
  length: 28,
  convRule: rule14
}, {
  start: 68325,
  length: 2,
  convRule: rule92
}, {
  start: 68331,
  length: 5,
  convRule: rule17
}, {
  start: 68336,
  length: 7,
  convRule: rule2
}, {
  start: 68352,
  length: 54,
  convRule: rule14
}, {
  start: 68409,
  length: 7,
  convRule: rule2
}, {
  start: 68416,
  length: 22,
  convRule: rule14
}, {
  start: 68440,
  length: 8,
  convRule: rule17
}, {
  start: 68448,
  length: 19,
  convRule: rule14
}, {
  start: 68472,
  length: 8,
  convRule: rule17
}, {
  start: 68480,
  length: 18,
  convRule: rule14
}, {
  start: 68505,
  length: 4,
  convRule: rule2
}, {
  start: 68521,
  length: 7,
  convRule: rule17
}, {
  start: 68608,
  length: 73,
  convRule: rule14
}, {
  start: 68736,
  length: 51,
  convRule: rule97
}, {
  start: 68800,
  length: 51,
  convRule: rule102
}, {
  start: 68858,
  length: 6,
  convRule: rule17
}, {
  start: 68864,
  length: 36,
  convRule: rule14
}, {
  start: 68900,
  length: 4,
  convRule: rule92
}, {
  start: 68912,
  length: 10,
  convRule: rule8
}, {
  start: 69216,
  length: 31,
  convRule: rule17
}, {
  start: 69248,
  length: 42,
  convRule: rule14
}, {
  start: 69291,
  length: 2,
  convRule: rule92
}, {
  start: 69293,
  length: 1,
  convRule: rule7
}, {
  start: 69296,
  length: 2,
  convRule: rule14
}, {
  start: 69376,
  length: 29,
  convRule: rule14
}, {
  start: 69405,
  length: 10,
  convRule: rule17
}, {
  start: 69415,
  length: 1,
  convRule: rule14
}, {
  start: 69424,
  length: 22,
  convRule: rule14
}, {
  start: 69446,
  length: 11,
  convRule: rule92
}, {
  start: 69457,
  length: 4,
  convRule: rule17
}, {
  start: 69461,
  length: 5,
  convRule: rule2
}, {
  start: 69552,
  length: 21,
  convRule: rule14
}, {
  start: 69573,
  length: 7,
  convRule: rule17
}, {
  start: 69600,
  length: 23,
  convRule: rule14
}, {
  start: 69632,
  length: 1,
  convRule: rule124
}, {
  start: 69633,
  length: 1,
  convRule: rule92
}, {
  start: 69634,
  length: 1,
  convRule: rule124
}, {
  start: 69635,
  length: 53,
  convRule: rule14
}, {
  start: 69688,
  length: 15,
  convRule: rule92
}, {
  start: 69703,
  length: 7,
  convRule: rule2
}, {
  start: 69714,
  length: 20,
  convRule: rule17
}, {
  start: 69734,
  length: 10,
  convRule: rule8
}, {
  start: 69759,
  length: 3,
  convRule: rule92
}, {
  start: 69762,
  length: 1,
  convRule: rule124
}, {
  start: 69763,
  length: 45,
  convRule: rule14
}, {
  start: 69808,
  length: 3,
  convRule: rule124
}, {
  start: 69811,
  length: 4,
  convRule: rule92
}, {
  start: 69815,
  length: 2,
  convRule: rule124
}, {
  start: 69817,
  length: 2,
  convRule: rule92
}, {
  start: 69819,
  length: 2,
  convRule: rule2
}, {
  start: 69821,
  length: 1,
  convRule: rule16
}, {
  start: 69822,
  length: 4,
  convRule: rule2
}, {
  start: 69837,
  length: 1,
  convRule: rule16
}, {
  start: 69840,
  length: 25,
  convRule: rule14
}, {
  start: 69872,
  length: 10,
  convRule: rule8
}, {
  start: 69888,
  length: 3,
  convRule: rule92
}, {
  start: 69891,
  length: 36,
  convRule: rule14
}, {
  start: 69927,
  length: 5,
  convRule: rule92
}, {
  start: 69932,
  length: 1,
  convRule: rule124
}, {
  start: 69933,
  length: 8,
  convRule: rule92
}, {
  start: 69942,
  length: 10,
  convRule: rule8
}, {
  start: 69952,
  length: 4,
  convRule: rule2
}, {
  start: 69956,
  length: 1,
  convRule: rule14
}, {
  start: 69957,
  length: 2,
  convRule: rule124
}, {
  start: 69959,
  length: 1,
  convRule: rule14
}, {
  start: 69968,
  length: 35,
  convRule: rule14
}, {
  start: 70003,
  length: 1,
  convRule: rule92
}, {
  start: 70004,
  length: 2,
  convRule: rule2
}, {
  start: 70006,
  length: 1,
  convRule: rule14
}, {
  start: 70016,
  length: 2,
  convRule: rule92
}, {
  start: 70018,
  length: 1,
  convRule: rule124
}, {
  start: 70019,
  length: 48,
  convRule: rule14
}, {
  start: 70067,
  length: 3,
  convRule: rule124
}, {
  start: 70070,
  length: 9,
  convRule: rule92
}, {
  start: 70079,
  length: 2,
  convRule: rule124
}, {
  start: 70081,
  length: 4,
  convRule: rule14
}, {
  start: 70085,
  length: 4,
  convRule: rule2
}, {
  start: 70089,
  length: 4,
  convRule: rule92
}, {
  start: 70093,
  length: 1,
  convRule: rule2
}, {
  start: 70094,
  length: 1,
  convRule: rule124
}, {
  start: 70095,
  length: 1,
  convRule: rule92
}, {
  start: 70096,
  length: 10,
  convRule: rule8
}, {
  start: 70106,
  length: 1,
  convRule: rule14
}, {
  start: 70107,
  length: 1,
  convRule: rule2
}, {
  start: 70108,
  length: 1,
  convRule: rule14
}, {
  start: 70109,
  length: 3,
  convRule: rule2
}, {
  start: 70113,
  length: 20,
  convRule: rule17
}, {
  start: 70144,
  length: 18,
  convRule: rule14
}, {
  start: 70163,
  length: 25,
  convRule: rule14
}, {
  start: 70188,
  length: 3,
  convRule: rule124
}, {
  start: 70191,
  length: 3,
  convRule: rule92
}, {
  start: 70194,
  length: 2,
  convRule: rule124
}, {
  start: 70196,
  length: 1,
  convRule: rule92
}, {
  start: 70197,
  length: 1,
  convRule: rule124
}, {
  start: 70198,
  length: 2,
  convRule: rule92
}, {
  start: 70200,
  length: 6,
  convRule: rule2
}, {
  start: 70206,
  length: 1,
  convRule: rule92
}, {
  start: 70272,
  length: 7,
  convRule: rule14
}, {
  start: 70280,
  length: 1,
  convRule: rule14
}, {
  start: 70282,
  length: 4,
  convRule: rule14
}, {
  start: 70287,
  length: 15,
  convRule: rule14
}, {
  start: 70303,
  length: 10,
  convRule: rule14
}, {
  start: 70313,
  length: 1,
  convRule: rule2
}, {
  start: 70320,
  length: 47,
  convRule: rule14
}, {
  start: 70367,
  length: 1,
  convRule: rule92
}, {
  start: 70368,
  length: 3,
  convRule: rule124
}, {
  start: 70371,
  length: 8,
  convRule: rule92
}, {
  start: 70384,
  length: 10,
  convRule: rule8
}, {
  start: 70400,
  length: 2,
  convRule: rule92
}, {
  start: 70402,
  length: 2,
  convRule: rule124
}, {
  start: 70405,
  length: 8,
  convRule: rule14
}, {
  start: 70415,
  length: 2,
  convRule: rule14
}, {
  start: 70419,
  length: 22,
  convRule: rule14
}, {
  start: 70442,
  length: 7,
  convRule: rule14
}, {
  start: 70450,
  length: 2,
  convRule: rule14
}, {
  start: 70453,
  length: 5,
  convRule: rule14
}, {
  start: 70459,
  length: 2,
  convRule: rule92
}, {
  start: 70461,
  length: 1,
  convRule: rule14
}, {
  start: 70462,
  length: 2,
  convRule: rule124
}, {
  start: 70464,
  length: 1,
  convRule: rule92
}, {
  start: 70465,
  length: 4,
  convRule: rule124
}, {
  start: 70471,
  length: 2,
  convRule: rule124
}, {
  start: 70475,
  length: 3,
  convRule: rule124
}, {
  start: 70480,
  length: 1,
  convRule: rule14
}, {
  start: 70487,
  length: 1,
  convRule: rule124
}, {
  start: 70493,
  length: 5,
  convRule: rule14
}, {
  start: 70498,
  length: 2,
  convRule: rule124
}, {
  start: 70502,
  length: 7,
  convRule: rule92
}, {
  start: 70512,
  length: 5,
  convRule: rule92
}, {
  start: 70656,
  length: 53,
  convRule: rule14
}, {
  start: 70709,
  length: 3,
  convRule: rule124
}, {
  start: 70712,
  length: 8,
  convRule: rule92
}, {
  start: 70720,
  length: 2,
  convRule: rule124
}, {
  start: 70722,
  length: 3,
  convRule: rule92
}, {
  start: 70725,
  length: 1,
  convRule: rule124
}, {
  start: 70726,
  length: 1,
  convRule: rule92
}, {
  start: 70727,
  length: 4,
  convRule: rule14
}, {
  start: 70731,
  length: 5,
  convRule: rule2
}, {
  start: 70736,
  length: 10,
  convRule: rule8
}, {
  start: 70746,
  length: 2,
  convRule: rule2
}, {
  start: 70749,
  length: 1,
  convRule: rule2
}, {
  start: 70750,
  length: 1,
  convRule: rule92
}, {
  start: 70751,
  length: 3,
  convRule: rule14
}, {
  start: 70784,
  length: 48,
  convRule: rule14
}, {
  start: 70832,
  length: 3,
  convRule: rule124
}, {
  start: 70835,
  length: 6,
  convRule: rule92
}, {
  start: 70841,
  length: 1,
  convRule: rule124
}, {
  start: 70842,
  length: 1,
  convRule: rule92
}, {
  start: 70843,
  length: 4,
  convRule: rule124
}, {
  start: 70847,
  length: 2,
  convRule: rule92
}, {
  start: 70849,
  length: 1,
  convRule: rule124
}, {
  start: 70850,
  length: 2,
  convRule: rule92
}, {
  start: 70852,
  length: 2,
  convRule: rule14
}, {
  start: 70854,
  length: 1,
  convRule: rule2
}, {
  start: 70855,
  length: 1,
  convRule: rule14
}, {
  start: 70864,
  length: 10,
  convRule: rule8
}, {
  start: 71040,
  length: 47,
  convRule: rule14
}, {
  start: 71087,
  length: 3,
  convRule: rule124
}, {
  start: 71090,
  length: 4,
  convRule: rule92
}, {
  start: 71096,
  length: 4,
  convRule: rule124
}, {
  start: 71100,
  length: 2,
  convRule: rule92
}, {
  start: 71102,
  length: 1,
  convRule: rule124
}, {
  start: 71103,
  length: 2,
  convRule: rule92
}, {
  start: 71105,
  length: 23,
  convRule: rule2
}, {
  start: 71128,
  length: 4,
  convRule: rule14
}, {
  start: 71132,
  length: 2,
  convRule: rule92
}, {
  start: 71168,
  length: 48,
  convRule: rule14
}, {
  start: 71216,
  length: 3,
  convRule: rule124
}, {
  start: 71219,
  length: 8,
  convRule: rule92
}, {
  start: 71227,
  length: 2,
  convRule: rule124
}, {
  start: 71229,
  length: 1,
  convRule: rule92
}, {
  start: 71230,
  length: 1,
  convRule: rule124
}, {
  start: 71231,
  length: 2,
  convRule: rule92
}, {
  start: 71233,
  length: 3,
  convRule: rule2
}, {
  start: 71236,
  length: 1,
  convRule: rule14
}, {
  start: 71248,
  length: 10,
  convRule: rule8
}, {
  start: 71264,
  length: 13,
  convRule: rule2
}, {
  start: 71296,
  length: 43,
  convRule: rule14
}, {
  start: 71339,
  length: 1,
  convRule: rule92
}, {
  start: 71340,
  length: 1,
  convRule: rule124
}, {
  start: 71341,
  length: 1,
  convRule: rule92
}, {
  start: 71342,
  length: 2,
  convRule: rule124
}, {
  start: 71344,
  length: 6,
  convRule: rule92
}, {
  start: 71350,
  length: 1,
  convRule: rule124
}, {
  start: 71351,
  length: 1,
  convRule: rule92
}, {
  start: 71352,
  length: 1,
  convRule: rule14
}, {
  start: 71360,
  length: 10,
  convRule: rule8
}, {
  start: 71424,
  length: 27,
  convRule: rule14
}, {
  start: 71453,
  length: 3,
  convRule: rule92
}, {
  start: 71456,
  length: 2,
  convRule: rule124
}, {
  start: 71458,
  length: 4,
  convRule: rule92
}, {
  start: 71462,
  length: 1,
  convRule: rule124
}, {
  start: 71463,
  length: 5,
  convRule: rule92
}, {
  start: 71472,
  length: 10,
  convRule: rule8
}, {
  start: 71482,
  length: 2,
  convRule: rule17
}, {
  start: 71484,
  length: 3,
  convRule: rule2
}, {
  start: 71487,
  length: 1,
  convRule: rule13
}, {
  start: 71680,
  length: 44,
  convRule: rule14
}, {
  start: 71724,
  length: 3,
  convRule: rule124
}, {
  start: 71727,
  length: 9,
  convRule: rule92
}, {
  start: 71736,
  length: 1,
  convRule: rule124
}, {
  start: 71737,
  length: 2,
  convRule: rule92
}, {
  start: 71739,
  length: 1,
  convRule: rule2
}, {
  start: 71840,
  length: 32,
  convRule: rule9
}, {
  start: 71872,
  length: 32,
  convRule: rule12
}, {
  start: 71904,
  length: 10,
  convRule: rule8
}, {
  start: 71914,
  length: 9,
  convRule: rule17
}, {
  start: 71935,
  length: 8,
  convRule: rule14
}, {
  start: 71945,
  length: 1,
  convRule: rule14
}, {
  start: 71948,
  length: 8,
  convRule: rule14
}, {
  start: 71957,
  length: 2,
  convRule: rule14
}, {
  start: 71960,
  length: 24,
  convRule: rule14
}, {
  start: 71984,
  length: 6,
  convRule: rule124
}, {
  start: 71991,
  length: 2,
  convRule: rule124
}, {
  start: 71995,
  length: 2,
  convRule: rule92
}, {
  start: 71997,
  length: 1,
  convRule: rule124
}, {
  start: 71998,
  length: 1,
  convRule: rule92
}, {
  start: 71999,
  length: 1,
  convRule: rule14
}, {
  start: 72e3,
  length: 1,
  convRule: rule124
}, {
  start: 72001,
  length: 1,
  convRule: rule14
}, {
  start: 72002,
  length: 1,
  convRule: rule124
}, {
  start: 72003,
  length: 1,
  convRule: rule92
}, {
  start: 72004,
  length: 3,
  convRule: rule2
}, {
  start: 72016,
  length: 10,
  convRule: rule8
}, {
  start: 72096,
  length: 8,
  convRule: rule14
}, {
  start: 72106,
  length: 39,
  convRule: rule14
}, {
  start: 72145,
  length: 3,
  convRule: rule124
}, {
  start: 72148,
  length: 4,
  convRule: rule92
}, {
  start: 72154,
  length: 2,
  convRule: rule92
}, {
  start: 72156,
  length: 4,
  convRule: rule124
}, {
  start: 72160,
  length: 1,
  convRule: rule92
}, {
  start: 72161,
  length: 1,
  convRule: rule14
}, {
  start: 72162,
  length: 1,
  convRule: rule2
}, {
  start: 72163,
  length: 1,
  convRule: rule14
}, {
  start: 72164,
  length: 1,
  convRule: rule124
}, {
  start: 72192,
  length: 1,
  convRule: rule14
}, {
  start: 72193,
  length: 10,
  convRule: rule92
}, {
  start: 72203,
  length: 40,
  convRule: rule14
}, {
  start: 72243,
  length: 6,
  convRule: rule92
}, {
  start: 72249,
  length: 1,
  convRule: rule124
}, {
  start: 72250,
  length: 1,
  convRule: rule14
}, {
  start: 72251,
  length: 4,
  convRule: rule92
}, {
  start: 72255,
  length: 8,
  convRule: rule2
}, {
  start: 72263,
  length: 1,
  convRule: rule92
}, {
  start: 72272,
  length: 1,
  convRule: rule14
}, {
  start: 72273,
  length: 6,
  convRule: rule92
}, {
  start: 72279,
  length: 2,
  convRule: rule124
}, {
  start: 72281,
  length: 3,
  convRule: rule92
}, {
  start: 72284,
  length: 46,
  convRule: rule14
}, {
  start: 72330,
  length: 13,
  convRule: rule92
}, {
  start: 72343,
  length: 1,
  convRule: rule124
}, {
  start: 72344,
  length: 2,
  convRule: rule92
}, {
  start: 72346,
  length: 3,
  convRule: rule2
}, {
  start: 72349,
  length: 1,
  convRule: rule14
}, {
  start: 72350,
  length: 5,
  convRule: rule2
}, {
  start: 72384,
  length: 57,
  convRule: rule14
}, {
  start: 72704,
  length: 9,
  convRule: rule14
}, {
  start: 72714,
  length: 37,
  convRule: rule14
}, {
  start: 72751,
  length: 1,
  convRule: rule124
}, {
  start: 72752,
  length: 7,
  convRule: rule92
}, {
  start: 72760,
  length: 6,
  convRule: rule92
}, {
  start: 72766,
  length: 1,
  convRule: rule124
}, {
  start: 72767,
  length: 1,
  convRule: rule92
}, {
  start: 72768,
  length: 1,
  convRule: rule14
}, {
  start: 72769,
  length: 5,
  convRule: rule2
}, {
  start: 72784,
  length: 10,
  convRule: rule8
}, {
  start: 72794,
  length: 19,
  convRule: rule17
}, {
  start: 72816,
  length: 2,
  convRule: rule2
}, {
  start: 72818,
  length: 30,
  convRule: rule14
}, {
  start: 72850,
  length: 22,
  convRule: rule92
}, {
  start: 72873,
  length: 1,
  convRule: rule124
}, {
  start: 72874,
  length: 7,
  convRule: rule92
}, {
  start: 72881,
  length: 1,
  convRule: rule124
}, {
  start: 72882,
  length: 2,
  convRule: rule92
}, {
  start: 72884,
  length: 1,
  convRule: rule124
}, {
  start: 72885,
  length: 2,
  convRule: rule92
}, {
  start: 72960,
  length: 7,
  convRule: rule14
}, {
  start: 72968,
  length: 2,
  convRule: rule14
}, {
  start: 72971,
  length: 38,
  convRule: rule14
}, {
  start: 73009,
  length: 6,
  convRule: rule92
}, {
  start: 73018,
  length: 1,
  convRule: rule92
}, {
  start: 73020,
  length: 2,
  convRule: rule92
}, {
  start: 73023,
  length: 7,
  convRule: rule92
}, {
  start: 73030,
  length: 1,
  convRule: rule14
}, {
  start: 73031,
  length: 1,
  convRule: rule92
}, {
  start: 73040,
  length: 10,
  convRule: rule8
}, {
  start: 73056,
  length: 6,
  convRule: rule14
}, {
  start: 73063,
  length: 2,
  convRule: rule14
}, {
  start: 73066,
  length: 32,
  convRule: rule14
}, {
  start: 73098,
  length: 5,
  convRule: rule124
}, {
  start: 73104,
  length: 2,
  convRule: rule92
}, {
  start: 73107,
  length: 2,
  convRule: rule124
}, {
  start: 73109,
  length: 1,
  convRule: rule92
}, {
  start: 73110,
  length: 1,
  convRule: rule124
}, {
  start: 73111,
  length: 1,
  convRule: rule92
}, {
  start: 73112,
  length: 1,
  convRule: rule14
}, {
  start: 73120,
  length: 10,
  convRule: rule8
}, {
  start: 73440,
  length: 19,
  convRule: rule14
}, {
  start: 73459,
  length: 2,
  convRule: rule92
}, {
  start: 73461,
  length: 2,
  convRule: rule124
}, {
  start: 73463,
  length: 2,
  convRule: rule2
}, {
  start: 73648,
  length: 1,
  convRule: rule14
}, {
  start: 73664,
  length: 21,
  convRule: rule17
}, {
  start: 73685,
  length: 8,
  convRule: rule13
}, {
  start: 73693,
  length: 4,
  convRule: rule3
}, {
  start: 73697,
  length: 17,
  convRule: rule13
}, {
  start: 73727,
  length: 1,
  convRule: rule2
}, {
  start: 73728,
  length: 922,
  convRule: rule14
}, {
  start: 74752,
  length: 111,
  convRule: rule128
}, {
  start: 74864,
  length: 5,
  convRule: rule2
}, {
  start: 74880,
  length: 196,
  convRule: rule14
}, {
  start: 77824,
  length: 1071,
  convRule: rule14
}, {
  start: 78896,
  length: 9,
  convRule: rule16
}, {
  start: 82944,
  length: 583,
  convRule: rule14
}, {
  start: 92160,
  length: 569,
  convRule: rule14
}, {
  start: 92736,
  length: 31,
  convRule: rule14
}, {
  start: 92768,
  length: 10,
  convRule: rule8
}, {
  start: 92782,
  length: 2,
  convRule: rule2
}, {
  start: 92880,
  length: 30,
  convRule: rule14
}, {
  start: 92912,
  length: 5,
  convRule: rule92
}, {
  start: 92917,
  length: 1,
  convRule: rule2
}, {
  start: 92928,
  length: 48,
  convRule: rule14
}, {
  start: 92976,
  length: 7,
  convRule: rule92
}, {
  start: 92983,
  length: 5,
  convRule: rule2
}, {
  start: 92988,
  length: 4,
  convRule: rule13
}, {
  start: 92992,
  length: 4,
  convRule: rule91
}, {
  start: 92996,
  length: 1,
  convRule: rule2
}, {
  start: 92997,
  length: 1,
  convRule: rule13
}, {
  start: 93008,
  length: 10,
  convRule: rule8
}, {
  start: 93019,
  length: 7,
  convRule: rule17
}, {
  start: 93027,
  length: 21,
  convRule: rule14
}, {
  start: 93053,
  length: 19,
  convRule: rule14
}, {
  start: 93760,
  length: 32,
  convRule: rule9
}, {
  start: 93792,
  length: 32,
  convRule: rule12
}, {
  start: 93824,
  length: 23,
  convRule: rule17
}, {
  start: 93847,
  length: 4,
  convRule: rule2
}, {
  start: 93952,
  length: 75,
  convRule: rule14
}, {
  start: 94031,
  length: 1,
  convRule: rule92
}, {
  start: 94032,
  length: 1,
  convRule: rule14
}, {
  start: 94033,
  length: 55,
  convRule: rule124
}, {
  start: 94095,
  length: 4,
  convRule: rule92
}, {
  start: 94099,
  length: 13,
  convRule: rule91
}, {
  start: 94176,
  length: 2,
  convRule: rule91
}, {
  start: 94178,
  length: 1,
  convRule: rule2
}, {
  start: 94179,
  length: 1,
  convRule: rule91
}, {
  start: 94180,
  length: 1,
  convRule: rule92
}, {
  start: 94192,
  length: 2,
  convRule: rule124
}, {
  start: 94208,
  length: 6136,
  convRule: rule14
}, {
  start: 100352,
  length: 1238,
  convRule: rule14
}, {
  start: 101632,
  length: 9,
  convRule: rule14
}, {
  start: 110592,
  length: 287,
  convRule: rule14
}, {
  start: 110928,
  length: 3,
  convRule: rule14
}, {
  start: 110948,
  length: 4,
  convRule: rule14
}, {
  start: 110960,
  length: 396,
  convRule: rule14
}, {
  start: 113664,
  length: 107,
  convRule: rule14
}, {
  start: 113776,
  length: 13,
  convRule: rule14
}, {
  start: 113792,
  length: 9,
  convRule: rule14
}, {
  start: 113808,
  length: 10,
  convRule: rule14
}, {
  start: 113820,
  length: 1,
  convRule: rule13
}, {
  start: 113821,
  length: 2,
  convRule: rule92
}, {
  start: 113823,
  length: 1,
  convRule: rule2
}, {
  start: 113824,
  length: 4,
  convRule: rule16
}, {
  start: 118784,
  length: 246,
  convRule: rule13
}, {
  start: 119040,
  length: 39,
  convRule: rule13
}, {
  start: 119081,
  length: 60,
  convRule: rule13
}, {
  start: 119141,
  length: 2,
  convRule: rule124
}, {
  start: 119143,
  length: 3,
  convRule: rule92
}, {
  start: 119146,
  length: 3,
  convRule: rule13
}, {
  start: 119149,
  length: 6,
  convRule: rule124
}, {
  start: 119155,
  length: 8,
  convRule: rule16
}, {
  start: 119163,
  length: 8,
  convRule: rule92
}, {
  start: 119171,
  length: 2,
  convRule: rule13
}, {
  start: 119173,
  length: 7,
  convRule: rule92
}, {
  start: 119180,
  length: 30,
  convRule: rule13
}, {
  start: 119210,
  length: 4,
  convRule: rule92
}, {
  start: 119214,
  length: 59,
  convRule: rule13
}, {
  start: 119296,
  length: 66,
  convRule: rule13
}, {
  start: 119362,
  length: 3,
  convRule: rule92
}, {
  start: 119365,
  length: 1,
  convRule: rule13
}, {
  start: 119520,
  length: 20,
  convRule: rule17
}, {
  start: 119552,
  length: 87,
  convRule: rule13
}, {
  start: 119648,
  length: 25,
  convRule: rule17
}, {
  start: 119808,
  length: 26,
  convRule: rule107
}, {
  start: 119834,
  length: 26,
  convRule: rule20
}, {
  start: 119860,
  length: 26,
  convRule: rule107
}, {
  start: 119886,
  length: 7,
  convRule: rule20
}, {
  start: 119894,
  length: 18,
  convRule: rule20
}, {
  start: 119912,
  length: 26,
  convRule: rule107
}, {
  start: 119938,
  length: 26,
  convRule: rule20
}, {
  start: 119964,
  length: 1,
  convRule: rule107
}, {
  start: 119966,
  length: 2,
  convRule: rule107
}, {
  start: 119970,
  length: 1,
  convRule: rule107
}, {
  start: 119973,
  length: 2,
  convRule: rule107
}, {
  start: 119977,
  length: 4,
  convRule: rule107
}, {
  start: 119982,
  length: 8,
  convRule: rule107
}, {
  start: 119990,
  length: 4,
  convRule: rule20
}, {
  start: 119995,
  length: 1,
  convRule: rule20
}, {
  start: 119997,
  length: 7,
  convRule: rule20
}, {
  start: 120005,
  length: 11,
  convRule: rule20
}, {
  start: 120016,
  length: 26,
  convRule: rule107
}, {
  start: 120042,
  length: 26,
  convRule: rule20
}, {
  start: 120068,
  length: 2,
  convRule: rule107
}, {
  start: 120071,
  length: 4,
  convRule: rule107
}, {
  start: 120077,
  length: 8,
  convRule: rule107
}, {
  start: 120086,
  length: 7,
  convRule: rule107
}, {
  start: 120094,
  length: 26,
  convRule: rule20
}, {
  start: 120120,
  length: 2,
  convRule: rule107
}, {
  start: 120123,
  length: 4,
  convRule: rule107
}, {
  start: 120128,
  length: 5,
  convRule: rule107
}, {
  start: 120134,
  length: 1,
  convRule: rule107
}, {
  start: 120138,
  length: 7,
  convRule: rule107
}, {
  start: 120146,
  length: 26,
  convRule: rule20
}, {
  start: 120172,
  length: 26,
  convRule: rule107
}, {
  start: 120198,
  length: 26,
  convRule: rule20
}, {
  start: 120224,
  length: 26,
  convRule: rule107
}, {
  start: 120250,
  length: 26,
  convRule: rule20
}, {
  start: 120276,
  length: 26,
  convRule: rule107
}, {
  start: 120302,
  length: 26,
  convRule: rule20
}, {
  start: 120328,
  length: 26,
  convRule: rule107
}, {
  start: 120354,
  length: 26,
  convRule: rule20
}, {
  start: 120380,
  length: 26,
  convRule: rule107
}, {
  start: 120406,
  length: 26,
  convRule: rule20
}, {
  start: 120432,
  length: 26,
  convRule: rule107
}, {
  start: 120458,
  length: 28,
  convRule: rule20
}, {
  start: 120488,
  length: 25,
  convRule: rule107
}, {
  start: 120513,
  length: 1,
  convRule: rule6
}, {
  start: 120514,
  length: 25,
  convRule: rule20
}, {
  start: 120539,
  length: 1,
  convRule: rule6
}, {
  start: 120540,
  length: 6,
  convRule: rule20
}, {
  start: 120546,
  length: 25,
  convRule: rule107
}, {
  start: 120571,
  length: 1,
  convRule: rule6
}, {
  start: 120572,
  length: 25,
  convRule: rule20
}, {
  start: 120597,
  length: 1,
  convRule: rule6
}, {
  start: 120598,
  length: 6,
  convRule: rule20
}, {
  start: 120604,
  length: 25,
  convRule: rule107
}, {
  start: 120629,
  length: 1,
  convRule: rule6
}, {
  start: 120630,
  length: 25,
  convRule: rule20
}, {
  start: 120655,
  length: 1,
  convRule: rule6
}, {
  start: 120656,
  length: 6,
  convRule: rule20
}, {
  start: 120662,
  length: 25,
  convRule: rule107
}, {
  start: 120687,
  length: 1,
  convRule: rule6
}, {
  start: 120688,
  length: 25,
  convRule: rule20
}, {
  start: 120713,
  length: 1,
  convRule: rule6
}, {
  start: 120714,
  length: 6,
  convRule: rule20
}, {
  start: 120720,
  length: 25,
  convRule: rule107
}, {
  start: 120745,
  length: 1,
  convRule: rule6
}, {
  start: 120746,
  length: 25,
  convRule: rule20
}, {
  start: 120771,
  length: 1,
  convRule: rule6
}, {
  start: 120772,
  length: 6,
  convRule: rule20
}, {
  start: 120778,
  length: 1,
  convRule: rule107
}, {
  start: 120779,
  length: 1,
  convRule: rule20
}, {
  start: 120782,
  length: 50,
  convRule: rule8
}, {
  start: 120832,
  length: 512,
  convRule: rule13
}, {
  start: 121344,
  length: 55,
  convRule: rule92
}, {
  start: 121399,
  length: 4,
  convRule: rule13
}, {
  start: 121403,
  length: 50,
  convRule: rule92
}, {
  start: 121453,
  length: 8,
  convRule: rule13
}, {
  start: 121461,
  length: 1,
  convRule: rule92
}, {
  start: 121462,
  length: 14,
  convRule: rule13
}, {
  start: 121476,
  length: 1,
  convRule: rule92
}, {
  start: 121477,
  length: 2,
  convRule: rule13
}, {
  start: 121479,
  length: 5,
  convRule: rule2
}, {
  start: 121499,
  length: 5,
  convRule: rule92
}, {
  start: 121505,
  length: 15,
  convRule: rule92
}, {
  start: 122880,
  length: 7,
  convRule: rule92
}, {
  start: 122888,
  length: 17,
  convRule: rule92
}, {
  start: 122907,
  length: 7,
  convRule: rule92
}, {
  start: 122915,
  length: 2,
  convRule: rule92
}, {
  start: 122918,
  length: 5,
  convRule: rule92
}, {
  start: 123136,
  length: 45,
  convRule: rule14
}, {
  start: 123184,
  length: 7,
  convRule: rule92
}, {
  start: 123191,
  length: 7,
  convRule: rule91
}, {
  start: 123200,
  length: 10,
  convRule: rule8
}, {
  start: 123214,
  length: 1,
  convRule: rule14
}, {
  start: 123215,
  length: 1,
  convRule: rule13
}, {
  start: 123584,
  length: 44,
  convRule: rule14
}, {
  start: 123628,
  length: 4,
  convRule: rule92
}, {
  start: 123632,
  length: 10,
  convRule: rule8
}, {
  start: 123647,
  length: 1,
  convRule: rule3
}, {
  start: 124928,
  length: 197,
  convRule: rule14
}, {
  start: 125127,
  length: 9,
  convRule: rule17
}, {
  start: 125136,
  length: 7,
  convRule: rule92
}, {
  start: 125184,
  length: 34,
  convRule: rule203
}, {
  start: 125218,
  length: 34,
  convRule: rule204
}, {
  start: 125252,
  length: 7,
  convRule: rule92
}, {
  start: 125259,
  length: 1,
  convRule: rule91
}, {
  start: 125264,
  length: 10,
  convRule: rule8
}, {
  start: 125278,
  length: 2,
  convRule: rule2
}, {
  start: 126065,
  length: 59,
  convRule: rule17
}, {
  start: 126124,
  length: 1,
  convRule: rule13
}, {
  start: 126125,
  length: 3,
  convRule: rule17
}, {
  start: 126128,
  length: 1,
  convRule: rule3
}, {
  start: 126129,
  length: 4,
  convRule: rule17
}, {
  start: 126209,
  length: 45,
  convRule: rule17
}, {
  start: 126254,
  length: 1,
  convRule: rule13
}, {
  start: 126255,
  length: 15,
  convRule: rule17
}, {
  start: 126464,
  length: 4,
  convRule: rule14
}, {
  start: 126469,
  length: 27,
  convRule: rule14
}, {
  start: 126497,
  length: 2,
  convRule: rule14
}, {
  start: 126500,
  length: 1,
  convRule: rule14
}, {
  start: 126503,
  length: 1,
  convRule: rule14
}, {
  start: 126505,
  length: 10,
  convRule: rule14
}, {
  start: 126516,
  length: 4,
  convRule: rule14
}, {
  start: 126521,
  length: 1,
  convRule: rule14
}, {
  start: 126523,
  length: 1,
  convRule: rule14
}, {
  start: 126530,
  length: 1,
  convRule: rule14
}, {
  start: 126535,
  length: 1,
  convRule: rule14
}, {
  start: 126537,
  length: 1,
  convRule: rule14
}, {
  start: 126539,
  length: 1,
  convRule: rule14
}, {
  start: 126541,
  length: 3,
  convRule: rule14
}, {
  start: 126545,
  length: 2,
  convRule: rule14
}, {
  start: 126548,
  length: 1,
  convRule: rule14
}, {
  start: 126551,
  length: 1,
  convRule: rule14
}, {
  start: 126553,
  length: 1,
  convRule: rule14
}, {
  start: 126555,
  length: 1,
  convRule: rule14
}, {
  start: 126557,
  length: 1,
  convRule: rule14
}, {
  start: 126559,
  length: 1,
  convRule: rule14
}, {
  start: 126561,
  length: 2,
  convRule: rule14
}, {
  start: 126564,
  length: 1,
  convRule: rule14
}, {
  start: 126567,
  length: 4,
  convRule: rule14
}, {
  start: 126572,
  length: 7,
  convRule: rule14
}, {
  start: 126580,
  length: 4,
  convRule: rule14
}, {
  start: 126585,
  length: 4,
  convRule: rule14
}, {
  start: 126590,
  length: 1,
  convRule: rule14
}, {
  start: 126592,
  length: 10,
  convRule: rule14
}, {
  start: 126603,
  length: 17,
  convRule: rule14
}, {
  start: 126625,
  length: 3,
  convRule: rule14
}, {
  start: 126629,
  length: 5,
  convRule: rule14
}, {
  start: 126635,
  length: 17,
  convRule: rule14
}, {
  start: 126704,
  length: 2,
  convRule: rule6
}, {
  start: 126976,
  length: 44,
  convRule: rule13
}, {
  start: 127024,
  length: 100,
  convRule: rule13
}, {
  start: 127136,
  length: 15,
  convRule: rule13
}, {
  start: 127153,
  length: 15,
  convRule: rule13
}, {
  start: 127169,
  length: 15,
  convRule: rule13
}, {
  start: 127185,
  length: 37,
  convRule: rule13
}, {
  start: 127232,
  length: 13,
  convRule: rule17
}, {
  start: 127245,
  length: 161,
  convRule: rule13
}, {
  start: 127462,
  length: 29,
  convRule: rule13
}, {
  start: 127504,
  length: 44,
  convRule: rule13
}, {
  start: 127552,
  length: 9,
  convRule: rule13
}, {
  start: 127568,
  length: 2,
  convRule: rule13
}, {
  start: 127584,
  length: 6,
  convRule: rule13
}, {
  start: 127744,
  length: 251,
  convRule: rule13
}, {
  start: 127995,
  length: 5,
  convRule: rule10
}, {
  start: 128e3,
  length: 728,
  convRule: rule13
}, {
  start: 128736,
  length: 13,
  convRule: rule13
}, {
  start: 128752,
  length: 13,
  convRule: rule13
}, {
  start: 128768,
  length: 116,
  convRule: rule13
}, {
  start: 128896,
  length: 89,
  convRule: rule13
}, {
  start: 128992,
  length: 12,
  convRule: rule13
}, {
  start: 129024,
  length: 12,
  convRule: rule13
}, {
  start: 129040,
  length: 56,
  convRule: rule13
}, {
  start: 129104,
  length: 10,
  convRule: rule13
}, {
  start: 129120,
  length: 40,
  convRule: rule13
}, {
  start: 129168,
  length: 30,
  convRule: rule13
}, {
  start: 129200,
  length: 2,
  convRule: rule13
}, {
  start: 129280,
  length: 121,
  convRule: rule13
}, {
  start: 129402,
  length: 82,
  convRule: rule13
}, {
  start: 129485,
  length: 135,
  convRule: rule13
}, {
  start: 129632,
  length: 14,
  convRule: rule13
}, {
  start: 129648,
  length: 5,
  convRule: rule13
}, {
  start: 129656,
  length: 3,
  convRule: rule13
}, {
  start: 129664,
  length: 7,
  convRule: rule13
}, {
  start: 129680,
  length: 25,
  convRule: rule13
}, {
  start: 129712,
  length: 7,
  convRule: rule13
}, {
  start: 129728,
  length: 3,
  convRule: rule13
}, {
  start: 129744,
  length: 7,
  convRule: rule13
}, {
  start: 129792,
  length: 147,
  convRule: rule13
}, {
  start: 129940,
  length: 55,
  convRule: rule13
}, {
  start: 130032,
  length: 10,
  convRule: rule8
}, {
  start: 131072,
  length: 42718,
  convRule: rule14
}, {
  start: 173824,
  length: 4149,
  convRule: rule14
}, {
  start: 177984,
  length: 222,
  convRule: rule14
}, {
  start: 178208,
  length: 5762,
  convRule: rule14
}, {
  start: 183984,
  length: 7473,
  convRule: rule14
}, {
  start: 194560,
  length: 542,
  convRule: rule14
}, {
  start: 196608,
  length: 4939,
  convRule: rule14
}, {
  start: 917505,
  length: 1,
  convRule: rule16
}, {
  start: 917536,
  length: 96,
  convRule: rule16
}, {
  start: 917760,
  length: 240,
  convRule: rule92
}, {
  start: 983040,
  length: 65534,
  convRule: rule200
}, {
  start: 1048576,
  length: 65534,
  convRule: rule200
}];
var checkAttr = function(categories) {
  return function($$char6) {
    var numOfBlocks = function() {
      var $43 = $$char6 < 256;
      if ($43) {
        return numLat1Blocks;
      }
      ;
      return numBlocks;
    }();
    var maybeConversionRule = getRule(allchars)($$char6)(numOfBlocks);
    if (maybeConversionRule instanceof Nothing) {
      return false;
    }
    ;
    if (maybeConversionRule instanceof Just) {
      return isJust(elemIndex2(maybeConversionRule.value0.category)(categories));
    }
    ;
    throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5645, column 5 - line 5647, column 86): " + [maybeConversionRule.constructor.name]);
  };
};
var uIswalnum = /* @__PURE__ */ checkAttr([gencatLT, gencatLU, gencatLL, gencatLM, gencatLO, gencatMC, gencatME, gencatMN, gencatNO, gencatND, gencatNL]);
var uIswlower = /* @__PURE__ */ checkAttr([gencatLL]);

// output/Data.CodePoint.Unicode/index.js
var fromEnum10 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var lessThan2 = /* @__PURE__ */ lessThan(ordCodePoint);
var isLower = function($68) {
  return uIswlower(fromEnum10($68));
};
var isDecDigit = function(c) {
  var diff6 = fromEnum10(c) - toCharCode2("0") | 0;
  return diff6 <= 9 && diff6 >= 0;
};
var isAscii = function(c) {
  return lessThan2(c)(codePointFromChar("\x80"));
};
var isAlphaNum = function($70) {
  return uIswalnum(fromEnum10($70));
};

// output/Parsing.String.Basic/index.js
var elem1 = /* @__PURE__ */ elem2(eqChar);
var show13 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showChar));
var satisfyCP = function(p) {
  return satisfy(function($32) {
    return p(codePointFromChar($32));
  });
};
var oneOf3 = function(ss) {
  return withLazyErrorMessage(satisfy(flip(elem1)(ss)))(function(v) {
    return "one of " + show13(ss);
  });
};
var lower2 = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isLower))("lowercase letter");
var digit = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isDecDigit))("digit");
var alphaNum = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isAlphaNum))("letter or digit");

// output/Registry.PackageName/index.js
var bind20 = /* @__PURE__ */ bind(bindParserT);
var elem4 = /* @__PURE__ */ elem2(eqString);
var discard5 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var when3 = /* @__PURE__ */ when(applicativeParserT);
var alt10 = /* @__PURE__ */ alt(altParserT);
var choice2 = /* @__PURE__ */ choice(foldableArray);
var pure29 = /* @__PURE__ */ pure(applicativeParserT);
var applySecond2 = /* @__PURE__ */ applySecond(applyParserT);
var map41 = /* @__PURE__ */ map(functorParserT);
var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);
var ordPackageName = ordString;
var eqPackageName = eqString;
var stripPureScriptPrefix = function(pkg) {
  return fromMaybe(pkg)(stripPrefix2("purescript-")(pkg));
};
var print5 = function(v) {
  return v;
};
var parser = /* @__PURE__ */ bind20(getParserT)(function(v) {
  var hasPureScriptPrefix = isJust(stripPrefix2("purescript-")(v.value0));
  var allowedPrefixNames = ["purescript-compiler-backend-utilities"];
  var isBlessedPackage = elem4(v.value0)(allowedPrefixNames);
  return discard5(when3(hasPureScriptPrefix && !isBlessedPackage)(fail2("Package names should not begin with 'purescript-'")))(function() {
    var acceptedChars = alt10(choice2([lower2, digit]))(fail2("Package name can contain lower case chars, digits and non-consecutive dashes"));
    var chunk1 = many1(acceptedChars);
    return bind20(alt10(chunk1)(fail2("Package name should start with a lower case char or a digit")))(function(firstChunk) {
      return bind20(bind20(flip(manyTill_)(eof)(bind20(alt10($$char3("-"))(fail2("Package name can contain lower case chars, digits and non-consecutive dashes")))(function() {
        return bind20(bind20(optionMaybe(lookAhead(anyChar)))(function(v1) {
          if (v1 instanceof Just) {
            if (v1.value0 === "-") {
              return fail2("Package names cannot contain consecutive dashes");
            }
            ;
            if (otherwise) {
              return pure29(unit);
            }
            ;
          }
          ;
          if (v1 instanceof Nothing) {
            return applySecond2(lookAhead(eof))(fail2("Package name should end with a lower case char or digit"));
          }
          ;
          throw new Error("Failed pattern match at Registry.PackageName (line 111, column 103 - line 115, column 91): " + [v1.constructor.name]);
        }))(function() {
          return alt10(map41(cons2("-"))(chunk1))(fail2("Package name should end with a lower case char or digit"));
        });
      })))(function(chunks) {
        return pure29(fst(chunks));
      }))(function(nextChunks) {
        return discard5(alt10(eof)(fail2("Package name can contain lower case chars, digits and non-consecutive dashes")))(function() {
          var allChunks = concatMap(toArray)(cons(firstChunk)(nextChunks));
          var name5 = fromCharArray(allChunks);
          var $29 = $$null2(name5);
          if ($29) {
            return fail2("Package name cannot be empty");
          }
          ;
          var $30 = length5(name5) > 150;
          if ($30) {
            return fail2("Package name cannot be longer than 150 characters");
          }
          ;
          return pure29(name5);
        });
      });
    });
  });
});
var parse3 = /* @__PURE__ */ function() {
  var $34 = lmap3(parseErrorMessage);
  var $35 = flip(runParser2)(parser);
  return function($36) {
    return $34($35($36));
  };
}();
var codec2 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $37 = encode2(string);
    return function($38) {
      return $37(print5($38));
    };
  }();
  var decode4 = composeKleisliFlipped(bindExceptT(monadIdentity))(function() {
    var $39 = except(applicativeIdentity);
    var $40 = lmap3(basic);
    return function($41) {
      return $39($40(parse3($41)));
    };
  }())(decode(string));
  return named("PackageName")(codec$prime(decode4)(encode6));
}();

// output/Data.Codec.JSON.Record/index.js
var coerce6 = /* @__PURE__ */ coerce();
var Optional = function(x) {
  return x;
};
var rowListCodecNil = {
  rowListCodec: function(v) {
    return function(v1) {
      return record;
    };
  }
};
var rowListCodec = function(dict) {
  return dict.rowListCodec;
};
var rowListCodecCons = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get6 = get3(dictIsSymbol)();
        var recordProp4 = recordProp(dictIsSymbol)();
        return {
          rowListCodec: function(v) {
            return function(codecs) {
              var tail4 = rowListCodec1($$Proxy.value)(codecs);
              var codec12 = get6($$Proxy.value)(codecs);
              return recordProp4($$Proxy.value)(codec12)(tail4);
            };
          }
        };
      };
    };
  };
};
var rowListCodecConsOptional = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get6 = get3(dictIsSymbol)();
        var recordPropOptional3 = recordPropOptional(dictIsSymbol)();
        return {
          rowListCodec: function(v) {
            return function(codecs) {
              var tail4 = rowListCodec1($$Proxy.value)(codecs);
              var codec12 = coerce6(get6($$Proxy.value)(codecs));
              return recordPropOptional3($$Proxy.value)(codec12)(tail4);
            };
          }
        };
      };
    };
  };
};
var record2 = function() {
  return function(dictRowListCodec) {
    return rowListCodec(dictRowListCodec)($$Proxy.value);
  };
};
var record1 = /* @__PURE__ */ record2();
var optional4 = Optional;
var object2 = function() {
  return function(dictRowListCodec) {
    var record22 = record1(dictRowListCodec);
    return function(rec) {
      return object(record22(rec));
    };
  };
};

// output/Control.Monad.State/index.js
var unwrap9 = /* @__PURE__ */ unwrap();
var runState = function(v) {
  return function($18) {
    return unwrap9(v($18));
  };
};

// output/Data.Formatter.Internal/index.js
var foldDigits = function(dictFoldable) {
  return foldl(dictFoldable)(function(acc) {
    return function(d) {
      return (acc * 10 | 0) + d | 0;
    };
  })(0);
};

// output/Data.Formatter.Parser.Utils/index.js
var show8 = /* @__PURE__ */ show(showInt);
var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);
var applyFirst2 = /* @__PURE__ */ applyFirst(applyParserT);
var voidLeft3 = /* @__PURE__ */ voidLeft(functorParserT);
var printPosition = function(v) {
  return "(line " + (show8(v.line) + (", col " + (show8(v.column) + ")")));
};
var printError = function(err) {
  return parseErrorMessage(err) + (" " + printPosition(parseErrorPosition(err)));
};
var runP2 = function(p) {
  return function(s) {
    return lmap4(printError)(runParser2(s)(applyFirst2(p)(eof)));
  };
};
var oneOfAs = function(dictFunctor) {
  var map154 = map(dictFunctor);
  return function(dictFoldable) {
    var choice4 = choice(dictFoldable);
    return function(dictMonad) {
      return function(p) {
        return function(xs) {
          return choice4(map154(function(v) {
            return voidLeft3(p(v.value0))(v.value1);
          })(xs));
        };
      };
    };
  };
};

// output/Data.Formatter.Parser.Number/index.js
var oneOfAs2 = /* @__PURE__ */ oneOfAs(functorArray)(foldableArray);
var parseDigit = function(dictMonad) {
  return $$try4(oneOfAs2(dictMonad)($$char3)([new Tuple("0", 0), new Tuple("1", 1), new Tuple("2", 2), new Tuple("3", 3), new Tuple("4", 4), new Tuple("5", 5), new Tuple("6", 6), new Tuple("7", 7), new Tuple("8", 8), new Tuple("9", 9)]));
};

// output/Data.Formatter.DateTime/index.js
var bind21 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(bindEither));
var ask2 = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadEither));
var lift7 = /* @__PURE__ */ lift(monadTransReaderT)(monadEither);
var show9 = /* @__PURE__ */ show(showInt);
var for_2 = /* @__PURE__ */ for_(applicativeEither)(foldableArray);
var when4 = /* @__PURE__ */ when(applicativeEither);
var pure30 = /* @__PURE__ */ pure(applicativeEither);
var foldMap5 = /* @__PURE__ */ foldMap(foldableList);
var foldMap15 = /* @__PURE__ */ foldMap5(monoidString);
var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorParserT);
var oneOfAs3 = /* @__PURE__ */ oneOfAs(functorArray)(foldableArray);
var bind110 = /* @__PURE__ */ bind(bindParserT);
var foldDigits2 = /* @__PURE__ */ foldDigits(foldableList);
var pure113 = /* @__PURE__ */ pure(applicativeParserT);
var map45 = /* @__PURE__ */ map(functorParserT);
var negate3 = /* @__PURE__ */ negate(ringInt);
var identity22 = /* @__PURE__ */ identity(categoryFn);
var abs3 = /* @__PURE__ */ abs(ordInt)(ringInt);
var some3 = /* @__PURE__ */ some2(alternativeParserT)(lazyParserT);
var fromEnum11 = /* @__PURE__ */ fromEnum(boundedEnumYear);
var show14 = /* @__PURE__ */ show(showMonth);
var fromEnum12 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromEnum23 = /* @__PURE__ */ fromEnum(boundedEnumDay);
var unwrap10 = /* @__PURE__ */ unwrap();
var fromEnum33 = /* @__PURE__ */ fromEnum(boundedEnumWeekday);
var show23 = /* @__PURE__ */ show(showWeekday);
var fromEnum43 = /* @__PURE__ */ fromEnum(boundedEnumHour);
var mod5 = /* @__PURE__ */ mod(euclideanRingInt);
var fromEnum52 = /* @__PURE__ */ fromEnum(boundedEnumMinute);
var fromEnum62 = /* @__PURE__ */ fromEnum(boundedEnumSecond);
var fromEnum72 = /* @__PURE__ */ fromEnum(boundedEnumMillisecond);
var div1 = /* @__PURE__ */ div(euclideanRingInt);
var monadStateT3 = /* @__PURE__ */ monadStateT(monadIdentity);
var lift13 = /* @__PURE__ */ lift(monadTransParserT)(monadStateT3);
var monadStateStateT2 = /* @__PURE__ */ monadStateStateT(monadIdentity);
var modify_4 = /* @__PURE__ */ modify_2(monadStateStateT2);
var lift25 = /* @__PURE__ */ lift2(applyParserT);
var mul2 = /* @__PURE__ */ mul(semiringInt);
var parseDigit2 = /* @__PURE__ */ parseDigit(monadStateT3);
var append111 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupReaderT(applyEither)(semigroupUnit));
var map117 = /* @__PURE__ */ map(functorMaybe);
var put4 = /* @__PURE__ */ put(monadStateStateT2);
var $$void11 = /* @__PURE__ */ $$void(functorParserT);
var applySecond3 = /* @__PURE__ */ applySecond(applyEither);
var apply16 = /* @__PURE__ */ apply2(applyEither);
var map214 = /* @__PURE__ */ map(functorEither);
var toEnum5 = /* @__PURE__ */ toEnum(boundedEnumYear);
var toEnum1 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var toEnum23 = /* @__PURE__ */ toEnum(boundedEnumDay);
var toEnum32 = /* @__PURE__ */ toEnum(boundedEnumHour);
var toEnum42 = /* @__PURE__ */ toEnum(boundedEnumMinute);
var toEnum52 = /* @__PURE__ */ toEnum(boundedEnumSecond);
var toEnum6 = /* @__PURE__ */ toEnum(boundedEnumMillisecond);
var voidLeft4 = /* @__PURE__ */ voidLeft(functorEither);
var mapParserT2 = /* @__PURE__ */ mapParserT(/* @__PURE__ */ monadRecStateT(monadRecIdentity));
var foldMap22 = /* @__PURE__ */ foldMap5(/* @__PURE__ */ monoidParserT(monoidUnit));
var AM = /* @__PURE__ */ function() {
  function AM2() {
  }
  ;
  AM2.value = new AM2();
  return AM2;
}();
var PM = /* @__PURE__ */ function() {
  function PM2() {
  }
  ;
  PM2.value = new PM2();
  return PM2;
}();
var YearFull = /* @__PURE__ */ function() {
  function YearFull2() {
  }
  ;
  YearFull2.value = new YearFull2();
  return YearFull2;
}();
var YearTwoDigits = /* @__PURE__ */ function() {
  function YearTwoDigits2() {
  }
  ;
  YearTwoDigits2.value = new YearTwoDigits2();
  return YearTwoDigits2;
}();
var YearAbsolute = /* @__PURE__ */ function() {
  function YearAbsolute2() {
  }
  ;
  YearAbsolute2.value = new YearAbsolute2();
  return YearAbsolute2;
}();
var MonthFull = /* @__PURE__ */ function() {
  function MonthFull2() {
  }
  ;
  MonthFull2.value = new MonthFull2();
  return MonthFull2;
}();
var MonthShort = /* @__PURE__ */ function() {
  function MonthShort2() {
  }
  ;
  MonthShort2.value = new MonthShort2();
  return MonthShort2;
}();
var MonthTwoDigits = /* @__PURE__ */ function() {
  function MonthTwoDigits2() {
  }
  ;
  MonthTwoDigits2.value = new MonthTwoDigits2();
  return MonthTwoDigits2;
}();
var DayOfMonthTwoDigits = /* @__PURE__ */ function() {
  function DayOfMonthTwoDigits2() {
  }
  ;
  DayOfMonthTwoDigits2.value = new DayOfMonthTwoDigits2();
  return DayOfMonthTwoDigits2;
}();
var DayOfMonth = /* @__PURE__ */ function() {
  function DayOfMonth2() {
  }
  ;
  DayOfMonth2.value = new DayOfMonth2();
  return DayOfMonth2;
}();
var UnixTimestamp = /* @__PURE__ */ function() {
  function UnixTimestamp2() {
  }
  ;
  UnixTimestamp2.value = new UnixTimestamp2();
  return UnixTimestamp2;
}();
var DayOfWeek = /* @__PURE__ */ function() {
  function DayOfWeek2() {
  }
  ;
  DayOfWeek2.value = new DayOfWeek2();
  return DayOfWeek2;
}();
var DayOfWeekName = /* @__PURE__ */ function() {
  function DayOfWeekName2() {
  }
  ;
  DayOfWeekName2.value = new DayOfWeekName2();
  return DayOfWeekName2;
}();
var DayOfWeekNameShort = /* @__PURE__ */ function() {
  function DayOfWeekNameShort2() {
  }
  ;
  DayOfWeekNameShort2.value = new DayOfWeekNameShort2();
  return DayOfWeekNameShort2;
}();
var Hours24 = /* @__PURE__ */ function() {
  function Hours242() {
  }
  ;
  Hours242.value = new Hours242();
  return Hours242;
}();
var Hours12 = /* @__PURE__ */ function() {
  function Hours122() {
  }
  ;
  Hours122.value = new Hours122();
  return Hours122;
}();
var Meridiem = /* @__PURE__ */ function() {
  function Meridiem2() {
  }
  ;
  Meridiem2.value = new Meridiem2();
  return Meridiem2;
}();
var Minutes2 = /* @__PURE__ */ function() {
  function Minutes3() {
  }
  ;
  Minutes3.value = new Minutes3();
  return Minutes3;
}();
var MinutesTwoDigits = /* @__PURE__ */ function() {
  function MinutesTwoDigits2() {
  }
  ;
  MinutesTwoDigits2.value = new MinutesTwoDigits2();
  return MinutesTwoDigits2;
}();
var Seconds = /* @__PURE__ */ function() {
  function Seconds2() {
  }
  ;
  Seconds2.value = new Seconds2();
  return Seconds2;
}();
var SecondsTwoDigits = /* @__PURE__ */ function() {
  function SecondsTwoDigits2() {
  }
  ;
  SecondsTwoDigits2.value = new SecondsTwoDigits2();
  return SecondsTwoDigits2;
}();
var Milliseconds2 = /* @__PURE__ */ function() {
  function Milliseconds3() {
  }
  ;
  Milliseconds3.value = new Milliseconds3();
  return Milliseconds3;
}();
var MillisecondsShort = /* @__PURE__ */ function() {
  function MillisecondsShort2() {
  }
  ;
  MillisecondsShort2.value = new MillisecondsShort2();
  return MillisecondsShort2;
}();
var MillisecondsTwoDigits = /* @__PURE__ */ function() {
  function MillisecondsTwoDigits2() {
  }
  ;
  MillisecondsTwoDigits2.value = new MillisecondsTwoDigits2();
  return MillisecondsTwoDigits2;
}();
var Placeholder = /* @__PURE__ */ function() {
  function Placeholder2(value0) {
    this.value0 = value0;
  }
  ;
  Placeholder2.create = function(value0) {
    return new Placeholder2(value0);
  };
  return Placeholder2;
}();
var validateRange = function(min8) {
  return function(max8) {
    return bind21(ask2)(function(v) {
      return lift7(function() {
        var $316 = v.num < min8 || v.num > max8;
        if ($316) {
          return new Left("Number is out of range [ " + (show9(min8) + (", " + (show9(max8) + " ]"))));
        }
        ;
        return new Right(unit);
      }());
    });
  };
};
var validAccum = function(v) {
  if (v.hour instanceof Just && v.hour.value0 === 24) {
    return for_2([v.minute, v.second, v.millisecond])(function(val) {
      return when4(fromMaybe(0)(val) > 0)(new Left("When hour is 24, other time components must be 0"));
    });
  }
  ;
  return pure30(unit);
};
var takeSome = function(dictAlternative) {
  var Applicative0 = dictAlternative.Applicative0();
  var pure217 = pure(Applicative0);
  var apply111 = apply2(Applicative0.Apply0());
  var map317 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return function(v1) {
        if (v === 0) {
          return pure217(Nil.value);
        }
        ;
        return apply111(map317(Cons.create)(v1))(defer6(function(v3) {
          return takeMany(dictAlternative)(dictLazy)(v - 1 | 0)(v1);
        }));
      };
    };
  };
};
var takeMany = function(dictAlternative) {
  var pure217 = pure(dictAlternative.Applicative0());
  var alt40 = alt(dictAlternative.Plus1().Alt0());
  return function(dictLazy) {
    return function(v) {
      return function(v1) {
        if (v === 0) {
          return pure217(Nil.value);
        }
        ;
        return alt40(takeSome(dictAlternative)(dictLazy)(v)(v1))(pure217(Nil.value));
      };
    };
  };
};
var takeSome1 = /* @__PURE__ */ takeSome(alternativeParserT)(lazyParserT);
var printShortMonth = function(v) {
  if (v instanceof January) {
    return "Jan";
  }
  ;
  if (v instanceof February) {
    return "Feb";
  }
  ;
  if (v instanceof March) {
    return "Mar";
  }
  ;
  if (v instanceof April) {
    return "Apr";
  }
  ;
  if (v instanceof May) {
    return "May";
  }
  ;
  if (v instanceof June) {
    return "Jun";
  }
  ;
  if (v instanceof July) {
    return "Jul";
  }
  ;
  if (v instanceof August) {
    return "Aug";
  }
  ;
  if (v instanceof September) {
    return "Sep";
  }
  ;
  if (v instanceof October) {
    return "Oct";
  }
  ;
  if (v instanceof November) {
    return "Nov";
  }
  ;
  if (v instanceof December) {
    return "Dec";
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 489, column 19 - line 501, column 22): " + [v.constructor.name]);
};
var parseShortMonth = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($659) {
    return $$try4(string3($659));
  })([new Tuple("Jan", January.value), new Tuple("Feb", February.value), new Tuple("Mar", March.value), new Tuple("Apr", April.value), new Tuple("May", May.value), new Tuple("Jun", June.value), new Tuple("Jul", July.value), new Tuple("Aug", August.value), new Tuple("Sep", September.value), new Tuple("Oct", October.value), new Tuple("Nov", November.value), new Tuple("Dec", December.value)]);
};
var parseShortMonth1 = /* @__PURE__ */ parseShortMonth(monadStateT3);
var parseMonth = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($660) {
    return $$try4(string3($660));
  })([new Tuple("January", January.value), new Tuple("February", February.value), new Tuple("March", March.value), new Tuple("April", April.value), new Tuple("May", May.value), new Tuple("June", June.value), new Tuple("July", July.value), new Tuple("August", August.value), new Tuple("September", September.value), new Tuple("October", October.value), new Tuple("November", November.value), new Tuple("December", December.value)]);
};
var parseMonth1 = /* @__PURE__ */ parseMonth(monadStateT3);
var parseMeridiem = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($661) {
    return $$try4(string3($661));
  })([new Tuple("am", AM.value), new Tuple("AM", AM.value), new Tuple("pm", PM.value), new Tuple("PM", PM.value)]);
};
var parseMeridiem1 = /* @__PURE__ */ parseMeridiem(monadStateT3);
var $$parseInt = function(dictMonad) {
  var parseDigit1 = parseDigit(dictMonad);
  return function(maxLength) {
    return function(validators) {
      return function(errMsg) {
        return bind110(takeSome1(maxLength)(parseDigit1))(function(ds) {
          var num = foldDigits2(ds);
          var length9 = length6(ds);
          var v = runReaderT(validators)({
            length: length9,
            num,
            maxLength
          });
          if (v instanceof Left) {
            return fail2(errMsg + ("(" + (v.value0 + ")")));
          }
          ;
          if (v instanceof Right) {
            return pure113(num);
          }
          ;
          throw new Error("Failed pattern match at Data.Formatter.DateTime (line 342, column 3 - line 344, column 24): " + [v.constructor.name]);
        });
      };
    };
  };
};
var parseInt1 = /* @__PURE__ */ $$parseInt(monadStateT3);
var parseSignedInt = function(dictMonad) {
  var parseInt2 = $$parseInt(dictMonad);
  return function(maxLength) {
    return function(validators) {
      return function(errMsg) {
        return bind110(map45(isJust)(optionMaybe($$char3("-"))))(function(isNegative) {
          return map45(function() {
            if (isNegative) {
              return negate3;
            }
            ;
            return identity22;
          }())(parseInt2(maxLength)(validators)(errMsg));
        });
      };
    };
  };
};
var parseSignedInt1 = /* @__PURE__ */ parseSignedInt(monadStateT3);
var parseDayOfWeekNameShort = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($662) {
    return $$try4(string3($662));
  })([new Tuple("Mon", Monday.value), new Tuple("Tue", Tuesday.value), new Tuple("Wed", Wednesday.value), new Tuple("Thu", Thursday.value), new Tuple("Fri", Friday.value), new Tuple("Sat", Saturday.value), new Tuple("Sun", Sunday.value)]);
};
var parseDayOfWeekNameShort1 = /* @__PURE__ */ parseDayOfWeekNameShort(monadStateT3);
var parseDayOfWeekName = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($663) {
    return $$try4(string3($663));
  })([new Tuple("Monday", Monday.value), new Tuple("Tuesday", Tuesday.value), new Tuple("Wednesday", Wednesday.value), new Tuple("Thursday", Thursday.value), new Tuple("Friday", Friday.value), new Tuple("Saturday", Saturday.value), new Tuple("Sunday", Sunday.value)]);
};
var parseDayOfWeekName1 = /* @__PURE__ */ parseDayOfWeekName(monadStateT3);
var padSingleDigit = function(i) {
  if (i < 0) {
    return "-" + padSingleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "0" + show9(i);
  }
  ;
  if (otherwise) {
    return show9(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 194, column 1 - line 194, column 32): " + [i.constructor.name]);
};
var padQuadrupleDigit = function(i) {
  if (i < 0) {
    return "-" + padQuadrupleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "000" + show9(i);
  }
  ;
  if (i < 100) {
    return "00" + show9(i);
  }
  ;
  if (i < 1e3) {
    return "0" + show9(i);
  }
  ;
  if (otherwise) {
    return show9(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 207, column 1 - line 207, column 35): " + [i.constructor.name]);
};
var padDoubleDigit = function(i) {
  if (i < 0) {
    return "-" + padDoubleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "00" + show9(i);
  }
  ;
  if (i < 100) {
    return "0" + show9(i);
  }
  ;
  if (otherwise) {
    return show9(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 200, column 1 - line 200, column 32): " + [i.constructor.name]);
};
var initialAccum = /* @__PURE__ */ function() {
  return {
    year: Nothing.value,
    month: Nothing.value,
    day: Nothing.value,
    hour: Nothing.value,
    minute: Nothing.value,
    second: Nothing.value,
    millisecond: Nothing.value,
    meridiem: Nothing.value
  };
}();
var formatYearTwoDigits = function(i) {
  var dateString = show9(abs3(i));
  var dateLength = length5(dateString);
  if (dateLength === 1) {
    return "0" + dateString;
  }
  ;
  if (dateLength === 2) {
    return dateString;
  }
  ;
  return drop3(dateLength - 2 | 0)(dateString);
};
var fix12 = function(h) {
  var $618 = h === 0;
  if ($618) {
    return 12;
  }
  ;
  return h;
};
var formatCommand = function(v) {
  return function(v1) {
    if (v1 instanceof YearFull) {
      return padQuadrupleDigit(fromEnum11(year(v.value0)));
    }
    ;
    if (v1 instanceof YearTwoDigits) {
      return formatYearTwoDigits(fromEnum11(year(v.value0)));
    }
    ;
    if (v1 instanceof YearAbsolute) {
      return show9(fromEnum11(year(v.value0)));
    }
    ;
    if (v1 instanceof MonthFull) {
      return show14(month(v.value0));
    }
    ;
    if (v1 instanceof MonthShort) {
      return printShortMonth(month(v.value0));
    }
    ;
    if (v1 instanceof MonthTwoDigits) {
      return padSingleDigit(fromEnum12(month(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonthTwoDigits) {
      return padSingleDigit(fromEnum23(day(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonth) {
      return show9(fromEnum23(day(v.value0)));
    }
    ;
    if (v1 instanceof UnixTimestamp) {
      return show9(floor2(function(v2) {
        return v2 / 1e3;
      }(unwrap10(unInstant(fromDateTime(v))))));
    }
    ;
    if (v1 instanceof DayOfWeek) {
      return show9(fromEnum33(weekday(v.value0)));
    }
    ;
    if (v1 instanceof DayOfWeekName) {
      return show23(weekday(v.value0));
    }
    ;
    if (v1 instanceof DayOfWeekNameShort) {
      return take3(3)(show23(weekday(v.value0)));
    }
    ;
    if (v1 instanceof Hours24) {
      return padSingleDigit(fromEnum43(hour(v.value1)));
    }
    ;
    if (v1 instanceof Hours12) {
      return padSingleDigit(fix12(mod5(fromEnum43(hour(v.value1)))(12)));
    }
    ;
    if (v1 instanceof Meridiem) {
      var $621 = fromEnum43(hour(v.value1)) >= 12;
      if ($621) {
        return "PM";
      }
      ;
      return "AM";
    }
    ;
    if (v1 instanceof Minutes2) {
      return show9(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof MinutesTwoDigits) {
      return padSingleDigit(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof Seconds) {
      return show9(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof SecondsTwoDigits) {
      return padSingleDigit(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof Milliseconds2) {
      return padDoubleDigit(fromEnum72(millisecond(v.value1)));
    }
    ;
    if (v1 instanceof MillisecondsShort) {
      return show9(function(v2) {
        return div1(v2)(100);
      }(fromEnum72(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof MillisecondsTwoDigits) {
      return padSingleDigit(function(v2) {
        return div1(v2)(10);
      }(fromEnum72(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof Placeholder) {
      return v1.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 169, column 38 - line 192, column 21): " + [v1.constructor.name]);
  };
};
var format = function(f) {
  return function(d) {
    return foldMap15(formatCommand(d))(f);
  };
};
var exactLength = /* @__PURE__ */ bind21(ask2)(function(v) {
  return lift7(function() {
    var $626 = v.maxLength !== v.length;
    if ($626) {
      return new Left("Expected " + (show9(v.maxLength) + (" digits but got " + show9(v.length))));
    }
    ;
    return new Right(unit);
  }());
});
var unformatCommandParser = /* @__PURE__ */ function() {
  var modifyWithParser = function(f) {
    return function(p) {
      return bind110(p)(function(v) {
        return lift13(modify_4(flip(f)(new Just(v))));
      });
    };
  };
  return function(v) {
    if (v instanceof YearFull) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v2
          };
        };
      })(parseSignedInt1(4)(exactLength)("Incorrect full year"));
    }
    ;
    if (v instanceof YearTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v2
          };
        };
      })(parseSignedInt1(2)(exactLength)("Incorrect 2-digit year"));
    }
    ;
    if (v instanceof YearAbsolute) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v2
          };
        };
      })(lift25(mul2)(option2(1)($$try4(mapFlipped4(string3("-"))($$const(-1 | 0)))))(mapFlipped4(some3(parseDigit2))(foldDigits2)));
    }
    ;
    if (v instanceof MonthFull) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year,
            month: v2
          };
        };
      })(map45(fromEnum12)(parseMonth1));
    }
    ;
    if (v instanceof MonthShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year,
            month: v2
          };
        };
      })(map45(fromEnum12)(parseShortMonth1));
    }
    ;
    if (v instanceof MonthTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year,
            month: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(1)(12))(exactLength))("Incorrect 2-digit month"));
    }
    ;
    if (v instanceof DayOfMonthTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            day: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(1)(31))(exactLength))("Incorrect day of month"));
    }
    ;
    if (v instanceof DayOfMonth) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            day: v2
          };
        };
      })(parseInt1(2)(validateRange(1)(31))("Incorrect day of month"));
    }
    ;
    if (v instanceof UnixTimestamp) {
      return bind110(map45(foldDigits2)(some3(parseDigit2)))(function(s) {
        var v1 = map117(toDateTime)(instant(1e3 * toNumber(s)));
        if (v1 instanceof Nothing) {
          return fail2("Incorrect timestamp");
        }
        ;
        if (v1 instanceof Just) {
          return lift13(put4({
            year: new Just(fromEnum11(year(v1.value0.value0))),
            month: new Just(fromEnum12(month(v1.value0.value0))),
            day: new Just(fromEnum23(day(v1.value0.value0))),
            hour: new Just(fromEnum43(hour(v1.value0.value1))),
            minute: new Just(fromEnum52(minute(v1.value0.value1))),
            second: new Just(fromEnum62(second(v1.value0.value1))),
            millisecond: new Just(fromEnum72(millisecond(v1.value0.value1))),
            meridiem: Nothing.value
          }));
        }
        ;
        throw new Error("Failed pattern match at Data.Formatter.DateTime (line 369, column 5 - line 380, column 10): " + [v1.constructor.name]);
      });
    }
    ;
    if (v instanceof DayOfWeek) {
      return $$void11(parseInt1(1)(validateRange(1)(7))("Incorrect day of week"));
    }
    ;
    if (v instanceof DayOfWeekName) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            day: v2
          };
        };
      })(map45(fromEnum33)(parseDayOfWeekName1));
    }
    ;
    if (v instanceof DayOfWeekNameShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            day: v2
          };
        };
      })(map45(fromEnum33)(parseDayOfWeekNameShort1));
    }
    ;
    if (v instanceof Hours24) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            hour: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(0)(24))(exactLength))("Incorrect 24 hour"));
    }
    ;
    if (v instanceof Hours12) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            hour: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(0)(12))(exactLength))("Incorrect 12 hour"));
    }
    ;
    if (v instanceof Meridiem) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            meridiem: v2
          };
        };
      })(parseMeridiem1);
    }
    ;
    if (v instanceof MinutesTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            minute: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(0)(59))(exactLength))("Incorrect 2-digit minute"));
    }
    ;
    if (v instanceof Minutes2) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            minute: v2
          };
        };
      })(parseInt1(2)(validateRange(0)(59))("Incorrect minute"));
    }
    ;
    if (v instanceof SecondsTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            year: v1.year,
            second: v2
          };
        };
      })(parseInt1(2)(append111(validateRange(0)(59))(exactLength))("Incorrect 2-digit second"));
    }
    ;
    if (v instanceof Seconds) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            year: v1.year,
            second: v2
          };
        };
      })(parseInt1(2)(validateRange(0)(59))("Incorrect second"));
    }
    ;
    if (v instanceof Milliseconds2) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            millisecond: v2
          };
        };
      })(parseInt1(3)(exactLength)("Incorrect millisecond"));
    }
    ;
    if (v instanceof Placeholder) {
      return $$void11(string3(v.value0));
    }
    ;
    if (v instanceof MillisecondsShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            millisecond: v2
          };
        };
      })(mapFlipped4(parseInt1(1)(exactLength)("Incorrect 1-digit millisecond"))(function(v1) {
        return v1 * 100 | 0;
      }));
    }
    ;
    if (v instanceof MillisecondsTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year,
            millisecond: v2
          };
        };
      })(mapFlipped4(parseInt1(2)(exactLength)("Incorrect 2-digit millisecond"))(function(v1) {
        return v1 * 10 | 0;
      }));
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 347, column 25 - line 406, column 74): " + [v.constructor.name]);
  };
}();
var adjustMeridiem = function(v) {
  return function(v1) {
    if (v instanceof Just && (v.value0 instanceof AM && v1 === 12)) {
      return 0;
    }
    ;
    if (v instanceof Just && (v.value0 instanceof PM && v1 === 12)) {
      return 12;
    }
    ;
    if (v instanceof Just && v.value0 instanceof PM) {
      return v1 + 12 | 0;
    }
    ;
    if (v instanceof Just && v.value0 instanceof AM) {
      return v1;
    }
    ;
    if (v instanceof Nothing && v1 === 24) {
      return 0;
    }
    ;
    if (v instanceof Nothing) {
      return v1;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 279, column 1 - line 279, column 47): " + [v.constructor.name, v1.constructor.name]);
  };
};
var adjustDay = function(v) {
  return function(v1) {
    if (v instanceof Just && v.value0 === 24) {
      return v1 + 1 | 0;
    }
    ;
    return v1;
  };
};
var unformatAccumToDateTime = function(a) {
  return applySecond3(validAccum(a))(apply16(map214(DateTime.create)(apply16(apply16(map214(canonicalDate)(maybe(new Left("Incorrect year"))(pure30)(toEnum5(fromMaybe(0)(a.year)))))(maybe(new Left("Incorrect month"))(pure30)(toEnum1(fromMaybe(1)(a.month)))))(maybe(new Left("Incorrect day"))(pure30)(toEnum23(adjustDay(a.hour)(fromMaybe(1)(a.day)))))))(apply16(apply16(apply16(map214(Time.create)(maybe(new Left("Incorrect hour"))(pure30)(toEnum32(fromMaybe(0)(map117(adjustMeridiem(a.meridiem))(a.hour))))))(maybe(new Left("Incorrect minute"))(pure30)(toEnum42(fromMaybe(0)(a.minute)))))(maybe(new Left("Incorrect second"))(pure30)(toEnum52(fromMaybe(0)(a.second)))))(maybe(new Left("Incorrect millisecond"))(pure30)(toEnum6(fromMaybe(0)(a.millisecond))))));
};
var unformatParser = function(dictMonad) {
  var mapParserT1 = mapParserT2(dictMonad.Bind1().Apply0().Functor0());
  return function(f) {
    var unState = function(dictMonad1) {
      var pure217 = pure(dictMonad1.Applicative0());
      return function(s) {
        var v = runState(s)(initialAccum);
        return pure217(new Tuple(voidLeft4(v.value0.value0)(v.value1), v.value0.value1));
      };
    };
    return bind110(mapParserT1(unState(dictMonad))(foldMap22(unformatCommandParser)(f)))(function(acc) {
      return either(fail2)(pure113)(unformatAccumToDateTime(acc));
    });
  };
};
var unformat = /* @__PURE__ */ function() {
  var $665 = unformatParser(monadIdentity);
  return function($666) {
    return runP2($665($666));
  };
}();

// output/Registry.Internal.Parsing/index.js
var bind23 = /* @__PURE__ */ bind(bindParserT);
var alt11 = /* @__PURE__ */ alt(altParserT);
var voidLeft5 = /* @__PURE__ */ voidLeft(functorParserT);
var pure31 = /* @__PURE__ */ pure(applicativeParserT);
var applySecond4 = /* @__PURE__ */ applySecond(applyParserT);
var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorParserT);
var show10 = /* @__PURE__ */ show(showInt);
var fold10 = /* @__PURE__ */ fold2(monoidString);
var gitUrl = /* @__PURE__ */ bind23(getParserT)(function(v) {
  return bind23(alt11(string3("git"))(alt11(string3("https"))(string3("http"))))(function() {
    return bind23(string3("://"))(function() {
      return bind23(function() {
        var terminator = alt11(voidLeft5(string3(".git"))(false))(voidLeft5(eof)(true));
        var matcher = alt11(alphaNum)(oneOf3([".", "/", "@", "_", "-", "~"]));
        return manyTill_(matcher)(terminator);
      }())(function(v1) {
        if (v1.value1) {
          return pure31(v.value0);
        }
        ;
        return bind23(optional3($$try4($$char3("/"))))(function() {
          return bind23(eof)(function() {
            return pure31(v.value0);
          });
        });
      });
    });
  });
});
var charsUntil = /* @__PURE__ */ function() {
  var $28 = map(functorParserT)(fst);
  var $29 = manyTill_(anyChar);
  return function($30) {
    return $28($29($30));
  };
}();
var charsUntilSpace = /* @__PURE__ */ charsUntil(/* @__PURE__ */ $$char3(" "));
var rfc3339 = /* @__PURE__ */ bind23(/* @__PURE__ */ takeN(4))(function(year2) {
  return bind23($$char3("-"))(function() {
    return bind23(takeN(2))(function(month2) {
      return bind23($$char3("-"))(function() {
        return bind23(takeN(2))(function(day2) {
          return bind23($$char3("T"))(function() {
            return bind23(takeN(2))(function(hour2) {
              return bind23($$char3(":"))(function() {
                return bind23(takeN(2))(function(minute2) {
                  return bind23($$char3(":"))(function() {
                    return bind23(takeN(2))(function(second3) {
                      return bind23(bind23(optionMaybe($$char3(".")))(function(v) {
                        if (v instanceof Nothing) {
                          return applySecond4($$char3("Z"))(pure31("000"));
                        }
                        ;
                        if (v instanceof Just) {
                          return mapFlipped5(charsUntil($$char3("Z")))(fromCharArray);
                        }
                        ;
                        throw new Error("Failed pattern match at Registry.Internal.Parsing (line 60, column 82 - line 62, column 79): " + [v.constructor.name]);
                      }))(function(milliseconds$prime) {
                        return bind23(function() {
                          var v = length5(milliseconds$prime);
                          if (v === 0) {
                            return pure31("000");
                          }
                          ;
                          if (v === 1) {
                            return pure31(milliseconds$prime + "00");
                          }
                          ;
                          if (v === 2) {
                            return pure31(milliseconds$prime + "0");
                          }
                          ;
                          if (v === 3) {
                            return pure31(milliseconds$prime);
                          }
                          ;
                          return fail2("Expected milliseconds with length 0-3, but received milliseconds with length: " + show10(v));
                        }())(function(milliseconds) {
                          return pure31({
                            date: fold10([year2, "-", month2, "-", day2]),
                            time: fold10([hour2, ":", minute2, ":", second3]),
                            milliseconds
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
var chars = /* @__PURE__ */ many(alternativeParserT)(lazyParserT)(anyChar);

// output/Registry.Internal.Format/index.js
var bind24 = /* @__PURE__ */ bind(bindEither);
var lmap5 = /* @__PURE__ */ lmap(bifunctorEither);
var pure33 = /* @__PURE__ */ pure(applicativeEither);
var fold11 = /* @__PURE__ */ fold2(monoidString);
var fromFoldable21 = /* @__PURE__ */ fromFoldable6(foldableArray);
var rfc3339ToISO8601 = function(input) {
  return bind24(lmap5(parseErrorMessage)(runParser2(input)(rfc3339)))(function(v) {
    return pure33(fold11([v.date, "T", v.time, ".", v.milliseconds, "Z"]));
  });
};
var iso8601Date = /* @__PURE__ */ function() {
  return fromFoldable21([YearFull.value, new Placeholder("-"), MonthTwoDigits.value, new Placeholder("-"), DayOfMonthTwoDigits.value]);
}();
var iso8601DateTime = /* @__PURE__ */ function() {
  var utcFormat = fromFoldable21([Milliseconds2.value, new Placeholder("Z")]);
  var timeFormat = fromFoldable21([Hours24.value, new Placeholder(":"), MinutesTwoDigits.value, new Placeholder(":"), SecondsTwoDigits.value]);
  return fold(foldableArray)(monoidList)([iso8601Date, singleton8(new Placeholder("T")), timeFormat, singleton8(new Placeholder(".")), utcFormat]);
}();

// output/Registry.Version/index.js
var compare5 = /* @__PURE__ */ compare(ordInt);
var map46 = /* @__PURE__ */ map(functorArray);
var bind25 = /* @__PURE__ */ bind(bindParserT);
var pure34 = /* @__PURE__ */ pure(applicativeParserT);
var discard6 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var when5 = /* @__PURE__ */ when(applicativeParserT);
var show11 = /* @__PURE__ */ show(showInt);
var lmap6 = /* @__PURE__ */ lmap(bifunctorEither);
var eqVersion = {
  eq: function(v) {
    return function(v1) {
      var v2 = v.major === v1.major;
      if (v2) {
        var v3 = v.minor === v1.minor;
        if (v3) {
          return v.patch === v1.patch;
        }
        ;
        return v3;
      }
      ;
      return v2;
    };
  }
};
var ordVersion = {
  compare: function(v) {
    return function(v1) {
      var v2 = compare5(v.major)(v1.major);
      if (v2 instanceof EQ) {
        var v3 = compare5(v.minor)(v1.minor);
        if (v3 instanceof EQ) {
          return compare5(v.patch)(v1.patch);
        }
        ;
        return v3;
      }
      ;
      return v2;
    };
  },
  Eq0: function() {
    return eqVersion;
  }
};
var print6 = function(v) {
  var places = map46(toStringAs(decimal))([v.major, v.minor, v.patch]);
  return joinWith(".")(places);
};
var patch = function(v) {
  return v.patch;
};
var parser2 = /* @__PURE__ */ function() {
  var nonNegativeInt2 = bind25(many1(digit))(function(digitChars) {
    var zeroCount = length(takeWhile2(function(v) {
      return v === "0";
    })(digitChars));
    var digitString = fromCharArray(toArray(digitChars));
    var failInteger = fail2("Invalid 32-bit integer: " + digitString);
    return bind25(maybe(failInteger)(pure34)(fromString3(digitString)))(function(integer) {
      return discard6(when5(zeroCount > 1 || zeroCount === 1 && integer !== 0)(fail2("Leading zeros are not allowed: " + digitString)))(function() {
        return discard6(when5(integer < 0)(fail2("Invalid non-negative integer: " + show11(integer))))(function() {
          return pure34(integer);
        });
      });
    });
  });
  return bind25(nonNegativeInt2)(function(major$prime) {
    return bind25($$char3("."))(function() {
      return bind25(nonNegativeInt2)(function(minor$prime) {
        return bind25($$char3("."))(function() {
          return bind25(nonNegativeInt2)(function(patch$prime) {
            return discard6(eof)(function() {
              return pure34({
                major: major$prime,
                minor: minor$prime,
                patch: patch$prime
              });
            });
          });
        });
      });
    });
  });
}();
var parse4 = /* @__PURE__ */ function() {
  var $68 = lmap6(parseErrorMessage);
  var $69 = flip(runParser2)(parser2);
  return function($70) {
    return $68($69($70));
  };
}();
var minor = function(v) {
  return v.minor;
};
var major = function(v) {
  return v.major;
};
var codec3 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $71 = encode2(string);
    return function($72) {
      return $71(print6($72));
    };
  }();
  var decode4 = composeKleisliFlipped(bindExceptT(monadIdentity))(function() {
    var $73 = except(applicativeIdentity);
    var $74 = lmap6(basic);
    return function($75) {
      return $73($74(parse4($75)));
    };
  }())(decode(string));
  return named("Version")(codec$prime(decode4)(encode6));
}();
var bumpPatch = function(v) {
  return {
    major: v.major,
    minor: v.minor,
    patch: v.patch + 1 | 0
  };
};
var bumpMinor = function(v) {
  return {
    major: v.major,
    minor: v.minor + 1 | 0,
    patch: 0
  };
};
var bumpMajor = function(v) {
  return {
    major: v.major + 1 | 0,
    minor: 0,
    patch: 0
  };
};
var bumpHighest = function(v) {
  var $66 = v.major >= 1;
  if ($66) {
    return bumpMajor(v);
  }
  ;
  var $67 = v.minor >= 1;
  if ($67) {
    return bumpMinor(v);
  }
  ;
  return bumpPatch(v);
};

// output/Registry.Internal.Codec/index.js
var fromFoldableWithIndex2 = /* @__PURE__ */ fromFoldableWithIndex(foldableWithIndexObject);
var forWithIndex_2 = /* @__PURE__ */ forWithIndex_(applicativeST)(foldableWithIndexMap);
var bind111 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
var map47 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var toUnfoldable10 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var applicativeExceptT3 = /* @__PURE__ */ applicativeExceptT(monadIdentity);
var $$for2 = /* @__PURE__ */ $$for(applicativeExceptT3)(traversableArray);
var except4 = /* @__PURE__ */ except(applicativeIdentity);
var lmap7 = /* @__PURE__ */ lmap(bifunctorEither);
var append11 = /* @__PURE__ */ append(semigroupString);
var pure114 = /* @__PURE__ */ pure(applicativeExceptT3);
var bind26 = /* @__PURE__ */ bind(bindEither);
var pure210 = /* @__PURE__ */ pure(applicativeEither);
var strMap = function(dictOrd) {
  var fromFoldable59 = fromFoldable7(dictOrd)(foldableArray);
  return function(typeName) {
    return function(parse15) {
      return function(print12) {
        return function(valueCodec) {
          var encode6 = function(m) {
            return encode2(jobject)(fromFoldableWithIndex2(runST(function __do3() {
              var obj = newImpl();
              forWithIndex_2(m)(function(k) {
                return function(v) {
                  return poke2(print12(k))(encode2(valueCodec)(v))(obj);
                };
              })();
              return obj;
            })));
          };
          var decode4 = function(json4) {
            return bind111(map47(toUnfoldable10)(decode(jobject)(json4)))(function(v) {
              return bind111($$for2(v)(function(v1) {
                return bind111(except4(lmap7(function() {
                  var $45 = error2(new AtKey(v1.value0, Tip.value));
                  var $46 = append11(typeName + ": ");
                  return function($47) {
                    return $45($46($47));
                  };
                }())(parse15(v1.value0))))(function(key) {
                  return bind111(withExcept(withPath(function(p) {
                    return extend2(p)(new AtKey(v1.value0, Tip.value));
                  }))(decode(valueCodec)(v1.value1)))(function(val) {
                    return pure114(new Tuple(key, val));
                  });
                });
              }))(function(parsed) {
                return pure114(fromFoldable59(parsed));
              });
            });
          };
          return codec$prime(decode4)(encode6);
        };
      };
    };
  };
};
var versionMap = /* @__PURE__ */ strMap(ordVersion)("Version")(parse4)(print6);
var parsedString = function(parser6) {
  var encode6 = encode2(string);
  var decode4 = function(json4) {
    return except4(bind26(decode2(string)(json4))(function(string8) {
      var v = runParser2(string8)(parser6);
      if (v instanceof Left) {
        return new Left(basic(parseErrorMessage(v.value0)));
      }
      ;
      if (v instanceof Right) {
        return pure210(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.Internal.Codec (line 118, column 5 - line 120, column 32): " + [v.constructor.name]);
    }));
  };
  return codec$prime(decode4)(encode6);
};
var packageMap = /* @__PURE__ */ strMap(ordPackageName)("PackageName")(parse3)(print5);
var limitedString = function(limit) {
  var encode6 = encode2(string);
  var decode4 = function(json4) {
    return except4(bind26(decode2(string)(json4))(function(string8) {
      var $41 = length5(string8) > limit;
      if ($41) {
        return new Left(basic("LimitedString: Exceeds limit of " + (toStringAs(decimal)(limit) + " characters.")));
      }
      ;
      return new Right(string8);
    }));
  };
  return codec$prime(decode4)(encode6);
};
var iso8601DateTime2 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $48 = encode2(string);
    var $49 = format(iso8601DateTime);
    return function($50) {
      return $48($49($50));
    };
  }();
  var decode4 = function(json4) {
    return bind111(decode(string)(json4))(function(string8) {
      return except4(function() {
        var v = rfc3339ToISO8601(string8);
        if (v instanceof Left) {
          return new Left(basic("Unable to parse input as ISO8601: " + v.value0));
        }
        ;
        if (v instanceof Right) {
          return lmap7(function() {
            var $51 = append11("ISO8601: ");
            return function($52) {
              return basic($51($52));
            };
          }())(unformat(iso8601DateTime)(v.value0));
        }
        ;
        throw new Error("Failed pattern match at Registry.Internal.Codec (line 64, column 12 - line 67, column 127): " + [v.constructor.name]);
      }());
    });
  };
  return codec$prime(decode4)(encode6);
}();
var iso8601Date2 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $53 = encode2(string);
    var $54 = format(iso8601Date);
    var $55 = flip(DateTime.create)(bottom(boundedTime));
    return function($56) {
      return $53($54($55($56)));
    };
  }();
  var decode4 = function(json4) {
    return bind111(decode(string)(json4))(function(string8) {
      return bind111(except4(lmap7(function() {
        var $57 = append11("YYYY-MM-DD: ");
        return function($58) {
          return basic($57($58));
        };
      }())(unformat(iso8601Date)(string8))))(function(dateTime) {
        return pure114(date(dateTime));
      });
    });
  };
  return codec$prime(decode4)(encode6);
}();

// output/Registry.License/foreign.js
var import_spdx_expression_parse = __toESM(require_spdx_expression_parse(), 1);
var parseSPDXLicenseIdImpl = (onError, onSuccess, identifier) => {
  try {
    (0, import_spdx_expression_parse.default)(identifier);
    return onSuccess(identifier);
  } catch (_) {
    return onError(`Invalid SPDX identifier ${identifier}`);
  }
};

// output/Registry.License/index.js
var License = function(x) {
  return x;
};
var print7 = function(v) {
  return v;
};
var parse6 = /* @__PURE__ */ function() {
  return runFn3(parseSPDXLicenseIdImpl)(Left.create)(function($17) {
    return Right.create(License($17));
  });
}();
var codec4 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $22 = encode2(string);
    return function($23) {
      return $22(print7($23));
    };
  }();
  var decode4 = composeKleisliFlipped(bindExceptT(monadIdentity))(function() {
    var $24 = except(applicativeIdentity);
    var $25 = lmap(bifunctorEither)(basic);
    return function($26) {
      return $24($25(parse6($26)));
    };
  }())(decode(string));
  return named("License")(codec$prime(decode4)(encode6));
}();

// output/Registry.Location/index.js
var eq6 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var functorExceptT3 = /* @__PURE__ */ functorExceptT(functorIdentity);
var dimap3 = /* @__PURE__ */ dimap(/* @__PURE__ */ profunctorCodec(functorExceptT3));
var object3 = /* @__PURE__ */ object2();
var rowListCodecCons2 = /* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "subdir";
  }
}))()();
var alt14 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var map48 = /* @__PURE__ */ map(functorExceptT3);
var Git = /* @__PURE__ */ function() {
  function Git2(value0) {
    this.value0 = value0;
  }
  ;
  Git2.create = function(value0) {
    return new Git2(value0);
  };
  return Git2;
}();
var GitHub = /* @__PURE__ */ function() {
  function GitHub2(value0) {
    this.value0 = value0;
  }
  ;
  GitHub2.create = function(value0) {
    return new GitHub2(value0);
  };
  return GitHub2;
}();
var eqLocation = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Git && y instanceof Git) {
        return eq6(x.value0.subdir)(y.value0.subdir) && x.value0.url === y.value0.url;
      }
      ;
      if (x instanceof GitHub && y instanceof GitHub) {
        return x.value0.owner === y.value0.owner && x.value0.repo === y.value0.repo && eq6(x.value0.subdir)(y.value0.subdir);
      }
      ;
      return false;
    };
  }
};
var githubCodec = /* @__PURE__ */ function() {
  var toJsonRep = function(v) {
    return {
      githubOwner: v.owner,
      githubRepo: v.repo,
      subdir: v.subdir
    };
  };
  var fromJsonRep = function(v) {
    return {
      owner: v.githubOwner,
      repo: v.githubRepo,
      subdir: v.subdir
    };
  };
  return dimap3(toJsonRep)(fromJsonRep)(named("GitHub")(object3(rowListCodecCons(rowListCodecCons2({
    reflectSymbol: function() {
      return "githubRepo";
    }
  }))()()({
    reflectSymbol: function() {
      return "githubOwner";
    }
  }))({
    githubOwner: string,
    githubRepo: string,
    subdir: optional4(string)
  })));
}();
var gitCodec = /* @__PURE__ */ function() {
  var toJsonRep = function(v) {
    return {
      gitUrl: v.url,
      subdir: v.subdir
    };
  };
  var fromJsonRep = function(v) {
    return {
      url: v.gitUrl,
      subdir: v.subdir
    };
  };
  return dimap3(toJsonRep)(fromJsonRep)(named("Git")(object3(rowListCodecCons2({
    reflectSymbol: function() {
      return "gitUrl";
    }
  }))({
    gitUrl: parsedString(gitUrl),
    subdir: optional4(string)
  })));
}();
var codec5 = /* @__PURE__ */ function() {
  var encode6 = function(v) {
    if (v instanceof Git) {
      return encode2(gitCodec)(v.value0);
    }
    ;
    if (v instanceof GitHub) {
      return encode2(githubCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Registry.Location (line 43, column 12 - line 45, column 50): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    return alt14(map48(Git.create)(decode(gitCodec)(json4)))(map48(GitHub.create)(decode(githubCodec)(json4)));
  };
  return named("Location")(codec$prime(decode4)(encode6));
}();

// output/Registry.Range/index.js
var min6 = /* @__PURE__ */ min(ordVersion);
var max5 = /* @__PURE__ */ max(ordVersion);
var fold14 = /* @__PURE__ */ fold2(monoidString);
var liftEither2 = /* @__PURE__ */ liftEither(monadThrowParseErrorParse);
var bind27 = /* @__PURE__ */ bind(bindParserT);
var alt15 = /* @__PURE__ */ alt(altParserT);
var bindFlipped6 = /* @__PURE__ */ bindFlipped(bindParserT);
var map49 = /* @__PURE__ */ map(functorParserT);
var discard7 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var greaterThanOrEq1 = /* @__PURE__ */ greaterThanOrEq(ordVersion);
var pure35 = /* @__PURE__ */ pure(applicativeParserT);
var lmap8 = /* @__PURE__ */ lmap(bifunctorEither);
var lessThan1 = /* @__PURE__ */ lessThan(ordVersion);
var eqRange = {
  eq: /* @__PURE__ */ on(/* @__PURE__ */ eq(/* @__PURE__ */ eqArray(eqVersion)))(function(v) {
    return [v.lhs, v.rhs];
  })
};
var print8 = function(v) {
  return fold14([">=", print6(v.lhs), " <", print6(v.rhs)]);
};
var parser3 = /* @__PURE__ */ function() {
  var parseVersion2 = function(input) {
    return liftEither2(runParser2(input)(parser2));
  };
  return bind27(alt15(string3(">="))(fail2("Ranges must begin with >=")))(function() {
    return bind27(bindFlipped6(parseVersion2)(map49(fromCharArray)(charsUntilSpace)))(function(lhs) {
      return bind27(alt15($$char3("<"))(fail2("Ranges must end with <")))(function() {
        return bind27(bindFlipped6(parseVersion2)(map49(fromCharArray)(chars)))(function(rhs) {
          return discard7(eof)(function() {
            var $43 = greaterThanOrEq1(lhs)(rhs);
            if ($43) {
              return fail2(fold14(["Left-hand version (", print6(lhs), ") must be less than right-hand version (", print6(rhs), ")"]));
            }
            ;
            return pure35({
              lhs,
              rhs
            });
          });
        });
      });
    });
  });
}();
var parse7 = /* @__PURE__ */ function() {
  var $54 = lmap8(parseErrorMessage);
  var $55 = flip(runParser2)(parser3);
  return function($56) {
    return $54($55($56));
  };
}();
var lessThan3 = function(v) {
  return v.rhs;
};
var intersect2 = function(v) {
  return function(v1) {
    if (greaterThanOrEq1(v.lhs)(v1.rhs) || greaterThanOrEq1(v1.lhs)(v.rhs)) {
      return Nothing.value;
    }
    ;
    if (otherwise) {
      return new Just({
        lhs: max5(v.lhs)(v1.lhs),
        rhs: min6(v.rhs)(v1.rhs)
      });
    }
    ;
    throw new Error("Failed pattern match at Registry.Range (line 135, column 1 - line 135, column 43): " + [v.constructor.name, v1.constructor.name]);
  };
};
var includes = function(v) {
  return function(version4) {
    return greaterThanOrEq1(version4)(v.lhs) && lessThan1(version4)(v.rhs);
  };
};
var greaterThanOrEq2 = function(v) {
  return v.lhs;
};
var codec6 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $57 = encode2(string);
    return function($58) {
      return $57(print8($58));
    };
  }();
  var decode4 = composeKleisliFlipped(bindExceptT(monadIdentity))(function() {
    var $59 = except(applicativeIdentity);
    var $60 = lmap8(basic);
    return function($61) {
      return $59($60(parse7($61)));
    };
  }())(decode(string));
  return named("Range")(codec$prime(decode4)(encode6));
}();
var caret = function(v) {
  return {
    lhs: v,
    rhs: bumpHighest(v)
  };
};

// output/Registry.Sha256/foreign.js
import crypto from "crypto";
var createHash = (algorithm) => () => crypto.createHash(algorithm);
var updateHash = (buffer) => (hash4) => () => hash4.update(buffer);
var digestHash = (hash4) => () => hash4.digest();

// output/Node.FS.Async/foreign.js
import {
  access,
  copyFile,
  mkdtemp,
  rename,
  truncate,
  chown,
  chmod,
  stat,
  lstat,
  link as link2,
  symlink,
  readlink,
  realpath,
  unlink,
  rmdir,
  rm,
  mkdir,
  readdir,
  utimes,
  readFile,
  writeFile,
  appendFile,
  open,
  read as read6,
  write as write4,
  close
} from "node:fs";

// output/Node.FS.Constants/foreign.js
import { constants } from "node:fs";
var f_OK = constants.F_OK;
var r_OK = constants.R_OK;
var w_OK = constants.W_OK;
var x_OK = constants.X_OK;
var copyFile_EXCL = constants.COPYFILE_EXCL;
var copyFile_FICLONE = constants.COPYFILE_FICLONE;
var copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;

// output/Node.FS.Constants/index.js
var R = /* @__PURE__ */ function() {
  function R2() {
  }
  ;
  R2.value = new R2();
  return R2;
}();
var R_PLUS = /* @__PURE__ */ function() {
  function R_PLUS2() {
  }
  ;
  R_PLUS2.value = new R_PLUS2();
  return R_PLUS2;
}();
var RS = /* @__PURE__ */ function() {
  function RS2() {
  }
  ;
  RS2.value = new RS2();
  return RS2;
}();
var RS_PLUS = /* @__PURE__ */ function() {
  function RS_PLUS2() {
  }
  ;
  RS_PLUS2.value = new RS_PLUS2();
  return RS_PLUS2;
}();
var W = /* @__PURE__ */ function() {
  function W2() {
  }
  ;
  W2.value = new W2();
  return W2;
}();
var WX = /* @__PURE__ */ function() {
  function WX2() {
  }
  ;
  WX2.value = new WX2();
  return WX2;
}();
var W_PLUS = /* @__PURE__ */ function() {
  function W_PLUS2() {
  }
  ;
  W_PLUS2.value = new W_PLUS2();
  return W_PLUS2;
}();
var WX_PLUS = /* @__PURE__ */ function() {
  function WX_PLUS2() {
  }
  ;
  WX_PLUS2.value = new WX_PLUS2();
  return WX_PLUS2;
}();
var A = /* @__PURE__ */ function() {
  function A2() {
  }
  ;
  A2.value = new A2();
  return A2;
}();
var AX = /* @__PURE__ */ function() {
  function AX2() {
  }
  ;
  AX2.value = new AX2();
  return AX2;
}();
var A_PLUS = /* @__PURE__ */ function() {
  function A_PLUS2() {
  }
  ;
  A_PLUS2.value = new A_PLUS2();
  return A_PLUS2;
}();
var AX_PLUS = /* @__PURE__ */ function() {
  function AX_PLUS2() {
  }
  ;
  AX_PLUS2.value = new AX_PLUS2();
  return AX_PLUS2;
}();
var fileFlagsToNode = function(ff2) {
  if (ff2 instanceof R) {
    return "r";
  }
  ;
  if (ff2 instanceof R_PLUS) {
    return "r+";
  }
  ;
  if (ff2 instanceof RS) {
    return "rs";
  }
  ;
  if (ff2 instanceof RS_PLUS) {
    return "rs+";
  }
  ;
  if (ff2 instanceof W) {
    return "w";
  }
  ;
  if (ff2 instanceof WX) {
    return "wx";
  }
  ;
  if (ff2 instanceof W_PLUS) {
    return "w+";
  }
  ;
  if (ff2 instanceof WX_PLUS) {
    return "wx+";
  }
  ;
  if (ff2 instanceof A) {
    return "a";
  }
  ;
  if (ff2 instanceof AX) {
    return "ax";
  }
  ;
  if (ff2 instanceof A_PLUS) {
    return "a+";
  }
  ;
  if (ff2 instanceof AX_PLUS) {
    return "ax+";
  }
  ;
  throw new Error("Failed pattern match at Node.FS.Constants (line 78, column 22 - line 90, column 19): " + [ff2.constructor.name]);
};

// output/Node.FS.Perms/index.js
var semiringPerm = {
  add: function(v) {
    return function(v1) {
      return {
        r: v.r || v1.r,
        w: v.w || v1.w,
        x: v.x || v1.x
      };
    };
  },
  zero: {
    r: false,
    w: false,
    x: false
  },
  mul: function(v) {
    return function(v1) {
      return {
        r: v.r && v1.r,
        w: v.w && v1.w,
        x: v.x && v1.x
      };
    };
  },
  one: {
    r: true,
    w: true,
    x: true
  }
};
var permToInt = function(v) {
  return (function() {
    if (v.r) {
      return 4;
    }
    ;
    return 0;
  }() + function() {
    if (v.w) {
      return 2;
    }
    ;
    return 0;
  }() | 0) + function() {
    if (v.x) {
      return 1;
    }
    ;
    return 0;
  }() | 0;
};
var permToString = /* @__PURE__ */ function() {
  var $129 = show(showInt);
  return function($130) {
    return $129(permToInt($130));
  };
}();
var permsToString = function(v) {
  return "0" + (permToString(v.u) + (permToString(v.g) + permToString(v.o)));
};
var mkPerms = function(u) {
  return function(g) {
    return function(o) {
      return {
        u,
        g,
        o
      };
    };
  };
};
var all4 = /* @__PURE__ */ one(semiringPerm);

// output/Node.FS.Async/index.js
var show15 = /* @__PURE__ */ show(showEncoding);
var handleCallback = function(cb) {
  return function(err, a) {
    var v = toMaybe(err);
    if (v instanceof Nothing) {
      return cb(new Right(a))();
    }
    ;
    if (v instanceof Just) {
      return cb(new Left(v.value0))();
    }
    ;
    throw new Error("Failed pattern match at Node.FS.Async (line 66, column 43 - line 68, column 30): " + [v.constructor.name]);
  };
};
var mkdir$prime = function(file) {
  return function(v) {
    return function(cb) {
      return function() {
        return mkdir(file, {
          recursive: v.recursive,
          mode: permsToString(v.mode)
        }, handleCallback(cb));
      };
    };
  };
};
var mkdir2 = function(path14) {
  return mkdir$prime(path14)({
    recursive: false,
    mode: mkPerms(all4)(all4)(all4)
  });
};
var readFile2 = function(file) {
  return function(cb) {
    return function() {
      return readFile(file, {}, handleCallback(cb));
    };
  };
};
var readTextFile = function(encoding) {
  return function(file) {
    return function(cb) {
      return function() {
        return readFile(file, {
          encoding: show15(encoding)
        }, handleCallback(cb));
      };
    };
  };
};
var readdir2 = function(file) {
  return function(cb) {
    return function() {
      return readdir(file, handleCallback(cb));
    };
  };
};
var stat2 = function(file) {
  return function(cb) {
    return function() {
      return stat(file, handleCallback(cb));
    };
  };
};
var writeFile2 = function(file) {
  return function(buff) {
    return function(cb) {
      return function() {
        return writeFile(file, buff, {}, handleCallback(cb));
      };
    };
  };
};
var writeTextFile = function(encoding) {
  return function(file) {
    return function(buff) {
      return function(cb) {
        return function() {
          return writeFile(file, buff, {
            encoding: show15(encoding)
          }, handleCallback(cb));
        };
      };
    };
  };
};
var chmod2 = function(file) {
  return function(perms) {
    return function(cb) {
      return function() {
        return chmod(file, permsToString(perms), handleCallback(cb));
      };
    };
  };
};

// output/Node.FS.Aff/index.js
var voidLeft6 = /* @__PURE__ */ voidLeft(functorEffect);
var toAff = function(p) {
  return makeAff(function(k) {
    return voidLeft6(p(k))(nonCanceler);
  });
};
var toAff1 = function(f) {
  return function(a) {
    return toAff(f(a));
  };
};
var toAff2 = function(f) {
  return function(a) {
    return function(b) {
      return toAff(f(a)(b));
    };
  };
};
var writeFile3 = /* @__PURE__ */ toAff2(writeFile2);
var toAff3 = function(f) {
  return function(a) {
    return function(b) {
      return function(c) {
        return toAff(f(a)(b)(c));
      };
    };
  };
};
var writeTextFile2 = /* @__PURE__ */ toAff3(writeTextFile);
var stat3 = /* @__PURE__ */ toAff1(stat2);
var readdir3 = /* @__PURE__ */ toAff1(readdir2);
var readTextFile2 = /* @__PURE__ */ toAff2(readTextFile);
var readFile3 = /* @__PURE__ */ toAff1(readFile2);
var mkdir$prime2 = /* @__PURE__ */ toAff2(mkdir$prime);
var mkdir3 = /* @__PURE__ */ toAff1(mkdir2);
var chmod3 = /* @__PURE__ */ toAff2(chmod2);

// output/Registry.Sha256/index.js
var bind28 = /* @__PURE__ */ bind(bindParserT);
var replicateM2 = /* @__PURE__ */ replicateM(monadParserT);
var discard8 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var fromFoldable23 = /* @__PURE__ */ fromFoldable(foldableList2);
var pure36 = /* @__PURE__ */ pure(applicativeParserT);
var lmap9 = /* @__PURE__ */ lmap(bifunctorEither);
var eqSha256 = {
  eq: function(x) {
    return function(y) {
      return x.hash === y.hash && x.sri === y.sri;
    };
  }
};
var print9 = function(v) {
  return v.sri + ("-" + v.hash);
};
var parser4 = /* @__PURE__ */ bind28(/* @__PURE__ */ string3("sha256"))(function(prefix4) {
  return bind28($$char3("-"))(function() {
    return bind28(replicateM2(43)(anyChar))(function(hash4) {
      return bind28($$char3("="))(function(suffix2) {
        return discard8(eof)(function() {
          var fromCharList = function($37) {
            return fromCharArray(fromFoldable23($37));
          };
          return pure36({
            sri: prefix4,
            hash: fromCharList(hash4) + singleton6(suffix2)
          });
        });
      });
    });
  });
});
var parse8 = /* @__PURE__ */ function() {
  var $38 = lmap9(parseErrorMessage);
  var $39 = flip(runParser2)(parser4);
  return function($40) {
    return $38($39($40));
  };
}();
var hashBuffer = function(dictMonadEffect) {
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(buffer) {
    return liftEffect19(function __do3() {
      var newHash = createHash("sha256")();
      var hash4 = updateHash(buffer)(newHash)();
      var digest = digestHash(hash4)();
      var string8 = toString6(Base64.value)(digest)();
      return {
        sri: "sha256",
        hash: string8
      };
    });
  };
};
var hashBuffer1 = /* @__PURE__ */ hashBuffer(monadEffectEffect);
var hashString = function(dictMonadEffect) {
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(string8) {
    return liftEffect19(function __do3() {
      var buffer = fromString7(string8)(UTF8.value)();
      return hashBuffer1(buffer)();
    });
  };
};
var codec7 = /* @__PURE__ */ function() {
  var encode6 = function() {
    var $41 = encode2(string);
    return function($42) {
      return $41(print9($42));
    };
  }();
  var decode4 = composeKleisliFlipped(bindExceptT(monadIdentity))(function() {
    var $43 = except(applicativeIdentity);
    var $44 = lmap9(basic);
    return function($45) {
      return $43($44(parse8($45)));
    };
  }())(decode(string));
  return named("Sha256")(codec$prime(decode4)(encode6));
}();

// output/Data.Map/index.js
var SemigroupMap = function(x) {
  return x;
};
var traversableWithIndexSemigroupMap = traversableWithIndexMap;
var traversableSemigroupMap = traversableMap;
var semigroupSemigroupMap = function(dictOrd) {
  var unionWith6 = unionWith(dictOrd);
  return function(dictSemigroup) {
    var append48 = append(dictSemigroup);
    return {
      append: function(v) {
        return function(v1) {
          return unionWith6(append48)(v)(v1);
        };
      }
    };
  };
};
var monoidSemigroupMap = function(dictOrd) {
  var semigroupSemigroupMap12 = semigroupSemigroupMap(dictOrd);
  return function(dictSemigroup) {
    var semigroupSemigroupMap23 = semigroupSemigroupMap12(dictSemigroup);
    return {
      mempty: empty4,
      Semigroup0: function() {
        return semigroupSemigroupMap23;
      }
    };
  };
};
var keys3 = /* @__PURE__ */ function() {
  var $38 = $$void(functorMap);
  return function($39) {
    return fromMap($38($39));
  };
}();
var functorWithIndexSemigroupMap = functorWithIndexMap;
var functorSemigroupMap = functorMap;
var foldableWithIndexSemigroupMap = foldableWithIndexMap;
var foldableSemigroupMap = foldableMap;
var eqSemigroupMap = function(dictEq) {
  var eqMap3 = eqMap(dictEq);
  return function(dictEq1) {
    return eqMap3(dictEq1);
  };
};

// output/Data.Graph/index.js
var map50 = /* @__PURE__ */ map(functorList);
var mempty9 = /* @__PURE__ */ mempty(monoidList);
var append20 = /* @__PURE__ */ append(semigroupCatList);
var fromFoldable24 = /* @__PURE__ */ fromFoldable14(foldableList);
var fromFoldable110 = /* @__PURE__ */ fromFoldable14(foldableArray);
var Emit = /* @__PURE__ */ function() {
  function Emit2(value0) {
    this.value0 = value0;
  }
  ;
  Emit2.create = function(value0) {
    return new Emit2(value0);
  };
  return Emit2;
}();
var Visit = /* @__PURE__ */ function() {
  function Visit2(value0) {
    this.value0 = value0;
  }
  ;
  Visit2.create = function(value0) {
    return new Visit2(value0);
  };
  return Visit2;
}();
var Graph = function(x) {
  return x;
};
var topologicalSort = function(dictOrd) {
  var member15 = member(dictOrd);
  var $$delete10 = $$delete2(dictOrd);
  var lookup110 = lookup3(dictOrd);
  return function(v) {
    var visit = function($copy_state) {
      return function($copy_stack) {
        var $tco_var_state = $copy_state;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(state2, stack) {
          var v1 = uncons6(stack);
          if (v1 instanceof Nothing) {
            $tco_done = true;
            return state2;
          }
          ;
          if (v1 instanceof Just && v1.value0.value0 instanceof Emit) {
            var state$prime = {
              result: new Cons(v1.value0.value0.value0, state2.result),
              unvisited: state2.unvisited
            };
            $tco_var_state = state$prime;
            $copy_stack = v1.value0.value1;
            return;
          }
          ;
          if (v1 instanceof Just && v1.value0.value0 instanceof Visit) {
            if (member15(v1.value0.value0.value0)(state2.unvisited)) {
              var start = {
                result: state2.result,
                unvisited: $$delete10(v1.value0.value0.value0)(state2.unvisited)
              };
              var next2 = maybe(mempty9)(snd)(lookup110(v1.value0.value0.value0)(v));
              $tco_var_state = start;
              $copy_stack = append20(fromFoldable24(map50(Visit.create)(next2)))(cons4(new Emit(v1.value0.value0.value0))(v1.value0.value1));
              return;
            }
            ;
            if (otherwise) {
              $tco_var_state = state2;
              $copy_stack = v1.value0.value1;
              return;
            }
            ;
          }
          ;
          throw new Error("Failed pattern match at Data.Graph (line 126, column 7 - line 144, column 40): " + [v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_state, $copy_stack);
        }
        ;
        return $tco_result;
      };
    };
    var initialState = {
      unvisited: v,
      result: Nil.value
    };
    var go = function($copy_v1) {
      var $tco_done1 = false;
      var $tco_result;
      function $tco_loop(v1) {
        var v2 = findMin(v1.unvisited);
        if (v2 instanceof Just) {
          $copy_v1 = visit(v1)(fromFoldable110([new Visit(v2.value0.key)]));
          return;
        }
        ;
        if (v2 instanceof Nothing) {
          $tco_done1 = true;
          return v1.result;
        }
        ;
        throw new Error("Failed pattern match at Data.Graph (line 120, column 7 - line 122, column 26): " + [v2.constructor.name]);
      }
      ;
      while (!$tco_done1) {
        $tco_result = $tco_loop($copy_v1);
      }
      ;
      return $tco_result;
    };
    return go(initialState);
  };
};
var fromMap2 = Graph;

// output/Node.FS.Sync/foreign.js
import {
  accessSync,
  copyFileSync,
  mkdtempSync,
  renameSync,
  truncateSync,
  chownSync,
  chmodSync,
  statSync,
  lstatSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  realpathSync,
  unlinkSync,
  rmdirSync,
  rmSync,
  mkdirSync,
  readdirSync,
  utimesSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  existsSync,
  openSync,
  readSync,
  writeSync,
  fsyncSync,
  closeSync
} from "node:fs";

// output/Node.FS.Sync/index.js
var show16 = /* @__PURE__ */ show(showEncoding);
var stat4 = function(file) {
  return function() {
    return statSync(file);
  };
};
var readTextFile3 = function(encoding) {
  return function(file) {
    return function() {
      return readFileSync(file, {
        encoding: show16(encoding)
      });
    };
  };
};
var fdRead2 = function(fd) {
  return function(buff) {
    return function(off) {
      return function(len) {
        return function(pos2) {
          return function() {
            return readSync(fd, buff, off, len, toNullable(pos2));
          };
        };
      };
    };
  };
};
var fdOpen2 = function(file) {
  return function(flags) {
    return function(mode2) {
      return function() {
        return openSync(file, fileFlagsToNode(flags), toNullable(mode2));
      };
    };
  };
};
var fdClose2 = function(fd) {
  return function() {
    return closeSync(fd);
  };
};
var exists = function(file) {
  return function() {
    return existsSync(file);
  };
};

// output/Registry.Owner/index.js
var publicIsSymbol = {
  reflectSymbol: function() {
    return "public";
  }
};
var keytypeIsSymbol = {
  reflectSymbol: function() {
    return "keytype";
  }
};
var idIsSymbol = {
  reflectSymbol: function() {
    return "id";
  }
};
var Owner = function(x) {
  return x;
};
var codec8 = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity)))()(Owner)(/* @__PURE__ */ named("Owner")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()(publicIsSymbol))()()(keytypeIsSymbol))()()(idIsSymbol))({
  id: /* @__PURE__ */ optional4(string),
  keytype: string,
  "public": string
})));

// output/Registry.Manifest/index.js
var Manifest = function(x) {
  return x;
};
var codec9 = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorExceptT(functorIdentity)))()(Manifest)(named("Manifest")(object(recordProp({
    reflectSymbol: function() {
      return "name";
    }
  })()($$Proxy.value)(codec2)(recordProp({
    reflectSymbol: function() {
      return "version";
    }
  })()($$Proxy.value)(codec3)(recordProp({
    reflectSymbol: function() {
      return "license";
    }
  })()($$Proxy.value)(codec4)(recordPropOptional({
    reflectSymbol: function() {
      return "description";
    }
  })()($$Proxy.value)(limitedString(300))(recordProp({
    reflectSymbol: function() {
      return "location";
    }
  })()($$Proxy.value)(codec5)(recordPropOptional({
    reflectSymbol: function() {
      return "owners";
    }
  })()($$Proxy.value)(nonEmptyArray(codec8))(recordPropOptional({
    reflectSymbol: function() {
      return "includeFiles";
    }
  })()($$Proxy.value)(nonEmptyArray(nonEmptyString))(recordPropOptional({
    reflectSymbol: function() {
      return "excludeFiles";
    }
  })()($$Proxy.value)(nonEmptyArray(nonEmptyString))(recordProp({
    reflectSymbol: function() {
      return "dependencies";
    }
  })()($$Proxy.value)(packageMap(codec6))(record))))))))))));
}();

// output/Registry.ManifestIndex/index.js
var bind112 = /* @__PURE__ */ bind(bindEither);
var traverse2 = /* @__PURE__ */ traverse(traversableArray)(applicativeEither);
var lmap10 = /* @__PURE__ */ lmap(bifunctorEither);
var pure37 = /* @__PURE__ */ pure(applicativeEither);
var parseEntry = function(entry) {
  var split3 = function() {
    var $236 = split("\n");
    return function($237) {
      return $236(trim($237));
    };
  }();
  return bind112(traverse2(parse)(split3(entry)))(function(jsonArray) {
    return bind112(traverse2(function() {
      var $238 = lmap10(print3);
      var $239 = decode2(codec9);
      return function($240) {
        return $238($239($240));
      };
    }())(jsonArray))(function(entries3) {
      var v = fromArray(entries3);
      if (v instanceof Nothing) {
        return new Left("No entries exist.");
      }
      ;
      if (v instanceof Just) {
        return pure37(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.ManifestIndex (line 249, column 3 - line 251, column 35): " + [v.constructor.name]);
    });
  });
};
var packageEntryDirectory = function($241) {
  return function(name5) {
    var v = length5(name5);
    if (v === 0) {
      return unsafeCrashWith("Unexpected empty PackageName");
    }
    ;
    if (v === 1) {
      return "1";
    }
    ;
    if (v === 2) {
      return "2";
    }
    ;
    if (v === 3) {
      return concat3(["3", take3(1)(name5)]);
    }
    ;
    return concat3([take3(2)(name5), take3(2)(drop3(2)(name5))]);
  }(print5($241));
};
var packageEntryFilePath = function(name5) {
  return concat3([packageEntryDirectory(name5), print5(name5)]);
};
var readEntryFile = function(dictMonadAff) {
  var Monad0 = dictMonadAff.MonadEffect0().Monad0();
  var bind312 = bind(Monad0.Bind1());
  var liftAff13 = liftAff(dictMonadAff);
  var pure129 = pure(Monad0.Applicative0());
  return function(indexPath) {
    return function($$package2) {
      var entryPath = concat3([indexPath, packageEntryFilePath($$package2)]);
      return bind312(liftAff13(attempt(readTextFile2(UTF8.value)(entryPath))))(function(v) {
        if (v instanceof Left) {
          return pure129(new Left("Failed to read entry: " + message(v.value0)));
        }
        ;
        if (v instanceof Right) {
          return pure129(parseEntry(v.value0));
        }
        ;
        throw new Error("Failed pattern match at Registry.ManifestIndex (line 267, column 66 - line 269, column 49): " + [v.constructor.name]);
      });
    };
  };
};

// output/Registry.Metadata/index.js
var refIsSymbol = {
  reflectSymbol: function() {
    return "ref";
  }
};
var publishedTimeIsSymbol = {
  reflectSymbol: function() {
    return "publishedTime";
  }
};
var hashIsSymbol = {
  reflectSymbol: function() {
    return "hash";
  }
};
var bytesIsSymbol = {
  reflectSymbol: function() {
    return "bytes";
  }
};
var unpublishedTimeIsSymbol = {
  reflectSymbol: function() {
    return "unpublishedTime";
  }
};
var reasonIsSymbol = {
  reflectSymbol: function() {
    return "reason";
  }
};
var object4 = /* @__PURE__ */ object2();
var rowListCodecCons3 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var Metadata = function(x) {
  return x;
};
var unpublishedMetadataCodec = /* @__PURE__ */ named("UnpublishedMetadata")(/* @__PURE__ */ object4(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons3(unpublishedTimeIsSymbol))()()(reasonIsSymbol))()()(publishedTimeIsSymbol))({
  publishedTime: iso8601DateTime2,
  reason: /* @__PURE__ */ limitedString(300),
  unpublishedTime: iso8601DateTime2
}));
var publishedMetadataCodec = /* @__PURE__ */ named("PublishedMetadata")(/* @__PURE__ */ object4(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons3(refIsSymbol))()()(publishedTimeIsSymbol))()()(hashIsSymbol))()()(bytesIsSymbol))({
  bytes: number,
  hash: codec7,
  publishedTime: iso8601DateTime2,
  ref: string
}));
var codec10 = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorExceptT(functorIdentity)))()(Metadata)(named("Metadata")(object(recordProp({
    reflectSymbol: function() {
      return "location";
    }
  })()($$Proxy.value)(codec5)(recordPropOptional({
    reflectSymbol: function() {
      return "owners";
    }
  })()($$Proxy.value)(nonEmptyArray(codec8))(recordProp({
    reflectSymbol: function() {
      return "published";
    }
  })()($$Proxy.value)(versionMap(publishedMetadataCodec))(recordProp({
    reflectSymbol: function() {
      return "unpublished";
    }
  })()($$Proxy.value)(versionMap(unpublishedMetadataCodec))(record)))))));
}();

// output/Registry.PackageSet/index.js
var versionIsSymbol = {
  reflectSymbol: function() {
    return "version";
  }
};
var publishedIsSymbol = {
  reflectSymbol: function() {
    return "published";
  }
};
var packagesIsSymbol = {
  reflectSymbol: function() {
    return "packages";
  }
};
var compilerIsSymbol = {
  reflectSymbol: function() {
    return "compiler";
  }
};
var PackageSet = function(x) {
  return x;
};
var codec11 = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorExceptT(functorIdentity)))()(PackageSet)(named("PackageSet")(object(recordProp(versionIsSymbol)()($$Proxy.value)(codec3)(recordProp(compilerIsSymbol)()($$Proxy.value)(codec3)(recordProp(publishedIsSymbol)()($$Proxy.value)(iso8601Date2)(recordProp(packagesIsSymbol)()($$Proxy.value)(packageMap(codec3))(record)))))));
}();

// output/Spago.Json/index.js
var foldMap6 = /* @__PURE__ */ foldMap2(monoidArray);
var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(bindEither);
var lmap11 = /* @__PURE__ */ lmap(bifunctorEither);
var stringifyJson = function(codec12) {
  var $12 = encode2(codec12);
  return function($13) {
    return print($12($13));
  };
};
var printJson = function(codec12) {
  var $14 = encode2(codec12);
  return function($15) {
    return printIndented($14($15));
  };
};
var printConfigError = function(v) {
  var v1 = $$null(v.causes);
  if (!v1) {
    return foldMap6(printConfigError)(v.causes);
  }
  ;
  if (v1) {
    return [print2(v.path) + (": " + v.message)];
  }
  ;
  throw new Error("Failed pattern match at Spago.Json (line 29, column 3 - line 33, column 56): " + [v1.constructor.name]);
};
var parseJson = function(codec12) {
  return composeKleisliFlipped2(decode2(codec12))(function() {
    var $16 = lmap11(function(err) {
      return basic("JSON: " + err);
    });
    return function($17) {
      return $16(parse($17));
    };
  }());
};

// output/Ansi.Codes/index.js
var show17 = /* @__PURE__ */ show(showInt);
var intercalate6 = /* @__PURE__ */ intercalate(foldableNonEmptyList)(monoidString);
var map52 = /* @__PURE__ */ map(functorNonEmptyList);
var Bold = /* @__PURE__ */ function() {
  function Bold2() {
  }
  ;
  Bold2.value = new Bold2();
  return Bold2;
}();
var Dim = /* @__PURE__ */ function() {
  function Dim2() {
  }
  ;
  Dim2.value = new Dim2();
  return Dim2;
}();
var Italic = /* @__PURE__ */ function() {
  function Italic2() {
  }
  ;
  Italic2.value = new Italic2();
  return Italic2;
}();
var Underline = /* @__PURE__ */ function() {
  function Underline2() {
  }
  ;
  Underline2.value = new Underline2();
  return Underline2;
}();
var Inverse = /* @__PURE__ */ function() {
  function Inverse2() {
  }
  ;
  Inverse2.value = new Inverse2();
  return Inverse2;
}();
var Strikethrough = /* @__PURE__ */ function() {
  function Strikethrough2() {
  }
  ;
  Strikethrough2.value = new Strikethrough2();
  return Strikethrough2;
}();
var ToEnd = /* @__PURE__ */ function() {
  function ToEnd2() {
  }
  ;
  ToEnd2.value = new ToEnd2();
  return ToEnd2;
}();
var FromBeginning = /* @__PURE__ */ function() {
  function FromBeginning2() {
  }
  ;
  FromBeginning2.value = new FromBeginning2();
  return FromBeginning2;
}();
var Entire = /* @__PURE__ */ function() {
  function Entire2() {
  }
  ;
  Entire2.value = new Entire2();
  return Entire2;
}();
var Black = /* @__PURE__ */ function() {
  function Black2() {
  }
  ;
  Black2.value = new Black2();
  return Black2;
}();
var Red = /* @__PURE__ */ function() {
  function Red2() {
  }
  ;
  Red2.value = new Red2();
  return Red2;
}();
var Green = /* @__PURE__ */ function() {
  function Green2() {
  }
  ;
  Green2.value = new Green2();
  return Green2;
}();
var Yellow = /* @__PURE__ */ function() {
  function Yellow2() {
  }
  ;
  Yellow2.value = new Yellow2();
  return Yellow2;
}();
var Blue = /* @__PURE__ */ function() {
  function Blue2() {
  }
  ;
  Blue2.value = new Blue2();
  return Blue2;
}();
var Magenta = /* @__PURE__ */ function() {
  function Magenta2() {
  }
  ;
  Magenta2.value = new Magenta2();
  return Magenta2;
}();
var Cyan = /* @__PURE__ */ function() {
  function Cyan2() {
  }
  ;
  Cyan2.value = new Cyan2();
  return Cyan2;
}();
var White = /* @__PURE__ */ function() {
  function White2() {
  }
  ;
  White2.value = new White2();
  return White2;
}();
var BrightBlack = /* @__PURE__ */ function() {
  function BrightBlack2() {
  }
  ;
  BrightBlack2.value = new BrightBlack2();
  return BrightBlack2;
}();
var BrightRed = /* @__PURE__ */ function() {
  function BrightRed2() {
  }
  ;
  BrightRed2.value = new BrightRed2();
  return BrightRed2;
}();
var BrightGreen = /* @__PURE__ */ function() {
  function BrightGreen2() {
  }
  ;
  BrightGreen2.value = new BrightGreen2();
  return BrightGreen2;
}();
var BrightYellow = /* @__PURE__ */ function() {
  function BrightYellow2() {
  }
  ;
  BrightYellow2.value = new BrightYellow2();
  return BrightYellow2;
}();
var BrightBlue = /* @__PURE__ */ function() {
  function BrightBlue2() {
  }
  ;
  BrightBlue2.value = new BrightBlue2();
  return BrightBlue2;
}();
var BrightMagenta = /* @__PURE__ */ function() {
  function BrightMagenta2() {
  }
  ;
  BrightMagenta2.value = new BrightMagenta2();
  return BrightMagenta2;
}();
var BrightCyan = /* @__PURE__ */ function() {
  function BrightCyan2() {
  }
  ;
  BrightCyan2.value = new BrightCyan2();
  return BrightCyan2;
}();
var BrightWhite = /* @__PURE__ */ function() {
  function BrightWhite2() {
  }
  ;
  BrightWhite2.value = new BrightWhite2();
  return BrightWhite2;
}();
var Reset = /* @__PURE__ */ function() {
  function Reset2() {
  }
  ;
  Reset2.value = new Reset2();
  return Reset2;
}();
var PMode = /* @__PURE__ */ function() {
  function PMode2(value0) {
    this.value0 = value0;
  }
  ;
  PMode2.create = function(value0) {
    return new PMode2(value0);
  };
  return PMode2;
}();
var PForeground = /* @__PURE__ */ function() {
  function PForeground2(value0) {
    this.value0 = value0;
  }
  ;
  PForeground2.create = function(value0) {
    return new PForeground2(value0);
  };
  return PForeground2;
}();
var PBackground = /* @__PURE__ */ function() {
  function PBackground2(value0) {
    this.value0 = value0;
  }
  ;
  PBackground2.create = function(value0) {
    return new PBackground2(value0);
  };
  return PBackground2;
}();
var Up = /* @__PURE__ */ function() {
  function Up2(value0) {
    this.value0 = value0;
  }
  ;
  Up2.create = function(value0) {
    return new Up2(value0);
  };
  return Up2;
}();
var Down = /* @__PURE__ */ function() {
  function Down2(value0) {
    this.value0 = value0;
  }
  ;
  Down2.create = function(value0) {
    return new Down2(value0);
  };
  return Down2;
}();
var Forward = /* @__PURE__ */ function() {
  function Forward2(value0) {
    this.value0 = value0;
  }
  ;
  Forward2.create = function(value0) {
    return new Forward2(value0);
  };
  return Forward2;
}();
var Back = /* @__PURE__ */ function() {
  function Back2(value0) {
    this.value0 = value0;
  }
  ;
  Back2.create = function(value0) {
    return new Back2(value0);
  };
  return Back2;
}();
var NextLine = /* @__PURE__ */ function() {
  function NextLine2(value0) {
    this.value0 = value0;
  }
  ;
  NextLine2.create = function(value0) {
    return new NextLine2(value0);
  };
  return NextLine2;
}();
var PreviousLine = /* @__PURE__ */ function() {
  function PreviousLine2(value0) {
    this.value0 = value0;
  }
  ;
  PreviousLine2.create = function(value0) {
    return new PreviousLine2(value0);
  };
  return PreviousLine2;
}();
var HorizontalAbsolute = /* @__PURE__ */ function() {
  function HorizontalAbsolute2(value0) {
    this.value0 = value0;
  }
  ;
  HorizontalAbsolute2.create = function(value0) {
    return new HorizontalAbsolute2(value0);
  };
  return HorizontalAbsolute2;
}();
var Position = /* @__PURE__ */ function() {
  function Position2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Position2.create = function(value0) {
    return function(value12) {
      return new Position2(value0, value12);
    };
  };
  return Position2;
}();
var EraseData = /* @__PURE__ */ function() {
  function EraseData2(value0) {
    this.value0 = value0;
  }
  ;
  EraseData2.create = function(value0) {
    return new EraseData2(value0);
  };
  return EraseData2;
}();
var EraseLine = /* @__PURE__ */ function() {
  function EraseLine2(value0) {
    this.value0 = value0;
  }
  ;
  EraseLine2.create = function(value0) {
    return new EraseLine2(value0);
  };
  return EraseLine2;
}();
var ScrollUp = /* @__PURE__ */ function() {
  function ScrollUp2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollUp2.create = function(value0) {
    return new ScrollUp2(value0);
  };
  return ScrollUp2;
}();
var ScrollDown = /* @__PURE__ */ function() {
  function ScrollDown2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollDown2.create = function(value0) {
    return new ScrollDown2(value0);
  };
  return ScrollDown2;
}();
var Graphics = /* @__PURE__ */ function() {
  function Graphics2(value0) {
    this.value0 = value0;
  }
  ;
  Graphics2.create = function(value0) {
    return new Graphics2(value0);
  };
  return Graphics2;
}();
var SavePosition = /* @__PURE__ */ function() {
  function SavePosition2() {
  }
  ;
  SavePosition2.value = new SavePosition2();
  return SavePosition2;
}();
var RestorePosition = /* @__PURE__ */ function() {
  function RestorePosition2() {
  }
  ;
  RestorePosition2.value = new RestorePosition2();
  return RestorePosition2;
}();
var QueryPosition = /* @__PURE__ */ function() {
  function QueryPosition2() {
  }
  ;
  QueryPosition2.value = new QueryPosition2();
  return QueryPosition2;
}();
var HideCursor = /* @__PURE__ */ function() {
  function HideCursor2() {
  }
  ;
  HideCursor2.value = new HideCursor2();
  return HideCursor2;
}();
var ShowCursor = /* @__PURE__ */ function() {
  function ShowCursor2() {
  }
  ;
  ShowCursor2.value = new ShowCursor2();
  return ShowCursor2;
}();
var prefix = "\x1B[";
var eraseParamToString = function(ep) {
  if (ep instanceof ToEnd) {
    return "0";
  }
  ;
  if (ep instanceof FromBeginning) {
    return "1";
  }
  ;
  if (ep instanceof Entire) {
    return "2";
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 95, column 3 - line 98, column 25): " + [ep.constructor.name]);
};
var eqRenderingMode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Bold && y instanceof Bold) {
        return true;
      }
      ;
      if (x instanceof Dim && y instanceof Dim) {
        return true;
      }
      ;
      if (x instanceof Italic && y instanceof Italic) {
        return true;
      }
      ;
      if (x instanceof Underline && y instanceof Underline) {
        return true;
      }
      ;
      if (x instanceof Inverse && y instanceof Inverse) {
        return true;
      }
      ;
      if (x instanceof Strikethrough && y instanceof Strikethrough) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq17 = /* @__PURE__ */ eq(eqRenderingMode);
var eqColor = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Black && y instanceof Black) {
        return true;
      }
      ;
      if (x instanceof Red && y instanceof Red) {
        return true;
      }
      ;
      if (x instanceof Green && y instanceof Green) {
        return true;
      }
      ;
      if (x instanceof Yellow && y instanceof Yellow) {
        return true;
      }
      ;
      if (x instanceof Blue && y instanceof Blue) {
        return true;
      }
      ;
      if (x instanceof Magenta && y instanceof Magenta) {
        return true;
      }
      ;
      if (x instanceof Cyan && y instanceof Cyan) {
        return true;
      }
      ;
      if (x instanceof White && y instanceof White) {
        return true;
      }
      ;
      if (x instanceof BrightBlack && y instanceof BrightBlack) {
        return true;
      }
      ;
      if (x instanceof BrightRed && y instanceof BrightRed) {
        return true;
      }
      ;
      if (x instanceof BrightGreen && y instanceof BrightGreen) {
        return true;
      }
      ;
      if (x instanceof BrightYellow && y instanceof BrightYellow) {
        return true;
      }
      ;
      if (x instanceof BrightBlue && y instanceof BrightBlue) {
        return true;
      }
      ;
      if (x instanceof BrightMagenta && y instanceof BrightMagenta) {
        return true;
      }
      ;
      if (x instanceof BrightCyan && y instanceof BrightCyan) {
        return true;
      }
      ;
      if (x instanceof BrightWhite && y instanceof BrightWhite) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq33 = /* @__PURE__ */ eq(eqColor);
var eqGraphicsParam = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Reset && y instanceof Reset) {
        return true;
      }
      ;
      if (x instanceof PMode && y instanceof PMode) {
        return eq17(x.value0)(y.value0);
      }
      ;
      if (x instanceof PForeground && y instanceof PForeground) {
        return eq33(x.value0)(y.value0);
      }
      ;
      if (x instanceof PBackground && y instanceof PBackground) {
        return eq33(x.value0)(y.value0);
      }
      ;
      return false;
    };
  }
};
var colorSuffix = "m";
var colorCode = function(c) {
  if (c instanceof Black) {
    return 30;
  }
  ;
  if (c instanceof Red) {
    return 31;
  }
  ;
  if (c instanceof Green) {
    return 32;
  }
  ;
  if (c instanceof Yellow) {
    return 33;
  }
  ;
  if (c instanceof Blue) {
    return 34;
  }
  ;
  if (c instanceof Magenta) {
    return 35;
  }
  ;
  if (c instanceof Cyan) {
    return 36;
  }
  ;
  if (c instanceof White) {
    return 37;
  }
  ;
  if (c instanceof BrightBlack) {
    return 90;
  }
  ;
  if (c instanceof BrightRed) {
    return 91;
  }
  ;
  if (c instanceof BrightGreen) {
    return 92;
  }
  ;
  if (c instanceof BrightYellow) {
    return 93;
  }
  ;
  if (c instanceof BrightBlue) {
    return 94;
  }
  ;
  if (c instanceof BrightMagenta) {
    return 95;
  }
  ;
  if (c instanceof BrightCyan) {
    return 96;
  }
  ;
  if (c instanceof BrightWhite) {
    return 97;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 173, column 3 - line 189, column 22): " + [c.constructor.name]);
};
var codeForRenderingMode = function(m) {
  if (m instanceof Bold) {
    return 1;
  }
  ;
  if (m instanceof Dim) {
    return 2;
  }
  ;
  if (m instanceof Italic) {
    return 3;
  }
  ;
  if (m instanceof Underline) {
    return 4;
  }
  ;
  if (m instanceof Inverse) {
    return 7;
  }
  ;
  if (m instanceof Strikethrough) {
    return 9;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 138, column 3 - line 144, column 23): " + [m.constructor.name]);
};
var graphicsParamToString = function(gp) {
  if (gp instanceof Reset) {
    return "0";
  }
  ;
  if (gp instanceof PMode) {
    return show17(codeForRenderingMode(gp.value0));
  }
  ;
  if (gp instanceof PForeground) {
    return show17(colorCode(gp.value0));
  }
  ;
  if (gp instanceof PBackground) {
    return show17(colorCode(gp.value0) + 10 | 0);
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 116, column 3 - line 120, column 45): " + [gp.constructor.name]);
};
var escapeCodeToString = /* @__PURE__ */ function() {
  var go = function(c) {
    if (c instanceof Up) {
      return show17(c.value0) + "A";
    }
    ;
    if (c instanceof Down) {
      return show17(c.value0) + "B";
    }
    ;
    if (c instanceof Forward) {
      return show17(c.value0) + "C";
    }
    ;
    if (c instanceof Back) {
      return show17(c.value0) + "D";
    }
    ;
    if (c instanceof NextLine) {
      return show17(c.value0) + "E";
    }
    ;
    if (c instanceof PreviousLine) {
      return show17(c.value0) + "F";
    }
    ;
    if (c instanceof HorizontalAbsolute) {
      return show17(c.value0) + "G";
    }
    ;
    if (c instanceof Position) {
      return show17(c.value0) + (";" + (show17(c.value1) + "H"));
    }
    ;
    if (c instanceof EraseData) {
      return eraseParamToString(c.value0) + "J";
    }
    ;
    if (c instanceof EraseLine) {
      return eraseParamToString(c.value0) + "K";
    }
    ;
    if (c instanceof ScrollUp) {
      return show17(c.value0) + "S";
    }
    ;
    if (c instanceof ScrollDown) {
      return show17(c.value0) + "T";
    }
    ;
    if (c instanceof Graphics) {
      return intercalate6(";")(map52(graphicsParamToString)(c.value0)) + colorSuffix;
    }
    ;
    if (c instanceof SavePosition) {
      return "s";
    }
    ;
    if (c instanceof RestorePosition) {
      return "u";
    }
    ;
    if (c instanceof QueryPosition) {
      return "6n";
    }
    ;
    if (c instanceof HideCursor) {
      return "?25l";
    }
    ;
    if (c instanceof ShowCursor) {
      return "?25h";
    }
    ;
    throw new Error("Failed pattern match at Ansi.Codes (line 53, column 5 - line 71, column 37): " + [c.constructor.name]);
  };
  return function($846) {
    return function(v) {
      return prefix + v;
    }(go($846));
  };
}();

// output/Data.String.Utils/foreign.js
function padStartPrimeImpl(targetLength, str2) {
  return str2.padStart(targetLength);
}
function startsWithImpl(searchString, s) {
  return s.startsWith(searchString);
}

// output/Data.String.Utils/index.js
var startsWith2 = function(searchString) {
  return function(s) {
    return startsWithImpl(searchString, s);
  };
};
var padStart$prime = function(n) {
  return function(s) {
    return padStartPrimeImpl(n, s);
  };
};
var padStart = function(n) {
  return function(s) {
    var numberOfCodeUnits = length4(s);
    var numberOfCodePoints = length5(s);
    return padStart$prime((n + numberOfCodeUnits | 0) - numberOfCodePoints | 0)(s);
  };
};

// output/Dodo.Ansi/index.js
var pure38 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var eq7 = /* @__PURE__ */ eq(eqRenderingMode);
var notEq6 = /* @__PURE__ */ notEq(eqGraphicsParam);
var foreground = function(color) {
  return annotate(new PForeground(color));
};
var dim = /* @__PURE__ */ function() {
  return annotate(new PMode(Dim.value));
}();
var bold = /* @__PURE__ */ function() {
  return annotate(new PMode(Bold.value));
}();
var ansiGraphics = /* @__PURE__ */ function() {
  var writePendingGraphics = function(v) {
    if (v.pending instanceof Nothing) {
      return v;
    }
    ;
    if (v.pending instanceof Just) {
      return {
        current: v.current,
        previous: v.previous,
        output: v.output + escapeCodeToString(new Graphics(v.pending.value0)),
        pending: Nothing.value
      };
    }
    ;
    throw new Error("Failed pattern match at Dodo.Ansi (line 136, column 5 - line 143, column 12): " + [v.pending.constructor.name]);
  };
  var writeText = function(v) {
    return function(text3) {
      return function(output8) {
        var v1 = writePendingGraphics(output8);
        return {
          pending: v1.pending,
          current: v1.current,
          output: v1.output + text3,
          previous: Nil.value
        };
      };
    };
  };
  var writeIndent = function(v) {
    return function(text3) {
      return function(v1) {
        return {
          pending: v1.pending,
          current: v1.current,
          previous: v1.previous,
          output: v1.output + text3
        };
      };
    };
  };
  var resetCode = escapeCodeToString(new Graphics(pure38(Reset.value)));
  var graphicsConflict = function(v) {
    return function(v1) {
      if (v instanceof Reset && v1 instanceof Reset) {
        return true;
      }
      ;
      if (v instanceof PForeground && v1 instanceof PForeground) {
        return true;
      }
      ;
      if (v instanceof PBackground && v1 instanceof PBackground) {
        return true;
      }
      ;
      if (v instanceof PMode && v1 instanceof PMode) {
        return eq7(v.value0)(v1.value0);
      }
      ;
      return false;
    };
  };
  var getPendingGraphics = function() {
    var $50 = map(functorMaybe)(cons3(Reset.value));
    return function($51) {
      return $50(fromList($51));
    };
  }();
  var writeBreak = function(v) {
    var pending = getPendingGraphics(v.current);
    var resetOrEmpty = function() {
      var $42 = isNothing(pending) && $$null5(v.previous);
      if ($42) {
        return "";
      }
      ;
      return resetCode;
    }();
    return {
      current: v.current,
      previous: v.previous,
      output: v.output + (resetOrEmpty + "\n"),
      pending
    };
  };
  var getCurrentGraphics = function() {
    var $52 = nubByEq2(graphicsConflict);
    var $53 = takeWhile4(function(v) {
      return notEq6(v)(Reset.value);
    });
    return function($54) {
      return reverse2($52($53($54)));
    };
  }();
  var leaveAnnotation = function(v) {
    return function(as3) {
      return function(v1) {
        var current = getCurrentGraphics(as3);
        return {
          output: v1.output,
          pending: new Just(fromMaybe(pure38(Reset.value))(getPendingGraphics(current))),
          current,
          previous: v1.current
        };
      };
    };
  };
  var flushBuffer = function(ansiBuffer) {
    var v = writePendingGraphics(ansiBuffer);
    return v.output;
  };
  var enterAnnotation = function(a) {
    return function(as3) {
      return function(v) {
        var current = getCurrentGraphics(new Cons(a, as3));
        return {
          output: v.output,
          pending: getPendingGraphics(current),
          current,
          previous: v.current
        };
      };
    };
  };
  var emptyBuffer = {
    output: "",
    pending: Nothing.value,
    current: Nil.value,
    previous: Nil.value
  };
  return {
    emptyBuffer,
    writeText,
    writeIndent,
    writeBreak,
    enterAnnotation,
    leaveAnnotation,
    flushBuffer
  };
}();

// output/Dodo.Box/index.js
var max6 = /* @__PURE__ */ max(ordInt);
var coerce7 = /* @__PURE__ */ coerce();
var append21 = /* @__PURE__ */ append(semigroupDoc);
var power3 = /* @__PURE__ */ power(monoidDoc);
var mempty10 = /* @__PURE__ */ mempty(monoidDoc);
var under2 = /* @__PURE__ */ under()();
var LinePad = /* @__PURE__ */ function() {
  function LinePad2(value0) {
    this.value0 = value0;
  }
  ;
  LinePad2.create = function(value0) {
    return new LinePad2(value0);
  };
  return LinePad2;
}();
var LineDoc = /* @__PURE__ */ function() {
  function LineDoc2(value0) {
    this.value0 = value0;
  }
  ;
  LineDoc2.create = function(value0) {
    return new LineDoc2(value0);
  };
  return LineDoc2;
}();
var LineAppend = /* @__PURE__ */ function() {
  function LineAppend2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LineAppend2.create = function(value0) {
    return function(value12) {
      return new LineAppend2(value0, value12);
    };
  };
  return LineAppend2;
}();
var FullHeight = /* @__PURE__ */ function() {
  function FullHeight2(value0) {
    this.value0 = value0;
  }
  ;
  FullHeight2.create = function(value0) {
    return new FullHeight2(value0);
  };
  return FullHeight2;
}();
var FullWidth = /* @__PURE__ */ function() {
  function FullWidth2(value0) {
    this.value0 = value0;
  }
  ;
  FullWidth2.create = function(value0) {
    return new FullWidth2(value0);
  };
  return FullWidth2;
}();
var AsIs = /* @__PURE__ */ function() {
  function AsIs2() {
  }
  ;
  AsIs2.value = new AsIs2();
  return AsIs2;
}();
var StpDone = /* @__PURE__ */ function() {
  function StpDone2() {
  }
  ;
  StpDone2.value = new StpDone2();
  return StpDone2;
}();
var StpLine = /* @__PURE__ */ function() {
  function StpLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  StpLine2.create = function(value0) {
    return function(value12) {
      return new StpLine2(value0, value12);
    };
  };
  return StpLine2;
}();
var StpPad = /* @__PURE__ */ function() {
  function StpPad2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  StpPad2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new StpPad2(value0, value12, value22);
      };
    };
  };
  return StpPad2;
}();
var StpHorz = /* @__PURE__ */ function() {
  function StpHorz2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  StpHorz2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new StpHorz2(value0, value12, value22);
      };
    };
  };
  return StpHorz2;
}();
var ResumeEnter = /* @__PURE__ */ function() {
  function ResumeEnter2(value0) {
    this.value0 = value0;
  }
  ;
  ResumeEnter2.create = function(value0) {
    return new ResumeEnter2(value0);
  };
  return ResumeEnter2;
}();
var ResumeLeave = /* @__PURE__ */ function() {
  function ResumeLeave2(value0) {
    this.value0 = value0;
  }
  ;
  ResumeLeave2.create = function(value0) {
    return new ResumeLeave2(value0);
  };
  return ResumeLeave2;
}();
var ResumeHorzR = /* @__PURE__ */ function() {
  function ResumeHorzR2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ResumeHorzR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ResumeHorzR2(value0, value12, value22);
      };
    };
  };
  return ResumeHorzR2;
}();
var ResumeHorzH = /* @__PURE__ */ function() {
  function ResumeHorzH2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ResumeHorzH2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ResumeHorzH2(value0, value12, value22);
      };
    };
  };
  return ResumeHorzH2;
}();
var ResumeNil = /* @__PURE__ */ function() {
  function ResumeNil2() {
  }
  ;
  ResumeNil2.value = new ResumeNil2();
  return ResumeNil2;
}();
var Start = /* @__PURE__ */ function() {
  function Start2() {
  }
  ;
  Start2.value = new Start2();
  return Start2;
}();
var Middle = /* @__PURE__ */ function() {
  function Middle2() {
  }
  ;
  Middle2.value = new Middle2();
  return Middle2;
}();
var End = /* @__PURE__ */ function() {
  function End2() {
  }
  ;
  End2.value = new End2();
  return End2;
}();
var DocLine = /* @__PURE__ */ function() {
  function DocLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DocLine2.create = function(value0) {
    return function(value12) {
      return new DocLine2(value0, value12);
    };
  };
  return DocLine2;
}();
var DocVApp = /* @__PURE__ */ function() {
  function DocVApp2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocVApp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocVApp2(value0, value12, value22);
      };
    };
  };
  return DocVApp2;
}();
var DocHApp = /* @__PURE__ */ function() {
  function DocHApp2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocHApp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocHApp2(value0, value12, value22);
      };
    };
  };
  return DocHApp2;
}();
var DocAlign = /* @__PURE__ */ function() {
  function DocAlign2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocAlign2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocAlign2(value0, value12, value22);
      };
    };
  };
  return DocAlign2;
}();
var DocPad = /* @__PURE__ */ function() {
  function DocPad2(value0) {
    this.value0 = value0;
  }
  ;
  DocPad2.create = function(value0) {
    return new DocPad2(value0);
  };
  return DocPad2;
}();
var DocEmpty = /* @__PURE__ */ function() {
  function DocEmpty2() {
  }
  ;
  DocEmpty2.value = new DocEmpty2();
  return DocEmpty2;
}();
var BuildEnter = /* @__PURE__ */ function() {
  function BuildEnter2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildEnter2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildEnter2(value0, value12, value22);
      };
    };
  };
  return BuildEnter2;
}();
var BuildLeave = /* @__PURE__ */ function() {
  function BuildLeave2(value0) {
    this.value0 = value0;
  }
  ;
  BuildLeave2.create = function(value0) {
    return new BuildLeave2(value0);
  };
  return BuildLeave2;
}();
var BuildVAppR = /* @__PURE__ */ function() {
  function BuildVAppR2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildVAppR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildVAppR2(value0, value12, value22);
      };
    };
  };
  return BuildVAppR2;
}();
var BuildHAppR = /* @__PURE__ */ function() {
  function BuildHAppR2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  BuildHAppR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new BuildHAppR2(value0, value12, value22, value32);
        };
      };
    };
  };
  return BuildHAppR2;
}();
var BuildHAppH = /* @__PURE__ */ function() {
  function BuildHAppH2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildHAppH2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildHAppH2(value0, value12, value22);
      };
    };
  };
  return BuildHAppH2;
}();
var BuildNil = /* @__PURE__ */ function() {
  function BuildNil2() {
  }
  ;
  BuildNil2.value = new BuildNil2();
  return BuildNil2;
}();
var Vertical = function(x) {
  return x;
};
var vpadding = function(height) {
  if (height <= 0) {
    return DocEmpty.value;
  }
  ;
  if (otherwise) {
    return new DocPad({
      height,
      width: 0
    });
  }
  ;
  throw new Error("Failed pattern match at Dodo.Box (line 228, column 1 - line 228, column 38): " + [height.constructor.name]);
};
var valignOf = function(v) {
  if (v instanceof DocAlign) {
    return v.value0;
  }
  ;
  return Start.value;
};
var valign = function(a) {
  return function(v) {
    var v1 = function(v2) {
      if (v instanceof DocAlign && otherwise) {
        return new DocAlign(a, v.value1, v.value2);
      }
      ;
      return new DocAlign(a, Start.value, v);
    };
    if (v instanceof DocAlign) {
      if (a instanceof Start) {
        if (v.value1 instanceof Start) {
          return v.value2;
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    }
    ;
    return v1(true);
  };
};
var sizeOf = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v instanceof DocLine) {
      $tco_done = true;
      return {
        width: v.value1,
        height: 1
      };
    }
    ;
    if (v instanceof DocVApp) {
      $tco_done = true;
      return v.value2;
    }
    ;
    if (v instanceof DocHApp) {
      $tco_done = true;
      return v.value2;
    }
    ;
    if (v instanceof DocAlign) {
      $copy_v = v.value2;
      return;
    }
    ;
    if (v instanceof DocPad) {
      $tco_done = true;
      return v.value0;
    }
    ;
    if (v instanceof DocEmpty) {
      $tco_done = true;
      return {
        width: 0,
        height: 0
      };
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 241, column 10 - line 247, column 38): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var vappend = /* @__PURE__ */ function() {
  var scale = function(sizea) {
    return function(sizeb) {
      return {
        width: max6(sizea.width)(sizeb.width),
        height: sizea.height + sizeb.height | 0
      };
    };
  };
  return function(v) {
    return function(v1) {
      if (v instanceof DocEmpty) {
        return v1;
      }
      ;
      if (v1 instanceof DocEmpty) {
        return v;
      }
      ;
      if (v instanceof DocPad && v1 instanceof DocPad) {
        return new DocPad(scale(v.value0)(v1.value0));
      }
      ;
      return new DocVApp(v, v1, scale(sizeOf(v))(sizeOf(v1)));
    };
  };
}();
var vertical = function(dictFoldable) {
  return foldr(dictFoldable)(vappend)(DocEmpty.value);
};
var semigroupVertical = {
  append: /* @__PURE__ */ coerce7(vappend)
};
var monoidVertical = /* @__PURE__ */ function() {
  return {
    mempty: DocEmpty.value,
    Semigroup0: function() {
      return semigroupVertical;
    }
  };
}();
var power1 = /* @__PURE__ */ power(monoidVertical);
var resume = /* @__PURE__ */ function() {
  var go = function($copy_cmd) {
    return function($copy_stack) {
      var $tco_var_cmd = $copy_cmd;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(cmd, stack) {
        if (cmd instanceof ResumeEnter) {
          if (cmd.value0 instanceof StpDone) {
            $tco_var_cmd = new ResumeLeave(Nothing.value);
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpLine) {
            $tco_var_cmd = new ResumeLeave(new Just({
              line: new LineDoc(cmd.value0.value0),
              next: cmd.value0.value1
            }));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpPad) {
            var $136 = cmd.value0.value1 === 0;
            if ($136) {
              $tco_var_cmd = new ResumeEnter(cmd.value0.value2);
              $copy_stack = stack;
              return;
            }
            ;
            $tco_var_cmd = new ResumeLeave(new Just({
              line: new LinePad(cmd.value0.value0),
              next: new StpPad(cmd.value0.value0, cmd.value0.value1 - 1 | 0, cmd.value0.value2)
            }));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpHorz) {
            $tco_var_cmd = new ResumeEnter(cmd.value0.value1);
            $copy_stack = new ResumeHorzR(cmd.value0.value0, cmd.value0.value2, stack);
            return;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 389, column 7 - line 406, column 56): " + [cmd.value0.constructor.name]);
        }
        ;
        if (cmd instanceof ResumeLeave) {
          if (stack instanceof ResumeHorzR) {
            $tco_var_cmd = new ResumeEnter(stack.value0);
            $copy_stack = new ResumeHorzH(cmd.value0, stack.value1, stack.value2);
            return;
          }
          ;
          if (stack instanceof ResumeHorzH) {
            if (cmd.value0 instanceof Just && stack.value0 instanceof Just) {
              $tco_var_cmd = new ResumeLeave(new Just({
                line: new LineAppend(cmd.value0.value0.line, stack.value0.value0.line),
                next: new StpHorz(cmd.value0.value0.next, stack.value0.value0.next, stack.value1)
              }));
              $copy_stack = stack.value2;
              return;
            }
            ;
            $tco_var_cmd = new ResumeEnter(stack.value1);
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof ResumeNil) {
            $tco_done = true;
            return cmd.value0;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 408, column 7 - line 424, column 15): " + [stack.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 387, column 18 - line 424, column 15): " + [cmd.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_cmd, $copy_stack);
      }
      ;
      return $tco_result;
    };
  };
  var $277 = flip(go)(ResumeNil.value);
  return function($278) {
    return $277(ResumeEnter.create($278));
  };
}();
var padWithAlign = function(appendFn) {
  return function(paddingFn) {
    return function(padWidth) {
      return function(doc) {
        return function(v) {
          if (v instanceof Start) {
            return appendFn(doc)(paddingFn(padWidth));
          }
          ;
          if (v instanceof Middle) {
            var mid = toNumber(padWidth) / 2;
            return appendFn(appendFn(paddingFn(floor2(mid)))(doc))(paddingFn(ceil2(mid)));
          }
          ;
          if (v instanceof End) {
            return appendFn(paddingFn(padWidth))(doc);
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 197, column 48 - line 206, column 38): " + [v.constructor.name]);
        };
      };
    };
  };
};
var isEmpty7 = function(v) {
  if (v instanceof DocEmpty) {
    return true;
  }
  ;
  return false;
};
var hpadding = function(width2) {
  if (width2 <= 0) {
    return DocEmpty.value;
  }
  ;
  if (otherwise) {
    return new DocPad({
      height: 1,
      width: width2
    });
  }
  ;
  throw new Error("Failed pattern match at Dodo.Box (line 234, column 1 - line 234, column 38): " + [width2.constructor.name]);
};
var happend = /* @__PURE__ */ function() {
  var scale = function(sizea) {
    return function(sizeb) {
      return {
        width: sizea.width + sizeb.width | 0,
        height: max6(sizea.height)(sizeb.height)
      };
    };
  };
  return function(v) {
    return function(v1) {
      if (v instanceof DocEmpty) {
        return v1;
      }
      ;
      if (v1 instanceof DocEmpty) {
        return v;
      }
      ;
      if (v instanceof DocPad && v1 instanceof DocPad) {
        return new DocPad(scale(v.value0)(v1.value0));
      }
      ;
      return new DocHApp(v, v1, scale(sizeOf(v))(sizeOf(v1)));
    };
  };
}();
var horizontal = function(dictFoldable) {
  return foldr(dictFoldable)(happend)(DocEmpty.value);
};
var halignOf = function(v) {
  if (v instanceof DocAlign) {
    return v.value1;
  }
  ;
  return Start.value;
};
var halign = function(b) {
  return function(v) {
    var v1 = function(v2) {
      if (v instanceof DocAlign && otherwise) {
        return new DocAlign(v.value0, b, v.value2);
      }
      ;
      return new DocAlign(Start.value, b, v);
    };
    if (v instanceof DocAlign) {
      if (v.value0 instanceof Start) {
        if (b instanceof Start) {
          return v.value2;
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    }
    ;
    return v1(true);
  };
};
var resize = function(newSize) {
  return function(box) {
    var size8 = sizeOf(box);
    var vpad = newSize.height - size8.height | 0;
    var hpad = newSize.width - size8.width | 0;
    var box$prime = function() {
      if (box instanceof DocAlign) {
        return box.value2;
      }
      ;
      return box;
    }();
    var hdoc = function() {
      if (hpad <= 0) {
        return valign(Start.value)(box$prime);
      }
      ;
      if (otherwise) {
        return padWithAlign(happend)(hpadding)(hpad)(box)(halignOf(box));
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 189, column 3 - line 191, column 72): ");
    }();
    var vdoc = function() {
      if (vpad <= 0) {
        return halign(Start.value)(hdoc);
      }
      ;
      if (otherwise) {
        return padWithAlign(vappend)(vpadding)(vpad)(hdoc)(valignOf(box));
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 192, column 3 - line 194, column 73): ");
    }();
    return vdoc;
  };
};
var formatLine = /* @__PURE__ */ function() {
  var go = function($copy_acc) {
    return function($copy_v) {
      var $tco_var_acc = $copy_acc;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(acc, v) {
        if (v instanceof Nil) {
          $tco_done = true;
          return acc;
        }
        ;
        if (v instanceof Cons) {
          if (v.value0 instanceof LinePad) {
            if (isEmpty4(acc)) {
              $tco_var_acc = acc;
              $copy_v = v.value1;
              return;
            }
            ;
            if (otherwise) {
              $tco_var_acc = append21(power3(space)(v.value0.value0))(acc);
              $copy_v = v.value1;
              return;
            }
            ;
          }
          ;
          if (v.value0 instanceof LineDoc) {
            $tco_var_acc = append21(v.value0.value0)(acc);
            $copy_v = v.value1;
            return;
          }
          ;
          if (v.value0 instanceof LineAppend) {
            $tco_var_acc = acc;
            $copy_v = new Cons(v.value0.value1, new Cons(v.value0.value0, v.value1));
            return;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 290, column 7 - line 299, column 33): " + [v.value0.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 286, column 12 - line 299, column 33): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_acc, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  var $279 = go(mempty10);
  return function($280) {
    return $279(singleton8($280));
  };
}();
var fill = function(ch) {
  return function(v) {
    var line2 = function() {
      if (ch instanceof Annotate) {
        return new DocLine(annotate(ch.value0)(power3(ch.value1)(v.width)), v.width);
      }
      ;
      return new DocLine(power3(ch)(v.width), v.width);
    }();
    return under2(Vertical)(flip(power1)(v.height))(line2);
  };
};
var docBox = /* @__PURE__ */ function() {
  var writeText = function(width2) {
    return function(text3) {
      return function(v) {
        var doc$prime = new Text(width2, text3);
        var line2 = function() {
          if (v.currentLine instanceof Cons && v.currentLine.value0 instanceof Right) {
            return new Cons(new Right(append21(v.currentLine.value0.value0)(doc$prime)), v.currentLine.value1);
          }
          ;
          return new Cons(new Right(doc$prime), v.currentLine);
        }();
        return {
          currentIndent: v.currentIndent,
          lines: v.lines,
          currentLine: line2,
          currentWidth: v.currentWidth + width2 | 0
        };
      };
    };
  };
  var writeIndent = function(width2) {
    return function(text3) {
      return function(v) {
        var doc = new Text(width2, text3);
        return {
          currentLine: v.currentLine,
          lines: v.lines,
          currentIndent: append21(v.currentIndent)(doc),
          currentWidth: v.currentWidth + width2 | 0
        };
      };
    };
  };
  var stkToDoc = foldl(foldableList)(function(doc) {
    return function(v) {
      if (v instanceof Left) {
        return annotate(v.value0)(doc);
      }
      ;
      if (v instanceof Right) {
        return append21(v.value0)(doc);
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 521, column 15 - line 525, column 22): " + [v.constructor.name]);
    };
  })(mempty10);
  var writeBreak = function(v) {
    var line2 = stkToDoc(v.currentLine);
    return {
      currentIndent: mempty10,
      currentLine: filter3(isLeft)(v.currentLine),
      currentWidth: 0,
      lines: vappend(v.lines)(new DocLine(append21(v.currentIndent)(line2), v.currentWidth))
    };
  };
  var leaveAnnotation = function(v) {
    return function(v1) {
      return function(v2) {
        var line2 = function() {
          if (v2.currentLine instanceof Cons && (v2.currentLine.value0 instanceof Right && (v2.currentLine.value1 instanceof Cons && v2.currentLine.value1.value0 instanceof Left))) {
            return new Cons(new Right(annotate(v2.currentLine.value1.value0.value0)(v2.currentLine.value0.value0)), v2.currentLine.value1.value1);
          }
          ;
          if (v2.currentLine instanceof Cons && v2.currentLine.value0 instanceof Left) {
            return v2.currentLine.value1;
          }
          ;
          return unsafeCrashWith("leaveAnnotation: docs and annotations must be interleaved");
        }();
        return {
          currentIndent: v2.currentIndent,
          currentWidth: v2.currentWidth,
          lines: v2.lines,
          currentLine: line2
        };
      };
    };
  };
  var flushBuffer = function(v) {
    if (isEmpty7(v.lines) && $$null5(v.currentLine)) {
      return DocEmpty.value;
    }
    ;
    if (otherwise) {
      var line2 = stkToDoc(v.currentLine);
      return vappend(v.lines)(new DocLine(append21(v.currentIndent)(line2), v.currentWidth));
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 511, column 3 - line 511, column 44): " + [v.constructor.name]);
  };
  var enterAnnotation = function(ann) {
    return function(v) {
      return function(v1) {
        return {
          currentIndent: v1.currentIndent,
          currentWidth: v1.currentWidth,
          lines: v1.lines,
          currentLine: new Cons(new Left(ann), v1.currentLine)
        };
      };
    };
  };
  var emptyBuffer = {
    currentIndent: mempty10,
    currentLine: Nil.value,
    currentWidth: 0,
    lines: DocEmpty.value
  };
  return {
    emptyBuffer,
    writeText,
    writeIndent,
    writeBreak,
    enterAnnotation,
    leaveAnnotation,
    flushBuffer
  };
}();
var build2 = /* @__PURE__ */ function() {
  var go = function($copy_cmd) {
    return function($copy_stack) {
      var $tco_var_cmd = $copy_cmd;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(cmd, stack) {
        if (cmd instanceof BuildEnter) {
          if (cmd.value0 instanceof FullHeight) {
            if (cmd.value2 instanceof DocHApp) {
              $tco_var_cmd = new BuildEnter(cmd.value0, StpDone.value, cmd.value2.value1);
              $copy_stack = new BuildHAppR(cmd.value0.value0, cmd.value2.value0, cmd.value1, stack);
              return;
            }
            ;
            $tco_var_cmd = new BuildEnter(AsIs.value, cmd.value1, resize({
              width: 0,
              height: cmd.value0.value0
            })(cmd.value2));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof FullWidth) {
            if (cmd.value2 instanceof DocVApp) {
              $tco_var_cmd = new BuildEnter(cmd.value0, cmd.value1, cmd.value2.value1);
              $copy_stack = new BuildVAppR(cmd.value0.value0, cmd.value2.value0, stack);
              return;
            }
            ;
            $tco_var_cmd = new BuildEnter(AsIs.value, cmd.value1, resize({
              width: cmd.value0.value0,
              height: 0
            })(cmd.value2));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof AsIs) {
            if (cmd.value2 instanceof DocVApp) {
              $tco_var_cmd = new BuildEnter(new FullWidth(cmd.value2.value2.width), cmd.value1, cmd.value2.value1);
              $copy_stack = new BuildVAppR(cmd.value2.value2.width, cmd.value2.value0, stack);
              return;
            }
            ;
            if (cmd.value2 instanceof DocHApp) {
              $tco_var_cmd = new BuildEnter(new FullHeight(cmd.value2.value2.height), StpDone.value, cmd.value2.value1);
              $copy_stack = new BuildHAppR(cmd.value2.value2.height, cmd.value2.value0, cmd.value1, stack);
              return;
            }
            ;
            if (cmd.value2 instanceof DocAlign) {
              $tco_var_cmd = new BuildEnter(cmd.value0, cmd.value1, cmd.value2.value2);
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocLine) {
              $tco_var_cmd = new BuildLeave(new StpLine(cmd.value2.value0, cmd.value1));
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocPad) {
              $tco_var_cmd = new BuildLeave(new StpPad(cmd.value2.value0.width, cmd.value2.value0.height, cmd.value1));
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocEmpty) {
              $tco_var_cmd = new BuildLeave(StpDone.value);
              $copy_stack = stack;
              return;
            }
            ;
            throw new Error("Failed pattern match at Dodo.Box (line 341, column 11 - line 353, column 44): " + [cmd.value2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 327, column 7 - line 353, column 44): " + [cmd.value0.constructor.name]);
        }
        ;
        if (cmd instanceof BuildLeave) {
          if (stack instanceof BuildVAppR) {
            $tco_var_cmd = new BuildEnter(new FullWidth(stack.value0), cmd.value0, stack.value1);
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof BuildHAppR) {
            $tco_var_cmd = new BuildEnter(new FullHeight(stack.value0), StpDone.value, stack.value1);
            $copy_stack = new BuildHAppH(cmd.value0, stack.value2, stack.value3);
            return;
          }
          ;
          if (stack instanceof BuildHAppH) {
            $tco_var_cmd = new BuildLeave(new StpHorz(cmd.value0, stack.value0, stack.value1));
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof BuildNil) {
            $tco_done = true;
            return cmd.value0;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 355, column 7 - line 363, column 15): " + [stack.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 325, column 18 - line 363, column 15): " + [cmd.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_cmd, $copy_stack);
      }
      ;
      return $tco_result;
    };
  };
  return function(size8) {
    return function(next2) {
      return function(box) {
        return go(new BuildEnter(size8, next2, box))(BuildNil.value);
      };
    };
  };
}();
var toDoc = /* @__PURE__ */ function() {
  var go2 = function($copy_acc) {
    return function($copy_v) {
      var $tco_var_acc = $copy_acc;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(acc, v) {
        if (v instanceof Nothing) {
          $tco_done = true;
          return acc;
        }
        ;
        if (v instanceof Just) {
          $tco_var_acc = append21(acc)(append21($$break)(formatLine(v.value0.line)));
          $copy_v = resume(v.value0.next);
          return;
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 278, column 13 - line 281, column 63): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_acc, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  var go1 = function(v) {
    if (v instanceof Nothing) {
      return mempty10;
    }
    ;
    if (v instanceof Just) {
      return go2(formatLine(v.value0.line))(resume(v.value0.next));
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 273, column 9 - line 276, column 42): " + [v.constructor.name]);
  };
  var $281 = build2(AsIs.value)(StpDone.value);
  return function($282) {
    return go1(resume($281($282)));
  };
}();

// output/Effect.Console/foreign.js
var log2 = function(s) {
  return function() {
    console.log(s);
  };
};
var error3 = function(s) {
  return function() {
    console.error(s);
  };
};

// output/Effect.Class.Console/index.js
var log3 = function(dictMonadEffect) {
  var $67 = liftEffect(dictMonadEffect);
  return function($68) {
    return $67(log2($68));
  };
};
var error4 = function(dictMonadEffect) {
  var $79 = liftEffect(dictMonadEffect);
  return function($80) {
    return $79(error3($80));
  };
};

// output/Spago.Yaml/foreign.js
var import_yaml = __toESM(require_dist(), 1);
function yamlDocParserImpl(fail7, succ2, s) {
  const doc = import_yaml.default.parseDocument(s);
  if (doc.errors.length === 0) {
    return succ2(doc);
  } else {
    return fail7(JSON.stringify(doc.errors));
  }
}
function toJsonImpl(doc) {
  return doc.toJSON();
}
function toStringImpl2(doc) {
  return doc.toString();
}
function stringifyWithIndent(i) {
  return function(j) {
    return import_yaml.default.stringify(j, null, i);
  };
}

// output/Spago.Yaml/index.js
var bind29 = /* @__PURE__ */ bind(bindEither);
var lmap12 = /* @__PURE__ */ lmap(bifunctorEither);
var pure39 = /* @__PURE__ */ pure(applicativeEither);
var map53 = /* @__PURE__ */ map(functorEither);
var toString7 = /* @__PURE__ */ runFn1(toStringImpl2);
var toJson = /* @__PURE__ */ runFn1(toJsonImpl);
var printYaml = function(codec12) {
  var $10 = stringifyWithIndent(2);
  var $11 = encode2(codec12);
  return function($12) {
    return $10($11($12));
  };
};
var parser5 = function(yaml) {
  return yamlDocParserImpl(Left.create, Right.create, yaml);
};
var parseYamlDoc = function(codec12) {
  return function(yamlStr) {
    return bind29(lmap12(function(err) {
      return basic("YAML: " + err);
    })(parser5(yamlStr)))(function(doc) {
      return bind29(decode2(codec12)(toJson(doc)))(function(yaml) {
        return pure39({
          doc,
          yaml
        });
      });
    });
  };
};
var parseYaml = function(codec12) {
  var $13 = map53(function(v) {
    return v.yaml;
  });
  var $14 = parseYamlDoc(codec12);
  return function($15) {
    return $13($14($15));
  };
};

// output/Spago.Log/index.js
var identity23 = /* @__PURE__ */ identity(categoryFn);
var lines3 = /* @__PURE__ */ lines(foldableArray);
var map54 = /* @__PURE__ */ map(functorArray);
var map118 = /* @__PURE__ */ map(functorNonEmptyArray);
var map215 = /* @__PURE__ */ map(functorMaybe);
var max7 = /* @__PURE__ */ max(ordInt);
var horizontal2 = /* @__PURE__ */ horizontal(foldableArray);
var vertical2 = /* @__PURE__ */ vertical(foldableArray);
var diff3 = /* @__PURE__ */ diff2(durationMilliseconds);
var show18 = /* @__PURE__ */ show(showInt);
var unwrap11 = /* @__PURE__ */ unwrap();
var append23 = /* @__PURE__ */ append(semigroupDoc);
var discard9 = /* @__PURE__ */ discard(discardUnit);
var traverse3 = /* @__PURE__ */ traverse(traversableArray);
var OutputJson = /* @__PURE__ */ function() {
  function OutputJson2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OutputJson2.create = function(value0) {
    return function(value12) {
      return new OutputJson2(value0, value12);
    };
  };
  return OutputJson2;
}();
var OutputYaml = /* @__PURE__ */ function() {
  function OutputYaml2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OutputYaml2.create = function(value0) {
    return function(value12) {
      return new OutputYaml2(value0, value12);
    };
  };
  return OutputYaml2;
}();
var OutputTable = /* @__PURE__ */ function() {
  function OutputTable2(value0) {
    this.value0 = value0;
  }
  ;
  OutputTable2.create = function(value0) {
    return new OutputTable2(value0);
  };
  return OutputTable2;
}();
var OutputLines = /* @__PURE__ */ function() {
  function OutputLines2(value0) {
    this.value0 = value0;
  }
  ;
  OutputLines2.create = function(value0) {
    return new OutputLines2(value0);
  };
  return OutputLines2;
}();
var LogQuiet = /* @__PURE__ */ function() {
  function LogQuiet2() {
  }
  ;
  LogQuiet2.value = new LogQuiet2();
  return LogQuiet2;
}();
var LogNormal = /* @__PURE__ */ function() {
  function LogNormal2() {
  }
  ;
  LogNormal2.value = new LogNormal2();
  return LogNormal2;
}();
var LogVerbose = /* @__PURE__ */ function() {
  function LogVerbose2() {
  }
  ;
  LogVerbose2.value = new LogVerbose2();
  return LogVerbose2;
}();
var LogDebug = /* @__PURE__ */ function() {
  function LogDebug2() {
  }
  ;
  LogDebug2.value = new LogDebug2();
  return LogDebug2;
}();
var LogInfo = /* @__PURE__ */ function() {
  function LogInfo2() {
  }
  ;
  LogInfo2.value = new LogInfo2();
  return LogInfo2;
}();
var LogWarning = /* @__PURE__ */ function() {
  function LogWarning2() {
  }
  ;
  LogWarning2.value = new LogWarning2();
  return LogWarning2;
}();
var LogError = /* @__PURE__ */ function() {
  function LogError2() {
  }
  ;
  LogError2.value = new LogError2();
  return LogError2;
}();
var loggableString = {
  toDoc: text
};
var loggableDocc = {
  toDoc: identity23
};
var toDoc2 = function(dict) {
  return dict.toDoc;
};
var toDoc1 = /* @__PURE__ */ toDoc2(loggableString);
var loggableArray = function(dictLoggable) {
  return {
    toDoc: function() {
      var $200 = map54(toDoc2(dictLoggable));
      return function($201) {
        return lines3($200($201));
      };
    }()
  };
};
var loggableNonEmptyArray = function(dictLoggable) {
  return {
    toDoc: function() {
      var $202 = map118(toDoc2(dictLoggable));
      return function($203) {
        return lines3(toArray($202($203)));
      };
    }()
  };
};
var loggablePackageName = {
  toDoc: function($204) {
    return toDoc1(print5($204));
  }
};
var textBox = /* @__PURE__ */ function() {
  var $205 = print4(docBox)(twoSpaces);
  return function($206) {
    return $205(text($206));
  };
}();
var logTable = function(v) {
  var widths = mapWithIndex2(function(ix) {
    return function(hd) {
      return foldr2(function() {
        var $207 = fromMaybe(0);
        var $208 = map215(function($211) {
          return function(v1) {
            return v1.width;
          }(sizeOf($211));
        });
        var $209 = flip(index)(ix);
        return function($210) {
          return max7($207($208($209($210))));
        };
      }())(sizeOf(hd).width)(v.rows);
    };
  })(v.headers);
  var joint = fill(text("+"))({
    width: 1,
    height: 1
  });
  var rowSep = horizontal2([joint, horizontal2(intersperse(joint)(map54(function(width2) {
    return fill(text("-"))({
      width: width2 + 2 | 0,
      height: 1
    });
  })(widths))), joint]);
  var columns = function(cols) {
    var height = foldr2(function($212) {
      return max7(function(v1) {
        return v1.height;
      }(sizeOf($212)));
    })(0)(cols);
    var sep3 = fill(text("|"))({
      width: 1,
      height
    });
    var colBoxes = mapWithIndex2(function(ix) {
      return function(col) {
        return horizontal2([hpadding(1), resize({
          width: fromMaybe(0)(index(widths)(ix)),
          height
        })(col), hpadding(1)]);
      };
    })(cols);
    return horizontal2([sep3, horizontal2(intersperse(sep3)(colBoxes)), sep3]);
  };
  return vertical2([rowSep, vertical2(cons(columns(v.headers))(cons(rowSep)(map54(columns)(v.rows)))), rowSep]);
};
var output = function(dictMonadEffect) {
  var log1 = log3(dictMonadEffect);
  return function(format2) {
    return log1(function() {
      if (format2 instanceof OutputJson) {
        return printJson(format2.value0)(format2.value1);
      }
      ;
      if (format2 instanceof OutputYaml) {
        return printYaml(format2.value0)(format2.value1);
      }
      ;
      if (format2 instanceof OutputLines) {
        return joinWith("\n")(format2.value0);
      }
      ;
      if (format2 instanceof OutputTable) {
        return print4(plainText)(twoSpaces)(toDoc(logTable({
          headers: map54(textBox)(format2.value0.titles),
          rows: map54(map54(textBox))(format2.value0.rows)
        })));
      }
      ;
      throw new Error("Failed pattern match at Spago.Log (line 212, column 29 - line 220, column 79): " + [format2.constructor.name]);
    }());
  };
};
var log4 = function(dictMonadEffect) {
  var liftEffect19 = liftEffect(dictMonadEffect);
  var error5 = error4(dictMonadEffect);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var bind82 = bind(Monad0.Bind1());
    var ask20 = ask(dictMonadAsk);
    var pure98 = pure(Monad0.Applicative0());
    return function(v) {
      return bind82(ask20)(function(v1) {
        var printFn = function() {
          if (v1.logOptions.color) {
            return print4(ansiGraphics);
          }
          ;
          return print4(plainText);
        }();
        if (v1.logOptions.verbosity instanceof LogQuiet) {
          return pure98(unit);
        }
        ;
        if (v1.logOptions.verbosity instanceof LogNormal && v.level instanceof LogDebug) {
          return pure98(unit);
        }
        ;
        if (v1.logOptions.verbosity instanceof LogVerbose) {
          return bind82(liftEffect19(now))(function(now3) {
            var v2 = diff3(now3)(v1.logOptions.startingTime);
            var millisDoc = foreground(White.value)(bold(text(padStart(8)(show18(round2(unwrap11(v2)))))));
            var contentWithTimeDiff = append23(text("["))(append23(millisDoc)(append23(text("ms]"))(append23(space)(v.content))));
            return error5(printFn({
              ribbonRatio: twoSpaces.ribbonRatio,
              indentUnit: twoSpaces.indentUnit,
              indentWidth: twoSpaces.indentWidth,
              pageWidth: 200
            })(contentWithTimeDiff));
          });
        }
        ;
        return error5(printFn({
          ribbonRatio: twoSpaces.ribbonRatio,
          indentUnit: twoSpaces.indentUnit,
          indentWidth: twoSpaces.indentWidth,
          pageWidth: 200
        })(v.content));
      });
    };
  };
};
var logDebug = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogDebug.value,
          content: foreground(Blue.value)(toDoc25(l))
        });
      };
    };
  };
};
var logError = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogError.value,
          content: foreground(Red.value)(toDoc25(l))
        });
      };
    };
  };
};
var logFailure = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: foreground(Red.value)(append23($$break)(append23(bold(append23(toDoc1("\u2718"))(append23(space)(toDoc25(l)))))($$break)))
        });
      };
    };
  };
};
var prepareToDie = function(dictMonadEffect) {
  var logFailure1 = logFailure(dictMonadEffect);
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(dictMonadAsk) {
    var discard115 = discard9(dictMonadAsk.Monad0().Bind1());
    var logFailure2 = logFailure1(dictMonadAsk);
    return function(dictLoggable) {
      var logFailure3 = logFailure2(dictLoggable);
      return function(msg) {
        return discard115(logFailure3(msg))(function() {
          return liftEffect19(setExitCode(1));
        });
      };
    };
  };
};
var logInfo = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: toDoc25(l)
        });
      };
    };
  };
};
var logSuccess = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: foreground(Green.value)(append23($$break)(append23(bold(append23(toDoc1("\u2713"))(append23(space)(toDoc25(l)))))($$break)))
        });
      };
    };
  };
};
var logWarn = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogWarning.value,
          content: foreground(Yellow.value)(bold(append23(toDoc1("\u203C"))(append23(space)(toDoc25(l)))))
        });
      };
    };
  };
};
var indent22 = function($213) {
  return indent(indent($213));
};
var die$prime = function(dictMonadEffect) {
  var logFailure1 = logFailure(dictMonadEffect);
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var bind82 = bind(Monad0.Bind1());
    var traverse13 = traverse3(Monad0.Applicative0());
    var logFailure2 = logFailure1(dictMonadAsk);
    return function(dictLoggable) {
      var logFailure3 = logFailure2(dictLoggable);
      return function(msgs) {
        return bind82(traverse13(logFailure3)(msgs))(function() {
          return liftEffect19(exit$prime(1));
        });
      };
    };
  };
};
var die = function(dictMonadEffect) {
  var logFailure1 = logFailure(dictMonadEffect);
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(dictMonadAsk) {
    var discard115 = discard9(dictMonadAsk.Monad0().Bind1());
    var logFailure2 = logFailure1(dictMonadAsk);
    return function(dictLoggable) {
      var logFailure3 = logFailure2(dictLoggable);
      return function(msg) {
        return discard115(logFailure3(msg))(function() {
          return liftEffect19(exit$prime(1));
        });
      };
    };
  };
};
var justOrDieWith = function(dictMonadEffect) {
  var die112 = die(dictMonadEffect);
  return function(dictMonadAsk) {
    var pure98 = pure(dictMonadAsk.Monad0().Applicative0());
    var die211 = die112(dictMonadAsk);
    return function(dictLoggable) {
      var die35 = die211(dictLoggable);
      return function(value4) {
        return function(msg) {
          if (value4 instanceof Just) {
            return pure98(value4.value0);
          }
          ;
          if (value4 instanceof Nothing) {
            return die35(msg);
          }
          ;
          throw new Error("Failed pattern match at Spago.Log (line 172, column 27 - line 176, column 12): " + [value4.constructor.name]);
        };
      };
    };
  };
};
var rightOrDieWith = function(dictMonadEffect) {
  var die112 = die(dictMonadEffect);
  return function(dictMonadAsk) {
    var pure98 = pure(dictMonadAsk.Monad0().Applicative0());
    var die211 = die112(dictMonadAsk);
    return function(dictLoggable) {
      var die35 = die211(dictLoggable);
      return function(value4) {
        return function(toMsg) {
          if (value4 instanceof Right) {
            return pure98(value4.value0);
          }
          ;
          if (value4 instanceof Left) {
            return die35(toMsg(value4.value0));
          }
          ;
          throw new Error("Failed pattern match at Spago.Log (line 192, column 30 - line 196, column 20): " + [value4.constructor.name]);
        };
      };
    };
  };
};
var rightOrDie = function(dictMonadEffect) {
  var rightOrDieWith1 = rightOrDieWith(dictMonadEffect);
  return function(dictMonadAsk) {
    var rightOrDieWith2 = rightOrDieWith1(dictMonadAsk);
    return function(dictLoggable) {
      var rightOrDieWith3 = rightOrDieWith2(dictLoggable);
      return function(value4) {
        return rightOrDieWith3(value4)(identity23);
      };
    };
  };
};
var rightOrDie_ = function(dictMonadEffect) {
  var rightOrDie1 = rightOrDie(dictMonadEffect);
  return function(dictMonadAsk) {
    var $$void25 = $$void(dictMonadAsk.Monad0().Bind1().Apply0().Functor0());
    var rightOrDie22 = rightOrDie1(dictMonadAsk);
    return function(dictLoggable) {
      var $214 = rightOrDie22(dictLoggable);
      return function($215) {
        return $$void25($214($215));
      };
    };
  };
};

// output/Spago.Core.Prelude/index.js
var monadSpago = /* @__PURE__ */ monadReaderT(monadAff);
var monadReaderSpago = /* @__PURE__ */ monadReaderReaderT(monadAff);
var monadErrorErrorSpago = /* @__PURE__ */ monadErrorReaderT(monadErrorAff);
var monadEffectSpago = /* @__PURE__ */ monadEffectReader(monadEffectAff);
var monadAskSpago = /* @__PURE__ */ monadAskReaderT(monadAff);
var monadAffSpago = /* @__PURE__ */ monadAffReader(monadAffAff);
var functorSpago = /* @__PURE__ */ functorReaderT(functorAff);
var bindSpago = /* @__PURE__ */ bindReaderT(bindAff);
var applySpago = /* @__PURE__ */ applyReaderT(applyAff);
var applicativeSpago = /* @__PURE__ */ applicativeReaderT(applicativeAff);
var unsafeFromJust = /* @__PURE__ */ fromMaybe$prime(function(v) {
  return unsafeCrashWith("Unexpected Nothing");
});
var runSpago$prime = function(env3) {
  return function(v) {
    return runReaderT(v)(env3);
  };
};
var runSpago = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(env3) {
    return function(a) {
      return liftAff13(runSpago$prime(env3)(a));
    };
  };
};

// output/Spago.Core.Config/index.js
var unionWith2 = /* @__PURE__ */ unionWith(ordPackageName);
var eq18 = /* @__PURE__ */ eq(eqVersion);
var eq24 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqSha256));
var eq34 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMap(eqPackageName)(/* @__PURE__ */ eqMaybe(eqRange)));
var eq42 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var eq52 = /* @__PURE__ */ eq(/* @__PURE__ */ eqArray(eqPackageName));
var object5 = /* @__PURE__ */ object2();
var rowListCodecCons4 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var functorExceptT4 = /* @__PURE__ */ functorExceptT(functorIdentity);
var map55 = /* @__PURE__ */ map(functorExceptT4);
var alt16 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var object1 = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecCons4({
  reflectSymbol: function() {
    return "path";
  }
}));
var mainIsSymbol = {
  reflectSymbol: function() {
    return "main";
  }
};
var recordPropOptional2 = /* @__PURE__ */ recordPropOptional({
  reflectSymbol: function() {
    return "execArgs";
  }
})();
var recordProp2 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "version";
  }
})();
var eq62 = /* @__PURE__ */ eq(eqRange);
var dependenciesIsSymbol = {
  reflectSymbol: function() {
    return "dependencies";
  }
};
var recordProp1 = /* @__PURE__ */ recordProp(dependenciesIsSymbol)();
var map119 = /* @__PURE__ */ map(functorArray);
var toUnfoldable11 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var rmap2 = /* @__PURE__ */ rmap(bifunctorTuple);
var toUnfoldable14 = /* @__PURE__ */ toUnfoldable5(unfoldableList);
var bind30 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
var except5 = /* @__PURE__ */ except(applicativeIdentity);
var bind113 = /* @__PURE__ */ bind(bindEither);
var recordPropOptional1 = /* @__PURE__ */ recordPropOptional({
  reflectSymbol: function() {
    return "strict";
  }
})();
var recordPropOptional22 = /* @__PURE__ */ recordPropOptional({
  reflectSymbol: function() {
    return "pedanticPackages";
  }
})();
var ByCode = /* @__PURE__ */ function() {
  function ByCode2(value0) {
    this.value0 = value0;
  }
  ;
  ByCode2.create = function(value0) {
    return new ByCode2(value0);
  };
  return ByCode2;
}();
var ByMessagePrefix = /* @__PURE__ */ function() {
  function ByMessagePrefix2(value0) {
    this.value0 = value0;
  }
  ;
  ByMessagePrefix2.create = function(value0) {
    return new ByMessagePrefix2(value0);
  };
  return ByMessagePrefix2;
}();
var NoStats = /* @__PURE__ */ function() {
  function NoStats2() {
  }
  ;
  NoStats2.value = new NoStats2();
  return NoStats2;
}();
var CompactStats = /* @__PURE__ */ function() {
  function CompactStats2() {
  }
  ;
  CompactStats2.value = new CompactStats2();
  return CompactStats2;
}();
var VerboseStats = /* @__PURE__ */ function() {
  function VerboseStats2() {
  }
  ;
  VerboseStats2.value = new VerboseStats2();
  return VerboseStats2;
}();
var SetFromRegistry = /* @__PURE__ */ function() {
  function SetFromRegistry2(value0) {
    this.value0 = value0;
  }
  ;
  SetFromRegistry2.create = function(value0) {
    return new SetFromRegistry2(value0);
  };
  return SetFromRegistry2;
}();
var SetFromUrl = /* @__PURE__ */ function() {
  function SetFromUrl2(value0) {
    this.value0 = value0;
  }
  ;
  SetFromUrl2.create = function(value0) {
    return new SetFromUrl2(value0);
  };
  return SetFromUrl2;
}();
var SetFromPath = /* @__PURE__ */ function() {
  function SetFromPath2(value0) {
    this.value0 = value0;
  }
  ;
  SetFromPath2.create = function(value0) {
    return new SetFromPath2(value0);
  };
  return SetFromPath2;
}();
var Dependencies = function(x) {
  return x;
};
var RemoteGitPackage = /* @__PURE__ */ function() {
  function RemoteGitPackage2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteGitPackage2.create = function(value0) {
    return new RemoteGitPackage2(value0);
  };
  return RemoteGitPackage2;
}();
var RemoteRegistryVersion = /* @__PURE__ */ function() {
  function RemoteRegistryVersion2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteRegistryVersion2.create = function(value0) {
    return new RemoteRegistryVersion2(value0);
  };
  return RemoteRegistryVersion2;
}();
var RemoteLegacyPackage = /* @__PURE__ */ function() {
  function RemoteLegacyPackage2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteLegacyPackage2.create = function(value0) {
    return new RemoteLegacyPackage2(value0);
  };
  return RemoteLegacyPackage2;
}();
var ExtraLocalPackage = /* @__PURE__ */ function() {
  function ExtraLocalPackage2(value0) {
    this.value0 = value0;
  }
  ;
  ExtraLocalPackage2.create = function(value0) {
    return new ExtraLocalPackage2(value0);
  };
  return ExtraLocalPackage2;
}();
var ExtraRemotePackage = /* @__PURE__ */ function() {
  function ExtraRemotePackage2(value0) {
    this.value0 = value0;
  }
  ;
  ExtraRemotePackage2.create = function(value0) {
    return new ExtraRemotePackage2(value0);
  };
  return ExtraRemotePackage2;
}();
var CensorAllWarnings = /* @__PURE__ */ function() {
  function CensorAllWarnings2() {
  }
  ;
  CensorAllWarnings2.value = new CensorAllWarnings2();
  return CensorAllWarnings2;
}();
var CensorSpecificWarnings = /* @__PURE__ */ function() {
  function CensorSpecificWarnings2(value0) {
    this.value0 = value0;
  }
  ;
  CensorSpecificWarnings2.create = function(value0) {
    return new CensorSpecificWarnings2(value0);
  };
  return CensorSpecificWarnings2;
}();
var BundleApp = /* @__PURE__ */ function() {
  function BundleApp2() {
  }
  ;
  BundleApp2.value = new BundleApp2();
  return BundleApp2;
}();
var BundleModule = /* @__PURE__ */ function() {
  function BundleModule2() {
  }
  ;
  BundleModule2.value = new BundleModule2();
  return BundleModule2;
}();
var BundleNode = /* @__PURE__ */ function() {
  function BundleNode2() {
  }
  ;
  BundleNode2.value = new BundleNode2();
  return BundleNode2;
}();
var BundleBrowser = /* @__PURE__ */ function() {
  function BundleBrowser2() {
  }
  ;
  BundleBrowser2.value = new BundleBrowser2();
  return BundleBrowser2;
}();
var showStatVerbosity = {
  show: function(v) {
    if (v instanceof NoStats) {
      return "NoStats";
    }
    ;
    if (v instanceof CompactStats) {
      return "CompactStats";
    }
    ;
    if (v instanceof VerboseStats) {
      return "VerboseStats";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 372, column 10 - line 375, column 35): " + [v.constructor.name]);
  }
};
var showBundleType = {
  show: function(v) {
    if (v instanceof BundleApp) {
      return "app";
    }
    ;
    if (v instanceof BundleModule) {
      return "module";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 206, column 10 - line 208, column 29): " + [v.constructor.name]);
  }
};
var showBundlePlatform = {
  show: function(v) {
    if (v instanceof BundleNode) {
      return "node";
    }
    ;
    if (v instanceof BundleBrowser) {
      return "browser";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 188, column 10 - line 190, column 31): " + [v.constructor.name]);
  }
};
var semigroupDependencies = {
  append: function(v) {
    return function(v1) {
      return unionWith2(function(v2) {
        return function(v3) {
          if (v2 instanceof Nothing && v3 instanceof Nothing) {
            return Nothing.value;
          }
          ;
          if (v2 instanceof Just && v3 instanceof Nothing) {
            return new Just(v2.value0);
          }
          ;
          if (v2 instanceof Nothing && v3 instanceof Just) {
            return new Just(v3.value0);
          }
          ;
          if (v2 instanceof Just && v3 instanceof Just) {
            return intersect2(v2.value0)(v3.value0);
          }
          ;
          throw new Error("Failed pattern match at Spago.Core.Config (line 226, column 7 - line 230, column 50): " + [v2.constructor.name, v3.constructor.name]);
        };
      })(v)(v1);
    };
  }
};
var monoidDependencies = {
  mempty: empty4,
  Semigroup0: function() {
    return semigroupDependencies;
  }
};
var eqSetAddress = {
  eq: function(x) {
    return function(y) {
      if (x instanceof SetFromRegistry && y instanceof SetFromRegistry) {
        return eq18(x.value0.registry)(y.value0.registry);
      }
      ;
      if (x instanceof SetFromUrl && y instanceof SetFromUrl) {
        return eq24(x.value0.hash)(y.value0.hash) && x.value0.url === y.value0.url;
      }
      ;
      if (x instanceof SetFromPath && y instanceof SetFromPath) {
        return x.value0.path === y.value0.path;
      }
      ;
      return false;
    };
  }
};
var eqDependencies = {
  eq: function(x) {
    return function(y) {
      return eq34(x)(y);
    };
  }
};
var eq8 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqDependencies));
var eqRemotePackage = {
  eq: function(x) {
    return function(y) {
      if (x instanceof RemoteGitPackage && y instanceof RemoteGitPackage) {
        return eq8(x.value0.dependencies)(y.value0.dependencies) && x.value0.git === y.value0.git && x.value0.ref === y.value0.ref && eq42(x.value0.subdir)(y.value0.subdir);
      }
      ;
      if (x instanceof RemoteRegistryVersion && y instanceof RemoteRegistryVersion) {
        return eq18(x.value0)(y.value0);
      }
      ;
      if (x instanceof RemoteLegacyPackage && y instanceof RemoteLegacyPackage) {
        return eq52(x.value0.dependencies)(y.value0.dependencies) && x.value0.repo === y.value0.repo && x.value0.version === y.value0.version;
      }
      ;
      return false;
    };
  }
};
var eq9 = /* @__PURE__ */ eq(eqRemotePackage);
var eqExtraPackage = {
  eq: function(x) {
    return function(y) {
      if (x instanceof ExtraLocalPackage && y instanceof ExtraLocalPackage) {
        return x.value0.path === y.value0.path;
      }
      ;
      if (x instanceof ExtraRemotePackage && y instanceof ExtraRemotePackage) {
        return eq9(x.value0)(y.value0);
      }
      ;
      return false;
    };
  }
};
var widestRange = /* @__PURE__ */ fromRight$prime(function(v) {
  return unsafeCrashWith("Fake range failed");
})(/* @__PURE__ */ parse7(">=0.0.0 <2147483647.0.0"));
var warningCensorTestCodec = /* @__PURE__ */ function() {
  var byMessagePrefixCodec = named("ByMessagePrefix")(object5(rowListCodecCons4({
    reflectSymbol: function() {
      return "byPrefix";
    }
  }))({
    byPrefix: string
  }));
  var decode4 = function(json4) {
    var byPrefix = map55(function($348) {
      return ByMessagePrefix.create(function(v) {
        return v.byPrefix;
      }($348));
    })(decode(byMessagePrefixCodec)(json4));
    var byCode = map55(ByCode.create)(decode(string)(json4));
    return alt16(byCode)(byPrefix);
  };
  var encode6 = function(v) {
    if (v instanceof ByCode) {
      return encode2(string)(v.value0);
    }
    ;
    if (v instanceof ByMessagePrefix) {
      return encode2(byMessagePrefixCodec)({
        byPrefix: v.value0
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 355, column 12 - line 357, column 76): " + [v.constructor.name]);
  };
  return codec$prime(decode4)(encode6);
}();
var statVerbosityCodec = /* @__PURE__ */ function() {
  var print12 = function(v) {
    if (v instanceof NoStats) {
      return "no-stats";
    }
    ;
    if (v instanceof CompactStats) {
      return "compact-stats";
    }
    ;
    if (v instanceof VerboseStats) {
      return "verbose-stats";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 380, column 11 - line 383, column 36): " + [v.constructor.name]);
  };
  var parse15 = function(v) {
    if (v === "no-stats") {
      return new Just(NoStats.value);
    }
    ;
    if (v === "compact-stats") {
      return new Just(CompactStats.value);
    }
    ;
    if (v === "verbose-stats") {
      return new Just(VerboseStats.value);
    }
    ;
    return Nothing.value;
  };
  return enumSum(print12)(parse15);
}();
var setAddressCodec = /* @__PURE__ */ function() {
  var setFromUrlCodec = named("SetFromUrl")(object5(rowListCodecConsOptional(rowListCodecCons4({
    reflectSymbol: function() {
      return "url";
    }
  }))()()({
    reflectSymbol: function() {
      return "hash";
    }
  }))({
    url: string,
    hash: optional4(codec7)
  }));
  var setFromRegistryCodec = named("SetFromRegistry")(object5(rowListCodecCons4({
    reflectSymbol: function() {
      return "registry";
    }
  }))({
    registry: codec3
  }));
  var setFromPathCodec = named("SetFromPath")(object1({
    path: string
  }));
  var encode6 = function(v) {
    if (v instanceof SetFromRegistry) {
      return encode2(setFromRegistryCodec)(v.value0);
    }
    ;
    if (v instanceof SetFromUrl) {
      return encode2(setFromUrlCodec)(v.value0);
    }
    ;
    if (v instanceof SetFromPath) {
      return encode2(setFromPathCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 404, column 3 - line 404, column 64): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    return alt16(map55(SetFromRegistry.create)(decode(setFromRegistryCodec)(json4)))(alt16(map55(SetFromUrl.create)(decode(setFromUrlCodec)(json4)))(map55(SetFromPath.create)(decode(setFromPathCodec)(json4))));
  };
  return codec$prime(decode4)(encode6);
}();
var runConfigCodec = /* @__PURE__ */ function() {
  return named("RunConfig")(object(recordPropOptional(mainIsSymbol)()($$Proxy.value)(string)(recordPropOptional2($$Proxy.value)(array(string))(record))));
}();
var publishConfigCodec = /* @__PURE__ */ function() {
  return named("PublishConfig")(object(recordProp2($$Proxy.value)(codec3)(recordProp({
    reflectSymbol: function() {
      return "license";
    }
  })()($$Proxy.value)(codec4)(recordPropOptional({
    reflectSymbol: function() {
      return "location";
    }
  })()($$Proxy.value)(codec5)(recordPropOptional({
    reflectSymbol: function() {
      return "include";
    }
  })()($$Proxy.value)(array(string))(recordPropOptional({
    reflectSymbol: function() {
      return "exclude";
    }
  })()($$Proxy.value)(array(string))(record)))))));
}();
var printSpagoRange = function(range3) {
  var $322 = eq62(range3)(widestRange);
  if ($322) {
    return "*";
  }
  ;
  return print8(range3);
};
var spagoRangeCodec = /* @__PURE__ */ function() {
  var rangeParse = function(str2) {
    var $323 = str2 === "*";
    if ($323) {
      return new Just(widestRange);
    }
    ;
    return hush(parse7(str2));
  };
  return prismaticCodec("SpagoRange")(rangeParse)(printSpagoRange)(string);
}();
var parsePlatform = function(v) {
  if (v === "node") {
    return new Just(BundleNode.value);
  }
  ;
  if (v === "browser") {
    return new Just(BundleBrowser.value);
  }
  ;
  return Nothing.value;
};
var parseBundleType = function(v) {
  if (v === "app") {
    return new Just(BundleApp.value);
  }
  ;
  if (v === "module") {
    return new Just(BundleModule.value);
  }
  ;
  return Nothing.value;
};
var localPackageCodec = /* @__PURE__ */ named("LocalPackage")(/* @__PURE__ */ object1({
  path: string
}));
var legacyPackageSetEntryCodec = /* @__PURE__ */ function() {
  return named("LegacyPackageSetEntry")(object(recordProp({
    reflectSymbol: function() {
      return "repo";
    }
  })()($$Proxy.value)(string)(recordProp2($$Proxy.value)(string)(recordProp1($$Proxy.value)(array(codec2))(record)))));
}();
var dependenciesCodec = /* @__PURE__ */ function() {
  var to2 = function(v) {
    return map119(function(v1) {
      if (v1.value1 instanceof Nothing) {
        return new Left(v1.value0);
      }
      ;
      if (v1.value1 instanceof Just) {
        return new Right(singleton10(v1.value0)(v1.value1.value0));
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 246, column 37 - line 248, column 49): " + [v1.value1.constructor.name]);
    })(toUnfoldable11(v));
  };
  var packageSingletonCodec = packageMap(spagoRangeCodec);
  var from4 = function() {
    var $349 = fromFoldable7(ordPackageName)(foldableArray);
    var $350 = map119(function(v) {
      if (v instanceof Left) {
        return new Tuple(v.value0, Nothing.value);
      }
      ;
      if (v instanceof Right) {
        return rmap2(Just.create)(unsafeFromJust(head3(toUnfoldable14(v.value0))));
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 254, column 7 - line 256, column 79): " + [v.constructor.name]);
    });
    return function($351) {
      return Dependencies($349($350($351)));
    };
  }();
  var dependencyCodec = function() {
    var encode6 = function(v) {
      if (v instanceof Left) {
        return encode2(codec2)(v.value0);
      }
      ;
      if (v instanceof Right) {
        return encode2(packageSingletonCodec)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 262, column 14 - line 264, column 73): " + [v.constructor.name]);
    };
    var decode4 = function(json4) {
      return alt16(map55(Left.create)(decode(codec2)(json4)))(map55(Right.create)(decode(packageSingletonCodec)(json4)));
    };
    return codec$prime(decode4)(encode6);
  }();
  return dimap(profunctorCodec(functorExceptT4))(to2)(from4)(array(dependencyCodec));
}();
var gitPackageCodec = /* @__PURE__ */ function() {
  return named("GitPackage")(object(recordProp({
    reflectSymbol: function() {
      return "git";
    }
  })()($$Proxy.value)(string)(recordProp({
    reflectSymbol: function() {
      return "ref";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "subdir";
    }
  })()($$Proxy.value)(string)(recordPropOptional(dependenciesIsSymbol)()($$Proxy.value)(dependenciesCodec)(record))))));
}();
var remotePackageCodec = /* @__PURE__ */ function() {
  var encode6 = function(v) {
    if (v instanceof RemoteRegistryVersion) {
      return encode2(codec3)(v.value0);
    }
    ;
    if (v instanceof RemoteGitPackage) {
      return encode2(gitPackageCodec)(v.value0);
    }
    ;
    if (v instanceof RemoteLegacyPackage) {
      return encode2(legacyPackageSetEntryCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 442, column 3 - line 442, column 63): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    return alt16(map55(RemoteRegistryVersion.create)(decode(codec3)(json4)))(alt16(map55(RemoteGitPackage.create)(decode(gitPackageCodec)(json4)))(map55(RemoteLegacyPackage.create)(decode(legacyPackageSetEntryCodec)(json4))));
  };
  return codec$prime(decode4)(encode6);
}();
var extraPackageCodec = /* @__PURE__ */ function() {
  var encode6 = function(v) {
    if (v instanceof ExtraLocalPackage) {
      return encode2(localPackageCodec)(v.value0);
    }
    ;
    if (v instanceof ExtraRemotePackage) {
      return encode2(remotePackageCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 421, column 3 - line 421, column 65): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    return alt16(map55(ExtraLocalPackage.create)(decode(localPackageCodec)(json4)))(map55(ExtraRemotePackage.create)(decode(remotePackageCodec)(json4)));
  };
  return codec$prime(decode4)(encode6);
}();
var censorBuildWarningsCodec = /* @__PURE__ */ function() {
  var encode6 = function(v) {
    if (v instanceof CensorAllWarnings) {
      return encode2(string)("all");
    }
    ;
    if (v instanceof CensorSpecificWarnings) {
      return encode2(array(warningCensorTestCodec))(toArray(v.value0));
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 328, column 12 - line 330, column 122): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    var decodeSpecific = map55(CensorSpecificWarnings.create)(bind30(decode(array(warningCensorTestCodec))(json4))(function(arr) {
      return except5(note(basic("Expected array of warning codes"))(fromArray(arr)));
    }));
    var decodeNoneOrAll = except5(bind113(decode2(string)(json4))(function(v) {
      if (v === "all") {
        return new Right(CensorAllWarnings.value);
      }
      ;
      return new Left(basic("Expected 'all' for all warnings"));
    }));
    return alt16(decodeNoneOrAll)(decodeSpecific);
  };
  return codec$prime(decode4)(encode6);
}();
var packageBuildOptionsCodec = /* @__PURE__ */ function() {
  return named("PackageBuildOptionsInput")(object(recordPropOptional({
    reflectSymbol: function() {
      return "censorProjectWarnings";
    }
  })()($$Proxy.value)(censorBuildWarningsCodec)(recordPropOptional1($$Proxy.value)($$boolean)(recordPropOptional22($$Proxy.value)($$boolean)(record)))));
}();
var testConfigCodec = /* @__PURE__ */ function() {
  return named("TestConfig")(object(recordProp(mainIsSymbol)()($$Proxy.value)(string)(recordPropOptional2($$Proxy.value)(array(string))(recordPropOptional({
    reflectSymbol: function() {
      return "censorTestWarnings";
    }
  })()($$Proxy.value)(censorBuildWarningsCodec)(recordPropOptional1($$Proxy.value)($$boolean)(recordPropOptional22($$Proxy.value)($$boolean)(recordProp1($$Proxy.value)(dependenciesCodec)(record))))))));
}();
var bundleTypeCodec = /* @__PURE__ */ enumSum(/* @__PURE__ */ show(showBundleType))(parseBundleType);
var bundlePlatformCodec = /* @__PURE__ */ enumSum(/* @__PURE__ */ show(showBundlePlatform))(parsePlatform);
var bundleConfigCodec = /* @__PURE__ */ function() {
  return named("BundleConfig")(object(recordPropOptional({
    reflectSymbol: function() {
      return "minify";
    }
  })()($$Proxy.value)($$boolean)(recordPropOptional({
    reflectSymbol: function() {
      return "module";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "outfile";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "platform";
    }
  })()($$Proxy.value)(bundlePlatformCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "type";
    }
  })()($$Proxy.value)(bundleTypeCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "extraArgs";
    }
  })()($$Proxy.value)(array(string))(record))))))));
}();
var packageConfigCodec = /* @__PURE__ */ function() {
  return named("PackageConfig")(object(recordProp({
    reflectSymbol: function() {
      return "name";
    }
  })()($$Proxy.value)(codec2)(recordPropOptional({
    reflectSymbol: function() {
      return "description";
    }
  })()($$Proxy.value)(string)(recordProp1($$Proxy.value)(dependenciesCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "build";
    }
  })()($$Proxy.value)(packageBuildOptionsCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "bundle";
    }
  })()($$Proxy.value)(bundleConfigCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "run";
    }
  })()($$Proxy.value)(runConfigCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "test";
    }
  })()($$Proxy.value)(testConfigCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "publish";
    }
  })()($$Proxy.value)(publishConfigCodec)(record))))))))));
}();
var buildOptionsCodec = /* @__PURE__ */ function() {
  return named("WorkspaceBuildOptionsInput")(object(recordPropOptional({
    reflectSymbol: function() {
      return "output";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "censorLibraryWarnings";
    }
  })()($$Proxy.value)(censorBuildWarningsCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "statVerbosity";
    }
  })()($$Proxy.value)(statVerbosityCodec)(record)))));
}();
var backendConfigCodec = /* @__PURE__ */ function() {
  return named("BackendConfig")(object(recordProp({
    reflectSymbol: function() {
      return "cmd";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "args";
    }
  })()($$Proxy.value)(array(string))(record))));
}();
var workspaceConfigCodec = /* @__PURE__ */ function() {
  return named("WorkspaceConfig")(object(recordPropOptional({
    reflectSymbol: function() {
      return "packageSet";
    }
  })()($$Proxy.value)(setAddressCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "backend";
    }
  })()($$Proxy.value)(backendConfigCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "buildOpts";
    }
  })()($$Proxy.value)(buildOptionsCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "extraPackages";
    }
  })()($$Proxy.value)(packageMap(extraPackageCodec))(record))))));
}();
var configCodec = /* @__PURE__ */ function() {
  return object(recordPropOptional({
    reflectSymbol: function() {
      return "package";
    }
  })()($$Proxy.value)(packageConfigCodec)(recordPropOptional({
    reflectSymbol: function() {
      return "workspace";
    }
  })()($$Proxy.value)(workspaceConfigCodec)(record)));
}();

// output/Spago.Prelude/foreign.js
import url from "node:url";
var parseUrlImpl = (onError, onSuccess, rawUrl) => {
  try {
    return onSuccess(new url.URL(rawUrl));
  } catch (err) {
    return onError(err);
  }
};

// output/Data.String.Extra/foreign.js
function levenshtein(str1) {
  return function(str2) {
    var prevRow = [], str2Char = [];
    var str1Len = str1.length, str2Len = str2.length;
    if (str1Len === 0)
      return str2Len;
    if (str2Len === 0)
      return str1Len;
    var curCol, nextCol, i, j, tmp;
    for (i = 0; i < str2Len; ++i) {
      prevRow[i] = i;
      str2Char[i] = str2.charCodeAt(i);
    }
    prevRow[str2Len] = str2Len;
    var strCmp;
    for (i = 0; i < str1Len; ++i) {
      nextCol = i + 1;
      for (j = 0; j < str2Len; ++j) {
        curCol = nextCol;
        strCmp = str1.charCodeAt(i) === str2Char[j];
        nextCol = prevRow[j] + (strCmp ? 0 : 1);
        tmp = curCol + 1;
        if (nextCol > tmp) {
          nextCol = tmp;
        }
        tmp = prevRow[j + 1] + 1;
        if (nextCol > tmp) {
          nextCol = tmp;
        }
        prevRow[j] = curCol;
      }
      prevRow[j] = nextCol;
    }
    return nextCol;
  };
}

// node_modules/env-paths/index.js
import path2 from "node:path";
import os2 from "node:os";
import process4 from "node:process";
var homedir = os2.homedir();
var tmpdir = os2.tmpdir();
var { env: env2 } = process4;
var macos = (name5) => {
  const library = path2.join(homedir, "Library");
  return {
    data: path2.join(library, "Application Support", name5),
    config: path2.join(library, "Preferences", name5),
    cache: path2.join(library, "Caches", name5),
    log: path2.join(library, "Logs", name5),
    temp: path2.join(tmpdir, name5)
  };
};
var windows = (name5) => {
  const appData = env2.APPDATA || path2.join(homedir, "AppData", "Roaming");
  const localAppData = env2.LOCALAPPDATA || path2.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path2.join(localAppData, name5, "Data"),
    config: path2.join(appData, name5, "Config"),
    cache: path2.join(localAppData, name5, "Cache"),
    log: path2.join(localAppData, name5, "Log"),
    temp: path2.join(tmpdir, name5)
  };
};
var linux = (name5) => {
  const username = path2.basename(homedir);
  return {
    data: path2.join(env2.XDG_DATA_HOME || path2.join(homedir, ".local", "share"), name5),
    config: path2.join(env2.XDG_CONFIG_HOME || path2.join(homedir, ".config"), name5),
    cache: path2.join(env2.XDG_CACHE_HOME || path2.join(homedir, ".cache"), name5),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path2.join(env2.XDG_STATE_HOME || path2.join(homedir, ".local", "state"), name5),
    temp: path2.join(tmpdir, username, name5)
  };
};
function envPaths(name5, { suffix: suffix2 = "nodejs" } = {}) {
  if (typeof name5 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name5}`);
  }
  if (suffix2) {
    name5 += `-${suffix2}`;
  }
  if (process4.platform === "darwin") {
    return macos(name5);
  }
  if (process4.platform === "win32") {
    return windows(name5);
  }
  return linux(name5);
}

// output/Spago.Paths/foreign.js
var paths = envPaths("spago");

// output/Spago.Paths/index.js
var toLocalCachePath = function(rootDir) {
  return concat3([rootDir, ".spago"]);
};
var toLocalCachePackagesPath = function(rootDir) {
  return concat3([toLocalCachePath(rootDir), "p"]);
};
var toLocalCacheGitPath = function(rootDir) {
  return concat3([toLocalCachePath(rootDir), "g"]);
};
var globalCachePath = /* @__PURE__ */ function() {
  return paths.cache;
}();
var registryIndexPath = /* @__PURE__ */ concat3([globalCachePath, "registry-index"]);
var registryPath = /* @__PURE__ */ concat3([globalCachePath, "registry"]);
var packageSetsPath = /* @__PURE__ */ concat3([registryPath, "package-sets"]);
var databaseVersion = 2;
var databasePath = /* @__PURE__ */ function() {
  return concat3([globalCachePath, "spago.v" + (show(showInt)(databaseVersion) + ".sqlite")]);
}();
var cwd2 = /* @__PURE__ */ unsafePerformEffect(cwd);
var localCacheGitPath = /* @__PURE__ */ toLocalCacheGitPath(cwd2);
var localCachePackagesPath = /* @__PURE__ */ toLocalCachePackagesPath(cwd2);
var localCachePath = /* @__PURE__ */ toLocalCachePath(cwd2);
var mkRelative = /* @__PURE__ */ relative(cwd2);

// output/Spago.Prelude/index.js
var bind31 = /* @__PURE__ */ bind(bindAff);
var pure40 = /* @__PURE__ */ pure(applicativeAff);
var sequential2 = /* @__PURE__ */ sequential(parallelAff);
var oneOf4 = /* @__PURE__ */ oneOf(foldableArray)(plusParAff);
var parallel3 = /* @__PURE__ */ parallel(parallelAff);
var map56 = /* @__PURE__ */ map(functorAff);
var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorArray);
var sortWith2 = /* @__PURE__ */ sortWith(ordInt);
var map120 = /* @__PURE__ */ map(functorMaybe);
var map216 = /* @__PURE__ */ map(functorArray);
var bind210 = /* @__PURE__ */ bind(bindSpago);
var ask3 = /* @__PURE__ */ ask(monadAskSpago);
var liftAff2 = /* @__PURE__ */ liftAff(monadAffSpago);
var parSequence2 = /* @__PURE__ */ parSequence(parallelAff)(applicativeParAff)(traversableArray);
var runSpago2 = /* @__PURE__ */ runSpago(monadAffAff);
var for_3 = /* @__PURE__ */ for_(applicativeAff)(foldableArray);
var parTraverse2 = /* @__PURE__ */ parTraverse(parallelAff)(applicativeParAff);
var liftEffect4 = /* @__PURE__ */ liftEffect(monadEffectAff);
var hashString2 = /* @__PURE__ */ hashString(monadEffectEffect);
var show19 = /* @__PURE__ */ show(showInstant);
var Offline = /* @__PURE__ */ function() {
  function Offline2() {
  }
  ;
  Offline2.value = new Offline2();
  return Offline2;
}();
var Online = /* @__PURE__ */ function() {
  function Online2() {
  }
  ;
  Online2.value = new Online2();
  return Online2;
}();
var withForwardSlashes = /* @__PURE__ */ replaceAll("\\")("/");
var withBackoff = function(v) {
  var runTimeout = function(attempt2) {
    return function(ms) {
      return bind31(delay(toNumber(ms)))(function() {
        return bind31(v.shouldCancel(attempt2))(function(v1) {
          if (v1) {
            return pure40(Nothing.value);
          }
          ;
          return runTimeout(attempt2)(ms * 2 | 0);
        });
      });
    };
  };
  var runAction = function(attempt2) {
    return function(action$prime) {
      return function(ms) {
        return sequential2(oneOf4([parallel3(map56(Just.create)(action$prime)), parallel3(runTimeout(attempt2)(ms))]));
      };
    };
  };
  var loop = function(attempt2) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        return bind31(v.shouldRetry(attempt2))(function(maybeRetry) {
          if (maybeRetry instanceof Nothing) {
            return pure40(Nothing.value);
          }
          ;
          if (maybeRetry instanceof Just) {
            var newTimeout = pow(floor2(v.delay))(attempt2 + 1 | 0);
            return bind31(runAction(attempt2)(maybeRetry.value0)(newTimeout))(function(maybeResult) {
              return loop(attempt2 + 1 | 0)(maybeResult);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Prelude (line 142, column 9 - line 147, column 43): " + [maybeRetry.constructor.name]);
        });
      }
      ;
      if (v1 instanceof Just) {
        return pure40(new Just(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Spago.Prelude (line 139, column 20 - line 149, column 33): " + [v1.constructor.name]);
    };
  };
  return bind31(runAction(0)(v.action)(floor2(v.delay)))(function(maybeResult) {
    return loop(1)(maybeResult);
  });
};
var withBackoff$prime = function(action) {
  return withBackoff({
    delay: 2e3,
    action,
    shouldCancel: function(v) {
      return pure40(true);
    },
    shouldRetry: function(attempt2) {
      var $72 = attempt2 > 3;
      if ($72) {
        return pure40(Nothing.value);
      }
      ;
      return pure40(new Just(action));
    }
  });
};
var unsafeStringify = function(a) {
  return print(a);
};
var unsafeFromRight = function(v) {
  return fromRight$prime(function(v1) {
    return unsafeCrashWith("Unexpected Left: " + unsafeStringify(v));
  })(v);
};
var typoSuggestions = function(dictFoldable) {
  var foldl21 = foldl(dictFoldable);
  return function(toString9) {
    return function(typo) {
      return function(allOptions) {
        var pickClosestOnes = function(acc) {
          return function(item) {
            var distance = levenshtein(toString9(typo))(toString9(item));
            var $73 = distance <= 2;
            if ($73) {
              return cons(new Tuple(item, distance))(acc);
            }
            ;
            return acc;
          };
        };
        return mapFlipped6(take(5)(sortWith2(snd)(foldl21(pickClosestOnes)([])(allOptions))))(fst);
      };
    };
  };
};
var shaToHex = function(s) {
  return function __do3() {
    var v = fromString7(print9(s))(UTF8.value)();
    var string8 = toString6(Hex.value)(v)();
    return string8;
  };
};
var partitionEithers = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "fail";
  }
})(monoidArray)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "success";
  }
})(monoidArray)()(monoidRecordNil))))(function(v) {
  if (v instanceof Left) {
    return {
      fail: [v.value0],
      success: []
    };
  }
  ;
  if (v instanceof Right) {
    return {
      fail: [],
      success: [v.value0]
    };
  }
  ;
  throw new Error("Failed pattern match at Spago.Prelude (line 83, column 34 - line 85, column 53): " + [v.constructor.name]);
});
var parseUrl = /* @__PURE__ */ function() {
  return runFn3(parseUrlImpl)(Left.create)(function($79) {
    return Right.create($79);
  });
}();
var parseLenientVersion = function(input) {
  var maybeIdentity = function(k) {
    return function(x) {
      return fromMaybe(x)(k(x));
    };
  };
  var dropLeadingZeros = function() {
    var $80 = map120(toStringAs(decimal));
    return function($81) {
      return $80(fromString3($81));
    };
  }();
  return parse4(joinWith(".")(map216(maybeIdentity(dropLeadingZeros))(split(".")(maybeIdentity(stripPrefix2("v"))(trim(input))))));
};
var parallelise = function(actions) {
  return bind210(ask3)(function(env3) {
    return bind210(liftAff2(parSequence2(map216(function() {
      var $82 = runSpago2(env3);
      return function($83) {
        return forkAff($82($83));
      };
    }())(actions))))(function(fibers) {
      return liftAff2(for_3(fibers)(joinFiber));
    });
  });
};
var parTraverseSpago = function(dictTraversable) {
  var parTraverse1 = parTraverse2(dictTraversable);
  return function(action) {
    return function(t) {
      return bind210(ask3)(function(env3) {
        return liftAff2(parTraverse1(function() {
          var $84 = runSpago2(env3);
          return function($85) {
            return $84(action($85));
          };
        }())(t));
      });
    };
  };
};
var mkTemp$prime = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(maybeSuffix) {
    return liftAff1(bind31(liftEffect4(function __do3() {
      var now3 = now();
      var sha = hashString2(show19(now3) + fromMaybe("")(maybeSuffix))();
      return shaToHex(sha)();
    }))(function(v) {
      var tempDirPath = concat3([paths.temp, drop3(50)(v)]);
      return pure40(tempDirPath);
    }));
  };
};
var mkTemp = function(dictMonadAff) {
  return mkTemp$prime(dictMonadAff)(Nothing.value);
};
var isPrefix = function(p) {
  var $86 = stripPrefix2(p);
  return function($87) {
    return isJust($86($87));
  };
};

// output/Spago.Bin.Flags/index.js
var append24 = /* @__PURE__ */ append(modSemigroup);
var $$long3 = /* @__PURE__ */ $$long(flagFieldsHasName);
var $$short2 = /* @__PURE__ */ $$short(flagFieldsHasName);
var optional5 = /* @__PURE__ */ optional2(parserAlt)(parserApplicative);
var long12 = /* @__PURE__ */ $$long(optionFieldsHasName);
var short1 = /* @__PURE__ */ $$short(optionFieldsHasName);
var metavar3 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var map57 = /* @__PURE__ */ map(parserFunctor);
var metavar12 = /* @__PURE__ */ metavar(argumentFieldsHasMetavar);
var fromFoldable25 = /* @__PURE__ */ fromFoldable(foldableList);
var verbose = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("verbose"))(/* @__PURE__ */ append24(/* @__PURE__ */ $$short2("v"))(/* @__PURE__ */ help("Enable additional debug logging, e.g. printing `purs` commands"))));
var useSolver = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("use-solver"))(/* @__PURE__ */ help("Use the solver instead of package sets")));
var transitive = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("transitive"))(/* @__PURE__ */ help("Include transitive dependencies")));
var topo = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("topo"))(/* @__PURE__ */ help("Sort the output topologically")));
var testDeps = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("test-deps"))(/* @__PURE__ */ help("Act on the test config rather than the main one")));
var sourceMaps = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("source-maps"))(/* @__PURE__ */ help("Creates a source map for your bundle")));
var selectedPackage = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("package"))(/* @__PURE__ */ append24(/* @__PURE__ */ short1("p"))(/* @__PURE__ */ append24(/* @__PURE__ */ help("Select the local project to build"))(/* @__PURE__ */ metavar3("PACKAGE"))))));
var quiet = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("quiet"))(/* @__PURE__ */ append24(/* @__PURE__ */ $$short2("q"))(/* @__PURE__ */ help("Suppress all spago logging"))));
var pursArgs = /* @__PURE__ */ map57(/* @__PURE__ */ fromFoldable6(foldableList))(/* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("purs-args"))(/* @__PURE__ */ append24(/* @__PURE__ */ metavar3("ARGS"))(/* @__PURE__ */ help("Arguments to pass to purs compile. Wrap in quotes. `--output` and `--json-errors` must be passed to Spago directly."))))));
var pure41 = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("pure"))(/* @__PURE__ */ help("Use the package information from the current lockfile, even if it is out of date")));
var platform2 = /* @__PURE__ */ optional5(/* @__PURE__ */ option(/* @__PURE__ */ eitherReader(function(v) {
  if (v === "node") {
    return new Right("node");
  }
  ;
  if (v === "browser") {
    return new Right("browser");
  }
  ;
  return new Left('Expected "node" or "browser"');
}))(/* @__PURE__ */ append24(/* @__PURE__ */ long12("platform"))(/* @__PURE__ */ help("The bundle platform. 'node' or 'browser'"))));
var pedanticPackages = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("pedantic-packages"))(/* @__PURE__ */ help("Check for redundant or missing packages in the config and fail the build if any")));
var packagesToRemove = /* @__PURE__ */ many3(/* @__PURE__ */ strArgument(/* @__PURE__ */ append24(/* @__PURE__ */ metavar12("PACKAGE"))(/* @__PURE__ */ help("Package name to remove from dependencies"))));
var packages = /* @__PURE__ */ many3(/* @__PURE__ */ strArgument(/* @__PURE__ */ append24(/* @__PURE__ */ metavar12("PACKAGE"))(/* @__PURE__ */ help("Package name to add as dependency"))));
var $$package = /* @__PURE__ */ strArgument(/* @__PURE__ */ append24(/* @__PURE__ */ metavar12("PACKAGE"))(/* @__PURE__ */ help("Package name")));
var output2 = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("output"))(/* @__PURE__ */ append24(/* @__PURE__ */ help("The output directory for compiled files"))(/* @__PURE__ */ metavar3("DIR")))));
var outfile = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("outfile"))(/* @__PURE__ */ help("Destination path for the bundle. Defaults to ./index.js"))));
var offline = /* @__PURE__ */ function() {
  return flag(Online.value)(Offline.value)(append24($$long3("offline"))(help("Do not attempt to use the network. Warning: this will fail if you don't have the necessary dependencies already cached")));
}();
var noColor = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("no-color"))(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("monochrome"))(/* @__PURE__ */ help("Force logging without ANSI color escape sequences"))));
var moduleName = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("main"))(/* @__PURE__ */ append24(/* @__PURE__ */ short1("m"))(/* @__PURE__ */ help("Module to be used as the application's entry point")))));
var minify = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("minify"))(/* @__PURE__ */ help("Minify the bundle")));
var migrateConfig = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("migrate"))(/* @__PURE__ */ help("Migrate the spago.yaml file to the latest format")));
var maybeSetVersion = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("package-set"))(/* @__PURE__ */ help("Optional package set version to be used instead of the latest one"))));
var maybePackageName = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("name"))(/* @__PURE__ */ help("Optional package name to be used for the new project"))));
var latest = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("latest"))(/* @__PURE__ */ help("Only include the latest package set for each compiler")));
var jsonErrors = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("json-errors"))(/* @__PURE__ */ help("Output compiler warnings/errors as JSON")));
var json2 = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("json"))(/* @__PURE__ */ help("Format the output as JSON")));
var forceBundle = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("force"))(/* @__PURE__ */ help("Overwrite the target bundle file even if it was manually created or generated by a tool other than Spago.")));
var flagMaybe = function(a) {
  return function(mod8) {
    return flag(Nothing.value)(new Just(a))(mod8);
  };
};
var statVerbosity = /* @__PURE__ */ function() {
  return alt(parserAlt)(flagMaybe(VerboseStats.value)(append24($$long3("verbose-stats"))(help("Show counts for each warning type"))))(flagMaybe(NoStats.value)(append24($$long3("censor-stats"))(help("Censor warning/error summary"))));
}();
var strict = /* @__PURE__ */ flagMaybe(true)(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("strict"))(/* @__PURE__ */ help("Promotes project sources' warnings to errors")));
var execArgs = /* @__PURE__ */ map57(function(s) {
  var $15 = $$null5(s);
  if ($15) {
    return Nothing.value;
  }
  ;
  return new Just(fromFoldable25(s));
})(/* @__PURE__ */ many3(/* @__PURE__ */ strArgument(/* @__PURE__ */ append24(/* @__PURE__ */ help("Arguments to pass to the running script"))(/* @__PURE__ */ metavar12("ARGS")))));
var entrypoint = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("module"))(/* @__PURE__ */ help("The module to bundle as the entrypoint"))));
var ensureRanges = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("ensure-ranges"))(/* @__PURE__ */ help("Add version bounds for all the dependencies of the selected project")));
var dot = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("dot"))(/* @__PURE__ */ help("Format the output as a DOT (GraphViz) graph")));
var depsOnly = /* @__PURE__ */ $$switch(/* @__PURE__ */ append24(/* @__PURE__ */ $$long3("deps-only"))(/* @__PURE__ */ help("Build depedencies only")));
var bundlerArgs = /* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("bundler-args"))(/* @__PURE__ */ append24(/* @__PURE__ */ help("Arguments to pass to bundler (esbuild)"))(/* @__PURE__ */ metavar3("ARGS")))));
var bundleType = /* @__PURE__ */ optional5(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("bundle-type"))(/* @__PURE__ */ help("The type of the module produced. 'app' will call main, 'module' will just export the contents."))));
var backendArgs = /* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append24(/* @__PURE__ */ long12("backend-args"))(/* @__PURE__ */ append24(/* @__PURE__ */ help("Arguments to pass to the running script"))(/* @__PURE__ */ metavar3("ARGS")))));

// output/Spago.Config/foreign.js
var import_yaml2 = __toESM(require_dist(), 1);
var getOrElse = (node, key, fallback) => {
  if (!node.has(key)) {
    node.set(key, fallback);
  }
  return node.get(key);
};
function addPackagesToConfigImpl(doc, isTest, newPkgs) {
  const pkg = doc.get("package");
  const deps = (() => {
    if (isTest) {
      const test2 = getOrElse(pkg, "test", doc.createNode({ main: "Test.Main", dependencies: [] }));
      return getOrElse(test2, "dependencies", doc.createNode([]));
    } else {
      return getOrElse(pkg, "dependencies", doc.createNode([]));
    }
  })();
  deps.flow = false;
  let depsSet = new Set(deps.toJSON());
  for (const pkg2 of newPkgs) {
    depsSet.add(pkg2);
  }
  let newItems = [];
  for (const el of deps.items) {
    if (import_yaml2.default.isScalar(el) && depsSet.has(el.value)) {
      depsSet.delete(el.value);
      newItems.push(el);
    }
    if (import_yaml2.default.isMap(el) && depsSet.has(el.items[0].key)) {
      depsSet.delete(el.value);
      newItems.push(el);
    }
  }
  for (const newPkg of depsSet) {
    newItems.push(doc.createNode(newPkg));
  }
  newItems.sort();
  deps.items = newItems;
}
function removePackagesFromConfigImpl(doc, isTest, shouldRemove) {
  const pkg = doc.get("package");
  const deps = isTest ? pkg.get("test").get("dependencies") : pkg.get("dependencies");
  let newItems = [];
  for (const el of deps.items) {
    if (import_yaml2.default.isScalar(el) && shouldRemove(el.value) || import_yaml2.default.isMap(el) && shouldRemove(el.items[0].key)) {
      continue;
    }
    newItems.push(el);
  }
  newItems.sort();
  deps.items = newItems;
}
function addRangesToConfigImpl(doc, rangesMap) {
  const deps = doc.get("package").get("dependencies");
  let newItems = [];
  for (const el of deps.items) {
    if (import_yaml2.default.isMap(el)) {
      newItems.push(el);
    }
    if (import_yaml2.default.isScalar(el)) {
      let newEl = /* @__PURE__ */ new Map();
      newEl.set(el.value, rangesMap[el.value]);
      newItems.push(doc.createNode(newEl));
    }
  }
  newItems.sort();
  deps.items = newItems;
}
function setPackageSetVersionInConfigImpl(doc, version4) {
  doc.setIn(["workspace", "packageSet", "registry"], version4);
}
function migrateV1ConfigImpl(doc) {
  let hasChanged = false;
  import_yaml2.default.visit(doc, {
    Pair(_idx, pair, _path2) {
      if (pair.key && import_yaml2.default.isScalar(pair.key)) {
        pair.key.value = pair.key.value.replaceAll(/_./g, function(match5) {
          hasChanged = true;
          return match5.charAt(1).toUpperCase();
        });
      }
    }
  });
  if (hasChanged) {
    return doc;
  }
}

// output/Affjax/foreign.js
function _ajax(platformSpecificDriver, timeoutErrorMessageIdent, requestFailedMessageIdent, mkHeader, options) {
  return function(errback, callback) {
    var xhr = platformSpecificDriver.newXHR();
    var fixedUrl = platformSpecificDriver.fixupUrl(options.url, xhr);
    xhr.open(options.method || "GET", fixedUrl, true, options.username, options.password);
    if (options.headers) {
      try {
        for (var i = 0, header; (header = options.headers[i]) != null; i++) {
          xhr.setRequestHeader(header.field, header.value);
        }
      } catch (e) {
        errback(e);
      }
    }
    var onerror = function(msgIdent) {
      return function() {
        errback(new Error(msgIdent));
      };
    };
    xhr.onerror = onerror(requestFailedMessageIdent);
    xhr.ontimeout = onerror(timeoutErrorMessageIdent);
    xhr.onload = function() {
      callback({
        status: xhr.status,
        statusText: xhr.statusText,
        headers: xhr.getAllResponseHeaders().split("\r\n").filter(function(header2) {
          return header2.length > 0;
        }).map(function(header2) {
          var i2 = header2.indexOf(":");
          return mkHeader(header2.substring(0, i2))(header2.substring(i2 + 2));
        }),
        body: xhr.response
      });
    };
    xhr.responseType = options.responseType;
    xhr.withCredentials = options.withCredentials;
    xhr.timeout = options.timeout;
    xhr.send(options.content);
    return function(error5, cancelErrback, cancelCallback) {
      try {
        xhr.abort();
      } catch (e) {
        return cancelErrback(e);
      }
      return cancelCallback();
    };
  };
}

// output/Data.MediaType.Common/index.js
var applicationJSON = "application/json";
var applicationFormURLEncoded = "application/x-www-form-urlencoded";

// output/Affjax.RequestBody/index.js
var ArrayView = /* @__PURE__ */ function() {
  function ArrayView2(value0) {
    this.value0 = value0;
  }
  ;
  ArrayView2.create = function(value0) {
    return new ArrayView2(value0);
  };
  return ArrayView2;
}();
var Blob = /* @__PURE__ */ function() {
  function Blob3(value0) {
    this.value0 = value0;
  }
  ;
  Blob3.create = function(value0) {
    return new Blob3(value0);
  };
  return Blob3;
}();
var Document = /* @__PURE__ */ function() {
  function Document3(value0) {
    this.value0 = value0;
  }
  ;
  Document3.create = function(value0) {
    return new Document3(value0);
  };
  return Document3;
}();
var $$String = /* @__PURE__ */ function() {
  function $$String3(value0) {
    this.value0 = value0;
  }
  ;
  $$String3.create = function(value0) {
    return new $$String3(value0);
  };
  return $$String3;
}();
var FormData = /* @__PURE__ */ function() {
  function FormData2(value0) {
    this.value0 = value0;
  }
  ;
  FormData2.create = function(value0) {
    return new FormData2(value0);
  };
  return FormData2;
}();
var FormURLEncoded = /* @__PURE__ */ function() {
  function FormURLEncoded2(value0) {
    this.value0 = value0;
  }
  ;
  FormURLEncoded2.create = function(value0) {
    return new FormURLEncoded2(value0);
  };
  return FormURLEncoded2;
}();
var Json = /* @__PURE__ */ function() {
  function Json3(value0) {
    this.value0 = value0;
  }
  ;
  Json3.create = function(value0) {
    return new Json3(value0);
  };
  return Json3;
}();
var toMediaType = function(v) {
  if (v instanceof FormURLEncoded) {
    return new Just(applicationFormURLEncoded);
  }
  ;
  if (v instanceof Json) {
    return new Just(applicationJSON);
  }
  ;
  return Nothing.value;
};
var json3 = /* @__PURE__ */ function() {
  return Json.create;
}();

// output/Affjax.RequestHeader/index.js
var unwrap12 = /* @__PURE__ */ unwrap();
var Accept = /* @__PURE__ */ function() {
  function Accept2(value0) {
    this.value0 = value0;
  }
  ;
  Accept2.create = function(value0) {
    return new Accept2(value0);
  };
  return Accept2;
}();
var ContentType = /* @__PURE__ */ function() {
  function ContentType2(value0) {
    this.value0 = value0;
  }
  ;
  ContentType2.create = function(value0) {
    return new ContentType2(value0);
  };
  return ContentType2;
}();
var RequestHeader = /* @__PURE__ */ function() {
  function RequestHeader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RequestHeader2.create = function(value0) {
    return function(value12) {
      return new RequestHeader2(value0, value12);
    };
  };
  return RequestHeader2;
}();
var value3 = function(v) {
  if (v instanceof Accept) {
    return unwrap12(v.value0);
  }
  ;
  if (v instanceof ContentType) {
    return unwrap12(v.value0);
  }
  ;
  if (v instanceof RequestHeader) {
    return v.value1;
  }
  ;
  throw new Error("Failed pattern match at Affjax.RequestHeader (line 26, column 1 - line 26, column 33): " + [v.constructor.name]);
};
var name3 = function(v) {
  if (v instanceof Accept) {
    return "Accept";
  }
  ;
  if (v instanceof ContentType) {
    return "Content-Type";
  }
  ;
  if (v instanceof RequestHeader) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Affjax.RequestHeader (line 21, column 1 - line 21, column 32): " + [v.constructor.name]);
};

// output/Affjax.ResponseFormat/index.js
var identity24 = /* @__PURE__ */ identity(categoryFn);
var $$ArrayBuffer = /* @__PURE__ */ function() {
  function $$ArrayBuffer2(value0) {
    this.value0 = value0;
  }
  ;
  $$ArrayBuffer2.create = function(value0) {
    return new $$ArrayBuffer2(value0);
  };
  return $$ArrayBuffer2;
}();
var Blob2 = /* @__PURE__ */ function() {
  function Blob3(value0) {
    this.value0 = value0;
  }
  ;
  Blob3.create = function(value0) {
    return new Blob3(value0);
  };
  return Blob3;
}();
var Document2 = /* @__PURE__ */ function() {
  function Document3(value0) {
    this.value0 = value0;
  }
  ;
  Document3.create = function(value0) {
    return new Document3(value0);
  };
  return Document3;
}();
var Json2 = /* @__PURE__ */ function() {
  function Json3(value0) {
    this.value0 = value0;
  }
  ;
  Json3.create = function(value0) {
    return new Json3(value0);
  };
  return Json3;
}();
var $$String2 = /* @__PURE__ */ function() {
  function $$String3(value0) {
    this.value0 = value0;
  }
  ;
  $$String3.create = function(value0) {
    return new $$String3(value0);
  };
  return $$String3;
}();
var Ignore = /* @__PURE__ */ function() {
  function Ignore4(value0) {
    this.value0 = value0;
  }
  ;
  Ignore4.create = function(value0) {
    return new Ignore4(value0);
  };
  return Ignore4;
}();
var toResponseType = function(v) {
  if (v instanceof $$ArrayBuffer) {
    return "arraybuffer";
  }
  ;
  if (v instanceof Blob2) {
    return "blob";
  }
  ;
  if (v instanceof Document2) {
    return "document";
  }
  ;
  if (v instanceof Json2) {
    return "text";
  }
  ;
  if (v instanceof $$String2) {
    return "text";
  }
  ;
  if (v instanceof Ignore) {
    return "";
  }
  ;
  throw new Error("Failed pattern match at Affjax.ResponseFormat (line 44, column 3 - line 50, column 19): " + [v.constructor.name]);
};
var toMediaType2 = function(v) {
  if (v instanceof Json2) {
    return new Just(applicationJSON);
  }
  ;
  return Nothing.value;
};
var string4 = /* @__PURE__ */ function() {
  return new $$String2(identity24);
}();
var ignore = /* @__PURE__ */ function() {
  return new Ignore(identity24);
}();
var arrayBuffer = /* @__PURE__ */ function() {
  return new $$ArrayBuffer(identity24);
}();

// output/Affjax.ResponseHeader/index.js
var ResponseHeader = /* @__PURE__ */ function() {
  function ResponseHeader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ResponseHeader2.create = function(value0) {
    return function(value12) {
      return new ResponseHeader2(value0, value12);
    };
  };
  return ResponseHeader2;
}();

// output/Data.Argonaut.Core/foreign.js
function id(x) {
  return x;
}
var jsonNull = null;
function stringify2(j) {
  return JSON.stringify(j);
}
function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {
  if (j == null)
    return isNull3();
  else if (typeof j === "boolean")
    return isBool(j);
  else if (typeof j === "number")
    return isNum(j);
  else if (typeof j === "string")
    return isStr(j);
  else if (Object.prototype.toString.call(j) === "[object Array]")
    return isArr(j);
  else
    return isObj(j);
}

// output/Data.Argonaut.Core/index.js
var jsonEmptyObject = /* @__PURE__ */ id(empty6);
var caseJson = function(a) {
  return function(b) {
    return function(c) {
      return function(d) {
        return function(e) {
          return function(f) {
            return function(json4) {
              return _caseJson(a, b, c, d, e, f, json4);
            };
          };
        };
      };
    };
  };
};

// output/Data.Argonaut.Parser/foreign.js
function _jsonParser(fail7, succ2, s) {
  try {
    return succ2(JSON.parse(s));
  } catch (e) {
    return fail7(e.message);
  }
}

// output/Data.Argonaut.Parser/index.js
var jsonParser = function(j) {
  return _jsonParser(Left.create, Right.create, j);
};

// output/JSURI/foreign.js
function encodeURIComponent_to_RFC3986(input) {
  return input.replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16);
  });
}
function _encodeURIComponent(fail7, succeed, input) {
  try {
    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)));
  } catch (err) {
    return fail7(err);
  }
}
function _encodeFormURLComponent(fail7, succeed, input) {
  try {
    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)).replace(/%20/g, "+"));
  } catch (err) {
    return fail7(err);
  }
}

// output/JSURI/index.js
var $$encodeURIComponent = /* @__PURE__ */ function() {
  return runFn3(_encodeURIComponent)($$const(Nothing.value))(Just.create);
}();
var encodeFormURLComponent = /* @__PURE__ */ function() {
  return runFn3(_encodeFormURLComponent)($$const(Nothing.value))(Just.create);
}();

// output/Data.FormURLEncoded/index.js
var apply17 = /* @__PURE__ */ apply2(applyMaybe);
var map58 = /* @__PURE__ */ map(functorMaybe);
var traverse4 = /* @__PURE__ */ traverse(traversableArray)(applicativeMaybe);
var toArray4 = function(v) {
  return v;
};
var encode3 = /* @__PURE__ */ function() {
  var encodePart = function(v) {
    if (v.value1 instanceof Nothing) {
      return encodeFormURLComponent(v.value0);
    }
    ;
    if (v.value1 instanceof Just) {
      return apply17(map58(function(key) {
        return function(val) {
          return key + ("=" + val);
        };
      })(encodeFormURLComponent(v.value0)))(encodeFormURLComponent(v.value1.value0));
    }
    ;
    throw new Error("Failed pattern match at Data.FormURLEncoded (line 37, column 16 - line 39, column 114): " + [v.constructor.name]);
  };
  var $37 = map58(joinWith("&"));
  var $38 = traverse4(encodePart);
  return function($39) {
    return $37($38(toArray4($39)));
  };
}();

// output/Data.HTTP.Method/index.js
var OPTIONS = /* @__PURE__ */ function() {
  function OPTIONS2() {
  }
  ;
  OPTIONS2.value = new OPTIONS2();
  return OPTIONS2;
}();
var GET = /* @__PURE__ */ function() {
  function GET2() {
  }
  ;
  GET2.value = new GET2();
  return GET2;
}();
var HEAD = /* @__PURE__ */ function() {
  function HEAD2() {
  }
  ;
  HEAD2.value = new HEAD2();
  return HEAD2;
}();
var POST = /* @__PURE__ */ function() {
  function POST2() {
  }
  ;
  POST2.value = new POST2();
  return POST2;
}();
var PUT = /* @__PURE__ */ function() {
  function PUT2() {
  }
  ;
  PUT2.value = new PUT2();
  return PUT2;
}();
var DELETE = /* @__PURE__ */ function() {
  function DELETE2() {
  }
  ;
  DELETE2.value = new DELETE2();
  return DELETE2;
}();
var TRACE = /* @__PURE__ */ function() {
  function TRACE2() {
  }
  ;
  TRACE2.value = new TRACE2();
  return TRACE2;
}();
var CONNECT = /* @__PURE__ */ function() {
  function CONNECT2() {
  }
  ;
  CONNECT2.value = new CONNECT2();
  return CONNECT2;
}();
var PROPFIND = /* @__PURE__ */ function() {
  function PROPFIND2() {
  }
  ;
  PROPFIND2.value = new PROPFIND2();
  return PROPFIND2;
}();
var PROPPATCH = /* @__PURE__ */ function() {
  function PROPPATCH2() {
  }
  ;
  PROPPATCH2.value = new PROPPATCH2();
  return PROPPATCH2;
}();
var MKCOL = /* @__PURE__ */ function() {
  function MKCOL2() {
  }
  ;
  MKCOL2.value = new MKCOL2();
  return MKCOL2;
}();
var COPY = /* @__PURE__ */ function() {
  function COPY2() {
  }
  ;
  COPY2.value = new COPY2();
  return COPY2;
}();
var MOVE = /* @__PURE__ */ function() {
  function MOVE2() {
  }
  ;
  MOVE2.value = new MOVE2();
  return MOVE2;
}();
var LOCK = /* @__PURE__ */ function() {
  function LOCK2() {
  }
  ;
  LOCK2.value = new LOCK2();
  return LOCK2;
}();
var UNLOCK = /* @__PURE__ */ function() {
  function UNLOCK2() {
  }
  ;
  UNLOCK2.value = new UNLOCK2();
  return UNLOCK2;
}();
var PATCH = /* @__PURE__ */ function() {
  function PATCH2() {
  }
  ;
  PATCH2.value = new PATCH2();
  return PATCH2;
}();
var unCustomMethod = function(v) {
  return v;
};
var showMethod = {
  show: function(v) {
    if (v instanceof OPTIONS) {
      return "OPTIONS";
    }
    ;
    if (v instanceof GET) {
      return "GET";
    }
    ;
    if (v instanceof HEAD) {
      return "HEAD";
    }
    ;
    if (v instanceof POST) {
      return "POST";
    }
    ;
    if (v instanceof PUT) {
      return "PUT";
    }
    ;
    if (v instanceof DELETE) {
      return "DELETE";
    }
    ;
    if (v instanceof TRACE) {
      return "TRACE";
    }
    ;
    if (v instanceof CONNECT) {
      return "CONNECT";
    }
    ;
    if (v instanceof PROPFIND) {
      return "PROPFIND";
    }
    ;
    if (v instanceof PROPPATCH) {
      return "PROPPATCH";
    }
    ;
    if (v instanceof MKCOL) {
      return "MKCOL";
    }
    ;
    if (v instanceof COPY) {
      return "COPY";
    }
    ;
    if (v instanceof MOVE) {
      return "MOVE";
    }
    ;
    if (v instanceof LOCK) {
      return "LOCK";
    }
    ;
    if (v instanceof UNLOCK) {
      return "UNLOCK";
    }
    ;
    if (v instanceof PATCH) {
      return "PATCH";
    }
    ;
    throw new Error("Failed pattern match at Data.HTTP.Method (line 43, column 1 - line 59, column 23): " + [v.constructor.name]);
  }
};
var print10 = /* @__PURE__ */ either(/* @__PURE__ */ show(showMethod))(unCustomMethod);

// output/Effect.Aff.Compat/index.js
var fromEffectFnAff = function(v) {
  return makeAff(function(k) {
    return function __do3() {
      var v1 = v(function($9) {
        return k(Left.create($9))();
      }, function($10) {
        return k(Right.create($10))();
      });
      return function(e) {
        return makeAff(function(k2) {
          return function __do4() {
            v1(e, function($11) {
              return k2(Left.create($11))();
            }, function($12) {
              return k2(Right.create($12))();
            });
            return nonCanceler;
          };
        });
      };
    };
  });
};

// output/Foreign/foreign.js
function tagOf(value4) {
  return Object.prototype.toString.call(value4).slice(8, -1);
}
var isArray = Array.isArray || function(value4) {
  return Object.prototype.toString.call(value4) === "[object Array]";
};

// output/Foreign/index.js
var show20 = /* @__PURE__ */ show(showString);
var show110 = /* @__PURE__ */ show(showInt);
var ForeignError = /* @__PURE__ */ function() {
  function ForeignError2(value0) {
    this.value0 = value0;
  }
  ;
  ForeignError2.create = function(value0) {
    return new ForeignError2(value0);
  };
  return ForeignError2;
}();
var TypeMismatch = /* @__PURE__ */ function() {
  function TypeMismatch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeMismatch2.create = function(value0) {
    return function(value12) {
      return new TypeMismatch2(value0, value12);
    };
  };
  return TypeMismatch2;
}();
var ErrorAtIndex = /* @__PURE__ */ function() {
  function ErrorAtIndex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ErrorAtIndex2.create = function(value0) {
    return function(value12) {
      return new ErrorAtIndex2(value0, value12);
    };
  };
  return ErrorAtIndex2;
}();
var ErrorAtProperty = /* @__PURE__ */ function() {
  function ErrorAtProperty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ErrorAtProperty2.create = function(value0) {
    return function(value12) {
      return new ErrorAtProperty2(value0, value12);
    };
  };
  return ErrorAtProperty2;
}();
var unsafeToForeign = unsafeCoerce2;
var unsafeFromForeign = unsafeCoerce2;
var renderForeignError = function(v) {
  if (v instanceof ForeignError) {
    return v.value0;
  }
  ;
  if (v instanceof ErrorAtIndex) {
    return "Error at array index " + (show110(v.value0) + (": " + renderForeignError(v.value1)));
  }
  ;
  if (v instanceof ErrorAtProperty) {
    return "Error at property " + (show20(v.value0) + (": " + renderForeignError(v.value1)));
  }
  ;
  if (v instanceof TypeMismatch) {
    return "Type mismatch: expected " + (v.value0 + (", found " + v.value1));
  }
  ;
  throw new Error("Failed pattern match at Foreign (line 78, column 1 - line 78, column 45): " + [v.constructor.name]);
};
var fail3 = function(dictMonad) {
  var $153 = throwError(monadThrowExceptT(dictMonad));
  return function($154) {
    return $153(singleton9($154));
  };
};
var unsafeReadTagged = function(dictMonad) {
  var pure129 = pure(applicativeExceptT(dictMonad));
  var fail1 = fail3(dictMonad);
  return function(tag) {
    return function(value4) {
      if (tagOf(value4) === tag) {
        return pure129(unsafeFromForeign(value4));
      }
      ;
      if (otherwise) {
        return fail1(new TypeMismatch(tag, tagOf(value4)));
      }
      ;
      throw new Error("Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): " + [tag.constructor.name, value4.constructor.name]);
    };
  };
};
var readString2 = function(dictMonad) {
  return unsafeReadTagged(dictMonad)("String");
};

// output/Affjax/index.js
var pure42 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
var fail4 = /* @__PURE__ */ fail3(monadIdentity);
var unsafeReadTagged2 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
var alt17 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var composeKleisliFlipped3 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));
var map59 = /* @__PURE__ */ map(functorMaybe);
var any6 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var eq10 = /* @__PURE__ */ eq(eqString);
var bindFlipped7 = /* @__PURE__ */ bindFlipped(bindMaybe);
var map121 = /* @__PURE__ */ map(functorArray);
var mapFlipped7 = /* @__PURE__ */ mapFlipped(functorAff);
var $$try5 = /* @__PURE__ */ $$try2(monadErrorAff);
var pure115 = /* @__PURE__ */ pure(applicativeAff);
var RequestContentError = /* @__PURE__ */ function() {
  function RequestContentError2(value0) {
    this.value0 = value0;
  }
  ;
  RequestContentError2.create = function(value0) {
    return new RequestContentError2(value0);
  };
  return RequestContentError2;
}();
var ResponseBodyError = /* @__PURE__ */ function() {
  function ResponseBodyError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ResponseBodyError2.create = function(value0) {
    return function(value12) {
      return new ResponseBodyError2(value0, value12);
    };
  };
  return ResponseBodyError2;
}();
var TimeoutError = /* @__PURE__ */ function() {
  function TimeoutError2() {
  }
  ;
  TimeoutError2.value = new TimeoutError2();
  return TimeoutError2;
}();
var RequestFailedError = /* @__PURE__ */ function() {
  function RequestFailedError2() {
  }
  ;
  RequestFailedError2.value = new RequestFailedError2();
  return RequestFailedError2;
}();
var XHROtherError = /* @__PURE__ */ function() {
  function XHROtherError2(value0) {
    this.value0 = value0;
  }
  ;
  XHROtherError2.create = function(value0) {
    return new XHROtherError2(value0);
  };
  return XHROtherError2;
}();
var request = function(driver2) {
  return function(req) {
    var parseJSON = function(v2) {
      if (v2 === "") {
        return pure42(jsonEmptyObject);
      }
      ;
      return either(function($74) {
        return fail4(ForeignError.create($74));
      })(pure42)(jsonParser(v2));
    };
    var fromResponse = function() {
      if (req.responseFormat instanceof $$ArrayBuffer) {
        return unsafeReadTagged2("ArrayBuffer");
      }
      ;
      if (req.responseFormat instanceof Blob2) {
        return unsafeReadTagged2("Blob");
      }
      ;
      if (req.responseFormat instanceof Document2) {
        return function(x) {
          return alt17(unsafeReadTagged2("Document")(x))(alt17(unsafeReadTagged2("XMLDocument")(x))(unsafeReadTagged2("HTMLDocument")(x)));
        };
      }
      ;
      if (req.responseFormat instanceof Json2) {
        return composeKleisliFlipped3(function($75) {
          return req.responseFormat.value0(parseJSON($75));
        })(unsafeReadTagged2("String"));
      }
      ;
      if (req.responseFormat instanceof $$String2) {
        return unsafeReadTagged2("String");
      }
      ;
      if (req.responseFormat instanceof Ignore) {
        return $$const(req.responseFormat.value0(pure42(unit)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 274, column 18 - line 283, column 57): " + [req.responseFormat.constructor.name]);
    }();
    var extractContent = function(v2) {
      if (v2 instanceof ArrayView) {
        return new Right(v2.value0(unsafeToForeign));
      }
      ;
      if (v2 instanceof Blob) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof Document) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof $$String) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof FormData) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof FormURLEncoded) {
        return note("Body contains values that cannot be encoded as application/x-www-form-urlencoded")(map59(unsafeToForeign)(encode3(v2.value0)));
      }
      ;
      if (v2 instanceof Json) {
        return new Right(unsafeToForeign(stringify2(v2.value0)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 235, column 20 - line 250, column 69): " + [v2.constructor.name]);
    };
    var addHeader = function(mh) {
      return function(hs) {
        if (mh instanceof Just && !any6(on(eq10)(name3)(mh.value0))(hs)) {
          return snoc(hs)(mh.value0);
        }
        ;
        return hs;
      };
    };
    var headers = function(reqContent) {
      return addHeader(map59(ContentType.create)(bindFlipped7(toMediaType)(reqContent)))(addHeader(map59(Accept.create)(toMediaType2(req.responseFormat)))(req.headers));
    };
    var ajaxRequest = function(v2) {
      return {
        method: print10(req.method),
        url: req.url,
        headers: map121(function(h) {
          return {
            field: name3(h),
            value: value3(h)
          };
        })(headers(req.content)),
        content: v2,
        responseType: toResponseType(req.responseFormat),
        username: toNullable(req.username),
        password: toNullable(req.password),
        withCredentials: req.withCredentials,
        timeout: fromMaybe(0)(map59(function(v1) {
          return v1;
        })(req.timeout))
      };
    };
    var send = function(content) {
      return mapFlipped7($$try5(fromEffectFnAff(_ajax(driver2, "AffjaxTimeoutErrorMessageIdent", "AffjaxRequestFailedMessageIdent", ResponseHeader.create, ajaxRequest(content)))))(function(v2) {
        if (v2 instanceof Right) {
          var v1 = runExcept(fromResponse(v2.value0.body));
          if (v1 instanceof Left) {
            return new Left(new ResponseBodyError(head4(v1.value0), v2.value0));
          }
          ;
          if (v1 instanceof Right) {
            return new Right({
              headers: v2.value0.headers,
              status: v2.value0.status,
              statusText: v2.value0.statusText,
              body: v1.value0
            });
          }
          ;
          throw new Error("Failed pattern match at Affjax (line 209, column 9 - line 211, column 52): " + [v1.constructor.name]);
        }
        ;
        if (v2 instanceof Left) {
          return new Left(function() {
            var message3 = message(v2.value0);
            var $61 = message3 === "AffjaxTimeoutErrorMessageIdent";
            if ($61) {
              return TimeoutError.value;
            }
            ;
            var $62 = message3 === "AffjaxRequestFailedMessageIdent";
            if ($62) {
              return RequestFailedError.value;
            }
            ;
            return new XHROtherError(v2.value0);
          }());
        }
        ;
        throw new Error("Failed pattern match at Affjax (line 207, column 144 - line 219, column 28): " + [v2.constructor.name]);
      });
    };
    if (req.content instanceof Nothing) {
      return send(toNullable(Nothing.value));
    }
    ;
    if (req.content instanceof Just) {
      var v = extractContent(req.content.value0);
      if (v instanceof Right) {
        return send(toNullable(new Just(v.value0)));
      }
      ;
      if (v instanceof Left) {
        return pure115(new Left(new RequestContentError(v.value0)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 199, column 7 - line 203, column 48): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Affjax (line 195, column 3 - line 203, column 48): " + [req.content.constructor.name]);
  };
};
var printError2 = function(v) {
  if (v instanceof RequestContentError) {
    return "There was a problem with the request content: " + v.value0;
  }
  ;
  if (v instanceof ResponseBodyError) {
    return "There was a problem with the response body: " + renderForeignError(v.value0);
  }
  ;
  if (v instanceof TimeoutError) {
    return "There was a problem making the request: timeout";
  }
  ;
  if (v instanceof RequestFailedError) {
    return "There was a problem making the request: request failed";
  }
  ;
  if (v instanceof XHROtherError) {
    return "There was a problem making the request: " + message(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Affjax (line 113, column 14 - line 123, column 66): " + [v.constructor.name]);
};
var defaultRequest = /* @__PURE__ */ function() {
  return {
    method: new Left(GET.value),
    url: "/",
    headers: [],
    content: Nothing.value,
    username: Nothing.value,
    password: Nothing.value,
    withCredentials: false,
    responseFormat: ignore,
    timeout: Nothing.value
  };
}();
var get4 = function(driver2) {
  return function(rf) {
    return function(u) {
      return request(driver2)({
        method: defaultRequest.method,
        headers: defaultRequest.headers,
        content: defaultRequest.content,
        username: defaultRequest.username,
        password: defaultRequest.password,
        withCredentials: defaultRequest.withCredentials,
        timeout: defaultRequest.timeout,
        url: u,
        responseFormat: rf
      });
    };
  };
};
var post = function(driver2) {
  return function(rf) {
    return function(u) {
      return function(c) {
        return request(driver2)({
          headers: defaultRequest.headers,
          username: defaultRequest.username,
          password: defaultRequest.password,
          withCredentials: defaultRequest.withCredentials,
          timeout: defaultRequest.timeout,
          method: new Left(POST.value),
          url: u,
          content: c,
          responseFormat: rf
        });
      };
    };
  };
};

// output/Affjax.Node/foreign.js
var import_xhr2 = __toESM(require_xhr2(), 1);
import urllib from "url";
var driver = {
  newXHR: function() {
    return new import_xhr2.default();
  },
  fixupUrl: function(url2, xhr) {
    if (xhr.nodejsBaseUrl === null) {
      var u = urllib.parse(url2);
      u.protocol = u.protocol || "http:";
      u.hostname = u.hostname || "localhost";
      return urllib.format(u);
    } else {
      return url2 || "/";
    }
  }
};

// output/Affjax.Node/index.js
var request2 = /* @__PURE__ */ request(driver);
var post2 = /* @__PURE__ */ post(driver);
var get5 = /* @__PURE__ */ get4(driver);

// output/Affjax.StatusCode/index.js
var show21 = /* @__PURE__ */ show(showInt);
var showStatusCode = {
  show: function(v) {
    return "(StatusCode " + (show21(v) + ")");
  }
};
var eqStatusCode = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};

// output/Spago.FS/foreign.js
var import_fs_extra = __toESM(require_lib(), 1);
var { moveSync, ensureFileSync } = import_fs_extra.default;
var moveSyncImpl = (source2) => (destination) => () => moveSync(source2, destination);
var cpImpl = (source2) => (dest) => () => import_fs_extra.default.copySync(source2, dest);

// output/Node.FS.Stats/foreign.js
var isDirectoryImpl = (s) => s.isDirectory();
var isFileImpl = (s) => s.isFile();
var isSymbolicLinkImpl = (s) => s.isSymbolicLink();
var modeImpl = (s) => s.mode;
var uidImpl = (s) => s.uid;
var gidImpl = (s) => s.gid;

// output/Node.FS.Stats/index.js
var uid = function(s) {
  return uidImpl(s);
};
var mode = function(s) {
  return modeImpl(s);
};
var isSymbolicLink = function(s) {
  return isSymbolicLinkImpl(s);
};
var isFile = function(s) {
  return isFileImpl(s);
};
var isDirectory = function(s) {
  return isDirectoryImpl(s);
};
var gid = function(s) {
  return gidImpl(s);
};

// output/Spago.FS/index.js
var bind32 = /* @__PURE__ */ bind(bindAff);
var pure43 = /* @__PURE__ */ pure(applicativeAff);
var bind114 = /* @__PURE__ */ bind(bindEither);
var lmap13 = /* @__PURE__ */ lmap(bifunctorEither);
var writeYamlFile = function(codec12) {
  return function(path14) {
    var $66 = writeTextFile2(UTF8.value)(path14);
    var $67 = printYaml(codec12);
    return function($68) {
      return $66(function(v) {
        return v + "\n";
      }(trim($67($68))));
    };
  };
};
var writeYamlDocFile = function(path14) {
  var $69 = writeTextFile2(UTF8.value)(path14);
  return function($70) {
    return $69(function(v) {
      return v + "\n";
    }(trim(toString7($70))));
  };
};
var writeTextFile3 = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(path14) {
    return function(text3) {
      return liftAff13(writeTextFile2(UTF8.value)(path14)(text3));
    };
  };
};
var writeFile4 = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(path14) {
    return function(buf) {
      return liftAff13(writeFile3(path14)(buf));
    };
  };
};
var readYamlFile = function(codec12) {
  return function(path14) {
    return bind32(attempt(readTextFile2(UTF8.value)(path14)))(function(result) {
      return pure43(bind114(lmap13(message)(result))(function() {
        var $76 = lmap13(print3);
        var $77 = parseYaml(codec12);
        return function($78) {
          return $76($77($78));
        };
      }()));
    });
  };
};
var readTextFile4 = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(path14) {
    return liftAff13(readTextFile2(UTF8.value)(path14));
  };
};
var readJsonFile = function(codec12) {
  return function(path14) {
    return bind32(attempt(readTextFile2(UTF8.value)(path14)))(function(result) {
      return pure43(bind114(lmap13(message)(result))(function() {
        var $82 = lmap13(print3);
        var $83 = parseJson(codec12);
        return function($84) {
          return $82($83($84));
        };
      }()));
    });
  };
};
var moveSync2 = function(dictMonadEffect) {
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(v) {
    return liftEffect19(moveSyncImpl(v.src)(v.dst));
  };
};
var mkdirp = function(dictMonadAff) {
  var $85 = liftAff(dictMonadAff);
  var $86 = flip(mkdir$prime2)({
    recursive: true,
    mode: mkPerms(all4)(all4)(all4)
  });
  return function($87) {
    return $85($86($87));
  };
};
var ls = function(dictMonadAff) {
  var $88 = liftAff(dictMonadAff);
  return function($89) {
    return $88(readdir3($89));
  };
};
var exists2 = function(dictMonadEffect) {
  var $90 = liftEffect(dictMonadEffect);
  return function($91) {
    return $90(exists($91));
  };
};
var copyTree = function(dictMonadEffect) {
  var liftEffect19 = liftEffect(dictMonadEffect);
  return function(v) {
    return liftEffect19(cpImpl(v.src)(v.dst));
  };
};
var chmod4 = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(path14) {
    return function(perms) {
      return liftAff13(chmod3(path14)(perms));
    };
  };
};

// output/Spago.Glob/foreign.js
var import_micromatch = __toESM(require_micromatch(), 1);
var import_picomatch = __toESM(require_picomatch4(), 1);
var fsWalk = __toESM(require_out3(), 1);
var testGlob = (glob3) => import_micromatch.default.matcher(glob3.include, { ignore: glob3.ignore });
var fsWalkImpl = (Left2) => (Right2) => (respond) => (options) => (path14) => () => {
  const entryFilter = (entry) => options.entryFilter(entry)();
  const deepFilter = (entry) => options.deepFilter(entry)();
  fsWalk.walk(path14, { entryFilter, deepFilter }, (error5, entries3) => {
    if (error5 !== null)
      return respond(Left2(error5))();
    return respond(Right2(entries3))();
  });
};
var isFile2 = (dirent) => dirent.isFile();
var scanPattern = import_picomatch.default.scan;

// output/Spago.Glob/index.js
var map60 = /* @__PURE__ */ map(functorArray);
var eq11 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqCodePoint));
var or2 = /* @__PURE__ */ or(foldableArray)(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var partitionMap2 = /* @__PURE__ */ partitionMap(filterableArray);
var bind33 = /* @__PURE__ */ bind(bindEffect);
var $$try6 = /* @__PURE__ */ $$try2(monadErrorEffect);
var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableEither);
var any7 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
var filter7 = /* @__PURE__ */ filter6(filterableArray);
var discard10 = /* @__PURE__ */ discard(discardUnit);
var when6 = /* @__PURE__ */ when(applicativeEffect);
var map122 = /* @__PURE__ */ map(functorEffect);
var bindMaybeT2 = /* @__PURE__ */ bindMaybeT(monadEffect);
var bind115 = /* @__PURE__ */ bind(bindMaybeT2);
var lift8 = /* @__PURE__ */ lift(monadTransMaybeT)(monadEffect);
var discard22 = /* @__PURE__ */ discard10(bindMaybeT2);
var guard6 = /* @__PURE__ */ guard(/* @__PURE__ */ alternativeMaybeT(monadEffect));
var pure116 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeMaybeT(monadEffect));
var $$void12 = /* @__PURE__ */ $$void(functorAff);
var liftEffect5 = /* @__PURE__ */ liftEffect(monadEffectAff);
var map217 = /* @__PURE__ */ map(functorAff);
var splitGlob = function(v) {
  return map60(function(a) {
    return {
      ignore: v.ignore,
      include: [a]
    };
  })(v.include);
};
var gitignoreFileToGlob = function(base) {
  var trailingSlash = function(str2) {
    return eq11(codePointAt(length5(str2) - 1 | 0)(str2))(new Just(codePointFromChar("/")));
  };
  var leadingSlash = function(str2) {
    return eq11(codePointAt(0)(str2))(new Just(codePointFromChar("/")));
  };
  var isComment = isPrefix("#");
  var dropSuffixSlash = function(str2) {
    return fromMaybe(str2)(stripSuffix("/")(str2));
  };
  var dropPrefixSlash = function(str2) {
    return fromMaybe(str2)(stripPrefix2("/")(str2));
  };
  var gitignorePatternToGlobPattern = function($copy_pattern) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(pattern) {
      if (trailingSlash(pattern)) {
        $copy_pattern = dropSuffixSlash(pattern);
        return;
      }
      ;
      if (leadingSlash(pattern)) {
        $tco_done = true;
        return dropPrefixSlash(pattern) + "/**";
      }
      ;
      if (otherwise) {
        $tco_done = true;
        return "**/" + (pattern + "/**");
      }
      ;
      throw new Error("Failed pattern match at Spago.Glob (line 86, column 3 - line 86, column 52): " + [pattern.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_pattern);
    }
    ;
    return $tco_result;
  };
  var $58 = partitionMap2(function(line2) {
    var pattern = function(lin) {
      return withForwardSlashes(concat3([base, gitignorePatternToGlobPattern(lin)]));
    };
    var v = stripPrefix2("!")(line2);
    if (v instanceof Just) {
      return new Left(pattern(v.value0));
    }
    ;
    if (v instanceof Nothing) {
      return new Right(pattern(line2));
    }
    ;
    throw new Error("Failed pattern match at Spago.Glob (line 72, column 11 - line 74, column 44): " + [v.constructor.name]);
  });
  var $59 = filter(function() {
    var $63 = or2([$$null2, isComment]);
    return function($64) {
      return !$63($64);
    };
  }());
  var $60 = map60(trim);
  var $61 = split("\n");
  return function($62) {
    return function(v) {
      return {
        ignore: v.left,
        include: v.right
      };
    }($58($59($60($61($62)))));
  };
};
var fsWalk2 = function(cwd3) {
  return function(ignorePatterns) {
    return function(includePatterns) {
      return makeAff(function(cb) {
        var includeMatcher = testGlob({
          ignore: [],
          include: includePatterns
        });
        return function __do3() {
          var v = $$new(testGlob({
            ignore: [],
            include: ignorePatterns
          }))();
          var canceled = $$new(false)();
          var updateIgnoreMatcherWithGitignore = function(entry) {
            var base = relative(cwd3)(dirname(entry.path));
            return bind33($$try6(readTextFile3(UTF8.value)(entry.path)))(traverse_2(function(gitignore) {
              var wouldConflictWithSearch = function(matcher) {
                return any7(matcher)(includePatterns);
              };
              var gitignored = map60(testGlob)(splitGlob(gitignoreFileToGlob(base)(gitignore)));
              var newMatchers = or2(filter7(function($65) {
                return !wouldConflictWithSearch($65);
              })(gitignored));
              var addMatcher = function(currentMatcher) {
                return or2([currentMatcher, newMatchers]);
              };
              return modify_(addMatcher)(v);
            }));
          };
          var includePatternBases = map60(function($66) {
            return function(v1) {
              return v1.base;
            }(scanPattern($66));
          })(includePatterns);
          var matchesAnyPatternBase = function(relDirPath) {
            var matchesPatternBase = function(v1) {
              if (v1 === "") {
                return true;
              }
              ;
              if (length5(relDirPath) < length5(v1)) {
                return isPrefix(relDirPath)(v1);
              }
              ;
              if (otherwise) {
                return isPrefix(v1)(relDirPath);
              }
              ;
              throw new Error("Failed pattern match at Spago.Glob (line 150, column 7 - line 150, column 46): " + [v1.constructor.name]);
            };
            return any7(matchesPatternBase)(includePatternBases);
          };
          var entryFilter = function(entry) {
            return function __do4() {
              when6(isFile2(entry.dirent) && entry.name === ".gitignore")(updateIgnoreMatcherWithGitignore(entry))();
              var ignoreMatcher = read(v)();
              var path14 = withForwardSlashes(relative(cwd3)(entry.path));
              return includeMatcher(path14) && !ignoreMatcher(path14);
            };
          };
          var deepFilter = function(entry) {
            return map122(fromMaybe(false))(runMaybeT(bind115(lift8(read(canceled)))(function(isCanceled) {
              return discard22(guard6(!isCanceled))(function() {
                var relPath = withForwardSlashes(relative(cwd3)(entry.path));
                return bind115(lift8(read(v)))(function(shouldIgnore) {
                  return discard22(guard6(!shouldIgnore(relPath)))(function() {
                    return pure116(matchesAnyPatternBase(relPath));
                  });
                });
              });
            })));
          };
          var options = {
            entryFilter,
            deepFilter
          };
          fsWalkImpl(Left.create)(Right.create)(cb)(options)(cwd3)();
          return function(v1) {
            return $$void12(liftEffect5(write(true)(canceled)));
          };
        };
      });
    };
  };
};
var gitignoringGlob = function(dir) {
  return function(patterns) {
    return map217(map60(function() {
      var $67 = relative(dir);
      return function($68) {
        return withForwardSlashes($67(function(v) {
          return v.path;
        }($68)));
      };
    }()))(fsWalk2(dir)([".git"])(patterns));
  };
};

// output/Spago.Lock/index.js
var recordProp3 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "dependencies";
  }
})();
var recordProp12 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "path";
  }
})();
var recordProp22 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "packages";
  }
})();
var except6 = /* @__PURE__ */ except(applicativeIdentity);
var bind34 = /* @__PURE__ */ bind(bindEither);
var pure44 = /* @__PURE__ */ pure(applicativeEither);
var typeIsSymbol = {
  reflectSymbol: function() {
    return "type";
  }
};
var insert9 = /* @__PURE__ */ insert5(typeIsSymbol)()();
var $$delete7 = /* @__PURE__ */ $$delete5(typeIsSymbol)()();
var functorExceptT5 = /* @__PURE__ */ functorExceptT(functorIdentity);
var dimap4 = /* @__PURE__ */ dimap(/* @__PURE__ */ profunctorCodec(functorExceptT5));
var recordProp32 = /* @__PURE__ */ recordProp(typeIsSymbol)();
var alt18 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var map61 = /* @__PURE__ */ map(functorExceptT5);
var FromPath = /* @__PURE__ */ function() {
  function FromPath2(value0) {
    this.value0 = value0;
  }
  ;
  FromPath2.create = function(value0) {
    return new FromPath2(value0);
  };
  return FromPath2;
}();
var FromGit = /* @__PURE__ */ function() {
  function FromGit2(value0) {
    this.value0 = value0;
  }
  ;
  FromGit2.create = function(value0) {
    return new FromGit2(value0);
  };
  return FromGit2;
}();
var FromRegistry = /* @__PURE__ */ function() {
  function FromRegistry2(value0) {
    this.value0 = value0;
  }
  ;
  FromRegistry2.create = function(value0) {
    return new FromRegistry2(value0);
  };
  return FromRegistry2;
}();
var registryLockType = "registry";
var pathLockType = "local";
var packageSetCodec = /* @__PURE__ */ function() {
  return named("PackageSetInfo")(object(recordProp({
    reflectSymbol: function() {
      return "address";
    }
  })()($$Proxy.value)(setAddressCodec)(recordProp({
    reflectSymbol: function() {
      return "compiler";
    }
  })()($$Proxy.value)(codec6)(recordProp({
    reflectSymbol: function() {
      return "content";
    }
  })()($$Proxy.value)(packageMap(remotePackageCodec))(record)))));
}();
var workspaceLockCodec = /* @__PURE__ */ function() {
  var envCodec = named("Environment")(object(recordProp3($$Proxy.value)(dependenciesCodec)(recordProp({
    reflectSymbol: function() {
      return "build_plan";
    }
  })()($$Proxy.value)(set(ordPackageName)(codec2))(record))));
  var dependenciesCodec2 = named("Dependencies")(object(recordProp12($$Proxy.value)(string)(recordProp({
    reflectSymbol: function() {
      return "core";
    }
  })()($$Proxy.value)(envCodec)(recordProp({
    reflectSymbol: function() {
      return "test";
    }
  })()($$Proxy.value)(envCodec)(record)))));
  return named("WorkspaceLock")(object(recordProp22($$Proxy.value)(packageMap(dependenciesCodec2))(recordPropOptional({
    reflectSymbol: function() {
      return "package_set";
    }
  })()($$Proxy.value)(packageSetCodec)(recordProp({
    reflectSymbol: function() {
      return "extra_packages";
    }
  })()($$Proxy.value)(packageMap(extraPackageCodec))(record)))));
}();
var gitLockType = "git";
var constant = function(val) {
  var encode6 = encode2(string);
  var decode4 = function(json4) {
    return except6(bind34(decode2(string)(json4))(function(v) {
      if (v === val) {
        return pure44(val);
      }
      ;
      return new Left(basic("Unexpected value: " + v));
    }));
  };
  return codec$prime(decode4)(encode6);
};
var gitLockCodec = /* @__PURE__ */ function() {
  var toRep = insert9($$Proxy.value)(gitLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(named("GitLock")(object(recordProp32($$Proxy.value)(constant(gitLockType))(recordProp({
    reflectSymbol: function() {
      return "url";
    }
  })()($$Proxy.value)(string)(recordProp({
    reflectSymbol: function() {
      return "rev";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "subdir";
    }
  })()($$Proxy.value)(string)(recordProp3($$Proxy.value)(array(codec2))(record))))))));
}();
var pathLockCodec = /* @__PURE__ */ function() {
  var toRep = insert9($$Proxy.value)(pathLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(named("PathLock")(object(recordProp32($$Proxy.value)(constant(pathLockType))(recordProp12($$Proxy.value)(string)(recordProp3($$Proxy.value)(array(codec2))(record))))));
}();
var registryLockCodec = /* @__PURE__ */ function() {
  var toRep = insert9($$Proxy.value)(registryLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(named("RegistryLock")(object(recordProp32($$Proxy.value)(constant(registryLockType))(recordProp({
    reflectSymbol: function() {
      return "version";
    }
  })()($$Proxy.value)(codec3)(recordProp({
    reflectSymbol: function() {
      return "integrity";
    }
  })()($$Proxy.value)(codec7)(recordProp3($$Proxy.value)(array(codec2))(record)))))));
}();
var lockEntryCodec = /* @__PURE__ */ function() {
  var encode6 = function(v) {
    if (v instanceof FromPath) {
      return encode2(pathLockCodec)(v.value0);
    }
    ;
    if (v instanceof FromGit) {
      return encode2(gitLockCodec)(v.value0);
    }
    ;
    if (v instanceof FromRegistry) {
      return encode2(registryLockCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Lock (line 101, column 12 - line 104, column 58): " + [v.constructor.name]);
  };
  var decode4 = function(json4) {
    return alt18(map61(FromPath.create)(decode(pathLockCodec)(json4)))(alt18(map61(FromGit.create)(decode(gitLockCodec)(json4)))(map61(FromRegistry.create)(decode(registryLockCodec)(json4))));
  };
  return codec$prime(decode4)(encode6);
}();
var lockfileCodec = /* @__PURE__ */ function() {
  return named("Lockfile")(object(recordProp({
    reflectSymbol: function() {
      return "workspace";
    }
  })()($$Proxy.value)(workspaceLockCodec)(recordProp22($$Proxy.value)(packageMap(lockEntryCodec))(record))));
}();

// output/Registry.Constants/index.js
var metadataDirectory = "metadata";

// output/Spago.Db/foreign.js
import Database from "better-sqlite3";
var connectImpl = (path14, logger) => {
  logger("Connecting to database at " + path14);
  let db = new Database(path14, {
    fileMustExist: false
    // verbose: logger,
  });
  db.pragma("journal_mode = WAL");
  db.pragma("foreign_keys = ON");
  db.prepare(`CREATE TABLE IF NOT EXISTS package_sets
    ( version TEXT PRIMARY KEY NOT NULL
    , compiler TEXT NOT NULL
    , date TEXT NOT NULL
    )`).run();
  db.prepare(`CREATE TABLE IF NOT EXISTS package_set_entries
    ( packageSetVersion TEXT NOT NULL
    , packageName TEXT NOT NULL
    , packageVersion TEXT NOT NULL
    , PRIMARY KEY (packageSetVersion, packageName, packageVersion)
    , FOREIGN KEY (packageSetVersion) REFERENCES package_sets(version)
    )`).run();
  db.prepare(`CREATE TABLE IF NOT EXISTS last_git_pull
    ( key TEXT PRIMARY KEY NOT NULL
    , date TEXT NOT NULL
    )`).run();
  db.prepare(`CREATE TABLE IF NOT EXISTS package_metadata
    ( name TEXT PRIMARY KEY NOT NULL
    , metadata TEXT NOT NULL
    , last_fetched TEXT NOT NULL
    )`).run();
  db.prepare(`CREATE TABLE IF NOT EXISTS package_manifests
    ( name TEXT NOT NULL
    , version TEXT NOT NULL
    , manifest TEXT NOT NULL
    , PRIMARY KEY (name, version)
    )`).run();
  return db;
};
var insertPackageSetImpl = (db, packageSet) => {
  db.prepare(
    "INSERT INTO package_sets (version, compiler, date) VALUES (@version, @compiler, @date)"
  ).run(packageSet);
};
var insertPackageSetEntryImpl = (db, packageSetEntry) => {
  db.prepare(
    "INSERT INTO package_set_entries (packageSetVersion, packageName, packageVersion) VALUES (@packageSetVersion, @packageName, @packageVersion)"
  ).run(packageSetEntry);
};
var selectLatestPackageSetByCompilerImpl = (db, compiler) => {
  const row = db.prepare("SELECT * FROM package_sets WHERE compiler = ? ORDER BY date DESC LIMIT 1").get(compiler);
  return row;
};
var selectPackageSetsImpl = (db) => {
  const row = db.prepare("SELECT * FROM package_sets ORDER BY date ASC").all();
  return row;
};
var getLastPullImpl = (db, key) => {
  const row = db.prepare("SELECT * FROM last_git_pull WHERE key = ? LIMIT 1").get(key);
  return row?.date;
};
var updateLastPullImpl = (db, key, date2) => {
  db.prepare("INSERT OR REPLACE INTO last_git_pull (key, date) VALUES (@key, @date)").run({ key, date: date2 });
};
var getManifestImpl = (db, name5, version4) => {
  const row = db.prepare("SELECT * FROM package_manifests WHERE name = ? AND version = ? LIMIT 1").get(name5, version4);
  return row?.manifest;
};
var insertManifestImpl = (db, name5, version4, manifest) => {
  db.prepare("INSERT OR IGNORE INTO package_manifests (name, version, manifest) VALUES (@name, @version, @manifest)").run({ name: name5, version: version4, manifest });
};
var removeManifestImpl = (db, name5, version4) => {
  db.prepare("DELETE FROM package_manifests WHERE name = ? AND version = ?").run(name5, version4);
};
var insertMetadataImpl = (db, name5, metadata, last_fetched) => {
  db.prepare("INSERT OR REPLACE INTO package_metadata (name, metadata, last_fetched) VALUES (@name, @metadata, @last_fetched)").run({ name: name5, metadata, last_fetched });
};
var getMetadataForPackagesImpl = (db, names) => {
  const query3 = db.prepare("SELECT * FROM package_metadata WHERE name IN (SELECT value FROM json_each(?));");
  return query3.all(JSON.stringify(names));
};

// output/Spago.Db/index.js
var bottom3 = /* @__PURE__ */ bottom(boundedTime);
var bind35 = /* @__PURE__ */ bind(bindEither);
var map62 = /* @__PURE__ */ map(functorEither);
var pure45 = /* @__PURE__ */ pure(applicativeEither);
var map123 = /* @__PURE__ */ map(functorEffect);
var bindFlipped8 = /* @__PURE__ */ bindFlipped(bindMaybe);
var for_4 = /* @__PURE__ */ for_(applicativeEffect)(foldableArray);
var toUnfoldable15 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var map218 = /* @__PURE__ */ map(functorArray);
var fromFoldable26 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var filterMap2 = /* @__PURE__ */ filterMap(filterableArray);
var bind211 = /* @__PURE__ */ bind(bindMaybe);
var diff4 = /* @__PURE__ */ diff(durationMinutes);
var pure211 = /* @__PURE__ */ pure(applicativeMaybe);
var updateLastPull = function(db) {
  return function(key) {
    return function(date2) {
      return function() {
        return updateLastPullImpl(db, key, format(iso8601DateTime)(date2));
      };
    };
  };
};
var packageSetToJs = function(v) {
  return {
    version: print6(v.version),
    compiler: print6(v.compiler),
    date: format(iso8601Date)(new DateTime(v.date, bottom3))
  };
};
var packageSetFromJs = function(p) {
  return hush(bind35(parse4(p.version))(function(version4) {
    return bind35(parse4(p.compiler))(function(compiler) {
      return bind35(map62(date)(unformat(iso8601Date)(p.date)))(function(date2) {
        return pure45({
          version: version4,
          compiler,
          date: date2
        });
      });
    });
  }));
};
var selectLatestPackageSetByCompiler = function(db) {
  return function(compiler) {
    return function __do3() {
      var maybePackageSet = map123(toMaybe)(function() {
        return selectLatestPackageSetByCompilerImpl(db, print6(compiler));
      })();
      return bindFlipped8(packageSetFromJs)(maybePackageSet);
    };
  };
};
var selectPackageSets = function(db) {
  return function __do3() {
    var packageSets2 = selectPackageSetsImpl(db);
    return mapMaybe(packageSetFromJs)(packageSets2);
  };
};
var packageSetEntryToJs = function(v) {
  return {
    packageSetVersion: print6(v.packageSetVersion),
    packageName: print5(v.packageName),
    packageVersion: print6(v.packageVersion)
  };
};
var packageSetCodec2 = /* @__PURE__ */ named("PackageSet")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "version";
  }
}))()()({
  reflectSymbol: function() {
    return "date";
  }
}))()()({
  reflectSymbol: function() {
    return "compiler";
  }
}))({
  date: iso8601Date2,
  version: codec3,
  compiler: codec3
}));
var insertPackageSetEntry = function(db) {
  var $66 = runEffectFn2(insertPackageSetEntryImpl)(db);
  return function($67) {
    return $66(packageSetEntryToJs($67));
  };
};
var insertPackageSet = function(db) {
  var $68 = runEffectFn2(insertPackageSetImpl)(db);
  return function($69) {
    return $68(packageSetToJs($69));
  };
};
var insertMetadata = function(db) {
  return function(packageName) {
    return function(v) {
      return function __do3() {
        var now3 = nowDateTime();
        insertMetadataImpl(db, print5(packageName), printJson(codec10)(v), format(iso8601DateTime)(now3));
        return for_4(toUnfoldable15(v.unpublished))(function(v1) {
          return function() {
            return removeManifestImpl(db, print5(packageName), print6(v1.value0));
          };
        })();
      };
    };
  };
};
var insertManifest = function(db) {
  return function(packageName) {
    return function(version4) {
      return function(manifest) {
        return function() {
          return insertManifestImpl(db, print5(packageName), print6(version4), printJson(codec9)(manifest));
        };
      };
    };
  };
};
var getMetadataForPackages = function(db) {
  return function(packageNames) {
    return function __do3() {
      var metadataEntries = getMetadataForPackagesImpl(db, map218(print5)(packageNames));
      var now3 = nowDateTime();
      return fromFoldable26(filterMap2(function(metadataEntry) {
        return bind211(hush(parse3(metadataEntry.name)))(function(packageName) {
          return bind211(hush(unformat(iso8601DateTime)(metadataEntry.last_fetched)))(function(lastFetched) {
            var v = diff4(now3)(lastFetched);
            if (v <= 15) {
              return bind211(hush(parseJson(codec10)(metadataEntry.metadata)))(function(metadata) {
                return pure211(new Tuple(packageName, metadata));
              });
            }
            ;
            return Nothing.value;
          });
        });
      })(metadataEntries));
    };
  };
};
var getManifest = function(db) {
  return function(packageName) {
    return function(version4) {
      return function __do3() {
        var maybeManifest = map123(toMaybe)(function() {
          return getManifestImpl(db, print5(packageName), print6(version4));
        })();
        return bindFlipped8(function() {
          var $70 = parseJson(codec9);
          return function($71) {
            return hush($70($71));
          };
        }())(maybeManifest);
      };
    };
  };
};
var getLastPull = function(db) {
  return function(key) {
    return function __do3() {
      var maybePull = map123(toMaybe)(function() {
        return getLastPullImpl(db, key);
      })();
      return bindFlipped8(function() {
        var $72 = unformat(iso8601DateTime);
        return function($73) {
          return hush($72($73));
        };
      }())(maybePull);
    };
  };
};
var connect = function(v) {
  return function() {
    return connectImpl(v.database, mkEffectFn1(v.logger));
  };
};

// output/Node.ChildProcess.Types/foreign.js
var showKillSignal = (ks) => ks + "";
var fromKillSignalImpl = (fromInt3, fromStr, sig) => {
  const ty = typeof sig;
  if (ty === "number")
    return fromInt3(sig | 0);
  if (ty === "string")
    return fromStr(sig);
  throw new Error("Impossible. Got kill signal that was neither int nor string: " + sig);
};

// output/Node.ChildProcess.Types/index.js
var show24 = /* @__PURE__ */ show(showInt);
var show111 = /* @__PURE__ */ show(showString);
var Normally = /* @__PURE__ */ function() {
  function Normally2(value0) {
    this.value0 = value0;
  }
  ;
  Normally2.create = function(value0) {
    return new Normally2(value0);
  };
  return Normally2;
}();
var BySignal = /* @__PURE__ */ function() {
  function BySignal2(value0) {
    this.value0 = value0;
  }
  ;
  BySignal2.create = function(value0) {
    return new BySignal2(value0);
  };
  return BySignal2;
}();
var showKillSignal1 = {
  show: showKillSignal
};
var stringSignal = unsafeCoerce2;
var pipe2 = "pipe";
var ipc = "ipc";
var inherit = "inherit";
var fromKillSignal$prime = function(fromInt3) {
  return function(fromStr) {
    return function(sig) {
      return fromKillSignalImpl(fromInt3, fromStr, sig);
    };
  };
};
var fromKillSignal = function(sig) {
  return fromKillSignal$prime(Left.create)(Right.create)(sig);
};
var showExit = {
  show: function(v) {
    if (v instanceof Normally) {
      return "Normally " + show24(v.value0);
    }
    ;
    if (v instanceof BySignal) {
      return "BySignal " + either(show24)(show111)(fromKillSignal(v.value0));
    }
    ;
    throw new Error("Failed pattern match at Node.ChildProcess.Types (line 149, column 1 - line 151, column 79): " + [v.constructor.name]);
  }
};
var defaultStdIO = nullImpl;
var customShell = unsafeCoerce2;

// output/Data.Posix/index.js
var show25 = /* @__PURE__ */ show(showInt);
var showPid = {
  show: function(v) {
    return "(Pid " + (show25(v) + ")");
  }
};

// output/Node.Library.Execa/foreign.js
function setTimeoutImpl(timeout, cb) {
  const t = setTimeout(cb, timeout);
  return t.unref ? t : { unref: () => {
  } };
}
var undefinedVal = void 0;

// output/Effect.Timer/foreign.js
function setTimeoutImpl2(ms) {
  return function(fn) {
    return function() {
      return setTimeout(fn, ms);
    };
  };
}
function clearTimeoutImpl(id2) {
  return function() {
    clearTimeout(id2);
  };
}

// output/Effect.Timer/index.js
var setTimeout2 = setTimeoutImpl2;
var clearTimeout2 = clearTimeoutImpl;

// output/Node.UnsafeChildProcess.Safe/foreign.js
var connectedImpl = (cp) => cp.connected;
var disconnectImpl2 = (cp) => cp.disconnect();
var exitCodeImpl = (cp) => cp.exitCode;
var pidImpl = (cp) => cp.pid;
var killImpl2 = (cp) => cp.kill();
var killStrImpl2 = (cp, str2) => cp.kill(str2);
var killedImpl = (cp) => cp.killed;
var refImpl = (cp) => cp.ref();
var unrefImpl = (cp) => cp.unref();
var signalCodeImpl = (cp) => cp.signalCode;
var spawnArgs = (cp) => cp.spawnArgs;
var spawnFile = (cp) => cp.spawnFile;

// output/Node.UnsafeChildProcess.Safe/index.js
var identity25 = /* @__PURE__ */ identity(categoryFn);
var map63 = /* @__PURE__ */ map(functorEffect);
var show26 = /* @__PURE__ */ show(/* @__PURE__ */ showNullable(showInt));
var unref = function(cp) {
  return function() {
    return unrefImpl(cp);
  };
};
var spawnH = /* @__PURE__ */ function() {
  return new EventHandle("spawn", identity25);
}();
var signalCode = function(cp) {
  return map63(toMaybe)(function() {
    return signalCodeImpl(cp);
  });
};
var ref = function(cp) {
  return function() {
    return refImpl(cp);
  };
};
var pid2 = function(cp) {
  return map63(toMaybe)(function() {
    return pidImpl(cp);
  });
};
var killed = function(cp) {
  return function() {
    return killedImpl(cp);
  };
};
var kill$prime = function(sig) {
  return function(cp) {
    return function() {
      return killStrImpl2(cp, sig);
    };
  };
};
var kill2 = function(cp) {
  return function() {
    return killImpl2(cp);
  };
};
var exitH = /* @__PURE__ */ function() {
  return new EventHandle("exit", function(cb) {
    return function(code3, signal) {
      var v = toMaybe(signal);
      var v1 = toMaybe(code3);
      if (v1 instanceof Just) {
        return cb(new Normally(v1.value0))();
      }
      ;
      if (v instanceof Just) {
        return cb(new BySignal(v.value0))();
      }
      ;
      return unsafeCrashWith("Impossible. 'exit' event did not get an exit code or kill signal: " + (show26(code3) + ("; " + signal)))();
    };
  });
}();
var exitCode = function(cp) {
  return map63(toMaybe)(function() {
    return exitCodeImpl(cp);
  });
};
var errorH2 = /* @__PURE__ */ function() {
  return new EventHandle("error", mkEffectFn1);
}();
var disconnect = function(cp) {
  return function() {
    return disconnectImpl2(cp);
  };
};
var connected2 = function(cp) {
  return function() {
    return connectedImpl(cp);
  };
};

// output/Node.UnsafeChildProcess.Unsafe/foreign.js
import {
  exec,
  exec as exec2,
  exec as exec3,
  exec as exec4,
  execFile,
  execFile as execFile2,
  execFile as execFile3,
  execFile as execFile4,
  spawn,
  spawn as spawn2,
  execSync,
  execSync as execSync2,
  execFileSync,
  execFileSync as execFileSync2,
  spawnSync,
  spawnSync as spawnSync2,
  fork,
  fork as fork2
} from "node:child_process";
var unsafeStdin = (cp) => cp.stdin;
var unsafeStdout = (cp) => cp.stdout;
var unsafeStderr = (cp) => cp.stderr;
var unsafeChannelRefImpl = (cp) => cp.channel.ref();
var unsafeChannelUnrefImpl = (cp) => cp.channel.unref();

// output/Node.UnsafeChildProcess.Unsafe/index.js
var unsafeChannelUnref = function(cp) {
  return function() {
    return unsafeChannelUnrefImpl(cp);
  };
};
var unsafeChannelRef = function(cp) {
  return function() {
    return unsafeChannelRefImpl(cp);
  };
};
var spawn$prime = function() {
  return function(command2) {
    return function(args) {
      return function(opts) {
        return function() {
          return spawn2(command2, args, opts);
        };
      };
    };
  };
};

// output/Node.ChildProcess.Aff/index.js
var mempty11 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidEffect(monoidUnit));
var join2 = /* @__PURE__ */ join(bindEffect);
var fromJust9 = /* @__PURE__ */ fromJust();
var parOneOf2 = /* @__PURE__ */ parOneOf(parallelAff)(alternativeParAff)(foldableArray)(functorArray);
var waitSpawned$prime = function(cp) {
  var pidOnSpawn = makeAff(function(done) {
    return function __do3() {
      var ref2 = $$new(mempty11)();
      var removeListener = once(spawnH)(function __do4() {
        join2(read(ref2))();
        var pid$prime = pid2(cp)();
        return done(new Right(new Right(fromJust9(pid$prime))))();
      })(cp)();
      write(removeListener)(ref2)();
      return effectCanceler(removeListener);
    };
  });
  var errored = makeAff(function(done) {
    return function __do3() {
      var ref2 = $$new(mempty11)();
      var removeListener = once(errorH2)(function(sysErr) {
        return function __do4() {
          join2(read(ref2))();
          return done(new Right(new Left(sysErr)))();
        };
      })(cp)();
      write(removeListener)(ref2)();
      return effectCanceler(removeListener);
    };
  });
  return parOneOf2([pidOnSpawn, errored]);
};

// output/Node.Errors.SystemError/foreign.js
var getField = (field, err) => err[field];

// output/Node.Errors.SystemError/index.js
var message2 = /* @__PURE__ */ runFn2(getField)("message");
var code = /* @__PURE__ */ runFn2(getField)("code");

// output/Node.Library.Execa.CrossSpawn/foreign.js
import process5 from "process";
var processHasChdir = () => process5.chdir !== void 0;

// output/Node.Library.Execa.ShebangCommand/index.js
var bind36 = /* @__PURE__ */ bind(bindMaybe);
var join3 = /* @__PURE__ */ join(bindMaybe);
var voidRight3 = /* @__PURE__ */ voidRight(functorMaybe);
var guard7 = /* @__PURE__ */ guard(alternativeMaybe);
var pure46 = /* @__PURE__ */ pure(applicativeMaybe);
var intercalate7 = /* @__PURE__ */ intercalate2(monoidString);
var shebangCommand = function(firstLineOfFile) {
  var shebangRegex = unsafeRegex("^#! ?(.*)")(noFlags);
  var extractBinary = function() {
    var $18 = split("/");
    return function($19) {
      return last($18($19));
    };
  }();
  return bind36(match(shebangRegex)(firstLineOfFile))(function(regexMatch) {
    return bind36(join3(index(toArray(regexMatch))(1)))(function(everythingAfterShebang) {
      var parts = split(" ")(everythingAfterShebang);
      var v = uncons(parts);
      if (v instanceof Just && v.value0.tail.length === 0) {
        return bind36(extractBinary(v.value0.head))(function(binary) {
          return voidRight3(binary)(guard7(binary !== "env"));
        });
      }
      ;
      if (v instanceof Just) {
        return bind36(extractBinary(v.value0.head))(function(binary) {
          return pure46(function() {
            var $14 = binary === "env";
            if ($14) {
              return intercalate7(" ")(v.value0.tail);
            }
            ;
            return intercalate7(" ")(cons(binary)(v.value0.tail));
          }());
        });
      }
      ;
      return Nothing.value;
    });
  });
};

// output/Node.Library.Execa.Utils/foreign.js
var buildCustomErrorImpl = (msg, obj) => Object.assign(new Error(msg), obj);

// output/Node.Library.Execa.Utils/index.js
var eq19 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var findMapWithIndex2 = /* @__PURE__ */ findMapWithIndex(foldableWithIndexObject);
var voidRight4 = /* @__PURE__ */ voidRight(functorMaybe);
var guard8 = /* @__PURE__ */ guard(alternativeMaybe);
var map64 = /* @__PURE__ */ map(functorEffect);
var voidRight1 = /* @__PURE__ */ voidRight(functorEffect);
var envKey$prime = function(env3) {
  return function(key) {
    if (eq19(platform)(new Just(Win32.value))) {
      return findMapWithIndex2(function(k) {
        return function(v) {
          return voidRight4(v)(guard8(toUpper(k) === toUpper(key)));
        };
      })(env3);
    }
    ;
    if (otherwise) {
      return lookup4(key)(env3);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa.Utils (line 68, column 1 - line 68, column 51): " + [env3.constructor.name, key.constructor.name]);
  };
};
var envKey = function(key) {
  return map64(flip(envKey$prime)(key))(getEnv);
};
var buildCustomError = function() {
  return function() {
    return function(msg) {
      return function(info4) {
        return buildCustomErrorImpl(msg, info4);
      };
    };
  };
};
var bracketEffect = function(open3) {
  return function(close2) {
    return function(use) {
      return function __do3() {
        var resource = open3();
        var b = use(resource)();
        return voidRight1(b)(close2(resource))();
      };
    };
  };
};

// output/Node.Library.Execa.IsExe/index.js
var alt19 = /* @__PURE__ */ alt(altMaybe);
var pure47 = /* @__PURE__ */ pure(applicativeEffect);
var eq20 = /* @__PURE__ */ eq(eqString);
var coerce8 = /* @__PURE__ */ coerce();
var identity26 = /* @__PURE__ */ identity(categoryFn);
var eq110 = /* @__PURE__ */ eq(eqInt);
var getErrorCode = function(e) {
  return e.code;
};
var defaultIsExeOptions = /* @__PURE__ */ function() {
  return {
    pathExt: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    ignoreErrors: false
  };
}();
var coreWindows = /* @__PURE__ */ function() {
  var checkPathExt = function(path14) {
    return function(options) {
      return function __do3() {
        var mbPathExt = envKey("PATHEXT")();
        var v = alt19(options.pathExt)(mbPathExt);
        if (v instanceof Nothing) {
          return true;
        }
        ;
        if (v instanceof Just) {
          var pathLen = length5(path14);
          var pathExt = split(";")(v.value0);
          var pathEndsInExt = isJust(find2(function(p1) {
            var p2 = drop3(pathLen - length5(p1) | 0)(path14);
            return toLower(p1) === toLower(p2);
          })(pathExt));
          var allElemsNonEmpty = isNothing(find2(eq20(""))(pathExt));
          return allElemsNonEmpty || pathEndsInExt;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 106, column 5 - line 120, column 49): " + [v.constructor.name]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(path14) {
      return function(options) {
        var v = function(v1) {
          if (otherwise) {
            return checkPathExt(path14)(options);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 93, column 1 - line 93, column 25): " + [stat6.constructor.name, path14.constructor.name, options.constructor.name]);
        };
        var $36 = !isSymbolicLink(stat6);
        if ($36) {
          var $37 = !isFile(stat6);
          if ($37) {
            return pure47(false);
          }
          ;
          return v(true);
        }
        ;
        return v(true);
      };
    };
  };
  var winIsExe = function(path14) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat2(path14)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var result = checkStat(v.value0)(path14)(options)();
                return cb(new Right(new Tuple(Nothing.value, result)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 124, column 23 - line 128, column 42): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var winIsExeSync = function(path14) {
    return function(options) {
      return function __do3() {
        var statsObj = stat4(path14)();
        return checkStat(statsObj)(path14)(options)();
      };
    };
  };
  return {
    isExe: winIsExe,
    isExeSync: winIsExeSync
  };
}();
var coreNonWindows = /* @__PURE__ */ function() {
  var checkMode = function(statsObj) {
    return function(options) {
      var uid2 = floor2(uid(statsObj));
      var mode2 = floor2(mode(statsObj));
      var gid2 = floor2(gid(statsObj));
      return function __do3() {
        var v = coerce8(getUid)();
        var v1 = coerce8(getGid)();
        var truthy = function(x) {
          return x !== 0;
        };
        var myUid = alt19(options.uid)(v);
        var myGid = alt19(options.gid)(v1);
        var ug = 64 | 8;
        return any2(identity26)([truthy(mode2 & 1), truthy(mode2 & 8) && maybe(false)(eq110(gid2))(myGid), truthy(mode2 & 64) && maybe(false)(eq110(uid2))(myUid), truthy(mode2 & ug) && maybe(false)(eq110(0))(myUid)]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(options) {
      return function __do3() {
        var b = checkMode(stat6)(options)();
        return isFile(stat6) && b;
      };
    };
  };
  var nonWinIsExe = function(path14) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat2(path14)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var b = checkStat(v.value0)(options)();
                return cb(new Right(new Tuple(Nothing.value, b)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 142, column 23 - line 146, column 37): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var nonWinIsExeSync = function(path14) {
    return function(options) {
      return function __do3() {
        var stats = stat4(path14)();
        return checkStat(stats)(options)();
      };
    };
  };
  return {
    isExe: nonWinIsExe,
    isExeSync: nonWinIsExeSync
  };
}();
var isExeSync = function(path14) {
  return function(options) {
    var core = function() {
      if (platform instanceof Just && platform.value0 instanceof Win32) {
        return coreWindows;
      }
      ;
      return coreNonWindows;
    }();
    return function __do3() {
      var mbEither = $$try(core.isExeSync(path14)(options))();
      var v = function(v1) {
        if (mbEither instanceof Left && otherwise) {
          return pure47(new Left(mbEither.value0));
        }
        ;
        if (mbEither instanceof Right) {
          return pure47(new Right(mbEither.value0));
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 71, column 1 - line 71, column 69): " + [mbEither.constructor.name]);
      };
      if (mbEither instanceof Left) {
        if (options.ignoreErrors) {
          var $59 = getErrorCode(mbEither.value0);
          if ($59 === "EACCESS") {
            return new Right(false);
          }
          ;
          return v(true)();
        }
        ;
        return v(true)();
      }
      ;
      return v(true)();
    };
  };
};

// output/Node.Library.Execa.Which/index.js
var pure48 = /* @__PURE__ */ pure(applicativeEffect);
var eq21 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var eq111 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var alt20 = /* @__PURE__ */ alt(altMaybe);
var buildCustomError2 = /* @__PURE__ */ buildCustomError()();
var tailRecM5 = /* @__PURE__ */ tailRecM(monadRecEffect);
var quotedRegex = /* @__PURE__ */ function() {
  return unsafeRegex('^".*"$')(noFlags);
}();
var isWindows = function __do() {
  var ty = envKey("OSTYPE")();
  return eq21(platform)(new Just(Win32.value)) || (eq111(ty)(new Just("cygwin")) || eq111(ty)(new Just("msys")));
};
var jsColon = function __do2() {
  var w = isWindows();
  if (w) {
    return ";";
  }
  ;
  return ":";
};
var getPathInfo = function(cmd) {
  return function(options) {
    var hasWindowsSlashRegex = unsafeRegex("\\\\")(noFlags);
    var hasPosixSlashRegex = unsafeRegex("\\/")(noFlags);
    return function __do3() {
      var cwd3 = cwd();
      var mbPath = envKey("PATH")();
      var mbPathExt = envKey("PATHEXT")();
      var isWin2 = isWindows();
      var colon = function() {
        if (options.colon instanceof Nothing) {
          return jsColon();
        }
        ;
        if (options.colon instanceof Just) {
          return options.colon.value0;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 77, column 12 - line 79, column 21): " + [options.colon.constructor.name]);
      }();
      var pathExtExe = function() {
        if (isWin2) {
          return fromMaybe(".EXE;.CMD;.BAT;.exe;.cmd;.bat")(alt20(options.pathExt)(mbPathExt));
        }
        ;
        if (otherwise) {
          return "";
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 92, column 5 - line 96, column 23): ");
      }();
      var pathExt = function() {
        if (isWin2) {
          return split(colon)(pathExtExe);
        }
        ;
        if (otherwise) {
          return [""];
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 98, column 5 - line 100, column 27): ");
      }();
      var pathEnv = function() {
        if (test(hasPosixSlashRegex)(cmd) || isWin2 && test(hasWindowsSlashRegex)(cmd)) {
          return [""];
        }
        ;
        if (otherwise) {
          var paths2 = split(colon)(fromMaybe("")(alt20(options.path)(mbPath)));
          if (isWin2) {
            return cons(cwd3)(paths2);
          }
          ;
          return paths2;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 84, column 5 - line 90, column 56): ");
      }();
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
  };
};
var getNotFoundError = function(cmd) {
  return buildCustomError2("not found: " + cmd)({
    code: "ENOENT"
  });
};
var dotSlashRegex = /* @__PURE__ */ unsafeRegex("^\\.[\\/]")(noFlags);
var whichSync = function(cmd) {
  return function(options) {
    var go = function(pathEnv) {
      return function(pathExt) {
        return function(pathExtExe) {
          var loop = function(v) {
            if (v.innerLoop instanceof Nothing) {
              var v1 = index(pathEnv)(v.outerLoopIdx);
              if (v1 instanceof Nothing) {
                return pure48(new Done(new Left(getNotFoundError(cmd))));
              }
              ;
              if (v1 instanceof Just) {
                var pathPart = function() {
                  if (test(quotedRegex)(v1.value0)) {
                    return slice2(1)(-1 | 0)(v1.value0);
                  }
                  ;
                  if (otherwise) {
                    return v1.value0;
                  }
                  ;
                  throw new Error("Failed pattern match at Node.Library.Execa.Which (line 163, column 15 - line 165, column 36): ");
                }();
                var pCmd = concat3([pathPart, cmd]);
                var p = function() {
                  var v2 = function(v3) {
                    if (otherwise) {
                      return pCmd;
                    }
                    ;
                    throw new Error("Failed pattern match at Node.Library.Execa.Which (line 148, column 1 - line 148, column 109): ");
                  };
                  var $61 = !$$null2(pathPart);
                  if ($61) {
                    var $62 = test(dotSlashRegex)(cmd);
                    if ($62) {
                      return slice2(0)(2)(cmd) + pCmd;
                    }
                    ;
                    return v2(true);
                  }
                  ;
                  return v2(true);
                }();
                return pure48(new Loop({
                  found: v.found,
                  outerLoopIdx: v.outerLoopIdx,
                  innerLoop: new Just({
                    p,
                    j: 0
                  })
                }));
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 158, column 20 - line 171, column 63): " + [v1.constructor.name]);
            }
            ;
            if (v.innerLoop instanceof Just) {
              var v1 = index(pathExt)(v.innerLoop.value0.j);
              if (v1 instanceof Nothing) {
                return pure48(new Loop({
                  found: v.found,
                  outerLoopIdx: v.outerLoopIdx + 1 | 0,
                  innerLoop: Nothing.value
                }));
              }
              ;
              if (v1 instanceof Just) {
                var cur = v.innerLoop.value0.p + v1.value0;
                return function __do3() {
                  var eOrB = isExeSync(cur)({
                    uid: defaultIsExeOptions.uid,
                    gid: defaultIsExeOptions.gid,
                    ignoreErrors: defaultIsExeOptions.ignoreErrors,
                    pathExt: new Just(pathExtExe)
                  })();
                  if (eOrB instanceof Right) {
                    if (eOrB.value0 && !options.all) {
                      return new Done(new Right(singleton4(cur)));
                    }
                    ;
                    if (eOrB.value0) {
                      return new Loop({
                        outerLoopIdx: v.outerLoopIdx,
                        found: snoc(v.found)(cur),
                        innerLoop: new Just({
                          p: v.innerLoop.value0.p,
                          j: v.innerLoop.value0.j + 1 | 0
                        })
                      });
                    }
                    ;
                  }
                  ;
                  return new Loop({
                    found: v.found,
                    outerLoopIdx: v.outerLoopIdx,
                    innerLoop: new Just({
                      p: v.innerLoop.value0.p,
                      j: v.innerLoop.value0.j + 1 | 0
                    })
                  });
                };
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 174, column 26 - line 187, column 71): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.Which (line 156, column 7 - line 187, column 71): " + [v.innerLoop.constructor.name]);
          };
          return tailRecM5(loop)({
            found: [],
            outerLoopIdx: 0,
            innerLoop: Nothing.value
          });
        };
      };
    };
    return function __do3() {
      var v = getPathInfo(cmd)(options)();
      return go(v.pathEnv)(v.pathExt)(v.pathExtExe)();
    };
  };
};
var defaultWhichOptions = /* @__PURE__ */ function() {
  return {
    path: Nothing.value,
    pathExt: Nothing.value,
    colon: Nothing.value,
    all: false
  };
}();

// output/Node.Library.Execa.CrossSpawn/index.js
var for_5 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var applySecond5 = /* @__PURE__ */ applySecond(applyMaybe);
var guard9 = /* @__PURE__ */ guard(alternativeMaybe);
var pure49 = /* @__PURE__ */ pure(applicativeEffect);
var map65 = /* @__PURE__ */ map(functorEffect);
var join4 = /* @__PURE__ */ join(bindMaybe);
var $$for3 = /* @__PURE__ */ $$for(applicativeEffect)(traversableMaybe);
var $$void13 = /* @__PURE__ */ $$void(functorEffect);
var append112 = /* @__PURE__ */ append(semigroupArray);
var voidLeft7 = /* @__PURE__ */ voidLeft(functorArray);
var guard1 = /* @__PURE__ */ guard(alternativeArray);
var intercalate8 = /* @__PURE__ */ intercalate2(monoidString);
var mapFlipped8 = /* @__PURE__ */ mapFlipped(functorArray);
var isWindows2 = /* @__PURE__ */ function() {
  return eq(eqMaybe(eqPlatform))(platform)(new Just(Win32.value));
}();
var parse10 = function(command2) {
  return function(args) {
    return function(options) {
      var wrapInDoubleQuotes = function(s) {
        return '"' + (s + '"');
      };
      var resolveCommand = function(parseRec) {
        var withOptionsCwdIfNeeded = function(optionsCwd) {
          var open3 = function __do3() {
            var cwd3 = cwd();
            var hasChdir = processHasChdir();
            for_5(applySecond5(guard9(hasChdir))(optionsCwd))(function(optionCwd) {
              return chdir(optionCwd);
            })();
            return {
              cwd: cwd3,
              hasChdir
            };
          };
          var close2 = function(v) {
            return for_5(applySecond5(guard9(v.hasChdir))(optionsCwd))(function(v1) {
              return chdir(v.cwd);
            });
          };
          return bracketEffect(open3)(close2);
        };
        return function __do3() {
          var env3 = function() {
            if (parseRec.options.env instanceof Nothing) {
              return getEnv();
            }
            ;
            if (parseRec.options.env instanceof Just) {
              return parseRec.options.env.value0;
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 147, column 12 - line 149, column 23): " + [parseRec.options.env.constructor.name]);
          }();
          var resolved = withOptionsCwdIfNeeded(parseRec.options.cwd)(function(v) {
            return map65(join4)($$for3(lookup4("Path")(env3))(function(envPath) {
              var getFirst = either($$const(Nothing.value))(function($57) {
                return Just.create(head2($57));
              });
              return function __do4() {
                var attempt1 = map65(getFirst)(whichSync(command2)({
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all,
                  path: new Just(envPath),
                  pathExt: new Just(delimiter)
                }))();
                var $40 = isJust(attempt1);
                if ($40) {
                  return attempt1;
                }
                ;
                return map65(getFirst)(whichSync(command2)({
                  pathExt: defaultWhichOptions.pathExt,
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all,
                  path: new Just(envPath)
                }))();
              };
            }));
          })();
          if (parseRec.options.cwd instanceof Just && resolved instanceof Just) {
            return map65(Just.create)(resolve([parseRec.options.cwd.value0])(resolved.value0))();
          }
          ;
          if (parseRec.options.cwd instanceof Nothing && resolved instanceof Just) {
            return map65(Just.create)(resolve([""])(resolved.value0))();
          }
          ;
          return Nothing.value;
        };
      };
      var readShebang = function(cmd) {
        return function __do3() {
          var buf = create(150)();
          $$void13($$try(bracketEffect(fdOpen2(cmd)(R.value)(Nothing.value))(fdClose2)(function(fd) {
            return fdRead2(fd)(buf)(0)(150)(new Just(0));
          })))();
          var firstLine = toString6(UTF8.value)(buf)();
          return shebangCommand(firstLine);
        };
      };
      var metaCharsRegex = unsafeRegex('([()\\][%!^"`<>&|;, *?])')(global2);
      var isExecutableRegex = unsafeRegex("\\.(?:com|exe)$")(ignoreCase);
      var isCommandShimRegex = unsafeRegex("node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$")(ignoreCase);
      var initParseRec = {
        command: command2,
        args,
        options
      };
      var escapeCommand = replace2(metaCharsRegex)("^$1");
      var escapeArgument = function(doubleEscapeMetaChars) {
        var escapeCount = function() {
          if (doubleEscapeMetaChars) {
            return 2;
          }
          ;
          return 1;
        }();
        var endOfStringRegex = unsafeRegex("(\\\\*)$")(noFlags);
        var backSlashSequenceThenDoubleQuoteRegex = unsafeRegex('(\\\\*)"')(global2);
        var $58 = applyN(replace2(metaCharsRegex)("^$1"))(escapeCount);
        var $59 = replace2(endOfStringRegex)("$1$1");
        var $60 = replace2(backSlashSequenceThenDoubleQuoteRegex)('$1$1\\"');
        return function($61) {
          return $58(wrapInDoubleQuotes($59($60($61))));
        };
      };
      var detectShebang = function(parseRec) {
        return function __do3() {
          var mbFile = resolveCommand(parseRec)();
          if (mbFile instanceof Nothing) {
            return new Tuple(parseRec, mbFile);
          }
          ;
          if (mbFile instanceof Just) {
            var mbShebang = readShebang(mbFile.value0)();
            if (mbShebang instanceof Nothing) {
              return new Tuple(parseRec, mbFile);
            }
            ;
            if (mbShebang instanceof Just) {
              var rec1 = {
                options: parseRec.options,
                args: cons(mbFile.value0)(parseRec.args),
                command: mbShebang.value0
              };
              var newCommand = resolveCommand(rec1)();
              return new Tuple(rec1, newCommand);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 134, column 9 - line 143, column 41): " + [mbShebang.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 130, column 5 - line 143, column 41): " + [mbFile.constructor.name]);
        };
      };
      var parseNonShell = function(parseRec) {
        return function __do3() {
          var v = detectShebang(parseRec)();
          var needsShell = function() {
            var $62 = test(isExecutableRegex);
            return function($63) {
              return !$62($63);
            };
          }();
          if (v.value1 instanceof Just && needsShell(v.value1.value0)) {
            var needsDoubleEscapeChars = test(isCommandShimRegex)(v.value1.value0);
            var comSpec = map65(fromMaybe("cmd.exe"))(envKey("COMSPEC"))();
            return {
              args: append112(voidLeft7(guard1(toLower(comSpec) === "cmd.exe" && !parseRec.options.windowsEnableCmdEcho))("/q"))(["/d", "/s", "/c", wrapInDoubleQuotes(intercalate8(" ")(cons(escapeCommand(normalize(v.value0.command)))(mapFlipped8(v.value0.args)(escapeArgument(needsDoubleEscapeChars)))))]),
              command: comSpec,
              options: {
                cwd: v.value0.options.cwd,
                env: v.value0.options.env,
                shell: v.value0.options.shell,
                windowsEnableCmdEcho: v.value0.options.windowsEnableCmdEcho,
                windowsVerbatimArguments: new Just(true)
              }
            };
          }
          ;
          return v.value0;
        };
      };
      var parseWindows = function() {
        if (isJust(options.shell)) {
          return pure49(initParseRec);
        }
        ;
        if (otherwise) {
          return parseNonShell(initParseRec);
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 82, column 3 - line 84, column 45): ");
      }();
      var $56 = !isWindows2;
      if ($56) {
        return pure49(initParseRec);
      }
      ;
      return parseWindows;
    };
  };
};

// output/Node.Library.Execa.GetStream/index.js
var bind116 = /* @__PURE__ */ bind(bindAff);
var liftEffect6 = /* @__PURE__ */ liftEffect(monadEffectAff);
var when7 = /* @__PURE__ */ when(applicativeEffect);
var show27 = /* @__PURE__ */ show(showNumber);
var getStreamBuffer = function(inputStream) {
  return function(initialOptions) {
    var bufferStream = function __do3() {
      var chunksRef = $$new([])();
      var lengthRef = $$new(0)();
      var stream3 = newPassThrough();
      var rmData = on2(dataH)(function(buf) {
        return function __do4() {
          modify_(function(chunks) {
            return snoc(chunks)(buf);
          })(chunksRef)();
          var bufLen = size5(buf)();
          return modify_(function(v) {
            return v + toNumber(bufLen);
          })(lengthRef)();
        };
      })(stream3)();
      return {
        getBufferedValue: function __do4() {
          var chunks = read(chunksRef)();
          var len = read(lengthRef)();
          return concat$prime2(chunks)(len)();
        },
        getBufferedLength: read(lengthRef),
        stream: stream3,
        unsubcribe: rmData
      };
    };
    var options = {
      maxBuffer: fromMaybe(infinity)(initialOptions.maxBuffer)
    };
    return bind116(liftEffect6(bufferStream))(function($$interface) {
      return makeAff(function(cb) {
        return function __do3() {
          pipeline(inputStream)([])($$interface.stream)(function(err) {
            return function __do4() {
              var bufferedData = $$interface.getBufferedValue();
              return cb(new Right({
                buffer: bufferedData,
                inputError: err
              }))();
            };
          })();
          var rmListener = on2(dataH)(function(v) {
            return function __do4() {
              var bufferedLen = $$interface.getBufferedLength();
              return when7(bufferedLen > options.maxBuffer)(function __do5() {
                var bufferedData = $$interface.getBufferedValue();
                return cb(new Right({
                  buffer: bufferedData,
                  inputError: new Just(error(maybe("Max buffer exceeded")(function(size8) {
                    return "Max buffer size exceeded. Buffer size was: " + show27(size8);
                  })(initialOptions.maxBuffer)))
                }))();
              })();
            };
          })($$interface.stream)();
          return effectCanceler(function __do4() {
            $$interface.unsubcribe();
            return rmListener();
          });
        };
      });
    });
  };
};

// output/Node.Library.Execa.NpmRunPath/index.js
var intercalate9 = /* @__PURE__ */ intercalate2(monoidString);
var append25 = /* @__PURE__ */ append(semigroupArray);
var foldMap7 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidArray);
var alt21 = /* @__PURE__ */ alt(altMaybe);
var map66 = /* @__PURE__ */ map(functorEffect);
var monoidMaybe2 = /* @__PURE__ */ monoidMaybe(semigroupString);
var npmRunPath = function(initialOptions) {
  var go = function(options) {
    return function(result) {
      return function(previous) {
        return function(cwdPath) {
          if (previous instanceof Just && previous.value0 === cwdPath) {
            return function __do3() {
              var nodeBinaryPath = resolve([cwdPath, options.execPath])("..")();
              return intercalate9(delimiter)(append25(result)(append25([nodeBinaryPath])(foldMap7(singleton2)(options.path))));
            };
          }
          ;
          var nextResult = concat3([cwdPath, "node_modules/.bin"]);
          var nextPrevious = new Just(cwdPath);
          return function __do3() {
            var nextCwdPath = resolve([cwdPath])("..")();
            return go(options)(snoc(result)(nextResult))(nextPrevious)(nextCwdPath)();
          };
        };
      };
    };
  };
  return function __do3() {
    var processCwd = cwd();
    var processPath = envKey("PATH")();
    var processExecPath = execPath();
    var options = {
      cwd: fromMaybe(processCwd)(initialOptions.cwd),
      path: alt21(initialOptions.path)(processPath),
      execPath: fromMaybe(processExecPath)(initialOptions.execPath)
    };
    var cwdPath = resolve([])(options.cwd)();
    return go(options)([])(Nothing.value)(cwdPath)();
  };
};
var npmRunPathEnv = function(env3) {
  return function(options) {
    return map66(function(p) {
      return insert4("PATH")(p)(env3);
    })(npmRunPath(options));
  };
};
var defaultNpmRunPathOptions = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "cwd";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "execPath";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "path";
  }
})(monoidMaybe2)()(monoidRecordNil)))));

// output/Node.Library.Execa.SignalExit/foreign.js
function unsafeProcessHasProp(prop4) {
  return global.process[prop4] !== null && global.process[prop4] !== void 0;
}
function unsafeReadProcessProp(prop4) {
  return global.process[prop4];
}
function unsafeWriteProcessProp(prop4, value4) {
  global.process[prop4] = value4;
}
function processCallFn(originalProcessReallyExit, exitCode2) {
  return originalProcessReallyExit.call(global.process, exitCode2);
}
function customProcessEmit(cb) {
  return function(ev, arg) {
    const thisArg = this;
    const argumentsArg = arguments;
    return cb((originalProcessEmit) => originalProcessEmit.apply(thisArg, argumentsArg), ev, arg);
  };
}

// output/Node.Library.Execa.SignalExit/index.js
var eq25 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var guard10 = /* @__PURE__ */ guard2(monoidArray);
var append26 = /* @__PURE__ */ append(semigroupArray);
var bind37 = /* @__PURE__ */ bind(bindEffect);
var pure50 = /* @__PURE__ */ pure(applicativeEffect);
var $$void14 = /* @__PURE__ */ $$void(functorEffect);
var whenM2 = /* @__PURE__ */ whenM(monadEffect);
var traverse_3 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray);
var unless2 = /* @__PURE__ */ unless(applicativeEffect);
var member4 = /* @__PURE__ */ member2(ordString);
var insert10 = /* @__PURE__ */ insert3(ordString);
var map67 = /* @__PURE__ */ map(functorEffect);
var when8 = /* @__PURE__ */ when(applicativeEffect);
var unlessM2 = /* @__PURE__ */ unlessM(monadEffect);
var $$for4 = /* @__PURE__ */ $$for(applicativeEffect)(traversableArray);
var signalExitProp = "__purescript_signal_exit__";
var processToEventEmitter = unsafeCoerce2;
var isWin = /* @__PURE__ */ function() {
  return eq25(new Just(Win32.value))(platform);
}();
var signals = /* @__PURE__ */ function() {
  var normal = ["SIGHUP", "SIGINT", "SIGTERM"];
  var nonWindows = guard10(!isWin)(["SIGABRT", "SIGALRM", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT", "SIGPROF"]);
  var linux2 = guard10(eq25(platform)(new Just(Linux.value)))(["SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT"]);
  return append26(normal)(append26(nonWindows)(linux2));
}();
var getGlobalRecOnProcessObject = /* @__PURE__ */ function() {
  var attachRefsToProcessObject = function __do3() {
    var v = unsafeReadProcessProp("emit");
    var v1 = unsafeReadProcessProp("reallyExit");
    var restoreOriginalProcessFunctions = function __do4() {
      unsafeWriteProcessProp("emit", v);
      return unsafeWriteProcessProp("reallyExit", v1);
    };
    var emitter = newImpl2();
    setUnlimitedListeners(emitter)();
    var countRef = $$new(0)();
    var emittedEventsRef = $$new(empty5)();
    var loadedRef = $$new(false)();
    var signalListenersRef = $$new([])();
    var obj = {
      originalProcessEmit: v,
      originalProcessReallyExit: v1,
      restoreOriginalProcessFunctions,
      emitter,
      countRef,
      emittedEventsRef,
      loadedRef,
      signalListenersRef
    };
    unsafeWriteProcessProp(signalExitProp, obj);
    return obj;
  };
  return ifM(bindEffect)(function() {
    return unsafeProcessHasProp(signalExitProp);
  })(function() {
    return unsafeReadProcessProp(signalExitProp);
  })(attachRefsToProcessObject);
}();
var exitEvent = "exit";
var exitH2 = /* @__PURE__ */ function() {
  return new EventHandle(exitEvent, function(cb) {
    return function(code3, err) {
      return cb(toMaybe(code3))(toMaybe(err))();
    };
  });
}();
var exitE = function(code3) {
  return function(err) {
    return function(v) {
      return $$void14(function() {
        return unsafeEmitFn(v)(exitEvent, toNullable(code3), toNullable(err));
      });
    };
  };
};
var afterexitEvent = "afterexit";
var afterexitH = /* @__PURE__ */ function() {
  return new EventHandle(afterexitEvent, function(cb) {
    return function(code3, err) {
      return cb(toMaybe(code3))(toMaybe(err))();
    };
  });
}();
var afterexitE = function(code3) {
  return function(err) {
    return function(v) {
      return $$void14(function() {
        return unsafeEmitFn(v)(afterexitEvent, toNullable(code3), toNullable(err));
      });
    };
  };
};
var onExit$prime = function(cb) {
  return function(options) {
    var unload = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return whenM2(read(v.loadedRef))(function __do4() {
        write(false)(v.loadedRef)();
        bind37(read(v.signalListenersRef))(traverse_3(function(v1) {
          if (v1 instanceof Nothing) {
            return pure50(unit);
          }
          ;
          if (v1 instanceof Just) {
            return v1.value0;
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 110, column 49 - line 112, column 40): " + [v1.constructor.name]);
        }))();
        v.restoreOriginalProcessFunctions();
        return modify_(function(v1) {
          return v1 - 1 | 0;
        })(v.countRef)();
      })();
    };
    var processReallyExitFn = function(v) {
      var v1 = getGlobalRecOnProcessObject();
      var exitCode2 = fromMaybe(0)(toMaybe(v));
      unsafeWriteProcessProp(exitEvent, exitCode2);
      exitE(new Just(exitCode2))(Nothing.value)(v1.emitter)();
      afterexitE(new Just(exitCode2))(Nothing.value)(v1.emitter)();
      return processCallFn(v1.originalProcessReallyExit, notNull(exitCode2));
    };
    var emitFn = function(event, code3, signal) {
      var v = getGlobalRecOnProcessObject();
      var eventsAlreadyEmitted = read(v.emittedEventsRef)();
      return unless2(member4(event)(eventsAlreadyEmitted))(function __do3() {
        modify_(insert10(event))(v.emittedEventsRef)();
        return map67(function(v1) {
          return unit;
        })(function() {
          return unsafeEmitFn(v.emitter)(event, code3, signal);
        })();
      })();
    };
    var mkListener = function(sig) {
      return function(countRef) {
        return function __do3() {
          var listenersLen = listenerCount(processToEventEmitter(process3))(sig)();
          var count = read(countRef)();
          return when8(listenersLen === count)(function __do4() {
            unload();
            emitFn(exitEvent, nullImpl, notNull(sig));
            emitFn(afterexitEvent, nullImpl, notNull(sig));
            var sig$prime = function() {
              var $65 = isWin && sig === "SIGHUP";
              if ($65) {
                return "SIGINT";
              }
              ;
              return sig;
            }();
            return killStr(pid)(sig$prime)();
          })();
        };
      };
    };
    var processEmitFn = customProcessEmit(function(runOriginalProcessEmit, ev, arg) {
      var v = getGlobalRecOnProcessObject();
      var $67 = ev === exitEvent;
      if ($67) {
        var exitCode2 = function() {
          var v1 = toMaybe(arg);
          if (v1 instanceof Nothing) {
            return map67(toNullable)(getExitCode)();
          }
          ;
          if (v1 instanceof Just) {
            setExitCode(v1.value0)();
            return notNull(v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 184, column 19 - line 189, column 35): " + [v1.constructor.name]);
        }();
        var ret = runOriginalProcessEmit(v.originalProcessEmit);
        emitFn(exitEvent, exitCode2, nullImpl);
        emitFn(afterexitEvent, exitCode2, nullImpl);
        return ret;
      }
      ;
      return runOriginalProcessEmit(v.originalProcessEmit);
    });
    var load3 = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return unlessM2(read(v.loadedRef))(function __do4() {
        write(true)(v.loadedRef)();
        modify_(function(v1) {
          return v1 + 1 | 0;
        })(v.countRef)();
        var signalListeners = $$for4(signals)(function(sig) {
          return map67(hush)($$try(function() {
            var listener = mkListener(sig)(v.countRef);
            return function __do5() {
              var rm3 = on2(mkSignalH$prime(sig))(listener)(process3)();
              return $$void14($$try(rm3));
            };
          }()));
        })();
        write(signalListeners)(v.signalListenersRef)();
        unsafeWriteProcessProp("emit", processEmitFn);
        return unsafeWriteProcessProp("reallyExit", processReallyExitFn);
      })();
    };
    return function __do3() {
      var v = getGlobalRecOnProcessObject();
      load3();
      var unSubscribe = function() {
        if (options.alwaysLast) {
          return on2(afterexitH)(cb)(v.emitter)();
        }
        ;
        return on2(exitH2)(cb)(v.emitter)();
      }();
      return function __do4() {
        unSubscribe();
        var exitLen = listenerCount(v.emitter)(exitEvent)();
        var afterExitLen = listenerCount(v.emitter)(afterexitEvent)();
        return when8(exitLen === 0 && afterExitLen === 0)(unload)();
      };
    };
  };
};
var onExit = function(cb) {
  return onExit$prime(cb)({
    alwaysLast: false
  });
};

// output/Node.Library.Execa.StripFinalNewline/index.js
var stripFinalNewlineBuf = function(b) {
  var charR = toNumber(toCharCode2("\r"));
  var charN = toNumber(toCharCode2("\n"));
  return function __do3() {
    var len = size5(b)();
    if (len === 0) {
      return b;
    }
    ;
    if (len === 1) {
      var lastChar = read5(UInt8.value)(len - 1 | 0)(b)();
      var $9 = lastChar === charN || lastChar === charR;
      if ($9) {
        return slice4(0)(len - 1 | 0)(b);
      }
      ;
      return b;
    }
    ;
    var lastChar = read5(UInt8.value)(len - 1 | 0)(b)();
    var sndLastChar = read5(UInt8.value)(len - 2 | 0)(b)();
    var $10 = lastChar === charN && sndLastChar === charR;
    if ($10) {
      return slice4(0)(len - 2 | 0)(b);
    }
    ;
    var $11 = lastChar === charN || lastChar === charR;
    if ($11) {
      return slice4(0)(len - 1 | 0)(b);
    }
    ;
    return b;
  };
};

// output/Node.Library.HumanSignals/foreign.js
import { constants as constants2 } from "os";

// output/Node.Library.HumanSignals/index.js
var identity27 = /* @__PURE__ */ identity(categoryFn);
var eq26 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var eq112 = /* @__PURE__ */ eq(eqInt);
var insert11 = /* @__PURE__ */ insert2(ordInt);
var alt22 = /* @__PURE__ */ alt(altMaybe);
var Terminate = /* @__PURE__ */ function() {
  function Terminate2() {
  }
  ;
  Terminate2.value = new Terminate2();
  return Terminate2;
}();
var Core = /* @__PURE__ */ function() {
  function Core2() {
  }
  ;
  Core2.value = new Core2();
  return Core2;
}();
var Ignore2 = /* @__PURE__ */ function() {
  function Ignore4() {
  }
  ;
  Ignore4.value = new Ignore4();
  return Ignore4;
}();
var Pause = /* @__PURE__ */ function() {
  function Pause2() {
  }
  ;
  Pause2.value = new Pause2();
  return Pause2;
}();
var Unpause = /* @__PURE__ */ function() {
  function Unpause2() {
  }
  ;
  Unpause2.value = new Unpause2();
  return Unpause2;
}();
var Ansi = /* @__PURE__ */ function() {
  function Ansi2() {
  }
  ;
  Ansi2.value = new Ansi2();
  return Ansi2;
}();
var Posix = /* @__PURE__ */ function() {
  function Posix2() {
  }
  ;
  Posix2.value = new Posix2();
  return Posix2;
}();
var Bsd = /* @__PURE__ */ function() {
  function Bsd2() {
  }
  ;
  Bsd2.value = new Bsd2();
  return Bsd2;
}();
var Systemv = /* @__PURE__ */ function() {
  function Systemv2() {
  }
  ;
  Systemv2.value = new Systemv2();
  return Systemv2;
}();
var Other = /* @__PURE__ */ function() {
  function Other2() {
  }
  ;
  Other2.value = new Other2();
  return Other2;
}();
var signals2 = /* @__PURE__ */ function() {
  var normalizeSignal = function(v) {
    var mbConstantSignal = lookup4(v.name)(constants2.signals);
    return {
      name: v.name,
      number: fromMaybe(v.number)(mbConstantSignal),
      description: v.description,
      supported: isJust(mbConstantSignal),
      action: v.action,
      standard: v.standard,
      forced: v.forced
    };
  };
  var byName = {
    SIGHUP: normalizeSignal({
      name: "SIGHUP",
      number: 1,
      action: Terminate.value,
      description: "Terminal closed",
      standard: Posix.value,
      forced: false
    }),
    SIGINT: normalizeSignal({
      name: "SIGINT",
      number: 2,
      action: Terminate.value,
      description: "User interruption with CTRL-C",
      standard: Ansi.value,
      forced: false
    }),
    SIGQUIT: normalizeSignal({
      name: "SIGQUIT",
      number: 3,
      action: Core.value,
      description: "User interruption with CTRL-\\",
      standard: Posix.value,
      forced: false
    }),
    SIGILL: normalizeSignal({
      name: "SIGILL",
      number: 4,
      action: Core.value,
      description: "Invalid machine instruction",
      standard: Ansi.value,
      forced: false
    }),
    SIGTRAP: normalizeSignal({
      name: "SIGTRAP",
      number: 5,
      action: Core.value,
      description: "Debugger breakpoint",
      standard: Posix.value,
      forced: false
    }),
    SIGABRT: normalizeSignal({
      name: "SIGABRT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Ansi.value,
      forced: false
    }),
    SIGIOT: normalizeSignal({
      name: "SIGIOT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Bsd.value,
      forced: false
    }),
    SIGBUS: normalizeSignal({
      name: "SIGBUS",
      number: 7,
      action: Core.value,
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: Bsd.value,
      forced: false
    }),
    SIGEMT: normalizeSignal({
      name: "SIGEMT",
      number: 7,
      action: Terminate.value,
      description: "Command should be emulated but is not implemented",
      standard: Other.value,
      forced: false
    }),
    SIGFPE: normalizeSignal({
      name: "SIGFPE",
      number: 8,
      action: Core.value,
      description: "Floating point arithmetic error",
      standard: Ansi.value,
      forced: false
    }),
    SIGKILL: normalizeSignal({
      name: "SIGKILL",
      number: 9,
      action: Terminate.value,
      description: "Forced termination",
      standard: Posix.value,
      forced: true
    }),
    SIGUSR1: normalizeSignal({
      name: "SIGUSR1",
      number: 10,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGSEGV: normalizeSignal({
      name: "SIGSEGV",
      number: 11,
      action: Core.value,
      description: "Segmentation fault",
      standard: Ansi.value,
      forced: false
    }),
    SIGUSR2: normalizeSignal({
      name: "SIGUSR2",
      number: 12,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGPIPE: normalizeSignal({
      name: "SIGPIPE",
      number: 13,
      action: Terminate.value,
      description: "Broken pipe or socket",
      standard: Posix.value,
      forced: false
    }),
    SIGALRM: normalizeSignal({
      name: "SIGALRM",
      number: 14,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Posix.value,
      forced: false
    }),
    SIGTERM: normalizeSignal({
      name: "SIGTERM",
      number: 15,
      action: Terminate.value,
      description: "Termination",
      standard: Ansi.value,
      forced: false
    }),
    SIGSTKFLT: normalizeSignal({
      name: "SIGSTKFLT",
      number: 16,
      action: Terminate.value,
      description: "Stack is empty or overflowed",
      standard: Other.value,
      forced: false
    }),
    SIGCHLD: normalizeSignal({
      name: "SIGCHLD",
      number: 17,
      action: Ignore2.value,
      description: "Child process terminated, paused or unpaused",
      standard: Posix.value,
      forced: false
    }),
    SIGCLD: normalizeSignal({
      name: "SIGCLD",
      number: 17,
      action: Ignore2.value,
      description: "Child process terminated, paused or unpaused",
      standard: Other.value,
      forced: false
    }),
    SIGCONT: normalizeSignal({
      name: "SIGCONT",
      number: 18,
      action: Unpause.value,
      description: "Unpaused",
      standard: Posix.value,
      forced: true
    }),
    SIGSTOP: normalizeSignal({
      name: "SIGSTOP",
      number: 19,
      action: Pause.value,
      description: "Paused",
      standard: Posix.value,
      forced: true
    }),
    SIGTSTP: normalizeSignal({
      name: "SIGTSTP",
      number: 20,
      action: Pause.value,
      description: 'Paused using CTRL-Z or "suspend"',
      standard: Posix.value,
      forced: false
    }),
    SIGTTIN: normalizeSignal({
      name: "SIGTTIN",
      number: 21,
      action: Pause.value,
      description: "Background process cannot read terminal input",
      standard: Posix.value,
      forced: false
    }),
    SIGBREAK: normalizeSignal({
      name: "SIGBREAK",
      number: 21,
      action: Terminate.value,
      description: "User interruption with CTRL-BREAK",
      standard: Other.value,
      forced: false
    }),
    SIGTTOU: normalizeSignal({
      name: "SIGTTOU",
      number: 22,
      action: Pause.value,
      description: "Background process cannot write to terminal output",
      standard: Posix.value,
      forced: false
    }),
    SIGURG: normalizeSignal({
      name: "SIGURG",
      number: 23,
      action: Ignore2.value,
      description: "Socket received out-of-band data",
      standard: Bsd.value,
      forced: false
    }),
    SIGXCPU: normalizeSignal({
      name: "SIGXCPU",
      number: 24,
      action: Core.value,
      description: "Process timed out",
      standard: Bsd.value,
      forced: false
    }),
    SIGXFSZ: normalizeSignal({
      name: "SIGXFSZ",
      number: 25,
      action: Core.value,
      description: "File too big",
      standard: Bsd.value,
      forced: false
    }),
    SIGVTALRM: normalizeSignal({
      name: "SIGVTALRM",
      number: 26,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGPROF: normalizeSignal({
      name: "SIGPROF",
      number: 27,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGWINCH: normalizeSignal({
      name: "SIGWINCH",
      number: 28,
      action: Ignore2.value,
      description: "Terminal window size changed",
      standard: Bsd.value,
      forced: false
    }),
    SIGIO: normalizeSignal({
      name: "SIGIO",
      number: 29,
      action: Terminate.value,
      description: "I/O is available",
      standard: Other.value,
      forced: false
    }),
    SIGPOLL: normalizeSignal({
      name: "SIGPOLL",
      number: 29,
      action: Terminate.value,
      description: "Watched event",
      standard: Other.value,
      forced: false
    }),
    SIGINFO: normalizeSignal({
      name: "SIGINFO",
      number: 29,
      action: Ignore2.value,
      description: "Request for process information",
      standard: Other.value,
      forced: false
    }),
    SIGPWR: normalizeSignal({
      name: "SIGPWR",
      number: 30,
      action: Terminate.value,
      description: "Device running out of power",
      standard: Systemv.value,
      forced: false
    }),
    SIGSYS: normalizeSignal({
      name: "SIGSYS",
      number: 31,
      action: Core.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGUNUSED: normalizeSignal({
      name: "SIGUNUSED",
      number: 31,
      action: Terminate.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGRT1: normalizeSignal({
      name: "SIGRT1",
      number: 34,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT2: normalizeSignal({
      name: "SIGRT2",
      number: 35,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT3: normalizeSignal({
      name: "SIGRT3",
      number: 36,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT4: normalizeSignal({
      name: "SIGRT4",
      number: 37,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT5: normalizeSignal({
      name: "SIGRT5",
      number: 38,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT6: normalizeSignal({
      name: "SIGRT6",
      number: 39,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT7: normalizeSignal({
      name: "SIGRT7",
      number: 40,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT8: normalizeSignal({
      name: "SIGRT8",
      number: 41,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT9: normalizeSignal({
      name: "SIGRT9",
      number: 42,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT10: normalizeSignal({
      name: "SIGRT10",
      number: 43,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT11: normalizeSignal({
      name: "SIGRT11",
      number: 44,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT12: normalizeSignal({
      name: "SIGRT12",
      number: 45,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT13: normalizeSignal({
      name: "SIGRT13",
      number: 46,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT14: normalizeSignal({
      name: "SIGRT14",
      number: 47,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT15: normalizeSignal({
      name: "SIGRT15",
      number: 48,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT16: normalizeSignal({
      name: "SIGRT16",
      number: 49,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT17: normalizeSignal({
      name: "SIGRT17",
      number: 50,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT18: normalizeSignal({
      name: "SIGRT18",
      number: 51,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT19: normalizeSignal({
      name: "SIGRT19",
      number: 52,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT20: normalizeSignal({
      name: "SIGRT20",
      number: 53,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT21: normalizeSignal({
      name: "SIGRT21",
      number: 54,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT22: normalizeSignal({
      name: "SIGRT22",
      number: 55,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT23: normalizeSignal({
      name: "SIGRT23",
      number: 56,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT24: normalizeSignal({
      name: "SIGRT24",
      number: 57,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT25: normalizeSignal({
      name: "SIGRT25",
      number: 58,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT26: normalizeSignal({
      name: "SIGRT26",
      number: 59,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT27: normalizeSignal({
      name: "SIGRT27",
      number: 60,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT28: normalizeSignal({
      name: "SIGRT28",
      number: 61,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT29: normalizeSignal({
      name: "SIGRT29",
      number: 62,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT30: normalizeSignal({
      name: "SIGRT30",
      number: 63,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT31: normalizeSignal({
      name: "SIGRT31",
      number: 64,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    })
  };
  var byString = fromHomogeneous()(byName);
  var signalsArray = toArrayWithKey(function(v) {
    return identity27;
  })(byString);
  var byNumber = flip(foldl2)(empty4)(function(acc) {
    return function(number2) {
      var byOsConstant = find2(function(v) {
        return eq26(new Just(number2))(lookup4(v.name)(constants2.signals));
      })(signalsArray);
      var byDefinedNumber = find2(function() {
        var $110 = eq112(number2);
        return function($111) {
          return $110(function(v) {
            return v.number;
          }($111));
        };
      }())(signalsArray);
      return maybe(acc)(function(sig) {
        return insert11(number2)(sig)(acc);
      })(alt22(byOsConstant)(byDefinedNumber));
    };
  })(range2(0)(64));
  return {
    byName,
    byNumber,
    byString
  };
}();

// output/Node.Library.Execa/index.js
var append27 = /* @__PURE__ */ append(semigroupArray);
var spawn$prime1 = /* @__PURE__ */ spawn$prime();
var bind38 = /* @__PURE__ */ bind(bindMaybe);
var map68 = /* @__PURE__ */ map(functorMaybe);
var lookup7 = /* @__PURE__ */ lookup3(ordInt);
var append113 = /* @__PURE__ */ append(semigroupString);
var show28 = /* @__PURE__ */ show(showInt);
var show112 = /* @__PURE__ */ show(showString);
var show29 = /* @__PURE__ */ show(showMilliseconds);
var intercalate10 = /* @__PURE__ */ intercalate2(monoidString);
var alt23 = /* @__PURE__ */ alt(altMaybe);
var mapFlipped1 = /* @__PURE__ */ mapFlipped(functorMaybe);
var pure51 = /* @__PURE__ */ pure(applicativeEffect);
var bind117 = /* @__PURE__ */ bind(bindEffect);
var eq27 = /* @__PURE__ */ eq(eqString);
var discard11 = /* @__PURE__ */ discard(discardUnit);
var discard12 = /* @__PURE__ */ discard11(bindMaybe);
var guard11 = /* @__PURE__ */ guard(alternativeMaybe);
var for_6 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var $$void15 = /* @__PURE__ */ $$void(functorEffect);
var map124 = /* @__PURE__ */ map(functorArray);
var greaterThan3 = /* @__PURE__ */ greaterThan(ordMilliseconds);
var bind212 = /* @__PURE__ */ bind(bindAff);
var liftEffect1 = /* @__PURE__ */ liftEffect(monadEffectAff);
var pure117 = /* @__PURE__ */ pure(applicativeAff);
var sequence_2 = /* @__PURE__ */ sequence_(applicativeEffect)(foldableMaybe);
var discard32 = /* @__PURE__ */ discard11(bindAff);
var when9 = /* @__PURE__ */ when(applicativeEffect);
var mempty15 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidEffect(monoidUnit));
var join5 = /* @__PURE__ */ join(bindEffect);
var void1 = /* @__PURE__ */ $$void(functorAff);
var unless3 = /* @__PURE__ */ unless(applicativeEffect);
var for_1 = /* @__PURE__ */ for_(applicativeAff)(foldableMaybe);
var sequential3 = /* @__PURE__ */ sequential(parallelAff);
var apply18 = /* @__PURE__ */ apply2(applyParAff);
var map219 = /* @__PURE__ */ map(functorParAff);
var parallel4 = /* @__PURE__ */ parallel(parallelAff);
var spawn$prime2 = function(cmd) {
  return function(args) {
    return function(buildOpts) {
      var o = buildOpts({
        cwd: Nothing.value,
        env: Nothing.value,
        argv0: Nothing.value,
        stdin: Nothing.value,
        stdout: Nothing.value,
        stderr: Nothing.value,
        ipc: Nothing.value,
        appendStdio: Nothing.value,
        detached: Nothing.value,
        uid: Nothing.value,
        gid: Nothing.value,
        serialization: Nothing.value,
        shell: Nothing.value,
        windowsVerbatimArguments: Nothing.value,
        windowsHide: Nothing.value,
        timeout: Nothing.value,
        killSignal: Nothing.value
      });
      var opts = {
        stdio: append27([fromMaybe(defaultStdIO)(o.stdin), fromMaybe(defaultStdIO)(o.stdout), fromMaybe(defaultStdIO)(o.stderr), function() {
          var $102 = fromMaybe(false)(o.ipc);
          if ($102) {
            return ipc;
          }
          ;
          return defaultStdIO;
        }()])(fromMaybe([])(o.appendStdio)),
        cwd: fromMaybe(undefinedVal)(o.cwd),
        env: fromMaybe(undefinedVal)(o.env),
        argv0: fromMaybe(undefinedVal)(o.argv0),
        detached: fromMaybe(undefinedVal)(o.detached),
        uid: fromMaybe(undefinedVal)(o.uid),
        gid: fromMaybe(undefinedVal)(o.gid),
        serialization: fromMaybe(undefinedVal)(o.serialization),
        shell: fromMaybe(undefinedVal)(o.shell),
        windowsVerbatimArguments: fromMaybe(undefinedVal)(o.windowsVerbatimArguments),
        windowsHide: fromMaybe(undefinedVal)(o.windowsHide),
        timeout: fromMaybe(undefinedVal)(o.timeout),
        killSignal: fromMaybe(undefinedVal)(o.killSignal)
      };
      return spawn$prime1(cmd)(args)(opts);
    };
  };
};
var noEscapeRegex = /* @__PURE__ */ unsafeRegex("^[\\w.-]+$")(noFlags);
var mkExecaResult = function(r) {
  var signalDescription = bind38(r.signal)(function($172) {
    return function(v) {
      if (v instanceof Left) {
        return map68(function(v1) {
          return v1.description;
        })(lookup7(v.value0)(signals2.byNumber));
      }
      ;
      if (v instanceof Right) {
        return map68(function(v1) {
          return v1.description;
        })(lookup4(v.value0)(signals2.byString));
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 887, column 55 - line 889, column 68): " + [v.constructor.name]);
    }(fromKillSignal($172));
  });
  var errorCode = map68(code)(r.spawnError);
  var prefix4 = function() {
    var v = function(v1) {
      if (r.canceled) {
        return "was canceled";
      }
      ;
      var v2 = function(v3) {
        var v4 = function(v5) {
          var v6 = function(v7) {
            var v8 = function(v9) {
              var v10 = function(v11) {
                var v12 = function(v13) {
                  var v14 = function(v15) {
                    if (otherwise) {
                      return "failed";
                    }
                    ;
                    throw new Error("Failed pattern match at Node.Library.Execa (line 848, column 1 - line 866, column 17): ");
                  };
                  if (r.spawnError instanceof Just) {
                    return "failed to spawn: " + message2(r.spawnError.value0);
                  }
                  ;
                  return v14(true);
                };
                if (r.stderrErr instanceof Just) {
                  return "had error in `stderr`: " + message(r.stderrErr.value0);
                }
                ;
                return v12(true);
              };
              if (r.stdoutErr instanceof Just) {
                return "had error in `stdout`: " + message(r.stdoutErr.value0);
              }
              ;
              return v10(true);
            };
            if (r.stdinErr instanceof Just) {
              return "had error in `stdin`: " + message(r.stdinErr.value0);
            }
            ;
            return v8(true);
          };
          if (r.exitCode instanceof Just) {
            return "failed with exit code " + show28(r.exitCode.value0);
          }
          ;
          return v6(true);
        };
        if (r.signal instanceof Just) {
          if (signalDescription instanceof Just) {
            return "was killed with " + (either(show28)(show112)(fromKillSignal(r.signal.value0)) + (" (" + (signalDescription.value0 + ")")));
          }
          ;
          return v4(true);
        }
        ;
        return v4(true);
      };
      if (errorCode instanceof Just) {
        return "failed with " + errorCode.value0;
      }
      ;
      return v2(true);
    };
    if (r.timedOut) {
      if (r.execaOptions.timeout instanceof Just) {
        return "timed out after " + (show29(r.execaOptions.timeout.value0) + "milliseconds");
      }
      ;
      return v(true);
    }
    ;
    return v(true);
  }();
  var execaMessage = "Command " + (prefix4 + (": " + r.command));
  var shortMessage = execaMessage + maybe("")(append113("\n"))(map68(message2)(r.spawnError));
  var message3 = intercalate10("\n")([shortMessage, r.stderr, r.stdout]);
  return {
    originalMessage: alt23(mapFlipped1(r.spawnError)(message2))(map68(message)(alt23(r.stdinErr)(alt23(r.stdoutErr)(r.stderrErr)))),
    message: message3,
    shortMessage,
    escapedCommand: r.escapedCommand,
    exit: r.exitStatus,
    exitCode: r.exitCode,
    pid: r.pid,
    signal: r.signal,
    signalDescription,
    stdinError: r.stdinErr,
    stdoutError: r.stdoutErr,
    stderrError: r.stderrErr,
    stdout: r.stdout,
    stderr: r.stderr,
    timedOut: r.timedOut,
    canceled: r.canceled,
    killed: r.killed && !r.timedOut
  };
};
var joinCommand = function(file) {
  return function(args) {
    return file + (" " + intercalate10(" ")(args));
  };
};
var handleOutput = function(options) {
  return function(value4) {
    if (options.stripFinalNewline) {
      return stripFinalNewlineBuf(value4);
    }
    ;
    if (otherwise) {
      return pure51(value4);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 732, column 1 - line 732, column 90): " + [options.constructor.name, value4.constructor.name]);
  };
};
var getEnv2 = function(r) {
  return function __do3() {
    var processEnv = getEnv();
    var env3 = function() {
      if (r.extendEnv) {
        return union4(r.env)(processEnv);
      }
      ;
      return r.env;
    }();
    if (r.preferLocal instanceof Nothing) {
      return env3;
    }
    ;
    if (r.preferLocal instanceof Just) {
      return npmRunPathEnv(env3)({
        path: defaultNpmRunPathOptions.path,
        cwd: r.preferLocal.value0.localDir,
        execPath: r.preferLocal.value0.execPath
      })();
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 85, column 3 - line 89, column 107): " + [r.preferLocal.constructor.name]);
  };
};
var execaKill = function(mbKillSignal) {
  return function(forceKillAfterTimeout) {
    return function(cp) {
      var isSigTerm = fromKillSignal$prime(function(i) {
        return maybe(false)(function() {
          var $173 = eq27("SIGTERM");
          return function($174) {
            return $173(toUpper(function(v) {
              return v.name;
            }($174)));
          };
        }())(lookup7(i)(signals2.byNumber));
      })(function(s) {
        return "SIGTERM" === toUpper(s);
      });
      var killSignal2 = fromMaybe(stringSignal("SIGTERM"))(mbKillSignal);
      return function __do3() {
        var killSignalSucceeded = kill$prime(killSignal2)(cp)();
        var mbTimeout = discard12(guard11(isSigTerm(killSignal2)))(function() {
          return discard12(guard11(killSignalSucceeded))(function() {
            return forceKillAfterTimeout;
          });
        });
        for_6(mbTimeout)(function(v) {
          return function __do4() {
            var t = setTimeoutImpl(floor2(v), $$void15(kill$prime(stringSignal("SIGKILL"))(cp)));
            return t.unref();
          };
        })();
        return killSignalSucceeded;
      };
    };
  };
};
var doubleQuotesregex = /* @__PURE__ */ unsafeRegex('"')(global2);
var getEscapedCommand = function(file) {
  return function(args) {
    var escapeArg = function(arg) {
      if (test(noEscapeRegex)(arg)) {
        return arg;
      }
      ;
      if (otherwise) {
        return '"' + (replace2(doubleQuotesregex)('\\"')(arg) + '"');
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 744, column 3 - line 746, column 87): " + [arg.constructor.name]);
    };
    return intercalate10(" ")(map124(escapeArg)(cons(file)(args)));
  };
};
var defaultOptions = /* @__PURE__ */ function() {
  return {
    cleanup: true,
    preferLocal: new Just({
      localDir: Nothing.value,
      execPath: Nothing.value
    }),
    stripFinalNewline: true,
    extendEnv: true,
    maxBuffer: toNumber((1e3 * 1e3 | 0) * 100 | 0),
    encoding: UTF8.value,
    windowsVerbatimArguments: false,
    windowsHide: true,
    windowsEnableCmdEcho: false
  };
}();
var handleArguments = function(file) {
  return function(args) {
    return function(initOptions) {
      return function __do3() {
        var parsed = parse10(file)(args)({
          shell: initOptions.shell,
          env: initOptions.env,
          cwd: initOptions.cwd,
          windowsVerbatimArguments: Nothing.value,
          windowsEnableCmdEcho: fromMaybe(defaultOptions.windowsEnableCmdEcho)(initOptions.windowsEnableCmdEcho)
        })();
        var processCwd = cwd();
        var env3 = getEnv2({
          env: fromMaybe(empty6)(initOptions.env),
          extendEnv: fromMaybe(defaultOptions.extendEnv)(initOptions.extendEnv),
          preferLocal: initOptions.preferLocal
        })();
        var v = function() {
          if (initOptions.timeout instanceof Just && greaterThan3(initOptions.timeout.value0.milliseconds)(0)) {
            return {
              timeout: new Just(initOptions.timeout.value0.milliseconds),
              killSignal: new Just(initOptions.timeout.value0.killSignal),
              timeoutWithKillSignal: new Just(initOptions.timeout.value0)
            };
          }
          ;
          return {
            timeout: Nothing.value,
            killSignal: Nothing.value,
            timeoutWithKillSignal: Nothing.value
          };
        }();
        var options = {
          cleanup: fromMaybe(defaultOptions.cleanup)(initOptions.cleanup),
          stdin: initOptions.stdin,
          stdout: initOptions.stdout,
          stderr: initOptions.stderr,
          ipc: initOptions.ipc,
          stdioExtra: fromMaybe([])(initOptions.stdioExtra),
          maxBuffer: fromMaybe(defaultOptions.maxBuffer)(initOptions.maxBuffer),
          stripFinalNewline: fromMaybe(defaultOptions.stripFinalNewline)(initOptions.stripFinalNewline),
          cwd: fromMaybe(processCwd)(initOptions.cwd),
          encoding: fromMaybe(defaultOptions.encoding)(initOptions.encoding),
          env: env3,
          argv0: initOptions.argv0,
          detached: fromMaybe(false)(initOptions.detached),
          uid: initOptions.uid,
          gid: initOptions.gid,
          shell: initOptions.shell,
          timeout: v.timeout,
          killSignal: v.killSignal,
          timeoutWithKillSignal: v.timeoutWithKillSignal,
          windowsHide: fromMaybe(defaultOptions.windowsHide)(initOptions.windowsHide),
          windowsVerbatimArguments: fromMaybe(defaultOptions.windowsVerbatimArguments)(parsed.options.windowsVerbatimArguments)
        };
        return {
          file: parsed.command,
          args: parsed.args,
          options,
          parsed
        };
      };
    };
  };
};
var defaultExecaOptions = /* @__PURE__ */ function() {
  return {
    cleanup: Nothing.value,
    preferLocal: Nothing.value,
    stdin: Nothing.value,
    stdout: Nothing.value,
    stderr: Nothing.value,
    ipc: Nothing.value,
    stdioExtra: Nothing.value,
    stripFinalNewline: Nothing.value,
    extendEnv: Nothing.value,
    encoding: Nothing.value,
    cwd: Nothing.value,
    env: Nothing.value,
    argv0: Nothing.value,
    detached: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    shell: Nothing.value,
    timeout: Nothing.value,
    maxBuffer: Nothing.value,
    windowsVerbatimArguments: Nothing.value,
    windowsHide: Nothing.value,
    windowsEnableCmdEcho: Nothing.value
  };
}();
var execa = function(file) {
  return function(args) {
    return function(buildOptions) {
      var options = buildOptions(defaultExecaOptions);
      return bind212(liftEffect1(handleArguments(file)(args)(options)))(function(parsed) {
        var escapedCommand = getEscapedCommand(file)(args);
        var command2 = joinCommand(file)(args);
        return bind212(liftEffect1(spawn$prime2(parsed.file)(parsed.args)(function(v) {
          return {
            timeout: v.timeout,
            killSignal: v.killSignal,
            cwd: new Just(parsed.options.cwd),
            env: new Just(parsed.options.env),
            argv0: options.argv0,
            stdin: parsed.options.stdin,
            stdout: parsed.options.stdout,
            stderr: parsed.options.stdin,
            ipc: parsed.options.ipc,
            appendStdio: new Just(parsed.options.stdioExtra),
            detached: options.detached,
            uid: options.uid,
            gid: options.gid,
            serialization: Nothing.value,
            shell: map68(customShell)(options.shell),
            windowsVerbatimArguments: new Just(parsed.options.windowsVerbatimArguments),
            windowsHide: new Just(parsed.options.windowsHide)
          };
        })))(function(spawned) {
          return bind212(liftEffect1($$new(Nothing.value)))(function(stdinErrRef) {
            return bind212(liftEffect1($$new(false)))(function(canceledRef) {
              return bind212(suspendAff(waitSpawned$prime(spawned)))(function(spawnedFiber) {
                return bind212(function() {
                  var $146 = !parsed.options.cleanup || parsed.options.detached;
                  if ($146) {
                    return pure117(spawnedFiber);
                  }
                  ;
                  return suspendAff(bind212(liftEffect1($$new(Nothing.value)))(function(removeHandlerRef) {
                    return $$finally(liftEffect1(bind117(read(removeHandlerRef))(sequence_2)))(discard32(liftEffect1(function __do3() {
                      var removal = onExit(function(v) {
                        return function(v1) {
                          return $$void15(kill$prime(stringSignal("SIGTERM"))(spawned));
                        };
                      })();
                      return write(new Just(removal))(removeHandlerRef)();
                    }))(function() {
                      return joinFiber(spawnedFiber);
                    }));
                  }));
                }())(function(processSpawnedFiber) {
                  var cancel = liftEffect1(function __do3() {
                    var killSucceeded = kill$prime(stringSignal("SIGTERM"))(spawned)();
                    return when9(killSucceeded)(write(true)(canceledRef))();
                  });
                  var mainFiber = function(postSpawn) {
                    return bind212(joinFiber(processSpawnedFiber))(function(res) {
                      if (res instanceof Left) {
                        return liftEffect1(function() {
                          var gotENOENT = code(res.value0) === "ENOENT";
                          return function __do3() {
                            var unfixedExitCode$prime = exitCode(spawned)();
                            var signalCode$prime = signalCode(spawned)();
                            var exitCode$prime = function() {
                              if (unfixedExitCode$prime instanceof Just && gotENOENT) {
                                return new Just(127);
                              }
                              ;
                              return unfixedExitCode$prime;
                            }();
                            var exitStatus = function() {
                              if (exitCode$prime instanceof Just) {
                                return new Normally(exitCode$prime.value0);
                              }
                              ;
                              if (signalCode$prime instanceof Just) {
                                return new BySignal(stringSignal(signalCode$prime.value0));
                              }
                              ;
                              return unsafeCrashWith("Impossible: either exit or signal should be non-null");
                            }();
                            var canceled = read(canceledRef)();
                            var killed$prime = killed(spawned)();
                            return mkExecaResult({
                              spawnError: new Just(res.value0),
                              pid: Nothing.value,
                              stdinErr: Nothing.value,
                              stdoutErr: Nothing.value,
                              stderrErr: Nothing.value,
                              exitStatus,
                              exitCode: exitCode$prime,
                              signal: map68(stringSignal)(signalCode$prime),
                              stdout: "",
                              stderr: "",
                              command: command2,
                              escapedCommand,
                              execaOptions: parsed.options,
                              timedOut: false,
                              canceled,
                              killed: killed$prime
                            });
                          };
                        }());
                      }
                      ;
                      if (res instanceof Right) {
                        return bind212(liftEffect1($$new(Nothing.value)))(function(timeoutRef) {
                          return bind212(liftEffect1($$new(mempty15)))(function(clearKillOnTimeoutRef) {
                            var clearKillOnTimeout = join5(read(clearKillOnTimeoutRef));
                            return discard32(void1(forkAff(function() {
                              if (parsed.options.timeoutWithKillSignal instanceof Just) {
                                return makeAff(function(cb) {
                                  return function __do3() {
                                    var tid = setTimeout2(parsed.options.timeoutWithKillSignal.value0.milliseconds)(function __do4() {
                                      var killed$prime = killed(spawned)();
                                      unless3(killed$prime)(function __do5() {
                                        $$void15(kill$prime(parsed.options.timeoutWithKillSignal.value0.killSignal)(spawned))();
                                        for_6(toMaybe(unsafeStdin(spawned)))(function($175) {
                                          return $$void15(destroy($175));
                                        })();
                                        for_6(toMaybe(unsafeStdout(spawned)))(function($176) {
                                          return $$void15(destroy($176));
                                        })();
                                        for_6(toMaybe(unsafeStderr(spawned)))(function($177) {
                                          return $$void15(destroy($177));
                                        })();
                                        return write(new Just(parsed.options.timeoutWithKillSignal.value0.killSignal))(timeoutRef)();
                                      })();
                                      return cb(new Right(unit))();
                                    })();
                                    write(clearTimeout2(tid))(clearKillOnTimeoutRef)();
                                    return nonCanceler;
                                  };
                                });
                              }
                              ;
                              return never;
                            }())))(function() {
                              return discard32(for_1(toMaybe(unsafeStdin(spawned)))(function(stdin$prime) {
                                return liftEffect1(once_(errorH)(function(error5) {
                                  return write(new Just(error5))(stdinErrRef);
                                })(stdin$prime));
                              }))(function() {
                                return discard32(for_1(postSpawn)(function(callback) {
                                  return callback(res.value0);
                                }))(function() {
                                  return bind212(forkAff(makeAff(function(done) {
                                    return function __do3() {
                                      once_(exitH)(function(exitResult) {
                                        return function __do4() {
                                          clearKillOnTimeout();
                                          return done(new Right(exitResult))();
                                        };
                                      })(spawned)();
                                      return nonCanceler;
                                    };
                                  })))(function(v) {
                                    var mkStdIoFiber = function($178) {
                                      return function(v1) {
                                        if (v1 instanceof Nothing) {
                                          return forkAff(pure117({
                                            text: "",
                                            error: Nothing.value
                                          }));
                                        }
                                        ;
                                        if (v1 instanceof Just) {
                                          return forkAff(bind212(getStreamBuffer(v1.value0)({
                                            maxBuffer: new Just(parsed.options.maxBuffer)
                                          }))(function(streamResult) {
                                            return bind212(liftEffect1(function __do3() {
                                              var buf = handleOutput({
                                                stripFinalNewline: parsed.options.stripFinalNewline
                                              })(streamResult.buffer)();
                                              var text3 = toString6(parsed.options.encoding)(buf)();
                                              when9(isJust(streamResult.inputError))(destroy(v1.value0))();
                                              return text3;
                                            }))(function(text3) {
                                              return pure117({
                                                text: text3,
                                                error: streamResult.inputError
                                              });
                                            });
                                          }));
                                        }
                                        ;
                                        throw new Error("Failed pattern match at Node.Library.Execa (line 469, column 40 - line 480, column 62): " + [v1.constructor.name]);
                                      }(toMaybe($178));
                                    };
                                    return bind212(mkStdIoFiber(unsafeStdout(spawned)))(function(stdoutFiber) {
                                      return bind212(mkStdIoFiber(unsafeStderr(spawned)))(function(stderrFiber) {
                                        return bind212(sequential3(apply18(apply18(map219(function(v1) {
                                          return function(v2) {
                                            return function(v3) {
                                              return {
                                                exit: v1,
                                                stdout: v2,
                                                stderr: v3
                                              };
                                            };
                                          };
                                        })(parallel4(joinFiber(v))))(parallel4(joinFiber(stdoutFiber))))(parallel4(joinFiber(stderrFiber)))))(function(result) {
                                          return liftEffect1(function __do3() {
                                            var stdinErr = read(stdinErrRef)();
                                            var canceled = read(canceledRef)();
                                            var killed$prime = killed(spawned)();
                                            var timeout = read(timeoutRef)();
                                            var exitResult = function() {
                                              if (result.exit instanceof Normally) {
                                                return {
                                                  exitCode: new Just(result.exit.value0),
                                                  signal: Nothing.value
                                                };
                                              }
                                              ;
                                              if (result.exit instanceof BySignal) {
                                                return {
                                                  exitCode: Nothing.value,
                                                  signal: new Just(result.exit.value0)
                                                };
                                              }
                                              ;
                                              throw new Error("Failed pattern match at Node.Library.Execa (line 499, column 28 - line 501, column 72): " + [result.exit.constructor.name]);
                                            }();
                                            return mkExecaResult({
                                              spawnError: Nothing.value,
                                              stdinErr,
                                              stdoutErr: result.stdout.error,
                                              stderrErr: result.stderr.error,
                                              exitStatus: result.exit,
                                              exitCode: exitResult.exitCode,
                                              pid: new Just(res.value0),
                                              signal: alt23(exitResult.signal)(timeout),
                                              stdout: result.stdout.text,
                                              stderr: result.stderr.text,
                                              command: command2,
                                              escapedCommand,
                                              execaOptions: parsed.options,
                                              timedOut: isJust(timeout),
                                              canceled,
                                              killed: killed$prime
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      }
                      ;
                      throw new Error("Failed pattern match at Node.Library.Execa (line 386, column 7 - line 519, column 16): " + [res.constructor.name]);
                    });
                  };
                  return pure117({
                    cancel,
                    getResult: mainFiber(Nothing.value),
                    "getResult'": function(cb) {
                      return mainFiber(new Just(cb));
                    },
                    unsafeChannelRef: liftEffect1(unsafeChannelRef(spawned)),
                    unsafeChannelUnref: liftEffect1(unsafeChannelUnref(spawned)),
                    connected: liftEffect1(connected2(spawned)),
                    disconnect: liftEffect1(disconnect(spawned)),
                    kill: liftEffect1(kill2(spawned)),
                    killWithSignal: function(signal) {
                      return liftEffect1(kill$prime(signal)(spawned));
                    },
                    killForced: function(forceKillAfterTimeout) {
                      return liftEffect1(execaKill(new Just(stringSignal("SIGTERM")))(new Just(forceKillAfterTimeout))(spawned));
                    },
                    killForcedWithSignal: function(signal) {
                      return function(forceKillAfterTimeout) {
                        return liftEffect1(execaKill(new Just(signal))(new Just(forceKillAfterTimeout))(spawned));
                      };
                    },
                    killed: liftEffect1(killed(spawned)),
                    unref: liftEffect1(unref(spawned)),
                    ref: liftEffect1(ref(spawned)),
                    spawnArgs: spawnArgs(spawned),
                    spawnFile: spawnFile(spawned),
                    childProcess: spawned,
                    stdin: mapFlipped1(toMaybe(unsafeStdin(spawned)))(function(stdin$prime) {
                      return {
                        stream: stdin$prime,
                        writeUtf8: function(string8) {
                          return liftEffect1(function __do3() {
                            var buf = fromString7(string8)(UTF8.value)();
                            return $$void15(write3(stdin$prime)(buf))();
                          });
                        },
                        writeUtf8End: function(string8) {
                          return liftEffect1(function __do3() {
                            var buf = fromString7(string8)(UTF8.value)();
                            $$void15(write3(stdin$prime)(buf))();
                            return $$void15(end(stdin$prime))();
                          });
                        },
                        end: liftEffect1($$void15(end(stdin$prime)))
                      };
                    }),
                    stdout: mapFlipped1(toMaybe(unsafeStdout(spawned)))(function(stdout$prime) {
                      return {
                        stream: stdout$prime,
                        pipeToParentStdout: liftEffect1($$void15(pipe(stdout$prime)(stdout)))
                      };
                    }),
                    stderr: mapFlipped1(toMaybe(unsafeStderr(spawned)))(function(stderr$prime) {
                      return {
                        stream: stderr$prime,
                        pipeToParentStderr: liftEffect1($$void15(pipe(stderr$prime)(stderr)))
                      };
                    }),
                    waitSpawned: bind212(liftEffect1(pid2(spawned)))(function(mbPid) {
                      if (mbPid instanceof Just) {
                        return pure117(new Right(mbPid.value0));
                      }
                      ;
                      if (mbPid instanceof Nothing) {
                        return waitSpawned$prime(spawned);
                      }
                      ;
                      throw new Error("Failed pattern match at Node.Library.Execa (line 565, column 9 - line 567, column 42): " + [mbPid.constructor.name]);
                    })
                  });
                });
              });
            });
          });
        });
      });
    };
  };
};

// output/Spago.Cmd/index.js
var bind39 = /* @__PURE__ */ bind(bindAff);
var discard13 = /* @__PURE__ */ discard(discardUnit);
var discard14 = /* @__PURE__ */ discard13(bindAff);
var pure52 = /* @__PURE__ */ pure(applicativeAff);
var when10 = /* @__PURE__ */ when(applicativeAff);
var traverse_4 = /* @__PURE__ */ traverse_(applicativeAff)(foldableMaybe);
var intercalate11 = /* @__PURE__ */ intercalate2(monoidString);
var append28 = /* @__PURE__ */ append(semigroupString);
var show30 = /* @__PURE__ */ show(showString);
var show113 = /* @__PURE__ */ show(showBoolean);
var show210 = /* @__PURE__ */ show(showExit);
var show32 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(showInt));
var show42 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(showKillSignal1));
var show52 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(showString));
var show62 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(showPid));
var show72 = /* @__PURE__ */ show(/* @__PURE__ */ showMaybe(showError));
var eq28 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var map69 = /* @__PURE__ */ map(functorMaybe);
var alt24 = /* @__PURE__ */ alt(altMaybe);
var unsafeIndex4 = /* @__PURE__ */ unsafeIndex();
var bindFlipped9 = /* @__PURE__ */ bindFlipped(bindAff);
var discard23 = /* @__PURE__ */ discard13(bindSpago);
var logDebug2 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug1 = /* @__PURE__ */ logDebug2(loggableString);
var loggableArray2 = /* @__PURE__ */ loggableArray(loggableString);
var die2 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableArray2);
var bind118 = /* @__PURE__ */ bind(bindSpago);
var pure118 = /* @__PURE__ */ pure(applicativeSpago);
var logDebug22 = /* @__PURE__ */ logDebug2(loggableArray2);
var StdinPipeParent = /* @__PURE__ */ function() {
  function StdinPipeParent2() {
  }
  ;
  StdinPipeParent2.value = new StdinPipeParent2();
  return StdinPipeParent2;
}();
var StdinNewPipe = /* @__PURE__ */ function() {
  function StdinNewPipe2() {
  }
  ;
  StdinNewPipe2.value = new StdinNewPipe2();
  return StdinNewPipe2;
}();
var StdinWrite = /* @__PURE__ */ function() {
  function StdinWrite2(value0) {
    this.value0 = value0;
  }
  ;
  StdinWrite2.create = function(value0) {
    return new StdinWrite2(value0);
  };
  return StdinWrite2;
}();
var spawn4 = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(cmd) {
    return function(args) {
      return function(opts) {
        return liftAff1(function() {
          var stdinOpt = function() {
            if (opts.pipeStdin instanceof StdinPipeParent) {
              return new Just(inherit);
            }
            ;
            if (opts.pipeStdin instanceof StdinWrite) {
              return new Just(pipe2);
            }
            ;
            if (opts.pipeStdin instanceof StdinNewPipe) {
              return new Just(pipe2);
            }
            ;
            throw new Error("Failed pattern match at Spago.Cmd (line 85, column 16 - line 88, column 32): " + [opts.pipeStdin.constructor.name]);
          }();
          return bind39(execa(cmd)(args)(function(v) {
            return {
              cleanup: v.cleanup,
              preferLocal: v.preferLocal,
              stripFinalNewline: v.stripFinalNewline,
              extendEnv: v.extendEnv,
              env: v.env,
              encoding: v.encoding,
              argv0: v.argv0,
              ipc: v.ipc,
              stdioExtra: v.stdioExtra,
              detached: v.detached,
              uid: v.uid,
              gid: v.gid,
              shell: v.shell,
              timeout: v.timeout,
              maxBuffer: v.maxBuffer,
              windowsVerbatimArguments: v.windowsVerbatimArguments,
              windowsHide: v.windowsHide,
              windowsEnableCmdEcho: v.windowsEnableCmdEcho,
              cwd: opts.cwd,
              stdin: stdinOpt,
              stdout: new Just(pipe2),
              stderr: new Just(pipe2)
            };
          }))(function(subprocess) {
            return discard14(function() {
              var v = function(v1) {
                return pure52(unit);
              };
              if (opts.pipeStdin instanceof StdinWrite) {
                if (subprocess.stdin instanceof Just) {
                  return subprocess.stdin.value0.writeUtf8End(opts.pipeStdin.value0);
                }
                ;
                return v(true);
              }
              ;
              return v(true);
            }())(function() {
              return discard14(when10(opts.pipeStderr)(traverse_4(function(v) {
                return v.pipeToParentStderr;
              })(subprocess.stderr)))(function() {
                return discard14(when10(opts.pipeStdout)(traverse_4(function(v) {
                  return v.pipeToParentStdout;
                })(subprocess.stdout)))(function() {
                  return pure52(subprocess);
                });
              });
            });
          });
        }());
      };
    };
  };
};
var spawn1 = /* @__PURE__ */ spawn4(monadAffAff);
var printExecResult = function(r) {
  return intercalate11("\n")(["escapedCommand: " + show30(r.escapedCommand), "canceled: " + show113(r.canceled), "exit: " + show210(r.exit), "exitCode: " + show32(r.exitCode), "signal: " + show42(r.signal), "signalDescription: " + show52(r.signalDescription), "pid: " + show62(r.pid), "killed: " + show113(r.killed), "timedOut: " + show113(r.timedOut), "shortMessage: " + show30(r.shortMessage), "message: " + show30(r.message), "originalMessage: " + show52(r.originalMessage), "stdinError: " + show72(r.stdinError), "stdoutError: " + show72(r.stdoutError), "stderrError: " + show72(r.stderrError), "stderr:", r.stderr, "", "stdout:", r.stdout, ""]);
};
var getStdout = /* @__PURE__ */ either(function(v) {
  return v.stdout;
})(function(v) {
  return v.stdout;
});
var findFlag = function(v) {
  var len = length(v.args);
  var lastIdx = len - 1 | 0;
  var isSingleCharFlag = function() {
    var $110 = eq28(new Just(1));
    var $111 = map69(length5);
    var $112 = stripPrefix2("-");
    return function($113) {
      return $110($111($112($113)));
    };
  }();
  var stripFlag = function(flag2) {
    return function(arg) {
      return map69(Tuple.create(isSingleCharFlag(flag2)))(stripPrefix2(flag2)(arg));
    };
  };
  var dropExtra = function(isOneCharFlag) {
    return function(restOfArg) {
      var dropSpace = stripPrefix2(" ");
      var dropEquals = stripPrefix2("=");
      if (isOneCharFlag) {
        return dropSpace(restOfArg);
      }
      ;
      return alt24(dropSpace(restOfArg))(dropEquals(restOfArg));
    };
  };
  var go = function($copy_idx) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(idx) {
      var arg = unsafeIndex4(v.args)(idx);
      var v1 = findMap(function(flag2) {
        return stripFlag(flag2)(arg);
      })(v.flags);
      if (v1 instanceof Just) {
        if (v1.value0.value1 === "") {
          $tco_done = true;
          return index(v.args)(idx + 1 | 0);
        }
        ;
        if (otherwise) {
          $tco_done = true;
          return dropExtra(v1.value0.value0)(v1.value0.value1);
        }
        ;
      }
      ;
      if (v1 instanceof Nothing) {
        if (idx < lastIdx) {
          $copy_idx = idx + 1 | 0;
          return;
        }
        ;
        if (otherwise) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
      }
      ;
      throw new Error("Failed pattern match at Spago.Cmd (line 148, column 5 - line 158, column 20): " + [v1.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_idx);
    }
    ;
    return $tco_result;
  };
  var $94 = len === 0;
  if ($94) {
    return Nothing.value;
  }
  ;
  return go(0);
};
var exec5 = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(cmd) {
    return function(args) {
      return function(opts) {
        return liftAff1(bind39(bindFlipped9(function(v) {
          return v.getResult;
        })(spawn1(cmd)(args)(opts)))(function(result) {
          if (result.exit instanceof Normally && result.exit.value0 === 0) {
            return pure52(new Right(result));
          }
          ;
          return pure52(new Left(result));
        }));
      };
    };
  };
};
var exec1 = /* @__PURE__ */ exec5(monadAffSpago);
var defaultExecOptions = /* @__PURE__ */ function() {
  return {
    pipeStdin: StdinNewPipe.value,
    pipeStdout: true,
    pipeStderr: true,
    cwd: Nothing.value
  };
}();
var getExecutable = function(command2) {
  var mkCmd = function(cmd) {
    return function(maybeExtension) {
      return cmd + maybe("")(append28("."))(maybeExtension);
    };
  };
  var complain = function(err) {
    return discard23(logDebug1(printExecResult(err)))(function() {
      return die2(["Failed to find " + (command2 + ". Have you installed it, and is it in your PATH?")]);
    });
  };
  var askVersion = function(cmd) {
    return exec1(cmd)(["--version"])({
      pipeStdin: defaultExecOptions.pipeStdin,
      cwd: defaultExecOptions.cwd,
      pipeStdout: false,
      pipeStderr: false
    });
  };
  if (platform instanceof Just && platform.value0 instanceof Win32) {
    var cmd1 = mkCmd(command2)(new Just("cmd"));
    return bind118(askVersion(cmd1))(function(v) {
      if (v instanceof Right) {
        return pure118({
          cmd: cmd1,
          output: v.value0.stdout
        });
      }
      ;
      if (v instanceof Left) {
        var cmd2 = mkCmd(command2)(Nothing.value);
        return discard23(logDebug22(["Failed to find purs.cmd. Trying with just purs...", show30(v.value0.message)]))(function() {
          return bind118(askVersion(cmd2))(function(v1) {
            if (v1 instanceof Right) {
              return pure118({
                cmd: cmd2,
                output: v1.value0.stdout
              });
            }
            ;
            if (v1 instanceof Left) {
              return complain(v1.value0);
            }
            ;
            throw new Error("Failed pattern match at Spago.Cmd (line 183, column 31 - line 185, column 35): " + [v1.constructor.name]);
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Cmd (line 178, column 27 - line 185, column 35): " + [v.constructor.name]);
    });
  }
  ;
  var cmd1 = mkCmd(command2)(Nothing.value);
  return bind118(askVersion(cmd1))(function(v) {
    if (v instanceof Right) {
      return pure118({
        cmd: cmd1,
        output: v.value0.stdout
      });
    }
    ;
    if (v instanceof Left) {
      return complain(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Cmd (line 189, column 27 - line 191, column 29): " + [v.constructor.name]);
  });
};

// output/Spago.Git/index.js
var bind40 = /* @__PURE__ */ bind(bindSpago);
var ask4 = /* @__PURE__ */ ask(monadAskSpago);
var exec6 = /* @__PURE__ */ exec5(monadAffSpago);
var pure53 = /* @__PURE__ */ pure(applicativeSpago);
var toDoc3 = /* @__PURE__ */ toDoc2(loggableString);
var $$void16 = /* @__PURE__ */ $$void(/* @__PURE__ */ functorExceptT(functorSpago));
var discard15 = /* @__PURE__ */ discard(discardUnit);
var discard16 = /* @__PURE__ */ discard15(bindSpago);
var logWarn2 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var logInfo2 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var loggableArray3 = /* @__PURE__ */ loggableArray(loggableString);
var toDoc12 = /* @__PURE__ */ toDoc2(loggableArray3);
var fromJust10 = /* @__PURE__ */ fromJust();
var mempty16 = /* @__PURE__ */ mempty(monoidRegexFlags);
var map70 = /* @__PURE__ */ map(functorMaybe);
var logDebug3 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var mapFlipped9 = /* @__PURE__ */ mapFlipped(functorSpago);
var pure119 = /* @__PURE__ */ pure(applicativeEither);
var nub3 = /* @__PURE__ */ nub(/* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(/* @__PURE__ */ ordRecordCons(/* @__PURE__ */ ordRecordCons(/* @__PURE__ */ ordRecordCons(ordRecordNil)()({
  reflectSymbol: function() {
    return "url";
  }
})(ordString))()({
  reflectSymbol: function() {
    return "repo";
  }
})(ordString))()({
  reflectSymbol: function() {
    return "owner";
  }
})(ordString))()({
  reflectSymbol: function() {
    return "name";
  }
})(ordString)));
var die3 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableArray3);
var exists3 = /* @__PURE__ */ exists2(monadEffectSpago);
var bindExceptT3 = /* @__PURE__ */ bindExceptT(monadSpago);
var discard24 = /* @__PURE__ */ discard15(bindExceptT3);
var logDebug12 = /* @__PURE__ */ logDebug(/* @__PURE__ */ monadEffectExceptT(monadEffectSpago))(/* @__PURE__ */ monadAskExceptT(monadAskSpago))(loggableString);
var bind213 = /* @__PURE__ */ bind(bindExceptT3);
var rightOrDie2 = /* @__PURE__ */ rightOrDie(monadEffectSpago)(monadAskSpago)(loggableString);
var tagCheckedOut = function(cwd3) {
  var opts = {
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3
  };
  return bind40(ask4)(function(v) {
    return bind40(exec6(v.git.cmd)(["describe", "--tags", "--exact-match"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure53(new Left(toDoc3("The git ref currently checked out is not a tag.")));
      }
      ;
      if (v1 instanceof Right) {
        return pure53(new Right(v1.value0.stdout));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 158, column 71 - line 160, column 37): " + [v1.constructor.name]);
    });
  });
};
var runGit = function(args) {
  return function(cwd3) {
    return bind40(ask4)(function(v) {
      return bind40(exec6(v.git.cmd)(args)({
        pipeStdin: defaultExecOptions.pipeStdin,
        pipeStdout: false,
        pipeStderr: false,
        cwd: cwd3
      }))(function(result) {
        return pure53(function() {
          if (result instanceof Right) {
            return new Right(result.value0.stdout);
          }
          ;
          if (result instanceof Left) {
            return new Left(result.value0.stderr);
          }
          ;
          throw new Error("Failed pattern match at Spago.Git (line 50, column 8 - line 52, column 28): " + [result.constructor.name]);
        }());
      });
    });
  };
};
var runGit_ = function(args) {
  return function(cwd3) {
    return $$void16(runGit(args)(cwd3));
  };
};
var pushTag = function(cwd3) {
  return function(version4) {
    var opts = {
      pipeStdin: defaultExecOptions.pipeStdin,
      pipeStdout: false,
      pipeStderr: false,
      cwd: cwd3
    };
    return bind40(ask4)(function(v) {
      if (v.offline instanceof Offline) {
        return discard16(logWarn2("Spago is in offline mode - not pushing the git tag v" + print6(version4)))(function() {
          return pure53(new Right(unit));
        });
      }
      ;
      if (v.offline instanceof Online) {
        return discard16(logInfo2("Pushing tag 'v" + (print6(version4) + "' to the remote")))(function() {
          return bind40(exec6(v.git.cmd)(["push", "origin", "v" + print6(version4)])(opts))(function(v1) {
            if (v1 instanceof Left) {
              return pure53(new Left(toDoc12(["Could not push the tag 'v" + (print6(version4) + "' to the remote."), "Error:", v1.value0.shortMessage])));
            }
            ;
            if (v1 instanceof Right) {
              return pure53(new Right(unit));
            }
            ;
            throw new Error("Failed pattern match at Spago.Git (line 172, column 84 - line 178, column 37): " + [v1.constructor.name]);
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 166, column 3 - line 178, column 37): " + [v.offline.constructor.name]);
    });
  };
};
var parseRemote = /* @__PURE__ */ function() {
  var tabOrSpaceRegex = fromJust10(hush(regex("\\s+")(mempty16)));
  var gitUrlRegex = fromJust10(hush(regex("^((ssh:\\/\\/)?[^@]+@[^:]+[:\\/]|https?:\\/\\/[^\\/]+\\/)(.*)\\/(.+)\\.git$")(mempty16)));
  return function(line2) {
    var v = split2(tabOrSpaceRegex)(line2);
    var v1 = function(v2) {
      return Nothing.value;
    };
    if (v.length === 3) {
      var $128 = map70(toArray)(match(gitUrlRegex)(v[1]));
      if ($128 instanceof Just && ($128.value0.length === 5 && ($128["value0"][3] instanceof Just && $128["value0"][4] instanceof Just))) {
        return new Just({
          name: v[0],
          url: v[1],
          owner: $128["value0"][3].value0,
          repo: $128["value0"][4].value0
        });
      }
      ;
      return v1(true);
    }
    ;
    return v1(true);
  };
}();
var listTags = function(cwd3) {
  var opts = {
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3
  };
  return bind40(ask4)(function(v) {
    return bind40(exec6(v.git.cmd)(["tag"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure53(new Left(toDoc12(["Could not run `git tag`. Error:", v1.value0.message])));
      }
      ;
      if (v1 instanceof Right) {
        return pure53(new Right(split("\n")(v1.value0.stdout)));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 113, column 39 - line 116, column 67): " + [v1.constructor.name]);
    });
  });
};
var getStatus = function(cwd3) {
  var opts = {
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3
  };
  return bind40(ask4)(function(v) {
    return bind40(exec6(v.git.cmd)(["status", "--porcelain"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure53(new Left(toDoc12(["Could not run `git status`. Error:", v1.value0.message])));
      }
      ;
      if (v1 instanceof Right) {
        return pure53(new Right(v1.value0.stdout));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 122, column 57 - line 125, column 37): " + [v1.constructor.name]);
    });
  });
};
var getRemotes = function(cwd3) {
  var opts = {
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3
  };
  return bind40(ask4)(function(v) {
    return mapFlipped9(exec6(v.git.cmd)(["remote", "--verbose"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return new Left(toDoc12(["Could not run `git remote --verbose` to verify correct repository path. Error:", v1.value0.stderr]));
      }
      ;
      if (v1 instanceof Right && v1.value0.stdout === "") {
        return pure119([]);
      }
      ;
      if (v1 instanceof Right) {
        return function(v2) {
          if (v2.length === 0) {
            return new Left(toDoc3("Could not parse any remotes from the output of `git remote --verbose`."));
          }
          ;
          return new Right(nub3(v2));
        }(mapMaybe(parseRemote)(split("\n")(v1.value0.stdout)));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 142, column 55 - line 152, column 45): " + [v1.constructor.name]);
    });
  });
};
var getRefType = function(v) {
  return runExceptT(runGit(["cat-file", "-t", v.ref])(new Just(v.repo)));
};
var getRef = function(cwd3) {
  var opts = {
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3
  };
  return bind40(ask4)(function(v) {
    return bind40(exec6(v.git.cmd)(["rev-parse", "HEAD"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure53(new Left(toDoc12(["Could not run `git rev-parse HEAD` to determine the current ref. Error:", v1.value0.shortMessage])));
      }
      ;
      if (v1 instanceof Right) {
        return pure53(new Right(v1.value0.stdout));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 131, column 53 - line 136, column 37): " + [v1.constructor.name]);
    });
  });
};
var getGit = /* @__PURE__ */ function() {
  return bind40(exec6("git")(["--version"])({
    pipeStdin: defaultExecOptions.pipeStdin,
    cwd: defaultExecOptions.cwd,
    pipeStdout: false,
    pipeStderr: false
  }))(function(v) {
    if (v instanceof Right) {
      return pure53({
        cmd: "git",
        version: v.value0.stdout
      });
    }
    ;
    if (v instanceof Left) {
      return discard16(logDebug3(printExecResult(v.value0)))(function() {
        return die3(["Failed to find git. Have you installed it, and is it in your PATH?"]);
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Git (line 214, column 104 - line 218, column 83): " + [v.constructor.name]);
  });
}();
var fetchRepo = function(v) {
  return function(path14) {
    return bind40(exists3(path14))(function(repoExists) {
      return bind40(ask4)(function(v1) {
        if (v1.offline instanceof Offline && repoExists) {
          return discard16(logDebug3("Found " + (v.git + " locally, skipping fetch because we are offline")))(function() {
            return pure53(new Right(unit));
          });
        }
        ;
        if (v1.offline instanceof Offline && !repoExists) {
          return die3(["You are offline and the repo '" + (v.git + "' is not available locally, can't make progress.")]);
        }
        ;
        if (v1.offline instanceof Online) {
          return bind40(function() {
            if (repoExists) {
              return discard16(logDebug3("Found " + (v.git + " locally, pulling...")))(function() {
                return runExceptT(runGit_(["fetch", "origin"])(new Just(path14)));
              });
            }
            ;
            if (!repoExists) {
              return discard16(logInfo2("Cloning " + v.git))(function() {
                return runExceptT(runGit_(["clone", "--filter=tree:0", v.git, path14])(Nothing.value));
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Git (line 64, column 29 - line 72, column 88): " + [repoExists.constructor.name]);
          }())(function(cloneOrFetchResult) {
            return bind40(runExceptT(discard24(pure53(cloneOrFetchResult))(function() {
              return discard24(logDebug12("Checking out the requested ref for " + (v.git + (" : " + v.ref))))(function() {
                return bind213(runGit(["checkout", v.ref])(new Just(path14)))(function() {
                  return mapExceptT(function(a) {
                    return bind40(a)(function(v2) {
                      if (v2 instanceof Left) {
                        return pure53(new Right(unit));
                      }
                      ;
                      if (v2 instanceof Right) {
                        return discard16(logDebug3("Pulling the latest changes"))(function() {
                          return runExceptT(runGit_(["pull", "--rebase", "--autostash"])(new Just(path14)));
                        });
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Git (line 80, column 25 - line 84, column 94): " + [v2.constructor.name]);
                    });
                  })(runGit_(["symbolic-ref", "-q", "HEAD"])(new Just(path14)));
                });
              });
            })))(function(result) {
              if (result instanceof Left) {
                return pure53(new Left(["Error while fetching the repo '" + (v.git + ("' at ref '" + (v.ref + "':"))), "  " + result.value0]));
              }
              ;
              if (result instanceof Right) {
                return discard16(logDebug3("Successfully fetched the repo '" + (v.git + ("' at ref '" + (v.ref + "'")))))(function() {
                  return pure53(new Right(unit));
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Git (line 88, column 7 - line 95, column 28): " + [result.constructor.name]);
            });
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Git (line 58, column 3 - line 95, column 28): " + [v1.offline.constructor.name, repoExists.constructor.name]);
      });
    });
  };
};
var fetch2 = function(v) {
  return bind40(bind40(runExceptT(runGit(["remote", "get-url", v.remote])(new Just(v.repo))))(rightOrDie2))(function(remoteUrl) {
    return discard16(logInfo2("Fetching from " + remoteUrl))(function() {
      return runExceptT(runGit_(["fetch", v.remote, "--tags"])(new Just(v.repo)));
    });
  });
};
var checkout = function(v) {
  return runExceptT($$void16(runGit(["checkout", v.ref])(new Just(v.repo))));
};

// output/Spago.Registry/index.js
var bind41 = /* @__PURE__ */ bind(bindSpago);
var liftEffect7 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var discard17 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug4 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug13 = /* @__PURE__ */ logDebug4(loggableString);
var pure54 = /* @__PURE__ */ pure(applicativeSpago);
var diff5 = /* @__PURE__ */ diff(durationMinutes);
var greaterThan4 = /* @__PURE__ */ greaterThan(ordMinutes);
var exists4 = /* @__PURE__ */ exists2(monadEffectSpago);
var ask5 = /* @__PURE__ */ ask(monadAskSpago);
var runSpago3 = /* @__PURE__ */ runSpago(monadAffSpago);
var liftAff3 = /* @__PURE__ */ liftAff(monadAffSpago);
var map71 = /* @__PURE__ */ map(functorSpago);
var parTraverseSpago2 = /* @__PURE__ */ parTraverseSpago(traversableArray);
var lookup8 = /* @__PURE__ */ lookup3(ordPackageName);
var fromFoldable27 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var mapFlipped10 = /* @__PURE__ */ mapFlipped(functorSpago);
var readEntryFile2 = /* @__PURE__ */ readEntryFile(monadAffAff);
var map125 = /* @__PURE__ */ map(functorArray);
var toUnfoldable16 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var logWarn3 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var fromFoldable111 = /* @__PURE__ */ fromFoldable7(ordVersion)(foldableArray);
var for_7 = /* @__PURE__ */ for_(applicativeSpago)(foldableArray);
var lookup1 = /* @__PURE__ */ lookup3(ordVersion);
var member5 = /* @__PURE__ */ member2(ordVersion);
var fromFoldable28 = /* @__PURE__ */ fromFoldable8(foldableArray)(ordVersion);
var die4 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var loggableArray4 = /* @__PURE__ */ loggableArray(loggableDocc);
var die1 = /* @__PURE__ */ die4(loggableArray4);
var append114 = /* @__PURE__ */ append(semigroupArray);
var toDoc4 = /* @__PURE__ */ toDoc2(loggableString);
var sort3 = /* @__PURE__ */ sort(ordVersion);
var compare6 = /* @__PURE__ */ compare(ordVersion);
var fromFoldable32 = /* @__PURE__ */ fromFoldable(foldableSet);
var die22 = /* @__PURE__ */ die4(loggableString);
var ls2 = /* @__PURE__ */ ls(monadAffSpago);
var unless4 = /* @__PURE__ */ unless(applicativeSpago);
var logDebug23 = /* @__PURE__ */ logDebug4(loggableArray4);
var show31 = /* @__PURE__ */ show(showString);
var difference4 = /* @__PURE__ */ difference3(ordVersion);
var toUnfoldable17 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var toUnfoldable22 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var when11 = /* @__PURE__ */ when(applicativeSpago);
var logInfo3 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var shouldFetchRegistryRepos = function(db) {
  return bind41(liftEffect7(nowDateTime))(function(now3) {
    return bind41(liftEffect7(getLastPull(db)("registry")))(function(maybeLastRegistryFetch) {
      if (maybeLastRegistryFetch instanceof Nothing) {
        return discard17(logDebug13("No record of last registry pull, will fetch"))(function() {
          return discard17(liftEffect7(updateLastPull(db)("registry")(now3)))(function() {
            return pure54(true);
          });
        });
      }
      ;
      if (maybeLastRegistryFetch instanceof Just) {
        var v = diff5(now3)(maybeLastRegistryFetch.value0);
        var isOldEnough = greaterThan4(v)(15);
        return bind41(exists4(registryPath))(function(registryExists) {
          var $107 = isOldEnough || !registryExists;
          if ($107) {
            return discard17(logDebug13("Registry is old, refreshing"))(function() {
              return discard17(liftEffect7(updateLastPull(db)("registry")(now3)))(function() {
                return pure54(true);
              });
            });
          }
          ;
          return pure54(false);
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Registry (line 331, column 3 - line 349, column 19): " + [maybeLastRegistryFetch.constructor.name]);
    });
  });
};
var readPackageSet = function(version4) {
  return bind41(ask5)(function(v) {
    return bind41(runSpago3({
      logOptions: v.logOptions,
      db: v.db,
      git: v.git,
      purs: v.purs,
      offline: v.offline
    })(v.getRegistry))(function(v1) {
      return runSpago3({
        logOptions: v.logOptions
      })(v1.readPackageSet(version4));
    });
  });
};
var listPackageSetsImpl = /* @__PURE__ */ bind41(ask5)(function(v) {
  return liftEffect7(selectPackageSets(v.db));
});
var listPackageSets = /* @__PURE__ */ bind41(ask5)(function(v) {
  return bind41(runSpago3({
    logOptions: v.logOptions,
    db: v.db,
    git: v.git,
    purs: v.purs,
    offline: v.offline
  })(v.getRegistry))(function(v1) {
    return runSpago3({
      logOptions: v.logOptions,
      db: v.db,
      git: v.git,
      purs: v.purs,
      offline: v.offline
    })(v1.listPackageSets);
  });
});
var listMetadataFiles = /* @__PURE__ */ bind41(ask5)(function(v) {
  return bind41(runSpago3({
    logOptions: v.logOptions,
    db: v.db,
    git: v.git,
    purs: v.purs,
    offline: v.offline
  })(v.getRegistry))(function(v1) {
    return runSpago3({
      logOptions: v.logOptions
    })(v1.listMetadataFiles);
  });
});
var isVersionCompatible = function(installedVersion) {
  return function(minVersion) {
    var minVersionList = [major(minVersion), minor(minVersion), patch(minVersion)];
    var installedVersionList = [major(installedVersion), minor(installedVersion), patch(installedVersion)];
    if (installedVersionList.length === 3 && (installedVersionList[0] === 0 && (minVersionList.length === 3 && (minVersionList[0] === 0 && (installedVersionList[1] === minVersionList[1] && installedVersionList[2] >= minVersionList[2]))))) {
      return true;
    }
    ;
    if (installedVersionList.length === 3 && (minVersionList.length === 3 && (installedVersionList[0] !== 0 && (installedVersionList[0] === minVersionList[0] && installedVersionList[1] >= minVersionList[1])))) {
      return true;
    }
    ;
    return false;
  };
};
var getMetadataForPackagesImpl2 = function(db) {
  return function(names) {
    var metadataFromFile = function(pkgName) {
      var metadataFilePath = concat3([registryPath, metadataDirectory, print5(pkgName) + ".json"]);
      return discard17(logDebug13("Reading metadata from file: " + metadataFilePath))(function() {
        return liftAff3(readJsonFile(codec10)(metadataFilePath));
      });
    };
    return bind41(liftEffect7(getMetadataForPackages(db)(names)))(function(metadatas) {
      return bind41(map71(partitionEithers)(parTraverseSpago2(function(name5) {
        var v = lookup8(name5)(metadatas);
        if (v instanceof Nothing) {
          return bind41(metadataFromFile(name5))(function(v1) {
            if (v1 instanceof Left) {
              return pure54(new Left(v1.value0));
            }
            ;
            if (v1 instanceof Right) {
              return discard17(liftEffect7(insertMetadata(db)(name5)(v1.value0)))(function() {
                return pure54(new Right(new Tuple(name5, v1.value0)));
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Registry (line 230, column 41 - line 235, column 43): " + [v1.constructor.name]);
          });
        }
        ;
        if (v instanceof Just) {
          return pure54(new Right(new Tuple(name5, v.value0)));
        }
        ;
        throw new Error("Failed pattern match at Spago.Registry (line 227, column 11 - line 236, column 47): " + [v.constructor.name]);
      })(names)))(function(v) {
        var v1 = head(v.fail);
        if (v1 instanceof Nothing) {
          return pure54(new Right(fromFoldable27(v.success)));
        }
        ;
        if (v1 instanceof Just) {
          return pure54(new Left(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Spago.Registry (line 239, column 5 - line 241, column 32): " + [v1.constructor.name]);
      });
    });
  };
};
var getMetadataImpl = function(db) {
  return function(name5) {
    return mapFlipped10(getMetadataForPackagesImpl2(db)([name5]))(function(v) {
      if (v instanceof Left) {
        return new Left(v.value0);
      }
      ;
      if (v instanceof Right) {
        var v1 = lookup8(name5)(v.value0);
        if (v1 instanceof Nothing) {
          return new Left("Failed to get metadata for package: " + print5(name5));
        }
        ;
        if (v1 instanceof Just) {
          return new Right(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Spago.Registry (line 216, column 28 - line 218, column 40): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Registry (line 214, column 9 - line 218, column 40): " + [v.constructor.name]);
    });
  };
};
var getMetadataForPackages2 = function(packageNames) {
  return bind41(ask5)(function(v) {
    return bind41(runSpago3({
      logOptions: v.logOptions,
      db: v.db,
      git: v.git,
      purs: v.purs,
      offline: v.offline
    })(v.getRegistry))(function(v1) {
      return runSpago3({
        logOptions: v.logOptions
      })(v1.getMetadataForPackages(packageNames));
    });
  });
};
var getMetadata = function(packageName) {
  return bind41(ask5)(function(v) {
    return bind41(runSpago3({
      logOptions: v.logOptions,
      db: v.db,
      git: v.git,
      purs: v.purs,
      offline: v.offline
    })(v.getRegistry))(function(v1) {
      return runSpago3({
        logOptions: v.logOptions
      })(v1.getMetadata(packageName));
    });
  });
};
var getManifestFromIndexImpl = function(db) {
  return function(name5) {
    return function(version4) {
      return bind41(liftEffect7(getManifest(db)(name5)(version4)))(function(v) {
        if (v instanceof Just) {
          return pure54(new Just(v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return discard17(logDebug13("Reading package from Index: " + print5(name5)))(function() {
            return bind41(liftAff3(readEntryFile2(registryIndexPath)(name5)))(function(maybeManifests) {
              return bind41(map71(map125(function(v1) {
                return new Tuple(v1.version, v1);
              }))(function() {
                if (maybeManifests instanceof Right) {
                  return pure54(toUnfoldable16(maybeManifests.value0));
                }
                ;
                if (maybeManifests instanceof Left) {
                  return discard17(logWarn3("Could not read package manifests from index, proceeding anyways. Error: " + maybeManifests.value0))(function() {
                    return pure54([]);
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Registry (line 259, column 71 - line 263, column 18): " + [maybeManifests.constructor.name]);
              }()))(function(manifests) {
                var versions = fromFoldable111(manifests);
                return discard17(for_7(manifests)(function(v1) {
                  return discard17(logDebug13("Inserting manifest in DB: " + (print5(name5) + (" v" + print6(v1.value1.version)))))(function() {
                    return liftEffect7(insertManifest(db)(name5)(v1.value1.version)(v1.value1));
                  });
                }))(function() {
                  return pure54(lookup1(version4)(versions));
                });
              });
            });
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Registry (line 252, column 51 - line 269, column 41): " + [v.constructor.name]);
      });
    };
  };
};
var getManifestFromIndex = function(packageName) {
  return function(version4) {
    return bind41(ask5)(function(v) {
      return bind41(runSpago3({
        logOptions: v.logOptions,
        db: v.db,
        git: v.git,
        purs: v.purs,
        offline: v.offline
      })(v.getRegistry))(function(v1) {
        return runSpago3({
          logOptions: v.logOptions
        })(v1.getManifestFromIndex(packageName)(version4));
      });
    });
  };
};
var findPackageSetImpl = function(maybeSet) {
  return bind41(ask5)(function(v) {
    return bind41(liftEffect7(selectPackageSets(v.db)))(function(availableSets) {
      var availableVersions = map125(function(v12) {
        return v12.version;
      })(availableSets);
      if (maybeSet instanceof Just) {
        var v1 = member5(maybeSet.value0)(fromFoldable28(availableVersions));
        if (v1) {
          return pure54(maybeSet.value0);
        }
        ;
        if (!v1) {
          return die1(append114([toDoc4("Could not find desired set " + (print6(maybeSet.value0) + " in the list of available set versions:"))])(map125(function($249) {
            return indent(toDoc4(print6($249)));
          })(sort3(availableVersions))));
        }
        ;
        throw new Error("Failed pattern match at Spago.Registry (line 284, column 24 - line 287, column 83): " + [v1.constructor.name]);
      }
      ;
      if (maybeSet instanceof Nothing) {
        return bind41(liftEffect7(selectLatestPackageSetByCompiler(v.db)(v.purs.version)))(function(maybeVersion) {
          if (maybeVersion instanceof Just) {
            return pure54(maybeVersion.value0.version);
          }
          ;
          if (maybeVersion instanceof Nothing) {
            var maybeLatestRelease = last(sortBy(on(compare6)(function(v12) {
              return v12.version;
            }))(availableSets));
            if (maybeLatestRelease instanceof Just && isVersionCompatible(v.purs.version)(maybeLatestRelease.value0.compiler)) {
              return pure54(maybeLatestRelease.value0.version);
            }
            ;
            var availableCompilers = fromFoldable28(map125(function(v12) {
              return v12.compiler;
            })(availableSets));
            return die1(append114([toDoc4("No package set is compatible with your compiler version " + print6(v.purs.version)), toDoc4("Compatible versions:")])(map125(function($250) {
              return indent(toDoc4(print6($250)));
            })(fromFoldable32(availableCompilers))));
          }
          ;
          throw new Error("Failed pattern match at Spago.Registry (line 291, column 7 - line 304, column 100): " + [maybeVersion.constructor.name]);
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Registry (line 282, column 3 - line 304, column 100): " + [maybeSet.constructor.name]);
    });
  });
};
var getRegistryFns = function(registryBox) {
  return function(registryLock) {
    var readPackageSetImpl = function(setVersion) {
      return discard17(logDebug13("Reading the package set from the Registry repo..."))(function() {
        var packageSetPath = concat3([packageSetsPath, print6(setVersion) + ".json"]);
        return bind41(liftAff3(readJsonFile(codec11)(packageSetPath)))(function(v) {
          if (v instanceof Left) {
            return die22("Couldn't read the package set: " + v.value0);
          }
          ;
          if (v instanceof Right) {
            return discard17(logDebug13("Read the package set " + (print6(setVersion) + " from the registry")))(function() {
              return pure54(v.value0);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Registry (line 203, column 67 - line 207, column 32): " + [v.constructor.name]);
        });
      });
    };
    var getAvailablePackageSets = function() {
      var parseSetVersion = function(str2) {
        return parse4(function() {
          var v = stripSuffix(".json")(str2);
          if (v instanceof Nothing) {
            return str2;
          }
          ;
          if (v instanceof Just) {
            return v.value0;
          }
          ;
          throw new Error("Failed pattern match at Spago.Registry (line 195, column 41 - line 197, column 18): " + [v.constructor.name]);
        }());
      };
      return bind41(map71(function() {
        var $251 = map125(parseSetVersion);
        return function($252) {
          return partitionEithers($251($252));
        };
      }())(ls2(packageSetsPath)))(function(v) {
        return discard17(unless4($$null(v.fail))(logDebug23(append114([toDoc4("Failed to parse some package-sets versions:")])(map125(function($253) {
          return indent(toDoc4(show31($253)));
        })(v.fail)))))(function() {
          return pure54(v.success);
        });
      });
    }();
    var updatePackageSetsDb = function(db) {
      return bind41(ask5)(function(v) {
        return bind41(map71(fromFoldable28)(getAvailablePackageSets))(function(setsAvailable) {
          return bind41(map71(function() {
            var $254 = map125(function(v1) {
              return v1.version;
            });
            return function($255) {
              return fromFoldable28($254($255));
            };
          }())(liftEffect7(selectPackageSets(db))))(function(setsInDb) {
            var setsToInsert = difference4(setsAvailable)(setsInDb);
            return unless4(isEmpty2(setsToInsert))(for_7(toUnfoldable17(setsToInsert))(function(setVersion) {
              return bind41(runSpago3({
                logOptions: v.logOptions
              })(readPackageSetImpl(setVersion)))(function(v1) {
                return discard17(logDebug13("Inserting package set in DB: " + print6(setVersion)))(function() {
                  return discard17(liftEffect7(insertPackageSet(db)({
                    compiler: v1.compiler,
                    date: v1.published,
                    version: v1.version
                  })))(function() {
                    return for_7(toUnfoldable22(v1.packages))(function(v2) {
                      return liftEffect7(insertPackageSetEntry(db)({
                        packageName: v2.value0,
                        packageVersion: v2.value1,
                        packageSetVersion: v1.version
                      }));
                    });
                  });
                });
              });
            }));
          });
        });
      });
    };
    var fetchRegistry = bind41(ask5)(function(v) {
      return bind41(shouldFetchRegistryRepos(v.db))(function(fetchingFreshRegistry) {
        return discard17(when11(fetchingFreshRegistry)(discard17(logInfo3("Refreshing the Registry Index..."))(function() {
          return parallelise([bind41(fetchRepo({
            git: "https://github.com/purescript/registry-index.git",
            ref: "main"
          })(registryIndexPath))(function(v1) {
            if (v1 instanceof Right) {
              return pure54(unit);
            }
            ;
            if (v1 instanceof Left) {
              return logWarn3("Couldn't refresh the registry-index, will proceed anyways");
            }
            ;
            throw new Error("Failed pattern match at Spago.Registry (line 155, column 126 - line 157, column 93): " + [v1.constructor.name]);
          }), bind41(fetchRepo({
            git: "https://github.com/purescript/registry.git",
            ref: "main"
          })(registryPath))(function(v1) {
            if (v1 instanceof Right) {
              return pure54(unit);
            }
            ;
            if (v1 instanceof Left) {
              return logWarn3("Couldn't refresh the registry, will proceed anyways");
            }
            ;
            throw new Error("Failed pattern match at Spago.Registry (line 158, column 115 - line 160, column 87): " + [v1.constructor.name]);
          })]);
        })))(function() {
          return discard17(updatePackageSetsDb(v.db))(function() {
            return pure54(fetchingFreshRegistry);
          });
        });
      });
    });
    return bind41(ask5)(function(v) {
      return discard17(liftAff3(take6(registryLock)))(function() {
        return bind41(liftAff3(tryRead2(registryBox)))(function(v1) {
          if (v1 instanceof Just) {
            return discard17(liftAff3(put3(unit)(registryLock)))(function() {
              return pure54(v1.value0);
            });
          }
          ;
          if (v1 instanceof Nothing) {
            return bind41(fetchRegistry)(function(_fetchingFreshRegistry) {
              var registryFns = {
                getManifestFromIndex: getManifestFromIndexImpl(v.db),
                getMetadata: getMetadataImpl(v.db),
                getMetadataForPackages: getMetadataForPackagesImpl2(v.db),
                listMetadataFiles: ls2(concat3([registryPath, metadataDirectory])),
                listPackageSets: listPackageSetsImpl,
                findPackageSet: findPackageSetImpl,
                readPackageSet: readPackageSetImpl
              };
              return discard17(liftAff3(put3(registryFns)(registryBox)))(function() {
                return discard17(liftAff3(put3(unit)(registryLock)))(function() {
                  return pure54(registryFns);
                });
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Registry (line 124, column 42 - line 142, column 23): " + [v1.constructor.name]);
        });
      });
    });
  };
};
var findPackageSet = function(version4) {
  return bind41(ask5)(function(v) {
    return bind41(runSpago3({
      logOptions: v.logOptions,
      db: v.db,
      git: v.git,
      purs: v.purs,
      offline: v.offline
    })(v.getRegistry))(function(v1) {
      return runSpago3({
        logOptions: v.logOptions,
        db: v.db,
        git: v.git,
        purs: v.purs,
        offline: v.offline
      })(v1.findPackageSet(version4));
    });
  });
};

// output/Spago.Config/index.js
var eqRec3 = /* @__PURE__ */ eqRec();
var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();
var versionIsSymbol2 = {
  reflectSymbol: function() {
    return "version";
  }
};
var packagesIsSymbol2 = {
  reflectSymbol: function() {
    return "packages";
  }
};
var eqMap2 = /* @__PURE__ */ eqMap(eqPackageName);
var compilerIsSymbol2 = {
  reflectSymbol: function() {
    return "compiler";
  }
};
var dependenciesIsSymbol2 = {
  reflectSymbol: function() {
    return "dependencies";
  }
};
var mempty17 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidSet(ordPackageName));
var foldMap8 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidDependencies);
var eqRec1 = /* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(dependenciesIsSymbol2)(eqDependencies))()({
  reflectSymbol: function() {
    return "build_plan";
  }
})(/* @__PURE__ */ eqSet(eqPackageName)));
var notEq7 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqMap2(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2({
  reflectSymbol: function() {
    return "test";
  }
})(eqRec1))()({
  reflectSymbol: function() {
    return "path";
  }
})(eqString))()({
  reflectSymbol: function() {
    return "core";
  }
})(eqRec1))));
var map72 = /* @__PURE__ */ map(functorMap);
var notEq12 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqMap2(eqExtraPackage));
var notEq22 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqMaybe(eqSetAddress));
var map126 = /* @__PURE__ */ map(functorMaybe);
var discard18 = /* @__PURE__ */ discard(discardUnit);
var exists5 = /* @__PURE__ */ exists2(monadEffectEffect);
var member6 = /* @__PURE__ */ member3(ordPackageName);
var wrapIso2 = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity)))();
var discard19 = /* @__PURE__ */ discard18(bindSpago);
var logDebug5 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug14 = /* @__PURE__ */ logDebug5(loggableString);
var bind42 = /* @__PURE__ */ bind(bindSpago);
var $$try7 = /* @__PURE__ */ $$try2(monadErrorErrorSpago);
var readTextFile5 = /* @__PURE__ */ readTextFile4(monadAffSpago);
var map220 = /* @__PURE__ */ map(functorSpago);
var join6 = /* @__PURE__ */ join(bindMaybe);
var $$for5 = /* @__PURE__ */ $$for(applicativeSpago)(traversableMaybe);
var exists1 = /* @__PURE__ */ exists2(monadEffectSpago);
var pure55 = /* @__PURE__ */ pure(applicativeSpago);
var lmap14 = /* @__PURE__ */ lmap(bifunctorEither);
var bimap4 = /* @__PURE__ */ bimap(bifunctorEither);
var toUnfoldable18 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var fromFoldable29 = /* @__PURE__ */ fromFoldable7(ordPackageName);
var lookup9 = /* @__PURE__ */ lookup3(ordPackageName);
var fromFoldable33 = /* @__PURE__ */ fromFoldable29(foldableArray);
var map410 = /* @__PURE__ */ map(functorArray);
var logInfo4 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var liftAff4 = /* @__PURE__ */ liftAff(monadAffSpago);
var logWarn4 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago);
var logWarn1 = /* @__PURE__ */ logWarn4(loggableString);
var die5 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var loggableArray5 = /* @__PURE__ */ loggableArray(loggableDocc);
var die12 = /* @__PURE__ */ die5(loggableArray5);
var toDoc5 = /* @__PURE__ */ toDoc2(loggableString);
var loggableArray1 = /* @__PURE__ */ loggableArray(loggableString);
var toDoc13 = /* @__PURE__ */ toDoc2(loggableArray1);
var die23 = /* @__PURE__ */ die5(loggableArray1);
var unless5 = /* @__PURE__ */ unless(applicativeSpago);
var logDebug24 = /* @__PURE__ */ logDebug5(loggableArray5);
var lines4 = /* @__PURE__ */ lines(foldableArray);
var toDoc22 = /* @__PURE__ */ toDoc2(loggableArray5);
var partitionMap3 = /* @__PURE__ */ partitionMap(filterableArray);
var identity28 = /* @__PURE__ */ identity(categoryFn);
var traverse5 = /* @__PURE__ */ traverse(traversableArray)(applicativeSpago);
var logWarn22 = /* @__PURE__ */ logWarn4(loggableArray5);
var append115 = /* @__PURE__ */ append(semigroupArray);
var voidRight5 = /* @__PURE__ */ voidRight(functorMaybe);
var show33 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showString));
var foldM4 = /* @__PURE__ */ foldM(monadSpago);
var logDebug32 = /* @__PURE__ */ logDebug5(loggableArray1);
var sort4 = /* @__PURE__ */ sort(ordString);
var die32 = /* @__PURE__ */ die5(loggableString);
var fromFoldable42 = /* @__PURE__ */ fromFoldable(foldableSet);
var typoSuggestions2 = /* @__PURE__ */ typoSuggestions(foldableArray);
var toDoc32 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggablePackageName));
var logWarn32 = /* @__PURE__ */ logWarn4(loggableArray1);
var ask6 = /* @__PURE__ */ ask(monadAskSpago);
var show114 = /* @__PURE__ */ show(showString);
var notEq32 = /* @__PURE__ */ notEq(eqStatusCode);
var show211 = /* @__PURE__ */ show(showStatusCode);
var show34 = /* @__PURE__ */ show(showDecodeError);
var intersection3 = /* @__PURE__ */ intersection2(ordPackageName);
var union6 = /* @__PURE__ */ union2(ordPackageName);
var logSuccess2 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago);
var logSuccess1 = /* @__PURE__ */ logSuccess2(loggableString);
var logSuccess22 = /* @__PURE__ */ logSuccess2(loggableArray5);
var show43 = /* @__PURE__ */ show(showInt);
var toUnfoldable23 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var bindFlipped10 = /* @__PURE__ */ bindFlipped(bindMaybe);
var disj1 = /* @__PURE__ */ disj(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var fromEnum13 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var fromFoldable52 = /* @__PURE__ */ fromFoldable9(foldableArray);
var WithTestGlobs = /* @__PURE__ */ function() {
  function WithTestGlobs2() {
  }
  ;
  WithTestGlobs2.value = new WithTestGlobs2();
  return WithTestGlobs2;
}();
var NoTestGlobs = /* @__PURE__ */ function() {
  function NoTestGlobs2() {
  }
  ;
  NoTestGlobs2.value = new NoTestGlobs2();
  return NoTestGlobs2;
}();
var OnlyTestGlobs = /* @__PURE__ */ function() {
  function OnlyTestGlobs2() {
  }
  ;
  OnlyTestGlobs2.value = new OnlyTestGlobs2();
  return OnlyTestGlobs2;
}();
var RemotePackageSet = function(x) {
  return x;
};
var RegistryVersion = /* @__PURE__ */ function() {
  function RegistryVersion2(value0) {
    this.value0 = value0;
  }
  ;
  RegistryVersion2.create = function(value0) {
    return new RegistryVersion2(value0);
  };
  return RegistryVersion2;
}();
var GitPackage = /* @__PURE__ */ function() {
  function GitPackage2(value0) {
    this.value0 = value0;
  }
  ;
  GitPackage2.create = function(value0) {
    return new GitPackage2(value0);
  };
  return GitPackage2;
}();
var LocalPackage = /* @__PURE__ */ function() {
  function LocalPackage3(value0) {
    this.value0 = value0;
  }
  ;
  LocalPackage3.create = function(value0) {
    return new LocalPackage3(value0);
  };
  return LocalPackage3;
}();
var WorkspacePackage = /* @__PURE__ */ function() {
  function WorkspacePackage2(value0) {
    this.value0 = value0;
  }
  ;
  WorkspacePackage2.create = function(value0) {
    return new WorkspacePackage2(value0);
  };
  return WorkspacePackage2;
}();
var LegacyPackageSet = function(x) {
  return x;
};
var RegistrySolverBuild = /* @__PURE__ */ function() {
  function RegistrySolverBuild2(value0) {
    this.value0 = value0;
  }
  ;
  RegistrySolverBuild2.create = function(value0) {
    return new RegistrySolverBuild2(value0);
  };
  return RegistrySolverBuild2;
}();
var PackageSetBuild = /* @__PURE__ */ function() {
  function PackageSetBuild2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  PackageSetBuild2.create = function(value0) {
    return function(value12) {
      return new PackageSetBuild2(value0, value12);
    };
  };
  return PackageSetBuild2;
}();
var workspacePackageToLockfilePackage = function(v) {
  return new Tuple(v["package"].name, {
    path: v.path,
    core: {
      dependencies: v["package"].dependencies,
      build_plan: mempty17
    },
    test: {
      dependencies: foldMap8(function(v1) {
        return v1.dependencies;
      })(v["package"].test),
      build_plan: mempty17
    }
  });
};
var testGlob2 = "test/**/*.purs";
var srcGlob = "src/**/*.purs";
var shouldComputeNewLockfile = function(v) {
  return function(workspaceLock) {
    var eraseBuildPlan = function(v1) {
      return {
        path: v1.path,
        core: {
          dependencies: v1.core.dependencies,
          build_plan: mempty17
        },
        test: {
          dependencies: v1.test.dependencies,
          build_plan: mempty17
        }
      };
    };
    return notEq7(map72(function($410) {
      return snd(workspacePackageToLockfilePackage($410));
    })(v.workspacePackages))(map72(eraseBuildPlan)(workspaceLock.packages)) || (notEq12(fromMaybe(empty4)(v.workspace.extraPackages))(workspaceLock.extra_packages) || (notEq22(v.workspace.packageSet)(map126(function(v1) {
      return v1.address;
    })(workspaceLock.package_set)) || function() {
      if (v.workspace.packageSet instanceof Just && v.workspace.packageSet.value0 instanceof SetFromPath) {
        return true;
      }
      ;
      return false;
    }()));
  };
};
var setPackageSetVersionInConfig = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var discard213 = discard18(MonadEffect0.Monad0().Bind1());
  var liftEffect19 = liftEffect(MonadEffect0);
  var liftAff1 = liftAff(dictMonadAff);
  return function(dictMonadEffect) {
    return function(doc) {
      return function(version4) {
        return discard213(liftEffect19(function() {
          return setPackageSetVersionInConfigImpl(doc, print6(version4));
        }))(function() {
          return liftAff1(writeYamlDocFile("spago.yaml")(doc));
        });
      };
    };
  };
};
var rootPackageToWorkspacePackage = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var bind128 = bind(Monad0.Bind1());
  var liftEffect19 = liftEffect(dictMonadEffect);
  var pure129 = pure(Monad0.Applicative0());
  return function(v) {
    return bind128(liftEffect19(exists5("test")))(function(hasTests) {
      return pure129({
        path: "./",
        doc: v.workspaceDoc,
        "package": v.rootPackage,
        hasTests
      });
    });
  };
};
var rootPackageToWorkspacePackage1 = /* @__PURE__ */ rootPackageToWorkspacePackage(monadEffectSpago);
var removePackagesFromConfig = function(doc) {
  return function(isTest) {
    return function(pkgs) {
      return function() {
        return removePackagesFromConfigImpl(doc, isTest, flip(member6)(pkgs));
      };
    };
  };
};
var remotePackageSetCodec = /* @__PURE__ */ wrapIso2(RemotePackageSet)(/* @__PURE__ */ named("PackageSet")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()(versionIsSymbol2))()()(packagesIsSymbol2))()()(compilerIsSymbol2))({
  version: codec3,
  compiler: codec3,
  packages: /* @__PURE__ */ packageMap(remotePackageCodec)
})));
var readConfig = function(path14) {
  return discard19(logDebug14("Reading config from " + path14))(function() {
    return bind42($$try7(readTextFile5(path14)))(function(v) {
      if (v instanceof Left) {
        return discard19(logDebug14("Could not read file " + (path14 + (", error: " + message(v.value0)))))(function() {
          var replaceExt = function() {
            var $411 = map126(function(v12) {
              return v12 + ".yml";
            });
            var $412 = stripSuffix(".yaml");
            return function($413) {
              return $411($412($413));
            };
          }();
          return bind42(map220(join6)($$for5(replaceExt(path14))(function(yml) {
            return bind42(exists1(yml))(function(hasYml) {
              return pure55(function() {
                if (hasYml) {
                  return new Just(yml);
                }
                ;
                return Nothing.value;
              }());
            });
          })))(function(yml) {
            return pure55(new Left(function() {
              if (path14 === "spago.yaml" && yml instanceof Nothing) {
                return ["Did not find `" + (path14 + "`. Run `spago init` to initialize a new project.")];
              }
              ;
              if (path14 === "spago.yaml" && yml instanceof Just) {
                return ["Did not find `" + (path14 + "`. Spago's configuration files must end with `.yaml`, not `.yml`."), "Try renaming `" + (yml.value0 + ("` to `" + (path14 + "` or run `spago init` to initialize a new project.")))];
              }
              ;
              if (yml instanceof Nothing) {
                return ["Did not find `" + (path14 + "`.")];
              }
              ;
              if (yml instanceof Just) {
                return ["Did not find `" + (path14 + "`. Spago's configuration files must end with `.yaml`, not `.yml`."), "Try renaming `" + (yml.value0 + ("` to `" + (path14 + "`.")))];
              }
              ;
              throw new Error("Failed pattern match at Spago.Config (line 568, column 21 - line 580, column 12): " + [path14.constructor.name, yml.constructor.name]);
            }()));
          });
        });
      }
      ;
      if (v instanceof Right) {
        var v1 = lmap14(function(err) {
          return basic("YAML: " + err);
        })(parser5(v.value0));
        if (v1 instanceof Left) {
          return pure55(new Left([print3(v1.value0)]));
        }
        ;
        if (v1 instanceof Right) {
          var maybeMigratedDoc = toMaybe(migrateV1ConfigImpl(v1.value0));
          return pure55(bimap4(printConfigError)(function(yaml) {
            return {
              doc: v1.value0,
              yaml,
              wasMigrated: isJust(maybeMigratedDoc)
            };
          })(decode2(configCodec)(toJson(fromMaybe(v1.value0)(maybeMigratedDoc)))));
        }
        ;
        throw new Error("Failed pattern match at Spago.Config (line 582, column 7 - line 599, column 88): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 557, column 34 - line 599, column 88): " + [v.constructor.name]);
    });
  });
};
var legacyPackageSetCodec = /* @__PURE__ */ wrapIso2(LegacyPackageSet)(/* @__PURE__ */ packageMap(legacyPackageSetEntryCodec));
var getWorkspacePackages = /* @__PURE__ */ function() {
  var extractWorkspacePackage = function(v) {
    if (v.value1 instanceof WorkspacePackage) {
      return new Just(v.value1.value0);
    }
    ;
    return Nothing.value;
  };
  var extractSet = function(v) {
    if (v instanceof PackageSetBuild) {
      return v.value1;
    }
    ;
    if (v instanceof RegistrySolverBuild) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Spago.Config (line 529, column 16 - line 531, column 31): " + [v.constructor.name]);
  };
  var $414 = fromFoldable2(foldableArray);
  var $415 = mapMaybe(extractWorkspacePackage);
  return function($416) {
    return unsafeFromJust($414($415(toUnfoldable18(extractSet(function(v) {
      return v.buildType;
    }($416))))));
  };
}();
var fromRemotePackage = function(v) {
  if (v instanceof RemoteGitPackage) {
    return new GitPackage(v.value0);
  }
  ;
  if (v instanceof RemoteRegistryVersion) {
    return new RegistryVersion(v.value0);
  }
  ;
  if (v instanceof RemoteLegacyPackage) {
    return new GitPackage({
      git: v.value0.repo,
      ref: v.value0.version,
      subdir: Nothing.value,
      dependencies: new Just(fromFoldable33(map410(function(p) {
        return new Tuple(p, Nothing.value);
      })(v.value0.dependencies)))
    });
  }
  ;
  throw new Error("Failed pattern match at Spago.Config (line 93, column 21 - line 101, column 6): " + [v.constructor.name]);
};
var fromExtraPackage = function(v) {
  if (v instanceof ExtraLocalPackage) {
    return new LocalPackage(v.value0);
  }
  ;
  if (v instanceof ExtraRemotePackage) {
    return fromRemotePackage(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Spago.Config (line 88, column 20 - line 90, column 53): " + [v.constructor.name]);
};
var readWorkspace = function(v) {
  return discard19(logInfo4("Reading Spago workspace configuration..."))(function() {
    var doMigrateConfig = function(path14) {
      return function(config2) {
        if (v.migrateConfig && config2.wasMigrated) {
          return discard19(logInfo4("Migrating your " + (path14 + " to the latest version...")))(function() {
            return liftAff4(writeYamlDocFile(path14)(config2.doc));
          });
        }
        ;
        if (!v.migrateConfig && config2.wasMigrated) {
          return logWarn1("Your " + (path14 + " is using an outdated format. Run Spago with the --migrate flag to update it to the latest version."));
        }
        ;
        if (!config2.wasMigrated) {
          return pure55(unit);
        }
        ;
        throw new Error("Failed pattern match at Spago.Config (line 176, column 7 - line 181, column 30): " + [v.migrateConfig.constructor.name, config2.wasMigrated.constructor.name]);
      };
    };
    return bind42(bind42(readConfig("spago.yaml"))(function(v1) {
      if (v1 instanceof Left) {
        return die12([toDoc5("Couldn't parse Spago config, error:"), $$break, indent(toDoc13(v1.value0)), $$break, toDoc5("The configuration file help can be found here https://github.com/purescript/spago#the-configuration-file")]);
      }
      ;
      if (v1 instanceof Right && v1.value0.yaml.workspace instanceof Nothing) {
        return die23(["Your spago.yaml doesn't contain a workspace section.", "See the relevant documentation here: https://github.com/purescript/spago#the-workspace"]);
      }
      ;
      if (v1 instanceof Right && v1.value0.yaml.workspace instanceof Just) {
        return discard19(doMigrateConfig("spago.yaml")(v1.value0))(function() {
          return pure55({
            workspace: v1.value0.yaml.workspace.value0,
            "package": v1["value0"]["yaml"]["package"],
            workspaceDoc: v1.value0.doc
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 185, column 85 - line 200, column 53): " + [v1.constructor.name]);
    }))(function(v1) {
      return discard19(logDebug14("Gathering all the spago configs in the tree..."))(function() {
        return bind42(liftAff4(gitignoringGlob(cwd2)(["**/spago.yaml"])))(function(otherConfigPaths) {
          return discard19(unless5($$null(otherConfigPaths))(logDebug24([toDoc5("Found packages at these paths:"), indent(lines4(map410(toDoc5)(otherConfigPaths)))])))(function() {
            var readWorkspaceConfig = function(path14) {
              return bind42(readConfig(path14))(function(maybeConfig) {
                return bind42(exists1(concat3([dirname(path14), "test"])))(function(hasTests) {
                  return pure55(function() {
                    if (maybeConfig instanceof Left) {
                      return new Left(toDoc22([toDoc5("Could not read config at path " + path14), toDoc5("Error was: "), indent(toDoc13(maybeConfig.value0))]));
                    }
                    ;
                    if (maybeConfig instanceof Right) {
                      return new Right({
                        config: maybeConfig.value0,
                        hasTests,
                        configPath: path14,
                        packagePath: dirname(path14)
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Config (line 214, column 14 - line 221, column 87): " + [maybeConfig.constructor.name]);
                  }());
                });
              });
            };
            return bind42(map220(partitionMap3(identity28))(traverse5(readWorkspaceConfig)(otherConfigPaths)))(function(v2) {
              return discard19(unless5($$null(v2.left))(logWarn22(append115([toDoc5("Failed to read some configs:")])(v2.left))))(function() {
                var configPathsWithWorkspaces = mapMaybe(function(readResult) {
                  return voidRight5(readResult.packagePath)(readResult.config.yaml.workspace);
                })(v2.right);
                return discard19(unless5($$null(configPathsWithWorkspaces))(logDebug14("Found these paths with workspaces: " + show33(configPathsWithWorkspaces))))(function() {
                  return bind42(function() {
                    var fn = function(v3) {
                      return function(v4) {
                        var $307 = any2(function(p) {
                          return isJust(stripPrefix2(p)(v4.packagePath));
                        })(configPathsWithWorkspaces);
                        if ($307) {
                          return pure55({
                            right: v3.right,
                            left: cons(v4.packagePath)(v3.left)
                          });
                        }
                        ;
                        if (v4["config"]["yaml"]["package"] instanceof Nothing) {
                          return pure55({
                            right: v3.right,
                            left: cons(v4.packagePath)(v3.left)
                          });
                        }
                        ;
                        if (v4["config"]["yaml"]["package"] instanceof Just) {
                          return discard19(doMigrateConfig(v4.configPath)(v4.config))(function() {
                            return pure55({
                              left: v3.left,
                              right: cons(new Tuple(v4["config"]["yaml"]["package"].value0.name, {
                                "package": v4["config"]["yaml"]["package"].value0,
                                hasTests: v4.hasTests,
                                path: v4.packagePath,
                                doc: v4.config.doc
                              }))(v3.right)
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Config (line 239, column 11 - line 246, column 132): " + [v4["config"]["yaml"]["package"].constructor.name]);
                      };
                    };
                    return foldM4(fn)({
                      right: [],
                      left: []
                    })(v2.right);
                  }())(function(v3) {
                    return discard19(unless5($$null(v3.left))(logDebug32(append115(["Excluding configs that use a different workspace (directly or implicitly via parent directory's config):"])(sort4(v3.left)))))(function() {
                      return bind42(function() {
                        if (v1["package"] instanceof Nothing) {
                          return pure55([]);
                        }
                        ;
                        if (v1["package"] instanceof Just) {
                          return bind42(rootPackageToWorkspacePackage1({
                            rootPackage: v1["package"].value0,
                            workspaceDoc: v1.workspaceDoc
                          }))(function(rootPackage$prime) {
                            return pure55([new Tuple(v1["package"].value0.name, rootPackage$prime)]);
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Config (line 253, column 18 - line 257, column 51): " + [v1["package"].constructor.name]);
                      }())(function(rootPackage) {
                        var workspacePackages = fromFoldable33(append115(v3.right)(rootPackage));
                        return bind42(function() {
                          if (v.maybeSelectedPackage instanceof Nothing) {
                            var v4 = uncons(toUnfoldable18(workspacePackages));
                            if (v4 instanceof Nothing) {
                              return die32("No valid packages found in the current project, halting.");
                            }
                            ;
                            if (v4 instanceof Just && v4.value0.tail.length === 0) {
                              return discard19(logDebug14("Selecting package " + (print5(v4.value0.head.value0) + (" from " + v4.value0.head.value1.path))))(function() {
                                return pure55(new Just(v4.value0.head.value1));
                              });
                            }
                            ;
                            return pure55(Nothing.value);
                          }
                          ;
                          if (v.maybeSelectedPackage instanceof Just) {
                            var v4 = lookup9(v.maybeSelectedPackage.value0)(workspacePackages);
                            if (v4 instanceof Nothing) {
                              return die12(append115([toDoc5("Selected package " + (print5(v.maybeSelectedPackage.value0) + " was not found in the local packages."))])(function() {
                                var v5 = fromFoldable42(keys3(workspacePackages));
                                if (v5.length === 0) {
                                  return [toDoc5("No available packages.")];
                                }
                                ;
                                var v6 = typoSuggestions2(print5)(v.maybeSelectedPackage.value0)(v5);
                                if (v6.length === 0) {
                                  return [toDoc5("All available packages:"), indent(toDoc32(v5))];
                                }
                                ;
                                return [toDoc5("Did you mean:"), indent(toDoc32(v6))];
                              }()));
                            }
                            ;
                            if (v4 instanceof Just) {
                              return pure55(new Just(v4.value0));
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Config (line 271, column 18 - line 282, column 22): " + [v4.constructor.name]);
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Config (line 262, column 20 - line 282, column 22): " + [v.maybeSelectedPackage.constructor.name]);
                        }())(function(maybeSelected) {
                          return discard19(logDebug14("Reading the lockfile..."))(function() {
                            return bind42(bind42(exists1("spago.lock"))(function(v4) {
                              if (!v4) {
                                return pure55(new Left("No lockfile found"));
                              }
                              ;
                              if (v4) {
                                return bind42(liftAff4(readYamlFile(lockfileCodec)("spago.lock")))(function(v5) {
                                  if (v5 instanceof Left) {
                                    return discard19(logWarn32(["Your project contains a spago.lock file, but it cannot be decoded. Spago will generate a new one.", "Error was: " + v5.value0]))(function() {
                                      return pure55(new Left("Could not decode lockfile"));
                                    });
                                  }
                                  ;
                                  if (v5 instanceof Right) {
                                    var v6 = shouldComputeNewLockfile({
                                      workspace: v1.workspace,
                                      workspacePackages
                                    })(v5.value0.workspace);
                                    if (v.pureBuild) {
                                      return discard19(logDebug14("Using lockfile because of --pure flag"))(function() {
                                        return pure55(new Right(v5.value0));
                                      });
                                    }
                                    ;
                                    if (!v.pureBuild && v6) {
                                      return pure55(new Left("Lockfile is out of date"));
                                    }
                                    ;
                                    if (!v.pureBuild && !v6) {
                                      return discard19(logDebug14("Lockfile is up to date, using it"))(function() {
                                        return pure55(new Right(v5.value0));
                                      });
                                    }
                                    ;
                                    throw new Error("Failed pattern match at Spago.Config (line 297, column 25 - line 304, column 32): " + [v.pureBuild.constructor.name, v6.constructor.name]);
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Config (line 287, column 75 - line 304, column 32): " + [v5.constructor.name]);
                                });
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Config (line 285, column 55 - line 304, column 32): " + [v4.constructor.name]);
                            }))(function(maybeLockfileContents) {
                              return bind42(ask6)(function(v4) {
                                return bind42(function() {
                                  if (v1.workspace.packageSet instanceof Nothing) {
                                    return discard19(logDebug14("Did not find a package set in your config, using Registry solver"))(function() {
                                      return pure55(Nothing.value);
                                    });
                                  }
                                  ;
                                  if (maybeLockfileContents instanceof Right) {
                                    return discard19(logDebug14("Found the lockfile, using the package set from there"))(function() {
                                      return pure55(maybeLockfileContents.value0.workspace.package_set);
                                    });
                                  }
                                  ;
                                  if (maybeLockfileContents instanceof Left && (v1.workspace.packageSet instanceof Just && v1.workspace.packageSet.value0 instanceof SetFromRegistry)) {
                                    return discard19(logDebug14(maybeLockfileContents.value0))(function() {
                                      return discard19(logDebug14("Reading the package set from the Registry repo..."))(function() {
                                        return bind42(readPackageSet(v1.workspace.packageSet.value0.value0.registry))(function(v6) {
                                          return discard19(logDebug14("Read the package set from the Registry repo"))(function() {
                                            return pure55(new Just({
                                              content: map72(RemoteRegistryVersion.create)(v6.packages),
                                              address: v1.workspace.packageSet.value0,
                                              compiler: caret(v6.compiler)
                                            }));
                                          });
                                        });
                                      });
                                    });
                                  }
                                  ;
                                  if (maybeLockfileContents instanceof Left && (v1.workspace.packageSet instanceof Just && v1.workspace.packageSet.value0 instanceof SetFromPath)) {
                                    return discard19(logDebug14(maybeLockfileContents.value0))(function() {
                                      return discard19(logDebug14("Reading the package set from local path: " + v1.workspace.packageSet.value0.value0.path))(function() {
                                        return bind42(liftAff4(readJsonFile(remotePackageSetCodec)(v1.workspace.packageSet.value0.value0.path)))(function(v5) {
                                          if (v5 instanceof Left) {
                                            return die32("Couldn't read the package set: " + v5.value0);
                                          }
                                          ;
                                          if (v5 instanceof Right) {
                                            return discard19(logInfo4("Read the package set from local path"))(function() {
                                              return pure55(new Just({
                                                content: v5.value0.packages,
                                                address: v1.workspace.packageSet.value0,
                                                compiler: caret(v5.value0.compiler)
                                              }));
                                            });
                                          }
                                          ;
                                          throw new Error("Failed pattern match at Spago.Config (line 333, column 64 - line 341, column 14): " + [v5.constructor.name]);
                                        });
                                      });
                                    });
                                  }
                                  ;
                                  if (maybeLockfileContents instanceof Left && (v1.workspace.packageSet instanceof Just && v1.workspace.packageSet.value0 instanceof SetFromUrl)) {
                                    return bind42(function() {
                                      if (v4.offline instanceof Offline) {
                                        return die32("You are offline, but the package set is not cached locally. Please connect to the internet and try again.");
                                      }
                                      ;
                                      if (v4.offline instanceof Online) {
                                        return discard19(logDebug14(maybeLockfileContents.value0))(function() {
                                          return discard19(logDebug14("Reading the package set from URL: " + v1.workspace.packageSet.value0.value0.url))(function() {
                                            return bind42(function() {
                                              var v5 = parseUrl(v1.workspace.packageSet.value0.value0.url);
                                              if (v5 instanceof Left) {
                                                return die32("Could not parse URL for the package set, error: " + show114(v5.value0));
                                              }
                                              ;
                                              if (v5 instanceof Right) {
                                                return pure55(v5.value0.href);
                                              }
                                              ;
                                              throw new Error("Failed pattern match at Spago.Config (line 349, column 18 - line 351, column 35): " + [v5.constructor.name]);
                                            }())(function(url2) {
                                              return bind42(liftAff4(request2({
                                                headers: defaultRequest.headers,
                                                content: defaultRequest.content,
                                                username: defaultRequest.username,
                                                password: defaultRequest.password,
                                                withCredentials: defaultRequest.withCredentials,
                                                timeout: defaultRequest.timeout,
                                                method: new Left(GET.value),
                                                responseFormat: string4,
                                                url: url2
                                              })))(function(response) {
                                                if (response instanceof Left) {
                                                  return die32("Couldn't fetch package set:\n  " + printError2(response.value0));
                                                }
                                                ;
                                                if (response instanceof Right && notEq32(response.value0.status)(200)) {
                                                  return die32("Couldn't fetch package set, status was not ok " + (show211(response.value0.status) + (", got answer:\n  " + response.value0.body)));
                                                }
                                                ;
                                                if (response instanceof Right) {
                                                  return discard19(logDebug14("Fetching package set - got status: " + show211(response.value0.status)))(function() {
                                                    var v5 = parseJson(remotePackageSetCodec)(response.value0.body);
                                                    if (v5 instanceof Right) {
                                                      return discard19(logDebug14("Read a new-format package set from URL"))(function() {
                                                        return pure55({
                                                          compiler: v5.value0.compiler,
                                                          remotePackageSet: v5.value0.packages
                                                        });
                                                      });
                                                    }
                                                    ;
                                                    if (v5 instanceof Left) {
                                                      return discard19(logDebug32(["Couldn't parse remote package set in modern format, error:", "  " + show34(v5.value0), "Trying with the legacy format..."]))(function() {
                                                        var v6 = parseJson(legacyPackageSetCodec)(response.value0.body);
                                                        if (v6 instanceof Left) {
                                                          return die32("Couldn't parse remote package set, error: " + show34(v6.value0));
                                                        }
                                                        ;
                                                        if (v6 instanceof Right) {
                                                          return discard19(logDebug14("Read legacy package set from URL"))(function() {
                                                            return bind42(function() {
                                                              var v7 = lookup9(unsafeFromRight(parse3("metadata")))(v6.value0);
                                                              if (v7 instanceof Just) {
                                                                return pure55(unsafeFromRight(parseLenientVersion(v7.value0.version)));
                                                              }
                                                              ;
                                                              if (v7 instanceof Nothing) {
                                                                return die32("Couldn't find 'metadata' package in legacy package set.");
                                                              }
                                                              ;
                                                              throw new Error("Failed pattern match at Spago.Config (line 369, column 34 - line 371, column 99): " + [v7.constructor.name]);
                                                            }())(function(version4) {
                                                              return pure55({
                                                                compiler: version4,
                                                                remotePackageSet: map72(RemoteLegacyPackage.create)(v6.value0)
                                                              });
                                                            });
                                                          });
                                                        }
                                                        ;
                                                        throw new Error("Failed pattern match at Spago.Config (line 365, column 19 - line 372, column 101): " + [v6.constructor.name]);
                                                      });
                                                    }
                                                    ;
                                                    throw new Error("Failed pattern match at Spago.Config (line 359, column 15 - line 372, column 101): " + [v5.constructor.name]);
                                                  });
                                                }
                                                ;
                                                throw new Error("Failed pattern match at Spago.Config (line 353, column 11 - line 372, column 101): " + [response.constructor.name]);
                                              });
                                            });
                                          });
                                        });
                                      }
                                      ;
                                      throw new Error("Failed pattern match at Spago.Config (line 344, column 17 - line 372, column 101): " + [v4.offline.constructor.name]);
                                    }())(function(result) {
                                      return pure55(new Just({
                                        content: result.remotePackageSet,
                                        compiler: caret(result.compiler),
                                        address: v1.workspace.packageSet.value0
                                      }));
                                    });
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Config (line 308, column 21 - line 377, column 10): " + [maybeLockfileContents.constructor.name, v1.workspace.packageSet.constructor.name]);
                                }())(function(packageSetInfo) {
                                  var extraPackages = map72(fromExtraPackage)(fromMaybe(empty4)(v1.workspace.extraPackages));
                                  var localPackagesOverlap = intersection3(keys3(workspacePackages))(keys3(extraPackages));
                                  var buildType = function() {
                                    var localPackages = union6(map72(WorkspacePackage.create)(workspacePackages))(extraPackages);
                                    if (packageSetInfo instanceof Nothing) {
                                      return new RegistrySolverBuild(localPackages);
                                    }
                                    ;
                                    if (packageSetInfo instanceof Just) {
                                      return new PackageSetBuild(packageSetInfo.value0, union6(localPackages)(map72(fromRemotePackage)(packageSetInfo.value0.content)));
                                    }
                                    ;
                                    throw new Error("Failed pattern match at Spago.Config (line 394, column 9 - line 396, column 107): " + [packageSetInfo.constructor.name]);
                                  }();
                                  var packageSet = {
                                    buildType,
                                    lockfile: maybeLockfileContents
                                  };
                                  return discard19(unless5(isEmpty2(localPackagesOverlap))(die12(append115([toDoc5("Some packages in your local tree overlap with ones you have declared in your workspace configuration."), toDoc5("To resolve this error, rename these packages declared in `extra_packages` to a different name:")])(map410(function(p) {
                                    return indent(toDoc5("- " + print5(p)));
                                  })(fromFoldable42(localPackagesOverlap))))))(function() {
                                    return discard19(function() {
                                      if (maybeSelected instanceof Just) {
                                        return discard19(logSuccess1("Selecting package to build: " + print5(maybeSelected["value0"]["package"].name)))(function() {
                                          return logDebug14("Package path: " + maybeSelected.value0.path);
                                        });
                                      }
                                      ;
                                      if (maybeSelected instanceof Nothing) {
                                        return logSuccess22([toDoc5("Selecting " + (show43(size(workspacePackages)) + " packages to build:")), indent22(toDoc32(toUnfoldable23(keys3(workspacePackages))))]);
                                      }
                                      ;
                                      throw new Error("Failed pattern match at Spago.Config (line 411, column 3 - line 419, column 10): " + [maybeSelected.constructor.name]);
                                    }())(function() {
                                      var buildOptions = {
                                        output: bindFlipped10(function(v5) {
                                          return v5.output;
                                        })(v1.workspace.buildOpts),
                                        censorLibWarnings: bindFlipped10(function(v5) {
                                          return v5.censorLibraryWarnings;
                                        })(v1.workspace.buildOpts),
                                        statVerbosity: bindFlipped10(function(v5) {
                                          return v5.statVerbosity;
                                        })(v1.workspace.buildOpts)
                                      };
                                      return pure55({
                                        selected: maybeSelected,
                                        packageSet,
                                        compatibleCompiler: fromMaybe(widestRange)(map126(function(v5) {
                                          return v5.compiler;
                                        })(packageSetInfo)),
                                        backend: v1.workspace.backend,
                                        buildOptions,
                                        doc: v1.workspaceDoc,
                                        workspaceConfig: v1.workspace,
                                        rootPackage: v1["package"]
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};
var fileSystemCharEscape = /* @__PURE__ */ function() {
  var commonlyUsedChars = map410(codePointFromChar)([".", ",", "-", "_", "+"]);
  var ignoreEscape = disj1(isLower)(disj1(isDecDigit)(flip(elem2(eqCodePoint))(commonlyUsedChars)));
  var escapeCodePoint = function(cp) {
    if (ignoreEscape(cp)) {
      return singleton7(cp);
    }
    ;
    if (otherwise) {
      return "%" + toStringAs(hexadecimal)(fromEnum13(cp));
    }
    ;
    throw new Error("Failed pattern match at Spago.Config (line 496, column 3 - line 496, column 41): " + [cp.constructor.name]);
  };
  var $417 = fold2(monoidString);
  var $418 = map410(escapeCodePoint);
  return function($419) {
    return $417($418(toCodePointArray($419)));
  };
}();
var getPackageLocation = function(name5) {
  return function($420) {
    return mkRelative(function(v) {
      if (v instanceof RegistryVersion) {
        return concat3([localCachePackagesPath, print5(name5) + ("-" + print6(v.value0))]);
      }
      ;
      if (v instanceof GitPackage) {
        return concat3([localCachePackagesPath, print5(name5), fileSystemCharEscape(v.value0.ref)]);
      }
      ;
      if (v instanceof LocalPackage) {
        return v.value0.path;
      }
      ;
      if (v instanceof WorkspacePackage) {
        return v.value0.path;
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 474, column 48 - line 478, column 36): " + [v.constructor.name]);
    }($420));
  };
};
var sourceGlob = function(withTestGlobs) {
  return function(name5) {
    return function($$package2) {
      return map410(function(p) {
        return concat3([getPackageLocation(name5)($$package2), p]);
      })(function() {
        if ($$package2 instanceof WorkspacePackage) {
          if (!$$package2.value0.hasTests && withTestGlobs instanceof OnlyTestGlobs) {
            return [];
          }
          ;
          if (!$$package2.value0.hasTests) {
            return [srcGlob];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof OnlyTestGlobs) {
            return [testGlob2];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof NoTestGlobs) {
            return [srcGlob];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof WithTestGlobs) {
            return [srcGlob, testGlob2];
          }
          ;
          throw new Error("Failed pattern match at Spago.Config (line 510, column 7 - line 515, column 53): " + [$$package2.value0.hasTests.constructor.name, withTestGlobs.constructor.name]);
        }
        ;
        if ($$package2 instanceof GitPackage && $$package2.value0.subdir instanceof Just) {
          return [concat3([$$package2.value0.subdir.value0, srcGlob])];
        }
        ;
        return [srcGlob];
      }());
    };
  };
};
var addRangesToConfig = function(doc) {
  var $421 = runEffectFn2(addRangesToConfigImpl)(doc);
  var $422 = map410(function(v) {
    return new Tuple(print5(v.value0), printSpagoRange(v.value1));
  });
  return function($423) {
    return $421(fromFoldable52($422(toUnfoldable18($423))));
  };
};
var addPackagesToConfig = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var discard213 = discard18(MonadEffect0.Monad0().Bind1());
  var liftEffect19 = liftEffect(MonadEffect0);
  var liftAff1 = liftAff(dictMonadAff);
  return function(configPath) {
    return function(doc) {
      return function(isTest) {
        return function(pkgs) {
          return discard213(liftEffect19(function() {
            return addPackagesToConfigImpl(doc, isTest, map410(print5)(pkgs));
          }))(function() {
            return liftAff1(writeYamlDocFile(configPath)(doc));
          });
        };
      };
    };
  };
};

// output/Spago.Generated.BuildInfo/index.js
var packages2 = {
  "docs-search-client-halogen": "0.0.0",
  "docs-search-common": "0.0.0",
  "docs-search-index": "0.0.0",
  spago: "0.93.39",
  "spago-bin": "0.93.39",
  "spago-core": "0.0.0"
};

// output/Spago.BuildInfo/index.js
var map73 = /* @__PURE__ */ map(functorMaybe);
var map127 = /* @__PURE__ */ map(functorArray);
var bind43 = /* @__PURE__ */ bind(bindSpago);
var toUnfoldable19 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var writeTextFile4 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var exists6 = /* @__PURE__ */ exists2(monadEffectSpago);
var readTextFile6 = /* @__PURE__ */ readTextFile4(monadAffSpago);
var when12 = /* @__PURE__ */ when(applicativeSpago);
var mkPackageBuildInfo = function(v) {
  return {
    name: print5(v["package"].name),
    version: fromMaybe("0.0.0")(map73(print6)(map73(function(v1) {
      return v1.version;
    })(v["package"].publish)))
  };
};
var mkBuildInfo = function(v) {
  var renderPackageType = function(p) {
    return '"' + (p.name + '" :: String');
  };
  var renderPackage = function(p) {
    return '"' + (p.name + ('": "' + (p.version + '"')));
  };
  var recordType = "{ " + (joinWith(", ")(map127(renderPackageType)(v.packages)) + " }");
  return joinWith("\n")(["-- @inline export packages always", "-- @inline export pursVersion always", "-- @inline export spagoVersion always", "module Spago.Generated.BuildInfo where", "", "packages :: " + recordType, "packages =", "  { " + (joinWith("\n  , ")(map127(renderPackage)(v.packages)) + "\n  }"), "", "pursVersion :: String", 'pursVersion = "' + (v.pursVersion + '"'), "", "spagoVersion :: String", 'spagoVersion = "' + (packages2["spago-bin"] + '"'), ""]);
};
var buildInfoPath = /* @__PURE__ */ concat3([localCachePath, "BuildInfo.purs"]);
var writeBuildInfo = /* @__PURE__ */ bind43(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  var buildInfo = {
    pursVersion: print6(v.purs.version),
    packages: map127(mkPackageBuildInfo)(toUnfoldable19(getWorkspacePackages(v.workspace.packageSet)))
  };
  var buildInfoString = mkBuildInfo(buildInfo);
  var writeIt = writeTextFile4(buildInfoPath)(buildInfoString);
  return bind43(exists6(buildInfoPath))(function(v1) {
    if (!v1) {
      return writeIt;
    }
    ;
    if (v1) {
      return bind43(readTextFile6(buildInfoPath))(function(currentContent) {
        return when12(currentContent !== buildInfoString)(writeIt);
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.BuildInfo (line 48, column 31 - line 53, column 16): " + [v1.constructor.name]);
  });
});

// output/Registry.Solver/index.js
var $runtime_lazy12 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var versionIsSymbol3 = {
  reflectSymbol: function() {
    return "version";
  }
};
var packageIsSymbol = {
  reflectSymbol: function() {
    return "package";
  }
};
var append29 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupNonEmptySet(/* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(/* @__PURE__ */ ordRecordCons(ordRecordNil)()(versionIsSymbol3)(ordVersion))()(packageIsSymbol)(ordPackageName))));
var append116 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSet(ordPackageName));
var compare7 = /* @__PURE__ */ compare(ordVersion);
var semigroupRecord3 = /* @__PURE__ */ semigroupRecord();
var lowerIsSymbol = {
  reflectSymbol: function() {
    return "lower";
  }
};
var semigroupRecordCons2 = /* @__PURE__ */ semigroupRecordCons(lowerIsSymbol)();
var upperIsSymbol = {
  reflectSymbol: function() {
    return "upper";
  }
};
var semigroupRecordCons1 = /* @__PURE__ */ semigroupRecordCons(upperIsSymbol)()(semigroupRecordNil);
var over9 = /* @__PURE__ */ over()();
var map74 = /* @__PURE__ */ map(functorFn);
var lmap15 = /* @__PURE__ */ lmap(bifunctorEither);
var eqRec4 = /* @__PURE__ */ eqRec();
var eqRowCons3 = /* @__PURE__ */ eqRowCons(eqRowNil)();
var eq29 = /* @__PURE__ */ eq(/* @__PURE__ */ eqNonEmptySet(/* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(versionIsSymbol3)(eqVersion))()(packageIsSymbol)(eqPackageName))));
var eq113 = /* @__PURE__ */ eq(/* @__PURE__ */ eqSet(eqPackageName));
var eq210 = /* @__PURE__ */ eq(eqVersion);
var intercalateMap2 = /* @__PURE__ */ intercalateMap(foldable1NonEmptySet)(semigroupString);
var fromFoldable30 = /* @__PURE__ */ fromFoldable2(foldableSet);
var difference5 = /* @__PURE__ */ difference3(ordPackageName);
var map128 = /* @__PURE__ */ map19(ordPackageName);
var mempty18 = /* @__PURE__ */ mempty(monoidString);
var intercalateMap1 = /* @__PURE__ */ intercalateMap(foldable1NonEmptyArray)(semigroupString);
var unwrap13 = /* @__PURE__ */ unwrap();
var greaterThanOrEq3 = /* @__PURE__ */ greaterThanOrEq(ordVersion);
var fold16 = /* @__PURE__ */ fold2(monoidString);
var intercalate12 = /* @__PURE__ */ intercalate(foldableMap)(monoidString);
var mapWithIndex4 = /* @__PURE__ */ mapWithIndex(functorWithIndexMap);
var fold17 = /* @__PURE__ */ fold(foldableMap)(monoidString);
var foldMapWithIndex2 = /* @__PURE__ */ foldMapWithIndex(foldableWithIndexSemigroupMap);
var monoidSemigroupMap2 = /* @__PURE__ */ monoidSemigroupMap(ordPackageName);
var semigroupSemigroupMap2 = /* @__PURE__ */ semigroupSemigroupMap(ordPackageName);
var lookup10 = /* @__PURE__ */ lookup3(ordPackageName);
var lessThan4 = /* @__PURE__ */ lessThan(ordVersion);
var greaterThan5 = /* @__PURE__ */ greaterThan(ordVersion);
var mapWithIndex1 = /* @__PURE__ */ mapWithIndex(functorWithIndexSemigroupMap);
var filterWithKey2 = /* @__PURE__ */ filterWithKey(ordVersion);
var coerce9 = /* @__PURE__ */ coerce();
var map221 = /* @__PURE__ */ map(functorMap);
var pure56 = /* @__PURE__ */ pure(applicativeArray);
var filterKeys2 = /* @__PURE__ */ filterKeys(ordVersion);
var heytingAlgebraFunction2 = /* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean);
var not1 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraFunction2));
var member7 = /* @__PURE__ */ member2(ordVersion);
var foldMap9 = /* @__PURE__ */ foldMap(foldableMap)(/* @__PURE__ */ monoidSemigroupMap2(semigroupArray));
var append33 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSet(ordVersion));
var $$delete8 = /* @__PURE__ */ $$delete2(ordPackageName);
var insert12 = /* @__PURE__ */ insert2(ordPackageName);
var append42 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSemigroupMap2(semigroupArray));
var wrap3 = /* @__PURE__ */ wrap();
var map310 = /* @__PURE__ */ map(functorSemigroupMap);
var anyWithIndex2 = /* @__PURE__ */ anyWithIndex(foldableWithIndexSemigroupMap)(/* @__PURE__ */ heytingAlgebraRecord()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "added";
  }
})()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "failedAlready";
  }
})()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "failedNow";
  }
})()(heytingAlgebraRecordNil)(heytingAlgebraBoolean))(heytingAlgebraBoolean))(heytingAlgebraBoolean)));
var not22 = /* @__PURE__ */ not(heytingAlgebraFunction2);
var $$for6 = /* @__PURE__ */ $$for(applicativeMaybe)(traversableMap);
var bind44 = /* @__PURE__ */ bind(bindMaybe);
var pure120 = /* @__PURE__ */ pure(applicativeMaybe);
var discard20 = /* @__PURE__ */ discard(discardUnit);
var discard110 = /* @__PURE__ */ discard20(bindMaybe);
var forWithIndex_3 = /* @__PURE__ */ forWithIndex_(applicativeMaybe)(foldableWithIndexSemigroupMap);
var guard12 = /* @__PURE__ */ guard(alternativeMaybe);
var join7 = /* @__PURE__ */ join(bindFn);
var eqSemigroupMap2 = /* @__PURE__ */ eqSemigroupMap(eqPackageName);
var insert1 = /* @__PURE__ */ insert2(ordVersion);
var alter3 = /* @__PURE__ */ alter(ordPackageName);
var traverseWithIndex3 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexMap)(applicativeEither);
var pure212 = /* @__PURE__ */ pure(applicativeEither);
var forWithIndex2 = /* @__PURE__ */ forWithIndex(applicativeEither)(traversableWithIndexMap);
var filterWithKey1 = /* @__PURE__ */ filterWithKey(ordPackageName);
var foldlWithIndex2 = /* @__PURE__ */ foldlWithIndex(foldableWithIndexSemigroupMap);
var traverse6 = /* @__PURE__ */ traverse(traversableSemigroupMap)(applicativeMaybe);
var fromFoldable112 = /* @__PURE__ */ fromFoldable(foldableSemigroupMap);
var map411 = /* @__PURE__ */ map(functorNonEmptyArray);
var un10 = /* @__PURE__ */ un();
var mapFlipped11 = /* @__PURE__ */ mapFlipped(functorMap);
var mapMaybeWithKey2 = /* @__PURE__ */ mapMaybeWithKey(ordPackageName);
var monoidEndo2 = /* @__PURE__ */ monoidEndo(categoryFn);
var traverseWithIndex1 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexSemigroupMap)(/* @__PURE__ */ applicativeTuple(monoidEndo2));
var mempty19 = /* @__PURE__ */ mempty(monoidEndo2);
var discard25 = /* @__PURE__ */ discard20(bindEither);
var pure310 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var Root = /* @__PURE__ */ function() {
  function Root2() {
  }
  ;
  Root2.value = new Root2();
  return Root2;
}();
var Trial = /* @__PURE__ */ function() {
  function Trial2() {
  }
  ;
  Trial2.value = new Trial2();
  return Trial2;
}();
var Solving = /* @__PURE__ */ function() {
  function Solving2(value0) {
    this.value0 = value0;
  }
  ;
  Solving2.create = function(value0) {
    return new Solving2(value0);
  };
  return Solving2;
}();
var Pos = /* @__PURE__ */ function() {
  function Pos2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Pos2.create = function(value0) {
    return function(value12) {
      return new Pos2(value0, value12);
    };
  };
  return Pos2;
}();
var Sourced = /* @__PURE__ */ function() {
  function Sourced2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Sourced2.create = function(value0) {
    return function(value12) {
      return new Sourced2(value0, value12);
    };
  };
  return Sourced2;
}();
var LastSuccess = function(x) {
  return x;
};
var Conflicts = /* @__PURE__ */ function() {
  function Conflicts2(value0) {
    this.value0 = value0;
  }
  ;
  Conflicts2.create = function(value0) {
    return new Conflicts2(value0);
  };
  return Conflicts2;
}();
var WhileSolving = /* @__PURE__ */ function() {
  function WhileSolving2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  WhileSolving2.create = function(value0) {
    return function(value12) {
      return new WhileSolving2(value0, value12);
    };
  };
  return WhileSolving2;
}();
var semigroupLocalSolverPosit = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Trial) {
        return Trial.value;
      }
      ;
      if (v1 instanceof Trial) {
        return Trial.value;
      }
      ;
      if (v instanceof Root) {
        return Root.value;
      }
      ;
      if (v1 instanceof Root) {
        return Root.value;
      }
      ;
      if (v instanceof Solving && v1 instanceof Solving) {
        return new Solving(append29(v.value0)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 573, column 1 - line 578, column 56): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var append52 = /* @__PURE__ */ append(semigroupLocalSolverPosit);
var semigroupSolverPosition = {
  append: function(v) {
    return function(v1) {
      return new Pos(append52(v.value0)(v1.value0), append116(v.value1)(v1.value1));
    };
  }
};
var append62 = /* @__PURE__ */ append(semigroupSolverPosition);
var semigroupMaxSourced = {
  append: function(v) {
    return function(v1) {
      var v2 = compare7(v.value0)(v1.value0);
      if (v2 instanceof GT) {
        return v;
      }
      ;
      if (v2 instanceof LT) {
        return v1;
      }
      ;
      if (v2 instanceof EQ) {
        return new Sourced(v.value0, append62(v.value1)(v1.value1));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 632, column 5 - line 635, column 47): " + [v2.constructor.name]);
    };
  }
};
var semigroupMinSourced = {
  append: function(v) {
    return function(v1) {
      var v2 = compare7(v.value0)(v1.value0);
      if (v2 instanceof LT) {
        return v;
      }
      ;
      if (v2 instanceof GT) {
        return v1;
      }
      ;
      if (v2 instanceof EQ) {
        return new Sourced(v.value0, append62(v.value1)(v1.value1));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 621, column 5 - line 624, column 47): " + [v2.constructor.name]);
    };
  }
};
var semigroupLoose = /* @__PURE__ */ semigroupRecord3(/* @__PURE__ */ semigroupRecordCons2(/* @__PURE__ */ semigroupRecordCons1(semigroupMaxSourced))(semigroupMinSourced));
var foldMap16 = /* @__PURE__ */ foldMap13(/* @__PURE__ */ semigroupApp(/* @__PURE__ */ applyMap(ordPackageName))(semigroupLoose));
var semigroupIntersection = /* @__PURE__ */ semigroupRecord3(/* @__PURE__ */ semigroupRecordCons2(/* @__PURE__ */ semigroupRecordCons1(semigroupMinSourced))(semigroupMaxSourced));
var semigroupSemigroupMap1 = /* @__PURE__ */ semigroupSemigroupMap2(semigroupIntersection);
var semigroupSemigroupMap22 = /* @__PURE__ */ semigroupSemigroupMap(ordVersion)(semigroupSemigroupMap1);
var monoidSemigroupMap1 = /* @__PURE__ */ monoidSemigroupMap2(semigroupSemigroupMap22);
var foldMapWithIndex1 = /* @__PURE__ */ foldMapWithIndex2(monoidSemigroupMap1);
var mempty24 = /* @__PURE__ */ mempty(monoidSemigroupMap1);
var foldMap23 = /* @__PURE__ */ foldMap(foldableSemigroupMap)(monoidSemigroupMap1);
var semigroupSemigroupMap3 = /* @__PURE__ */ semigroupSemigroupMap2(semigroupSemigroupMap22);
var mempty32 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidSemigroupMap(ordVersion)(semigroupSemigroupMap1));
var monoidSemigroupMap22 = /* @__PURE__ */ monoidSemigroupMap2(semigroupIntersection);
var mempty42 = /* @__PURE__ */ mempty(monoidSemigroupMap22);
var append72 = /* @__PURE__ */ append(semigroupIntersection);
var monoidTuple2 = /* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidDisj(heytingAlgebraBoolean))(monoidSemigroupMap22);
var mempty52 = /* @__PURE__ */ mempty(monoidTuple2);
var foldMapWithIndex22 = /* @__PURE__ */ foldMapWithIndex2(monoidTuple2);
var append82 = /* @__PURE__ */ append(semigroupSemigroupMap1);
var foldMapWithIndex3 = /* @__PURE__ */ foldMapWithIndex2(monoidSemigroupMap22);
var append92 = /* @__PURE__ */ append(semigroupSemigroupMap3);
var functorLastSuccess = {
  map: function(f) {
    return over9(LastSuccess)(map74(lmap15(f)));
  }
};
var eqLocalSolverPosition = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Root && y instanceof Root) {
        return true;
      }
      ;
      if (x instanceof Trial && y instanceof Trial) {
        return true;
      }
      ;
      if (x instanceof Solving && y instanceof Solving) {
        return eq29(x.value0)(y.value0);
      }
      ;
      return false;
    };
  }
};
var eq43 = /* @__PURE__ */ eq(eqLocalSolverPosition);
var eqSolverPosition = {
  eq: function(x) {
    return function(y) {
      return eq43(x.value0)(y.value0) && eq113(x.value1)(y.value1);
    };
  }
};
var eq53 = /* @__PURE__ */ eq(eqSolverPosition);
var eqSourced = {
  eq: function(x) {
    return function(y) {
      return eq210(x.value0)(y.value0) && eq53(x.value1)(y.value1);
    };
  }
};
var eqMaxSourced = eqSourced;
var eqMinSourced = eqSourced;
var eqIntersection = /* @__PURE__ */ eqRec4(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons3(upperIsSymbol)(eqMinSourced))()(lowerIsSymbol)(eqMaxSourced));
var applyLastSuccess = {
  apply: function(v) {
    return function(v1) {
      return function(u) {
        var v2 = v1(u);
        if (v2 instanceof Right) {
          return new Right(v2.value0);
        }
        ;
        if (v2 instanceof Left) {
          var v3 = v(u);
          if (v3 instanceof Right) {
            return new Right(v3.value0);
          }
          ;
          if (v3 instanceof Left) {
            return new Left(v3.value0(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 730, column 9 - line 732, column 31): " + [v3.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 727, column 5 - line 732, column 31): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLastSuccess;
  }
};
var applicativeLastSuccess = {
  pure: /* @__PURE__ */ function() {
    var $601 = pure(applicativeFn);
    return function($602) {
      return LastSuccess($601(Left.create($602)));
    };
  }(),
  Apply0: function() {
    return applyLastSuccess;
  }
};
var sequence3 = /* @__PURE__ */ sequence(traversableMap)(applicativeLastSuccess);
var upperBound = function(v) {
  return v.upper.value0;
};
var solveSeed = function(v) {
  return {
    registry: v.registry,
    required: v.required,
    updated: v.registry
  };
};
var soleVersion = function(v) {
  return {
    lower: new Sourced(v, new Pos(Trial.value, empty5)),
    upper: new Sourced(bumpPatch(v), new Pos(Trial.value, empty5))
  };
};
var soleVersionOf = function($$package2) {
  return function(v) {
    return singleton10($$package2)(soleVersion(v));
  };
};
var printPackageVersion = function(v) {
  return print5(v["package"]) + ("@" + print6(v.version));
};
var printSolverPosition = function(v) {
  if (v.value0 instanceof Root) {
    return " (declared dependency)";
  }
  ;
  if (v.value0 instanceof Trial) {
    return " (attempted version)";
  }
  ;
  if (v.value0 instanceof Solving) {
    return " seen in " + (intercalateMap2(", ")(printPackageVersion)(v.value0.value0) + function() {
      var v1 = fromFoldable30(difference5(v.value1)(map128(function(v2) {
        return v2["package"];
      })(toSet(v.value0.value0))));
      if (v1 instanceof Nothing) {
        return mempty18;
      }
      ;
      if (v1 instanceof Just) {
        return " from declared dependencies " + intercalateMap1(", ")(print5)(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 165, column 10 - line 167, column 94): " + [v1.constructor.name]);
    }());
  }
  ;
  throw new Error("Failed pattern match at Registry.Solver (line 160, column 23 - line 167, column 94): " + [v.constructor.name]);
};
var printSourced = function() {
  return function($603) {
    return function(v) {
      return print6(v.value0) + printSolverPosition(v.value1);
    }(unwrap13($603));
  };
};
var printSourced1 = /* @__PURE__ */ printSourced();
var noUpdates = function(v) {
  return isEmpty(v.updated);
};
var lowerBound = function(v) {
  return v.lower.value0;
};
var printConflict = function(v) {
  return function(v1) {
    return function(v2) {
      if (greaterThanOrEq3(lowerBound(v2))(upperBound(v2))) {
        return fold16(["Conflict in version ranges for ", print5(v1), ":", "\n", v, "  >=", printSourced1(unwrap13(v2).lower), "\n", v, "  <", printSourced1(unwrap13(v2).upper)]);
      }
      ;
      return fold16(["No versions found in the registry for ", print5(v1), " in range", "\n", v, "  >=", printSourced1(unwrap13(v2).lower), "\n", v, "  <", printSourced1(unwrap13(v2).upper)]);
    };
  };
};
var printErrorAt = function(indent3) {
  return function(v) {
    if (v instanceof Conflicts) {
      return intercalate12("\n" + indent3)(mapWithIndex4(printConflict(indent3))(v.value0));
    }
    ;
    if (v instanceof WhileSolving) {
      return fold16(["While solving ", print5(v.value0), " each version could not be solved:", fold17(mapWithIndex4(function(version4) {
        return function(nested) {
          return fold16(["\n", indent3, "- ", print6(version4), ": ", "\n", indent3 + "  ", printErrorAt(indent3 + "  ")(nested)]);
        };
      })(v.value1))]);
    }
    ;
    throw new Error("Failed pattern match at Registry.Solver (line 181, column 23 - line 199, column 6): " + [v.constructor.name]);
  };
};
var printSolverError = /* @__PURE__ */ printErrorAt("");
var requirementUpdates = function(v) {
  return foldMapWithIndex1(function($$package2) {
    return function(newRange) {
      var changed = function() {
        var v12 = lookup10($$package2)(v.required);
        if (v12 instanceof Nothing) {
          return true;
        }
        ;
        if (v12 instanceof Just) {
          return lessThan4(lowerBound(v12.value0))(lowerBound(newRange)) || greaterThan5(upperBound(v12.value0))(upperBound(newRange));
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 514, column 9 - line 520, column 56): " + [v12.constructor.name]);
      }();
      var $471 = !changed;
      if ($471) {
        return mempty24;
      }
      ;
      var v1 = lookup10($$package2)(v.registry);
      if (v1 instanceof Just) {
        return singleton10($$package2)(v1.value0);
      }
      ;
      if (v1 instanceof Nothing) {
        return mempty24;
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 527, column 9 - line 529, column 28): " + [v1.constructor.name]);
    };
  });
};
var satisfies = function(v) {
  return function(r) {
    return greaterThanOrEq3(v)(lowerBound(r)) && lessThan4(v)(upperBound(r));
  };
};
var trimReachable = function(r) {
  var $478 = {};
  for (var $479 in r) {
    if ({}.hasOwnProperty.call(r, $479)) {
      $478[$479] = r[$479];
    }
    ;
  }
  ;
  $478.registry = mapWithIndex1(function($$package2) {
    return over9(SemigroupMap)(filterWithKey2(function(version4) {
      return function(v1) {
        var v2 = lookup10($$package2)(unwrap13(r.required));
        if (v2 instanceof Nothing) {
          return true;
        }
        ;
        if (v2 instanceof Just) {
          return satisfies(version4)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 549, column 9 - line 551, column 48): " + [v2.constructor.name]);
      };
    }));
  })(r.registry);
  return $478;
};
var toLoose = function(v) {
  if (lessThan4(lowerBound(v))(upperBound(v))) {
    return new Just(coerce9(v));
  }
  ;
  return Nothing.value;
};
var wouldUpdate = function(j) {
  return function(i) {
    return greaterThan5(lowerBound(j))(lowerBound(i)) || lessThan4(upperBound(j))(upperBound(i));
  };
};
var loadIndex = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var map512 = map(Bind1.Apply0().Functor0());
  var pure411 = pure(dictMonad.Applicative0());
  var bind128 = bind(Bind1);
  return function(loader) {
    return function(required) {
      var need = function() {
        var $604 = map221(pure56);
        return function($605) {
          return SemigroupMap($604($605));
        };
      }();
      var needMore = function(v) {
        return function(needed) {
          var isNeeded = function(k) {
            return any2(function(r) {
              return includes(r)(k);
            })(needed);
          };
          var more = filterKeys2(function(k) {
            return not1(member7)(k)(v.found) && isNeeded(k);
          })(v.known);
          return {
            needed: foldMap9(need)(more),
            found: append33(v.found)(keys3(more))
          };
        };
      };
      var loadNew = function($$package2) {
        return function(v) {
          return map512(function(v1) {
            return {
              found: empty5,
              known: v1
            };
          })(loader($$package2));
        };
      };
      var go = function(v) {
        return function(v1) {
          var v2 = function(v3) {
            return pure411(v);
          };
          var $492 = findMin(v1);
          if ($492 instanceof Just) {
            return bind128(maybe$prime(loadNew($492.value0.key))(pure411)(lookup10($492.value0.key)(v)))(function(loaded) {
              var needed$prime = $$delete8($492.value0.key)(v1);
              var v3 = needMore(loaded)($492.value0.value);
              var loaded$prime = {
                known: loaded.known,
                found: append33(loaded.found)(v3.found)
              };
              var acc$prime = insert12($492.value0.key)(loaded$prime)(v);
              return go(acc$prime)(append42(needed$prime)(v3.needed));
            });
          }
          ;
          return v2(true);
        };
      };
      return map512(map221(function(v) {
        return v.known;
      }))(go(empty4)(need(required)));
    };
  };
};
var intersectionFromRange$prime = function($$package2) {
  return function(range3) {
    var mkSourced = function(v) {
      return new Sourced(v, new Pos(Root.value, singleton11($$package2)));
    };
    return {
      lower: wrap3(mkSourced(greaterThanOrEq2(range3))),
      upper: wrap3(mkSourced(lessThan3(range3)))
    };
  };
};
var intersectionFromRange = function($$package2) {
  return function(version4) {
    return function(range3) {
      var mkSourced = function(v) {
        return new Sourced(v, new Pos(new Solving(singleton12({
          "package": $$package2,
          version: version4
        })), empty5));
      };
      return {
        lower: wrap3(mkSourced(greaterThanOrEq2(range3))),
        upper: wrap3(mkSourced(lessThan3(range3)))
      };
    };
  };
};
var initializeRequired = /* @__PURE__ */ function() {
  var $606 = mapWithIndex1(intersectionFromRange$prime);
  return function($607) {
    return $606(coerce9($607));
  };
}();
var initializeRegistry = /* @__PURE__ */ function() {
  var $608 = mapWithIndex1(function($$package2) {
    return mapWithIndex1(function(version4) {
      return map310(intersectionFromRange($$package2)(version4));
    });
  });
  return function($609) {
    return $608(coerce9($609));
  };
}();
var good = function(i) {
  return greaterThan5(upperBound(i))(lowerBound(i));
};
var majorUpdate = function(v) {
  return function(v1) {
    return function(updated) {
      var minor2 = {
        added: false,
        failedAlready: false,
        failedNow: false
      };
      var info4 = anyWithIndex2(function($$package2) {
        return function(range3) {
          var v2 = lookup10($$package2)(v1);
          if (v2 instanceof Nothing) {
            var v3 = lookup10($$package2)(v);
            if (v3 instanceof Nothing) {
              return {
                failedAlready: minor2.failedAlready,
                failedNow: minor2.failedNow,
                added: true
              };
            }
            ;
            if (v3 instanceof Just) {
              return {
                failedAlready: minor2.failedAlready,
                failedNow: minor2.failedNow,
                added: greaterThan5(lowerBound(range3))(lowerBound(v3.value0)) || lessThan4(upperBound(range3))(upperBound(v3.value0))
              };
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 493, column 11 - line 495, column 122): " + [v3.constructor.name]);
          }
          ;
          if (v2 instanceof Just) {
            return {
              added: minor2.added,
              failedAlready: not22(good)(v2.value0),
              failedNow: not22(good)(range3)
            };
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 491, column 7 - line 496, column 83): " + [v2.constructor.name]);
        };
      })(updated);
      if (info4.added) {
        return true;
      }
      ;
      if (info4.failedNow && !info4.failedAlready) {
        return true;
      }
      ;
      return false;
    };
  };
};
var getPos = function() {
  return function($610) {
    return function(v) {
      return v.value1;
    }(unwrap13($610));
  };
};
var getPos1 = /* @__PURE__ */ getPos();
var getPackageRange = function(v) {
  return function($$package2) {
    return function(range3) {
      var v1 = lookup10($$package2)(v);
      if (v1 instanceof Nothing) {
        return empty4;
      }
      ;
      if (v1 instanceof Just) {
        return filterKeys2(function(v2) {
          return satisfies(v2)(range3);
        })(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 676, column 3 - line 679, column 73): " + [v1.constructor.name]);
    };
  };
};
var withInRange = function(r) {
  return {
    registry: r.registry,
    required: r.required,
    inRange: mapWithIndex1(getPackageRange(r.registry))(r.required)
  };
};
var getLatest = function(v) {
  return $$for6(v.inRange)(function(v1) {
    return bind44(findMax(v1))(function(v2) {
      return pure120({
        version: v2.key,
        dependencies: v2.value
      });
    });
  });
};
var tryLatest = function(r) {
  return bind44(getLatest(r))(function(sol) {
    return $$for6(sol)(function(v) {
      return discard110(forWithIndex_3(v.dependencies)(function(dep) {
        return function(range3) {
          return bind44(lookup10(dep)(sol))(function(v1) {
            return guard12(satisfies(v1.version)(range3));
          });
        };
      }))(function() {
        return pure120(v.version);
      });
    });
  });
};
var fromLoose = coerce9;
var fixEqM = function(dictSemigroup) {
  var append102 = append(dictSemigroup);
  return function(dictEq) {
    var eq72 = eq(dictEq);
    return function(f) {
      var go = function($copy_acc) {
        return function($copy_lastAdded) {
          var $tco_var_acc = $copy_acc;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(acc, lastAdded) {
            var moreAdded = f(lastAdded);
            var moreAcc = append102(acc)(moreAdded);
            var $529 = eq72(moreAcc)(acc);
            if ($529) {
              $tco_done = true;
              return acc;
            }
            ;
            $tco_var_acc = moreAcc;
            $copy_lastAdded = moreAdded;
            return;
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_acc, $copy_lastAdded);
          }
          ;
          return $tco_result;
        };
      };
      return join7(go);
    };
  };
};
var fixEqM1 = /* @__PURE__ */ fixEqM(semigroupSemigroupMap3)(/* @__PURE__ */ eqSemigroupMap2(/* @__PURE__ */ eqSemigroupMap(eqVersion)(/* @__PURE__ */ eqSemigroupMap2(eqIntersection))));
var gatherReachable = function(v) {
  var reachable0 = mapWithIndex1(getPackageRange(v.registry))(v.required);
  var moreReachable = foldMap23(foldMap23(mapWithIndex1(getPackageRange(v.registry))));
  var reachable = fixEqM1(moreReachable)(reachable0);
  return reachable;
};
var doubleton = function($$package2) {
  return function(version4) {
    return function(dat) {
      var helper2 = function(v) {
        if (v instanceof Nothing) {
          return singleton10(version4)(dat);
        }
        ;
        if (v instanceof Just) {
          return insert1(version4)(dat)(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 743, column 3 - line 743, column 45): " + [v.constructor.name]);
      };
      return coerce9(alter3(function($611) {
        return Just.create(helper2($611));
      })($$package2));
    };
  };
};
var dependency = function(v) {
  return function(v1) {
    return new Pos(v1.value0, append116(v.value1)(v1.value1));
  };
};
var dependencyOf = function() {
  return function(p1) {
    return coerce9(function(v) {
      return new Sourced(v.value0, dependency(p1)(v.value1));
    });
  };
};
var dependencyOf1 = /* @__PURE__ */ dependencyOf();
var checkSolved = function(v) {
  var v1 = function(v2) {
    return traverseWithIndex3(function($$package2) {
      return function(v3) {
        var v4 = findMax(v3);
        var v5 = size(v3);
        if (v5 === 1 && v4 instanceof Just) {
          return pure212(v4.value0.key);
        }
        ;
        return new Left({
          "package": $$package2,
          versions: v3
        });
      };
    })(v.inRange);
  };
  var $553 = tryLatest(v);
  if ($553 instanceof Just) {
    return pure212($553.value0);
  }
  ;
  return v1(true);
};
var checkRequired = function(v) {
  var checkRequirementShallow = function($$package2) {
    return function(range3) {
      var versions = unwrap13(getPackageRange(v.registry)($$package2)(range3));
      return isEmpty(versions);
    };
  };
  var checkRequirement = function($$package2) {
    return function(range3) {
      return function(previous) {
        var versions = unwrap13(map310(unwrap13)(fromMaybe(mempty32)(lookup10($$package2)(v.inRange))));
        var noVersions = isEmpty(versions);
        var hasErrored = forWithIndex2(versions)(function(v1) {
          return function(deps) {
            var failedDeps = filterWithKey1(checkRequirementShallow)(deps);
            var $556 = isEmpty(failedDeps);
            if ($556) {
              return new Left(unit);
            }
            ;
            return new Right(failedDeps);
          };
        });
        if (noVersions && (previous instanceof Left && previous.value0 instanceof Conflicts)) {
          return new Left(new Conflicts(insert12($$package2)(range3)(previous.value0.value0)));
        }
        ;
        if (noVersions) {
          return new Left(new Conflicts(singleton10($$package2)(range3)));
        }
        ;
        if (!noVersions && (hasErrored instanceof Right && previous instanceof Right)) {
          return new Left(new WhileSolving($$package2, map221(Conflicts.create)(hasErrored.value0)));
        }
        ;
        if (!noVersions) {
          return previous;
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 322, column 7 - line 327, column 32): " + [noVersions.constructor.name, hasErrored.constructor.name, previous.constructor.name]);
      };
    };
  };
  return foldlWithIndex2(function(i) {
    return function(b) {
      return function(a) {
        return checkRequirement(i)(a)(b);
      };
    };
  })(new Right(unit))(v.required);
};
var asDependencyOf = function(v) {
  return function(v1) {
    var pos2 = append62(getPos1(v.lower))(getPos1(v.upper));
    return {
      lower: dependencyOf1(pos2)(v1.lower),
      upper: dependencyOf1(pos2)(v1.upper)
    };
  };
};
var commonDependencies = function(registry) {
  return function($$package2) {
    return function(range3) {
      var inRange = getPackageRange(registry)($$package2)(range3);
      var solvableInRange = mapMaybe(traverse6(toLoose))(fromFoldable112(inRange));
      var v = fromArray(solvableInRange);
      if (v instanceof Nothing) {
        return mempty42;
      }
      ;
      if (v instanceof Just) {
        var v1 = foldMap16(App)(map411(un10(SemigroupMap))(v.value0));
        return mapFlipped11(v1)(function() {
          var $612 = asDependencyOf(range3);
          return function($613) {
            return $612(fromLoose($613));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 424, column 5 - line 429, column 71): " + [v.constructor.name]);
    };
  };
};
var addFrom = function(v) {
  return over9(SemigroupMap)(mapMaybeWithKey2(function($$package2) {
    var v1 = lookup10($$package2)(v);
    if (v1 instanceof Nothing) {
      return Just.create;
    }
    ;
    if (v1 instanceof Just) {
      return function(j) {
        var $574 = wouldUpdate(j)(v1.value0);
        if ($574) {
          return new Just(append72(j)(v1.value0));
        }
        ;
        return Nothing.value;
      };
    }
    ;
    throw new Error("Failed pattern match at Registry.Solver (line 391, column 87 - line 395, column 17): " + [v1.constructor.name]);
  }));
};
var withReachable = function(r) {
  var $576 = {};
  for (var $577 in r) {
    if ({}.hasOwnProperty.call(r, $577)) {
      $576[$577] = r[$577];
    }
    ;
  }
  ;
  $576.registry = map310(map310(addFrom(r.required)))(gatherReachable(r));
  return $576;
};
var accumulated = function(dictMonoid) {
  var mempty62 = mempty(dictMonoid);
  return function(v) {
    return v(mempty62);
  };
};
var accumulated1 = /* @__PURE__ */ accumulated(monoidSemigroupMap1);
var exploreTransitiveDependencies = function(lastTick) {
  return function(t) {
    return {
      required: lastTick.required,
      updated: accumulated1(fst(t)),
      registry: snd(t)
    };
  }(traverseWithIndex1(function($$package2) {
    return traverseWithIndex1(function(version4) {
      return function(deps) {
        var updateOne = function(depName) {
          return function(depRange) {
            var v2 = isEmpty(unwrap13(getPackageRange(lastTick.updated)(depName)(depRange)));
            if (v2) {
              return mempty52;
            }
            ;
            if (!v2) {
              return new Tuple(true, commonDependencies(lastTick.registry)(depName)(depRange));
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 466, column 36 - line 468, column 91): " + [v2.constructor.name]);
          };
        };
        var v = foldMapWithIndex22(updateOne)(deps);
        var dependencies = function() {
          if (v.value0) {
            return append82(deps)(v.value1);
          }
          ;
          return deps;
        }();
        var updated = function() {
          var v1 = v.value0 && majorUpdate(lastTick.required)(deps)(dependencies);
          if (v1) {
            return doubleton($$package2)(version4)(dependencies);
          }
          ;
          if (!v1) {
            return mempty19;
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 472, column 17 - line 474, column 24): " + [v1.constructor.name]);
        }();
        return new Tuple(updated, dependencies);
      };
    });
  })(lastTick.registry));
};
var solveStep = function(initial) {
  var moreRequired = foldMapWithIndex3(commonDependencies(initial.registry))(initial.required);
  var updatedOfReqs = requirementUpdates(initial)(moreRequired);
  var v = exploreTransitiveDependencies({
    required: initial.required,
    updated: initial.updated,
    registry: map310(map310(addFrom(moreRequired)))(initial.registry)
  });
  return {
    required: append82(initial.required)(moreRequired),
    registry: v.registry,
    updated: append92(v.updated)(updatedOfReqs)
  };
};
var solveSteps = function(r0) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (noUpdates(v)) {
        $tco_done = true;
        return {
          registry: v.registry,
          required: v.required
        };
      }
      ;
      $copy_v = solveStep(v);
      return;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return go(r0);
};
var solveFull = /* @__PURE__ */ function() {
  var applyPackage = function(r) {
    return function($$package2) {
      return function(version4) {
        return function(dependencies) {
          var updated = maybe(empty4)(singleton10($$package2))(lookup10($$package2)(unwrap13(r.registry)));
          var required = append82(r.required)(append82(soleVersionOf($$package2)(version4))(dependencies));
          return {
            required,
            registry: r.registry,
            updated
          };
        };
      };
    };
  };
  var solvePackage = function(r) {
    return function($$package2) {
      return function(version4) {
        return function(dependencies) {
          return $lazy_solveAux(289)(trimReachable(applyPackage(r)($$package2)(version4)(dependencies)));
        };
      };
    };
  };
  var $lazy_solveAux = $runtime_lazy12("solveAux", "Registry.Solver", function() {
    return function($614) {
      return function(r) {
        var rScanned = withInRange(r);
        return discard25(lmap15(pure310)(checkRequired(rScanned)))(function() {
          var v = checkSolved(rScanned);
          if (v instanceof Right) {
            return new Right(v.value0);
          }
          ;
          if (v instanceof Left) {
            var sols = mapWithIndex4(function(version4) {
              return function(deps) {
                return function(v12) {
                  return solvePackage(r)(v["value0"]["package"])(version4)(deps);
                };
              };
            })(v.value0.versions);
            var v1 = unwrap13(sequence3(sols))(unit);
            if (v1 instanceof Right) {
              return new Right(v1.value0);
            }
            ;
            if (v1 instanceof Left) {
              return new Left(pure310(new WhileSolving(v["value0"]["package"], map221(head4)(v1.value0))));
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 274, column 11 - line 281, column 36): " + [v1.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 267, column 5 - line 281, column 36): " + [v.constructor.name]);
        });
      }(solveSteps($614));
    };
  });
  var solveAux = $lazy_solveAux(258);
  return function($615) {
    return solveAux(solveSeed(withReachable($615)));
  };
}();
var loadAndSolve = function(dictMonad) {
  var mapFlipped112 = mapFlipped(dictMonad.Bind1().Apply0().Functor0());
  var loadIndex1 = loadIndex(dictMonad);
  return function(loader) {
    return function(required) {
      return mapFlipped112(loadIndex1(loader)(required))(function(index5) {
        return solveFull({
          registry: initializeRegistry(index5),
          required: initializeRequired(required)
        });
      });
    };
  };
};

// output/Spago.Repl/index.js
var pure57 = /* @__PURE__ */ pure(applicativeSpago);
var filterWithKey3 = /* @__PURE__ */ filterWithKey(ordPackageName);
var eq30 = /* @__PURE__ */ eq(eqPackageName);
var bind45 = /* @__PURE__ */ bind(bindSpago);
var supportPackageName = /* @__PURE__ */ unsafeFromRight(/* @__PURE__ */ parse3("psci-support"));
var supportPackage = function(packageSet) {
  if (packageSet.buildType instanceof PackageSetBuild) {
    return pure57(filterWithKey3(function(k) {
      return function(_v) {
        return eq30(k)(supportPackageName);
      };
    })(packageSet.buildType.value1));
  }
  ;
  if (packageSet.buildType instanceof RegistrySolverBuild) {
    return bind45(getMetadata(supportPackageName))(function(maybeMetadata) {
      return pure57(function() {
        if (maybeMetadata instanceof Right) {
          var v = findMax(maybeMetadata.value0.published);
          if (v instanceof Nothing) {
            return empty4;
          }
          ;
          if (v instanceof Just) {
            return singleton10(supportPackageName)(new RegistryVersion(v.value0.key));
          }
          ;
          throw new Error("Failed pattern match at Spago.Repl (line 25, column 38 - line 27, column 81): " + [v.constructor.name]);
        }
        ;
        if (maybeMetadata instanceof Left) {
          return empty4;
        }
        ;
        throw new Error("Failed pattern match at Spago.Repl (line 24, column 12 - line 28, column 31): " + [maybeMetadata.constructor.name]);
      }());
    });
  }
  ;
  throw new Error("Failed pattern match at Spago.Repl (line 19, column 3 - line 28, column 31): " + [packageSet.buildType.constructor.name]);
};

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
import EE from "events";
import fs2 from "fs";

// node_modules/minipass/dist/esm/index.js
import { EventEmitter as EventEmitter2 } from "node:events";
import Stream from "node:stream";
import { StringDecoder } from "node:string_decoder";
var proc = typeof process === "object" && process ? process : {
  stdout: null,
  stderr: null
};
var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof Stream || isReadable(s) || isWritable(s));
var isReadable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== Stream.Writable.prototype.pipe;
var isWritable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter2 && typeof s.write === "function" && typeof s.end === "function";
var EOF = Symbol("EOF");
var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
var EMITTED_END = Symbol("emittedEnd");
var EMITTING_END = Symbol("emittingEnd");
var EMITTED_ERROR = Symbol("emittedError");
var CLOSED = Symbol("closed");
var READ = Symbol("read");
var FLUSH = Symbol("flush");
var FLUSHCHUNK = Symbol("flushChunk");
var ENCODING = Symbol("encoding");
var DECODER = Symbol("decoder");
var FLOWING = Symbol("flowing");
var PAUSED = Symbol("paused");
var RESUME = Symbol("resume");
var BUFFER = Symbol("buffer");
var PIPES = Symbol("pipes");
var BUFFERLENGTH = Symbol("bufferLength");
var BUFFERPUSH = Symbol("bufferPush");
var BUFFERSHIFT = Symbol("bufferShift");
var OBJECTMODE = Symbol("objectMode");
var DESTROYED = Symbol("destroyed");
var ERROR = Symbol("error");
var EMITDATA = Symbol("emitData");
var EMITEND = Symbol("emitEnd");
var EMITEND2 = Symbol("emitEnd2");
var ASYNC = Symbol("async");
var ABORT = Symbol("abort");
var ABORTED = Symbol("aborted");
var SIGNAL = Symbol("signal");
var DATALISTENERS = Symbol("dataListeners");
var DISCARDED = Symbol("discarded");
var defer4 = (fn) => Promise.resolve().then(fn);
var nodefer = (fn) => fn();
var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
var Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src;
    this.dest = dest;
    this.opts = opts;
    this.ondrain = () => src[RESUME]();
    this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe();
    if (this.opts.end)
      this.dest.end();
  }
};
var PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors);
    super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts);
    this.proxyErrors = (er) => dest.emit("error", er);
    src.on("error", this.proxyErrors);
  }
};
var isObjectModeOptions = (o) => !!o.objectMode;
var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
var Minipass = class extends EventEmitter2 {
  [FLOWING] = false;
  [PAUSED] = false;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = false;
  [EMITTED_END] = false;
  [EMITTING_END] = false;
  [CLOSED] = false;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = false;
  [SIGNAL];
  [ABORTED] = false;
  [DATALISTENERS] = 0;
  [DISCARDED] = false;
  /**
   * true if the stream can be written
   */
  writable = true;
  /**
   * true if the stream can be read
   */
  readable = true;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    const options = args[0] || {};
    super();
    if (options.objectMode && typeof options.encoding === "string") {
      throw new TypeError("Encoding and objectMode may not be used together");
    }
    if (isObjectModeOptions(options)) {
      this[OBJECTMODE] = true;
      this[ENCODING] = null;
    } else if (isEncodingOptions(options)) {
      this[ENCODING] = options.encoding;
      this[OBJECTMODE] = false;
    } else {
      this[OBJECTMODE] = false;
      this[ENCODING] = null;
    }
    this[ASYNC] = !!options.async;
    this[DECODER] = this[ENCODING] ? new StringDecoder(this[ENCODING]) : null;
    if (options && options.debugExposeBuffer === true) {
      Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
    }
    if (options && options.debugExposePipes === true) {
      Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    }
    const { signal } = options;
    if (signal) {
      this[SIGNAL] = signal;
      if (signal.aborted) {
        this[ABORT]();
      } else {
        signal.addEventListener("abort", () => this[ABORT]());
      }
    }
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get ["async"]() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set ["async"](a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    this[ABORTED] = true;
    this.emit("abort", this[SIGNAL]?.reason);
    this.destroy(this[SIGNAL]?.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    if (this[ABORTED])
      return false;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED]) {
      this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
      return true;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (!encoding)
      encoding = "utf8";
    const fn = this[ASYNC] ? defer4 : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk)) {
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      } else if (isArrayBufferLike(chunk)) {
        chunk = Buffer.from(chunk);
      } else if (typeof chunk !== "string") {
        throw new Error("Non-contiguous data written to non-objectMode stream");
      }
    }
    if (this[OBJECTMODE]) {
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (!chunk.length) {
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    if (typeof chunk === "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (Buffer.isBuffer(chunk) && this[ENCODING]) {
      chunk = this[DECODER].write(chunk);
    }
    if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
      this[FLUSH](true);
    if (this[FLOWING])
      this.emit("data", chunk);
    else
      this[BUFFERPUSH](chunk);
    if (this[BUFFERLENGTH] !== 0)
      this.emit("readable");
    if (cb)
      fn(cb);
    return this[FLOWING];
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    this[DISCARDED] = false;
    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
      this[MAYBE_EMIT_END]();
      return null;
    }
    if (this[OBJECTMODE])
      n = null;
    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
      this[BUFFER] = [
        this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
      ];
    }
    const ret = this[READ](n || null, this[BUFFER][0]);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      const c = chunk;
      if (n === c.length || n === null)
        this[BUFFERSHIFT]();
      else if (typeof c === "string") {
        this[BUFFER][0] = c.slice(n);
        chunk = c.slice(0, n);
        this[BUFFERLENGTH] -= n;
      } else {
        this[BUFFER][0] = c.subarray(n);
        chunk = c.subarray(0, n);
        this[BUFFERLENGTH] -= n;
      }
    }
    this.emit("data", chunk);
    if (!this[BUFFER].length && !this[EOF])
      this.emit("drain");
    return chunk;
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = "utf8";
    }
    if (chunk !== void 0)
      this.write(chunk, encoding);
    if (cb)
      this.once("end", cb);
    this[EOF] = true;
    this.writable = false;
    if (this[FLOWING] || !this[PAUSED])
      this[MAYBE_EMIT_END]();
    return this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    if (this[DESTROYED])
      return;
    if (!this[DATALISTENERS] && !this[PIPES].length) {
      this[DISCARDED] = true;
    }
    this[PAUSED] = false;
    this[FLOWING] = true;
    this.emit("resume");
    if (this[BUFFER].length)
      this[FLUSH]();
    else if (this[EOF])
      this[MAYBE_EMIT_END]();
    else
      this.emit("drain");
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = false;
    this[PAUSED] = true;
    this[DISCARDED] = false;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] += 1;
    else
      this[BUFFERLENGTH] += chunk.length;
    this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    if (this[OBJECTMODE])
      this[BUFFERLENGTH] -= 1;
    else
      this[BUFFERLENGTH] -= this[BUFFER][0].length;
    return this[BUFFER].shift();
  }
  [FLUSH](noDrain = false) {
    do {
    } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    if (!noDrain && !this[BUFFER].length && !this[EOF])
      this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    this.emit("data", chunk);
    return this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = false;
    const ended = this[EMITTED_END];
    opts = opts || {};
    if (dest === proc.stdout || dest === proc.stderr)
      opts.end = false;
    else
      opts.end = opts.end !== false;
    opts.proxyErrors = !!opts.proxyErrors;
    if (ended) {
      if (opts.end)
        dest.end();
    } else {
      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
      if (this[ASYNC])
        defer4(() => this[RESUME]());
      else
        this[RESUME]();
    }
    return dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    const p = this[PIPES].find((p2) => p2.dest === dest);
    if (p) {
      if (this[PIPES].length === 1) {
        if (this[FLOWING] && this[DATALISTENERS] === 0) {
          this[FLOWING] = false;
        }
        this[PIPES] = [];
      } else
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
      p.unpipe();
    }
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    const ret = super.on(ev, handler);
    if (ev === "data") {
      this[DISCARDED] = false;
      this[DATALISTENERS]++;
      if (!this[PIPES].length && !this[FLOWING]) {
        this[RESUME]();
      }
    } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
      super.emit("readable");
    } else if (isEndish(ev) && this[EMITTED_END]) {
      super.emit(ev);
      this.removeAllListeners(ev);
    } else if (ev === "error" && this[EMITTED_ERROR]) {
      const h = handler;
      if (this[ASYNC])
        defer4(() => h.call(this, this[EMITTED_ERROR]));
      else
        h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    const ret = super.off(ev, handler);
    if (ev === "data") {
      this[DATALISTENERS] = this.listeners("data").length;
      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    const ret = super.removeAllListeners(ev);
    if (ev === "data" || ev === void 0) {
      this[DATALISTENERS] = 0;
      if (!this[DISCARDED] && !this[PIPES].length) {
        this[FLOWING] = false;
      }
    }
    return ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
      this[EMITTING_END] = true;
      this.emit("end");
      this.emit("prefinish");
      this.emit("finish");
      if (this[CLOSED])
        this.emit("close");
      this[EMITTING_END] = false;
    }
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    const data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
      return false;
    } else if (ev === "data") {
      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer4(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
    } else if (ev === "end") {
      return this[EMITEND]();
    } else if (ev === "close") {
      this[CLOSED] = true;
      if (!this[EMITTED_END] && !this[DESTROYED])
        return false;
      const ret2 = super.emit("close");
      this.removeAllListeners("close");
      return ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data;
      super.emit(ERROR, data);
      const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "resume") {
      const ret2 = super.emit("resume");
      this[MAYBE_EMIT_END]();
      return ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      const ret2 = super.emit(ev);
      this.removeAllListeners(ev);
      return ret2;
    }
    const ret = super.emit(ev, ...args);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITDATA](data) {
    for (const p of this[PIPES]) {
      if (p.dest.write(data) === false)
        this.pause();
    }
    const ret = this[DISCARDED] ? false : super.emit("data", data);
    this[MAYBE_EMIT_END]();
    return ret;
  }
  [EMITEND]() {
    if (this[EMITTED_END])
      return false;
    this[EMITTED_END] = true;
    this.readable = false;
    return this[ASYNC] ? (defer4(() => this[EMITEND2]()), true) : this[EMITEND2]();
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      const data = this[DECODER].end();
      if (data) {
        for (const p of this[PIPES]) {
          p.dest.write(data);
        }
        if (!this[DISCARDED])
          super.emit("data", data);
      }
    }
    for (const p of this[PIPES]) {
      p.end();
    }
    const ret = super.emit("end");
    this.removeAllListeners("end");
    return ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    const buf = Object.assign([], {
      dataLength: 0
    });
    if (!this[OBJECTMODE])
      buf.dataLength = 0;
    const p = this.promise();
    this.on("data", (c) => {
      buf.push(c);
      if (!this[OBJECTMODE])
        buf.dataLength += c.length;
    });
    await p;
    return buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE]) {
      throw new Error("cannot concat in objectMode");
    }
    const buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve3, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed")));
      this.on("error", (er) => reject(er));
      this.on("end", () => resolve3());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = async () => {
      this.pause();
      stopped = true;
      return { value: void 0, done: true };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const res = this.read();
      if (res !== null)
        return Promise.resolve({ done: false, value: res });
      if (this[EOF])
        return stop();
      let resolve3;
      let reject;
      const onerr = (er) => {
        this.off("data", ondata);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        stop();
        reject(er);
      };
      const ondata = (value4) => {
        this.off("error", onerr);
        this.off("end", onend);
        this.off(DESTROYED, ondestroy);
        this.pause();
        resolve3({ value: value4, done: !!this[EOF] });
      };
      const onend = () => {
        this.off("error", onerr);
        this.off("data", ondata);
        this.off(DESTROYED, ondestroy);
        stop();
        resolve3({ done: true, value: void 0 });
      };
      const ondestroy = () => onerr(new Error("stream destroyed"));
      return new Promise((res2, rej) => {
        reject = rej;
        resolve3 = res2;
        this.once(DESTROYED, ondestroy);
        this.once("error", onerr);
        this.once("end", onend);
        this.once("data", ondata);
      });
    };
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = false;
    let stopped = false;
    const stop = () => {
      this.pause();
      this.off(ERROR, stop);
      this.off(DESTROYED, stop);
      this.off("end", stop);
      stopped = true;
      return { done: true, value: void 0 };
    };
    const next2 = () => {
      if (stopped)
        return stop();
      const value4 = this.read();
      return value4 === null ? stop() : { done: false, value: value4 };
    };
    this.once("end", stop);
    this.once(ERROR, stop);
    this.once(DESTROYED, stop);
    return {
      next: next2,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED]) {
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    this[DESTROYED] = true;
    this[DISCARDED] = true;
    this[BUFFER].length = 0;
    this[BUFFERLENGTH] = 0;
    const wc = this;
    if (typeof wc.close === "function" && !this[CLOSED])
      wc.close();
    if (er)
      this.emit("error", er);
    else
      this.emit(DESTROYED);
    return this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// node_modules/@isaacs/fs-minipass/dist/esm/index.js
var writev = fs2.writev;
var _autoClose = Symbol("_autoClose");
var _close = Symbol("_close");
var _ended = Symbol("_ended");
var _fd = Symbol("_fd");
var _finished = Symbol("_finished");
var _flags = Symbol("_flags");
var _flush = Symbol("_flush");
var _handleChunk = Symbol("_handleChunk");
var _makeBuf = Symbol("_makeBuf");
var _mode = Symbol("_mode");
var _needDrain = Symbol("_needDrain");
var _onerror = Symbol("_onerror");
var _onopen = Symbol("_onopen");
var _onread = Symbol("_onread");
var _onwrite = Symbol("_onwrite");
var _open = Symbol("_open");
var _path = Symbol("_path");
var _pos = Symbol("_pos");
var _queue = Symbol("_queue");
var _read = Symbol("_read");
var _readSize = Symbol("_readSize");
var _reading = Symbol("_reading");
var _remain = Symbol("_remain");
var _size = Symbol("_size");
var _write = Symbol("_write");
var _writing = Symbol("_writing");
var _defaultFlag = Symbol("_defaultFlag");
var _errored = Symbol("_errored");
var ReadStream = class extends Minipass {
  [_errored] = false;
  [_fd];
  [_path];
  [_readSize];
  [_reading] = false;
  [_size];
  [_remain];
  [_autoClose];
  constructor(path14, opt) {
    opt = opt || {};
    super(opt);
    this.readable = true;
    this.writable = false;
    if (typeof path14 !== "string") {
      throw new TypeError("path must be a string");
    }
    this[_errored] = false;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : void 0;
    this[_path] = path14;
    this[_readSize] = opt.readSize || 16 * 1024 * 1024;
    this[_reading] = false;
    this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
    this[_remain] = this[_size];
    this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
    if (typeof this[_fd] === "number") {
      this[_read]();
    } else {
      this[_open]();
    }
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  //@ts-ignore
  write() {
    throw new TypeError("this is a readable stream");
  }
  //@ts-ignore
  end() {
    throw new TypeError("this is a readable stream");
  }
  [_open]() {
    fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    if (er) {
      this[_onerror](er);
    } else {
      this[_fd] = fd;
      this.emit("open", fd);
      this[_read]();
    }
  }
  [_makeBuf]() {
    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
  }
  [_read]() {
    if (!this[_reading]) {
      this[_reading] = true;
      const buf = this[_makeBuf]();
      if (buf.length === 0) {
        return process.nextTick(() => this[_onread](null, 0, buf));
      }
      fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));
    }
  }
  [_onread](er, br, buf) {
    this[_reading] = false;
    if (er) {
      this[_onerror](er);
    } else if (this[_handleChunk](br, buf)) {
      this[_read]();
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = void 0;
      fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
  [_onerror](er) {
    this[_reading] = true;
    this[_close]();
    this.emit("error", er);
  }
  [_handleChunk](br, buf) {
    let ret = false;
    this[_remain] -= br;
    if (br > 0) {
      ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);
    }
    if (br === 0 || this[_remain] <= 0) {
      ret = false;
      this[_close]();
      super.end();
    }
    return ret;
  }
  emit(ev, ...args) {
    switch (ev) {
      case "prefinish":
      case "finish":
        return false;
      case "drain":
        if (typeof this[_fd] === "number") {
          this[_read]();
        }
        return false;
      case "error":
        if (this[_errored]) {
          return false;
        }
        this[_errored] = true;
        return super.emit(ev, ...args);
      default:
        return super.emit(ev, ...args);
    }
  }
};
var ReadStreamSync = class extends ReadStream {
  [_open]() {
    let threw = true;
    try {
      this[_onopen](null, fs2.openSync(this[_path], "r"));
      threw = false;
    } finally {
      if (threw) {
        this[_close]();
      }
    }
  }
  [_read]() {
    let threw = true;
    try {
      if (!this[_reading]) {
        this[_reading] = true;
        do {
          const buf = this[_makeBuf]();
          const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
          if (!this[_handleChunk](br, buf)) {
            break;
          }
        } while (true);
        this[_reading] = false;
      }
      threw = false;
    } finally {
      if (threw) {
        this[_close]();
      }
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = void 0;
      fs2.closeSync(fd);
      this.emit("close");
    }
  }
};
var WriteStream = class extends EE {
  readable = false;
  writable = true;
  [_errored] = false;
  [_writing] = false;
  [_ended] = false;
  [_queue] = [];
  [_needDrain] = false;
  [_path];
  [_mode];
  [_autoClose];
  [_fd];
  [_defaultFlag];
  [_flags];
  [_finished] = false;
  [_pos];
  constructor(path14, opt) {
    opt = opt || {};
    super(opt);
    this[_path] = path14;
    this[_fd] = typeof opt.fd === "number" ? opt.fd : void 0;
    this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
    this[_pos] = typeof opt.start === "number" ? opt.start : void 0;
    this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
    const defaultFlag = this[_pos] !== void 0 ? "r+" : "w";
    this[_defaultFlag] = opt.flags === void 0;
    this[_flags] = opt.flags === void 0 ? defaultFlag : opt.flags;
    if (this[_fd] === void 0) {
      this[_open]();
    }
  }
  emit(ev, ...args) {
    if (ev === "error") {
      if (this[_errored]) {
        return false;
      }
      this[_errored] = true;
    }
    return super.emit(ev, ...args);
  }
  get fd() {
    return this[_fd];
  }
  get path() {
    return this[_path];
  }
  [_onerror](er) {
    this[_close]();
    this[_writing] = true;
    this.emit("error", er);
  }
  [_open]() {
    fs2.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
  }
  [_onopen](er, fd) {
    if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
      this[_flags] = "w";
      this[_open]();
    } else if (er) {
      this[_onerror](er);
    } else {
      this[_fd] = fd;
      this.emit("open", fd);
      if (!this[_writing]) {
        this[_flush]();
      }
    }
  }
  end(buf, enc) {
    if (buf) {
      this.write(buf, enc);
    }
    this[_ended] = true;
    if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number") {
      this[_onwrite](null, 0);
    }
    return this;
  }
  write(buf, enc) {
    if (typeof buf === "string") {
      buf = Buffer.from(buf, enc);
    }
    if (this[_ended]) {
      this.emit("error", new Error("write() after end()"));
      return false;
    }
    if (this[_fd] === void 0 || this[_writing] || this[_queue].length) {
      this[_queue].push(buf);
      this[_needDrain] = true;
      return false;
    }
    this[_writing] = true;
    this[_write](buf);
    return true;
  }
  [_write](buf) {
    fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
  }
  [_onwrite](er, bw) {
    if (er) {
      this[_onerror](er);
    } else {
      if (this[_pos] !== void 0 && typeof bw === "number") {
        this[_pos] += bw;
      }
      if (this[_queue].length) {
        this[_flush]();
      } else {
        this[_writing] = false;
        if (this[_ended] && !this[_finished]) {
          this[_finished] = true;
          this[_close]();
          this.emit("finish");
        } else if (this[_needDrain]) {
          this[_needDrain] = false;
          this.emit("drain");
        }
      }
    }
  }
  [_flush]() {
    if (this[_queue].length === 0) {
      if (this[_ended]) {
        this[_onwrite](null, 0);
      }
    } else if (this[_queue].length === 1) {
      this[_write](this[_queue].pop());
    } else {
      const iovec = this[_queue];
      this[_queue] = [];
      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
    }
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = void 0;
      fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
    }
  }
};
var WriteStreamSync = class extends WriteStream {
  [_open]() {
    let fd;
    if (this[_defaultFlag] && this[_flags] === "r+") {
      try {
        fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
      } catch (er) {
        if (er?.code === "ENOENT") {
          this[_flags] = "w";
          return this[_open]();
        } else {
          throw er;
        }
      }
    } else {
      fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
    }
    this[_onopen](null, fd);
  }
  [_close]() {
    if (this[_autoClose] && typeof this[_fd] === "number") {
      const fd = this[_fd];
      this[_fd] = void 0;
      fs2.closeSync(fd);
      this.emit("close");
    }
  }
  [_write](buf) {
    let threw = true;
    try {
      this[_onwrite](null, fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
      threw = false;
    } finally {
      if (threw) {
        try {
          this[_close]();
        } catch {
        }
      }
    }
  }
};

// node_modules/tar/dist/esm/create.js
import path5 from "node:path";

// node_modules/tar/dist/esm/list.js
import fs3 from "node:fs";
import { dirname as dirname2, parse as parse12 } from "path";

// node_modules/tar/dist/esm/options.js
var argmap = /* @__PURE__ */ new Map([
  ["C", "cwd"],
  ["f", "file"],
  ["z", "gzip"],
  ["P", "preservePaths"],
  ["U", "unlink"],
  ["strip-components", "strip"],
  ["stripComponents", "strip"],
  ["keep-newer", "newer"],
  ["keepNewer", "newer"],
  ["keep-newer-files", "newer"],
  ["keepNewerFiles", "newer"],
  ["k", "keep"],
  ["keep-existing", "keep"],
  ["keepExisting", "keep"],
  ["m", "noMtime"],
  ["no-mtime", "noMtime"],
  ["p", "preserveOwner"],
  ["L", "follow"],
  ["h", "follow"]
]);
var isSyncFile = (o) => !!o.sync && !!o.file;
var isAsyncFile = (o) => !o.sync && !!o.file;
var isSyncNoFile = (o) => !!o.sync && !o.file;
var isAsyncNoFile = (o) => !o.sync && !o.file;
var isFile3 = (o) => !!o.file;
var dealiasKey = (k) => {
  const d = argmap.get(k);
  if (d)
    return d;
  return k;
};
var dealias = (opt = {}) => {
  if (!opt)
    return {};
  const result = {};
  for (const [key, v] of Object.entries(opt)) {
    const k = dealiasKey(key);
    result[k] = v;
  }
  if (result.chmod === void 0 && result.noChmod === false) {
    result.chmod = true;
  }
  delete result.noChmod;
  return result;
};

// node_modules/tar/dist/esm/make-command.js
var makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {
  return Object.assign((opt_ = [], entries3, cb) => {
    if (Array.isArray(opt_)) {
      entries3 = opt_;
      opt_ = {};
    }
    if (typeof entries3 === "function") {
      cb = entries3;
      entries3 = void 0;
    }
    if (!entries3) {
      entries3 = [];
    } else {
      entries3 = Array.from(entries3);
    }
    const opt = dealias(opt_);
    validate?.(opt, entries3);
    if (isSyncFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncFile(opt, entries3);
    } else if (isAsyncFile(opt)) {
      const p = asyncFile(opt, entries3);
      const c = cb ? cb : void 0;
      return c ? p.then(() => c(), c) : p;
    } else if (isSyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      return syncNoFile(opt, entries3);
    } else if (isAsyncNoFile(opt)) {
      if (typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return asyncNoFile(opt, entries3);
    } else {
      throw new Error("impossible options??");
    }
  }, {
    syncFile,
    asyncFile,
    syncNoFile,
    asyncNoFile,
    validate
  });
};

// node_modules/tar/dist/esm/parse.js
import { EventEmitter as EE2 } from "events";

// node_modules/minizlib/dist/esm/index.js
import assert from "assert";
import { Buffer as Buffer3 } from "buffer";
import realZlib2 from "zlib";

// node_modules/minizlib/dist/esm/constants.js
import realZlib from "zlib";
var realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 };
var constants3 = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
}, realZlibConstants));

// node_modules/minizlib/dist/esm/index.js
var OriginalBufferConcat = Buffer3.concat;
var _superWrite = Symbol("_superWrite");
var ZlibError = class extends Error {
  code;
  errno;
  constructor(err) {
    super("zlib: " + err.message);
    this.code = err.code;
    this.errno = err.errno;
    if (!this.code)
      this.code = "ZLIB_ERROR";
    this.message = "zlib: " + err.message;
    Error.captureStackTrace(this, this.constructor);
  }
  get name() {
    return "ZlibError";
  }
};
var _flushFlag = Symbol("flushFlag");
var ZlibBase = class extends Minipass {
  #sawError = false;
  #ended = false;
  #flushFlag;
  #finishFlushFlag;
  #fullFlushFlag;
  #handle;
  #onError;
  get sawError() {
    return this.#sawError;
  }
  get handle() {
    return this.#handle;
  }
  /* c8 ignore start */
  get flushFlag() {
    return this.#flushFlag;
  }
  /* c8 ignore stop */
  constructor(opts, mode2) {
    if (!opts || typeof opts !== "object")
      throw new TypeError("invalid options for ZlibBase constructor");
    super(opts);
    this.#flushFlag = opts.flush ?? 0;
    this.#finishFlushFlag = opts.finishFlush ?? 0;
    this.#fullFlushFlag = opts.fullFlushFlag ?? 0;
    try {
      this.#handle = new realZlib2[mode2](opts);
    } catch (er) {
      throw new ZlibError(er);
    }
    this.#onError = (err) => {
      if (this.#sawError)
        return;
      this.#sawError = true;
      this.close();
      this.emit("error", err);
    };
    this.#handle?.on("error", (er) => this.#onError(new ZlibError(er)));
    this.once("end", () => this.close);
  }
  close() {
    if (this.#handle) {
      this.#handle.close();
      this.#handle = void 0;
      this.emit("close");
    }
  }
  reset() {
    if (!this.#sawError) {
      assert(this.#handle, "zlib binding closed");
      return this.#handle.reset?.();
    }
  }
  flush(flushFlag) {
    if (this.ended)
      return;
    if (typeof flushFlag !== "number")
      flushFlag = this.#fullFlushFlag;
    this.write(Object.assign(Buffer3.alloc(0), { [_flushFlag]: flushFlag }));
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = void 0;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (chunk) {
      if (encoding)
        this.write(chunk, encoding);
      else
        this.write(chunk);
    }
    this.flush(this.#finishFlushFlag);
    this.#ended = true;
    return super.end(cb);
  }
  get ended() {
    return this.#ended;
  }
  // overridden in the gzip classes to do portable writes
  [_superWrite](data) {
    return super.write(data);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function")
      cb = encoding, encoding = "utf8";
    if (typeof chunk === "string")
      chunk = Buffer3.from(chunk, encoding);
    if (this.#sawError)
      return;
    assert(this.#handle, "zlib binding closed");
    const nativeHandle = this.#handle._handle;
    const originalNativeClose = nativeHandle.close;
    nativeHandle.close = () => {
    };
    const originalClose = this.#handle.close;
    this.#handle.close = () => {
    };
    Buffer3.concat = (args) => args;
    let result = void 0;
    try {
      const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this.#flushFlag;
      result = this.#handle._processChunk(chunk, flushFlag);
      Buffer3.concat = OriginalBufferConcat;
    } catch (err) {
      Buffer3.concat = OriginalBufferConcat;
      this.#onError(new ZlibError(err));
    } finally {
      if (this.#handle) {
        ;
        this.#handle._handle = nativeHandle;
        nativeHandle.close = originalNativeClose;
        this.#handle.close = originalClose;
        this.#handle.removeAllListeners("error");
      }
    }
    if (this.#handle)
      this.#handle.on("error", (er) => this.#onError(new ZlibError(er)));
    let writeReturn;
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        const r = result[0];
        writeReturn = this[_superWrite](Buffer3.from(r));
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i]);
        }
      } else {
        writeReturn = this[_superWrite](Buffer3.from(result));
      }
    }
    if (cb)
      cb();
    return writeReturn;
  }
};
var Zlib = class extends ZlibBase {
  #level;
  #strategy;
  constructor(opts, mode2) {
    opts = opts || {};
    opts.flush = opts.flush || constants3.Z_NO_FLUSH;
    opts.finishFlush = opts.finishFlush || constants3.Z_FINISH;
    opts.fullFlushFlag = constants3.Z_FULL_FLUSH;
    super(opts, mode2);
    this.#level = opts.level;
    this.#strategy = opts.strategy;
  }
  params(level, strategy) {
    if (this.sawError)
      return;
    if (!this.handle)
      throw new Error("cannot switch params when binding is closed");
    if (!this.handle.params)
      throw new Error("not supported in this implementation");
    if (this.#level !== level || this.#strategy !== strategy) {
      this.flush(constants3.Z_SYNC_FLUSH);
      assert(this.handle, "zlib binding closed");
      const origFlush = this.handle.flush;
      this.handle.flush = (flushFlag, cb) => {
        if (typeof flushFlag === "function") {
          cb = flushFlag;
          flushFlag = this.flushFlag;
        }
        this.flush(flushFlag);
        cb?.();
      };
      try {
        ;
        this.handle.params(level, strategy);
      } finally {
        this.handle.flush = origFlush;
      }
      if (this.handle) {
        this.#level = level;
        this.#strategy = strategy;
      }
    }
  }
};
var Gzip = class extends Zlib {
  #portable;
  constructor(opts) {
    super(opts, "Gzip");
    this.#portable = opts && !!opts.portable;
  }
  [_superWrite](data) {
    if (!this.#portable)
      return super[_superWrite](data);
    this.#portable = false;
    data[9] = 255;
    return super[_superWrite](data);
  }
};
var Unzip = class extends Zlib {
  constructor(opts) {
    super(opts, "Unzip");
  }
};
var Brotli = class extends ZlibBase {
  constructor(opts, mode2) {
    opts = opts || {};
    opts.flush = opts.flush || constants3.BROTLI_OPERATION_PROCESS;
    opts.finishFlush = opts.finishFlush || constants3.BROTLI_OPERATION_FINISH;
    opts.fullFlushFlag = constants3.BROTLI_OPERATION_FLUSH;
    super(opts, mode2);
  }
};
var BrotliCompress = class extends Brotli {
  constructor(opts) {
    super(opts, "BrotliCompress");
  }
};
var BrotliDecompress = class extends Brotli {
  constructor(opts) {
    super(opts, "BrotliDecompress");
  }
};

// node_modules/yallist/dist/esm/index.js
var Yallist = class _Yallist {
  tail;
  head;
  length = 0;
  static create(list3 = []) {
    return new _Yallist(list3);
  }
  constructor(list3 = []) {
    for (const item of list3) {
      this.push(item);
    }
  }
  *[Symbol.iterator]() {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value;
    }
  }
  removeNode(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    const next2 = node.next;
    const prev = node.prev;
    if (next2) {
      next2.prev = prev;
    }
    if (prev) {
      prev.next = next2;
    }
    if (node === this.head) {
      this.head = next2;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    this.length--;
    node.next = void 0;
    node.prev = void 0;
    node.list = void 0;
    return next2;
  }
  unshiftNode(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    const head6 = this.head;
    node.list = this;
    node.next = head6;
    if (head6) {
      head6.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  }
  pushNode(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    const tail4 = this.tail;
    node.list = this;
    node.prev = tail4;
    if (tail4) {
      tail4.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  }
  push(...args) {
    for (let i = 0, l = args.length; i < l; i++) {
      push2(this, args[i]);
    }
    return this.length;
  }
  unshift(...args) {
    for (var i = 0, l = args.length; i < l; i++) {
      unshift(this, args[i]);
    }
    return this.length;
  }
  pop() {
    if (!this.tail) {
      return void 0;
    }
    const res = this.tail.value;
    const t = this.tail;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = void 0;
    } else {
      this.head = void 0;
    }
    t.list = void 0;
    this.length--;
    return res;
  }
  shift() {
    if (!this.head) {
      return void 0;
    }
    const res = this.head.value;
    const h = this.head;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = void 0;
    } else {
      this.tail = void 0;
    }
    h.list = void 0;
    this.length--;
    return res;
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.head, i = 0; !!walker; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  }
  forEachReverse(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this.tail, i = this.length - 1; !!walker; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  }
  get(n) {
    let i = 0;
    let walker = this.head;
    for (; !!walker && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && !!walker) {
      return walker.value;
    }
  }
  getReverse(n) {
    let i = 0;
    let walker = this.tail;
    for (; !!walker && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && !!walker) {
      return walker.value;
    }
  }
  map(fn, thisp) {
    thisp = thisp || this;
    const res = new _Yallist();
    for (let walker = this.head; !!walker; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  }
  mapReverse(fn, thisp) {
    thisp = thisp || this;
    var res = new _Yallist();
    for (let walker = this.tail; !!walker; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  }
  reduce(fn, initial) {
    let acc;
    let walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; !!walker; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  }
  reduceReverse(fn, initial) {
    let acc;
    let walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (let i = this.length - 1; !!walker; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  }
  toArray() {
    const arr = new Array(this.length);
    for (let i = 0, walker = this.head; !!walker; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  }
  toArrayReverse() {
    const arr = new Array(this.length);
    for (let i = 0, walker = this.tail; !!walker; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  }
  slice(from4 = 0, to2 = this.length) {
    if (to2 < 0) {
      to2 += this.length;
    }
    if (from4 < 0) {
      from4 += this.length;
    }
    const ret = new _Yallist();
    if (to2 < from4 || to2 < 0) {
      return ret;
    }
    if (from4 < 0) {
      from4 = 0;
    }
    if (to2 > this.length) {
      to2 = this.length;
    }
    let walker = this.head;
    let i = 0;
    for (i = 0; !!walker && i < from4; i++) {
      walker = walker.next;
    }
    for (; !!walker && i < to2; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  }
  sliceReverse(from4 = 0, to2 = this.length) {
    if (to2 < 0) {
      to2 += this.length;
    }
    if (from4 < 0) {
      from4 += this.length;
    }
    const ret = new _Yallist();
    if (to2 < from4 || to2 < 0) {
      return ret;
    }
    if (from4 < 0) {
      from4 = 0;
    }
    if (to2 > this.length) {
      to2 = this.length;
    }
    let i = this.length;
    let walker = this.tail;
    for (; !!walker && i > to2; i--) {
      walker = walker.prev;
    }
    for (; !!walker && i > from4; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  }
  splice(start, deleteCount = 0, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    let walker = this.head;
    for (let i = 0; !!walker && i < start; i++) {
      walker = walker.next;
    }
    const ret = [];
    for (let i = 0; !!walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (!walker) {
      walker = this.tail;
    } else if (walker !== this.tail) {
      walker = walker.prev;
    }
    for (const v of nodes) {
      walker = insertAfter(this, walker, v);
    }
    return ret;
  }
  reverse() {
    const head6 = this.head;
    const tail4 = this.tail;
    for (let walker = head6; !!walker; walker = walker.prev) {
      const p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail4;
    this.tail = head6;
    return this;
  }
};
function insertAfter(self2, node, value4) {
  const prev = node;
  const next2 = node ? node.next : self2.head;
  const inserted = new Node2(value4, prev, next2, self2);
  if (inserted.next === void 0) {
    self2.tail = inserted;
  }
  if (inserted.prev === void 0) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push2(self2, item) {
  self2.tail = new Node2(item, self2.tail, void 0, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node2(item, void 0, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
var Node2 = class {
  list;
  next;
  prev;
  value;
  constructor(value4, prev, next2, list3) {
    this.list = list3;
    this.value = value4;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = void 0;
    }
    if (next2) {
      next2.prev = this;
      this.next = next2;
    } else {
      this.next = void 0;
    }
  }
};

// node_modules/tar/dist/esm/header.js
import { posix as pathModule } from "node:path";

// node_modules/tar/dist/esm/large-numbers.js
var encode4 = (num, buf) => {
  if (!Number.isSafeInteger(num)) {
    throw Error("cannot encode number outside of javascript safe integer range");
  } else if (num < 0) {
    encodeNegative(num, buf);
  } else {
    encodePositive(num, buf);
  }
  return buf;
};
var encodePositive = (num, buf) => {
  buf[0] = 128;
  for (var i = buf.length; i > 1; i--) {
    buf[i - 1] = num & 255;
    num = Math.floor(num / 256);
  }
};
var encodeNegative = (num, buf) => {
  buf[0] = 255;
  var flipped = false;
  num = num * -1;
  for (var i = buf.length; i > 1; i--) {
    var byte = num & 255;
    num = Math.floor(num / 256);
    if (flipped) {
      buf[i - 1] = onesComp(byte);
    } else if (byte === 0) {
      buf[i - 1] = 0;
    } else {
      flipped = true;
      buf[i - 1] = twosComp(byte);
    }
  }
};
var parse11 = (buf) => {
  const pre = buf[0];
  const value4 = pre === 128 ? pos(buf.subarray(1, buf.length)) : pre === 255 ? twos(buf) : null;
  if (value4 === null) {
    throw Error("invalid base256 encoding");
  }
  if (!Number.isSafeInteger(value4)) {
    throw Error("parsed number outside of javascript safe integer range");
  }
  return value4;
};
var twos = (buf) => {
  var len = buf.length;
  var sum4 = 0;
  var flipped = false;
  for (var i = len - 1; i > -1; i--) {
    var byte = Number(buf[i]);
    var f;
    if (flipped) {
      f = onesComp(byte);
    } else if (byte === 0) {
      f = byte;
    } else {
      flipped = true;
      f = twosComp(byte);
    }
    if (f !== 0) {
      sum4 -= f * Math.pow(256, len - i - 1);
    }
  }
  return sum4;
};
var pos = (buf) => {
  var len = buf.length;
  var sum4 = 0;
  for (var i = len - 1; i > -1; i--) {
    var byte = Number(buf[i]);
    if (byte !== 0) {
      sum4 += byte * Math.pow(256, len - i - 1);
    }
  }
  return sum4;
};
var onesComp = (byte) => (255 ^ byte) & 255;
var twosComp = (byte) => (255 ^ byte) + 1 & 255;

// node_modules/tar/dist/esm/types.js
var isCode = (c) => name4.has(c);
var name4 = /* @__PURE__ */ new Map([
  ["0", "File"],
  // same as File
  ["", "OldFile"],
  ["1", "Link"],
  ["2", "SymbolicLink"],
  // Devices and FIFOs aren't fully supported
  // they are parsed, but skipped when unpacking
  ["3", "CharacterDevice"],
  ["4", "BlockDevice"],
  ["5", "Directory"],
  ["6", "FIFO"],
  // same as File
  ["7", "ContiguousFile"],
  // pax headers
  ["g", "GlobalExtendedHeader"],
  ["x", "ExtendedHeader"],
  // vendor-specific stuff
  // skip
  ["A", "SolarisACL"],
  // like 5, but with data, which should be skipped
  ["D", "GNUDumpDir"],
  // metadata only, skip
  ["I", "Inode"],
  // data = link path of next file
  ["K", "NextFileHasLongLinkpath"],
  // data = path of next file
  ["L", "NextFileHasLongPath"],
  // skip
  ["M", "ContinuationFile"],
  // like L
  ["N", "OldGnuLongPath"],
  // skip
  ["S", "SparseFile"],
  // skip
  ["V", "TapeVolumeHeader"],
  // like x
  ["X", "OldExtendedHeader"]
]);
var code2 = new Map(Array.from(name4).map((kv) => [kv[1], kv[0]]));

// node_modules/tar/dist/esm/header.js
var Header = class {
  cksumValid = false;
  needPax = false;
  nullBlock = false;
  block;
  path;
  mode;
  uid;
  gid;
  size;
  cksum;
  #type = "Unsupported";
  linkpath;
  uname;
  gname;
  devmaj = 0;
  devmin = 0;
  atime;
  ctime;
  mtime;
  charset;
  comment;
  constructor(data, off = 0, ex, gex) {
    if (Buffer.isBuffer(data)) {
      this.decode(data, off || 0, ex, gex);
    } else if (data) {
      this.#slurp(data);
    }
  }
  decode(buf, off, ex, gex) {
    if (!off) {
      off = 0;
    }
    if (!buf || !(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    this.path = decString(buf, off, 100);
    this.mode = decNumber(buf, off + 100, 8);
    this.uid = decNumber(buf, off + 108, 8);
    this.gid = decNumber(buf, off + 116, 8);
    this.size = decNumber(buf, off + 124, 12);
    this.mtime = decDate(buf, off + 136, 12);
    this.cksum = decNumber(buf, off + 148, 12);
    if (gex)
      this.#slurp(gex, true);
    if (ex)
      this.#slurp(ex);
    const t = decString(buf, off + 156, 1);
    if (isCode(t)) {
      this.#type = t || "0";
    }
    if (this.#type === "0" && this.path.slice(-1) === "/") {
      this.#type = "5";
    }
    if (this.#type === "5") {
      this.size = 0;
    }
    this.linkpath = decString(buf, off + 157, 100);
    if (buf.subarray(off + 257, off + 265).toString() === "ustar\x0000") {
      this.uname = decString(buf, off + 265, 32);
      this.gname = decString(buf, off + 297, 32);
      this.devmaj = decNumber(buf, off + 329, 8) ?? 0;
      this.devmin = decNumber(buf, off + 337, 8) ?? 0;
      if (buf[off + 475] !== 0) {
        const prefix4 = decString(buf, off + 345, 155);
        this.path = prefix4 + "/" + this.path;
      } else {
        const prefix4 = decString(buf, off + 345, 130);
        if (prefix4) {
          this.path = prefix4 + "/" + this.path;
        }
        this.atime = decDate(buf, off + 476, 12);
        this.ctime = decDate(buf, off + 488, 12);
      }
    }
    let sum4 = 8 * 32;
    for (let i = off; i < off + 148; i++) {
      sum4 += buf[i];
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum4 += buf[i];
    }
    this.cksumValid = sum4 === this.cksum;
    if (this.cksum === void 0 && sum4 === 8 * 32) {
      this.nullBlock = true;
    }
  }
  #slurp(ex, gex = false) {
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
      return !(v === null || v === void 0 || k === "path" && gex || k === "linkpath" && gex || k === "global");
    })));
  }
  encode(buf, off = 0) {
    if (!buf) {
      buf = this.block = Buffer.alloc(512);
    }
    if (this.#type === "Unsupported") {
      this.#type = "0";
    }
    if (!(buf.length >= off + 512)) {
      throw new Error("need 512 bytes for header");
    }
    const prefixSize = this.ctime || this.atime ? 130 : 155;
    const split3 = splitPrefix(this.path || "", prefixSize);
    const path14 = split3[0];
    const prefix4 = split3[1];
    this.needPax = !!split3[2];
    this.needPax = encString(buf, off, 100, path14) || this.needPax;
    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
    buf[off + 156] = this.#type.charCodeAt(0);
    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
    buf.write("ustar\x0000", off + 257, 8);
    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
    this.needPax = encString(buf, off + 345, prefixSize, prefix4) || this.needPax;
    if (buf[off + 475] !== 0) {
      this.needPax = encString(buf, off + 345, 155, prefix4) || this.needPax;
    } else {
      this.needPax = encString(buf, off + 345, 130, prefix4) || this.needPax;
      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
    }
    let sum4 = 8 * 32;
    for (let i = off; i < off + 148; i++) {
      sum4 += buf[i];
    }
    for (let i = off + 156; i < off + 512; i++) {
      sum4 += buf[i];
    }
    this.cksum = sum4;
    encNumber(buf, off + 148, 8, this.cksum);
    this.cksumValid = true;
    return this.needPax;
  }
  get type() {
    return this.#type === "Unsupported" ? this.#type : name4.get(this.#type);
  }
  get typeKey() {
    return this.#type;
  }
  set type(type) {
    const c = String(code2.get(type));
    if (isCode(c) || c === "Unsupported") {
      this.#type = c;
    } else if (isCode(type)) {
      this.#type = type;
    } else {
      throw new TypeError("invalid entry type: " + type);
    }
  }
};
var splitPrefix = (p, prefixSize) => {
  const pathSize = 100;
  let pp = p;
  let prefix4 = "";
  let ret = void 0;
  const root2 = pathModule.parse(p).root || ".";
  if (Buffer.byteLength(pp) < pathSize) {
    ret = [pp, prefix4, false];
  } else {
    prefix4 = pathModule.dirname(pp);
    pp = pathModule.basename(pp);
    do {
      if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix4) <= prefixSize) {
        ret = [pp, prefix4, false];
      } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix4) <= prefixSize) {
        ret = [pp.slice(0, pathSize - 1), prefix4, true];
      } else {
        pp = pathModule.join(pathModule.basename(prefix4), pp);
        prefix4 = pathModule.dirname(prefix4);
      }
    } while (prefix4 !== root2 && ret === void 0);
    if (!ret) {
      ret = [p.slice(0, pathSize - 1), "", true];
    }
  }
  return ret;
};
var decString = (buf, off, size8) => buf.subarray(off, off + size8).toString("utf8").replace(/\0.*/, "");
var decDate = (buf, off, size8) => numToDate(decNumber(buf, off, size8));
var numToDate = (num) => num === void 0 ? void 0 : new Date(num * 1e3);
var decNumber = (buf, off, size8) => Number(buf[off]) & 128 ? parse11(buf.subarray(off, off + size8)) : decSmallNumber(buf, off, size8);
var nanUndef = (value4) => isNaN(value4) ? void 0 : value4;
var decSmallNumber = (buf, off, size8) => nanUndef(parseInt(buf.subarray(off, off + size8).toString("utf8").replace(/\0.*$/, "").trim(), 8));
var MAXNUM = {
  12: 8589934591,
  8: 2097151
};
var encNumber = (buf, off, size8, num) => num === void 0 ? false : num > MAXNUM[size8] || num < 0 ? (encode4(num, buf.subarray(off, off + size8)), true) : (encSmallNumber(buf, off, size8, num), false);
var encSmallNumber = (buf, off, size8, num) => buf.write(octalString(num, size8), off, size8, "ascii");
var octalString = (num, size8) => padOctal(Math.floor(num).toString(8), size8);
var padOctal = (str2, size8) => (str2.length === size8 - 1 ? str2 : new Array(size8 - str2.length - 1).join("0") + str2 + " ") + "\0";
var encDate = (buf, off, size8, date2) => date2 === void 0 ? false : encNumber(buf, off, size8, date2.getTime() / 1e3);
var NULLS = new Array(156).join("\0");
var encString = (buf, off, size8, str2) => str2 === void 0 ? false : (buf.write(str2 + NULLS, off, size8, "utf8"), str2.length !== Buffer.byteLength(str2) || str2.length > size8);

// node_modules/tar/dist/esm/pax.js
import { basename as basename2 } from "node:path";
var Pax = class _Pax {
  atime;
  mtime;
  ctime;
  charset;
  comment;
  gid;
  uid;
  gname;
  uname;
  linkpath;
  dev;
  ino;
  nlink;
  path;
  size;
  mode;
  global;
  constructor(obj, global3 = false) {
    this.atime = obj.atime;
    this.charset = obj.charset;
    this.comment = obj.comment;
    this.ctime = obj.ctime;
    this.dev = obj.dev;
    this.gid = obj.gid;
    this.global = global3;
    this.gname = obj.gname;
    this.ino = obj.ino;
    this.linkpath = obj.linkpath;
    this.mtime = obj.mtime;
    this.nlink = obj.nlink;
    this.path = obj.path;
    this.size = obj.size;
    this.uid = obj.uid;
    this.uname = obj.uname;
  }
  encode() {
    const body = this.encodeBody();
    if (body === "") {
      return Buffer.allocUnsafe(0);
    }
    const bodyLen = Buffer.byteLength(body);
    const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
    const buf = Buffer.allocUnsafe(bufLen);
    for (let i = 0; i < 512; i++) {
      buf[i] = 0;
    }
    new Header({
      // XXX split the path
      // then the path should be PaxHeader + basename, but less than 99,
      // prepend with the dirname
      /* c8 ignore start */
      path: ("PaxHeader/" + basename2(this.path ?? "")).slice(0, 99),
      /* c8 ignore stop */
      mode: this.mode || 420,
      uid: this.uid,
      gid: this.gid,
      size: bodyLen,
      mtime: this.mtime,
      type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
      linkpath: "",
      uname: this.uname || "",
      gname: this.gname || "",
      devmaj: 0,
      devmin: 0,
      atime: this.atime,
      ctime: this.ctime
    }).encode(buf);
    buf.write(body, 512, bodyLen, "utf8");
    for (let i = bodyLen + 512; i < buf.length; i++) {
      buf[i] = 0;
    }
    return buf;
  }
  encodeBody() {
    return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
  }
  encodeField(field) {
    if (this[field] === void 0) {
      return "";
    }
    const r = this[field];
    const v = r instanceof Date ? r.getTime() / 1e3 : r;
    const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
    const byteLen = Buffer.byteLength(s);
    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
    if (byteLen + digits >= Math.pow(10, digits)) {
      digits += 1;
    }
    const len = digits + byteLen;
    return len + s;
  }
  static parse(str2, ex, g = false) {
    return new _Pax(merge2(parseKV(str2), ex), g);
  }
};
var merge2 = (a, b) => b ? Object.assign({}, b, a) : a;
var parseKV = (str2) => str2.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
var parseKVLine = (set4, line2) => {
  const n = parseInt(line2, 10);
  if (n !== Buffer.byteLength(line2) + 1) {
    return set4;
  }
  line2 = line2.slice((n + " ").length);
  const kv = line2.split("=");
  const r = kv.shift();
  if (!r) {
    return set4;
  }
  const k = r.replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
  const v = kv.join("=");
  set4[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(Number(v) * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
  return set4;
};

// node_modules/tar/dist/esm/normalize-windows-path.js
var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var normalizeWindowsPath = platform3 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");

// node_modules/tar/dist/esm/read-entry.js
var ReadEntry = class extends Minipass {
  extended;
  globalExtended;
  header;
  startBlockSize;
  blockRemain;
  remain;
  type;
  meta = false;
  ignore = false;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  size = 0;
  mtime;
  atime;
  ctime;
  linkpath;
  dev;
  ino;
  nlink;
  invalid = false;
  absolute;
  unsupported = false;
  constructor(header, ex, gex) {
    super({});
    this.pause();
    this.extended = ex;
    this.globalExtended = gex;
    this.header = header;
    this.remain = header.size ?? 0;
    this.startBlockSize = 512 * Math.ceil(this.remain / 512);
    this.blockRemain = this.startBlockSize;
    this.type = header.type;
    switch (this.type) {
      case "File":
      case "OldFile":
      case "Link":
      case "SymbolicLink":
      case "CharacterDevice":
      case "BlockDevice":
      case "Directory":
      case "FIFO":
      case "ContiguousFile":
      case "GNUDumpDir":
        break;
      case "NextFileHasLongLinkpath":
      case "NextFileHasLongPath":
      case "OldGnuLongPath":
      case "GlobalExtendedHeader":
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this.meta = true;
        break;
      default:
        this.ignore = true;
    }
    if (!header.path) {
      throw new Error("no path provided for tar.ReadEntry");
    }
    this.path = normalizeWindowsPath(header.path);
    this.mode = header.mode;
    if (this.mode) {
      this.mode = this.mode & 4095;
    }
    this.uid = header.uid;
    this.gid = header.gid;
    this.uname = header.uname;
    this.gname = header.gname;
    this.size = this.remain;
    this.mtime = header.mtime;
    this.atime = header.atime;
    this.ctime = header.ctime;
    this.linkpath = header.linkpath ? normalizeWindowsPath(header.linkpath) : void 0;
    this.uname = header.uname;
    this.gname = header.gname;
    if (ex) {
      this.#slurp(ex);
    }
    if (gex) {
      this.#slurp(gex, true);
    }
  }
  write(data) {
    const writeLen = data.length;
    if (writeLen > this.blockRemain) {
      throw new Error("writing more to entry than is appropriate");
    }
    const r = this.remain;
    const br = this.blockRemain;
    this.remain = Math.max(0, r - writeLen);
    this.blockRemain = Math.max(0, br - writeLen);
    if (this.ignore) {
      return true;
    }
    if (r >= writeLen) {
      return super.write(data);
    }
    return super.write(data.subarray(0, r));
  }
  #slurp(ex, gex = false) {
    if (ex.path)
      ex.path = normalizeWindowsPath(ex.path);
    if (ex.linkpath)
      ex.linkpath = normalizeWindowsPath(ex.linkpath);
    Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {
      return !(v === null || v === void 0 || k === "path" && gex);
    })));
  }
};

// node_modules/tar/dist/esm/warn-method.js
var warnMethod = (self2, code3, message3, data = {}) => {
  if (self2.file) {
    data.file = self2.file;
  }
  if (self2.cwd) {
    data.cwd = self2.cwd;
  }
  data.code = message3 instanceof Error && message3.code || code3;
  data.tarCode = code3;
  if (!self2.strict && data.recoverable !== false) {
    if (message3 instanceof Error) {
      data = Object.assign(message3, data);
      message3 = message3.message;
    }
    self2.emit("warn", code3, message3, data);
  } else if (message3 instanceof Error) {
    self2.emit("error", Object.assign(message3, data));
  } else {
    self2.emit("error", Object.assign(new Error(`${code3}: ${message3}`), data));
  }
};

// node_modules/tar/dist/esm/parse.js
var maxMetaEntrySize = 1024 * 1024;
var gzipHeader = Buffer.from([31, 139]);
var STATE = Symbol("state");
var WRITEENTRY = Symbol("writeEntry");
var READENTRY = Symbol("readEntry");
var NEXTENTRY = Symbol("nextEntry");
var PROCESSENTRY = Symbol("processEntry");
var EX = Symbol("extendedHeader");
var GEX = Symbol("globalExtendedHeader");
var META = Symbol("meta");
var EMITMETA = Symbol("emitMeta");
var BUFFER2 = Symbol("buffer");
var QUEUE = Symbol("queue");
var ENDED = Symbol("ended");
var EMITTEDEND = Symbol("emittedEnd");
var EMIT = Symbol("emit");
var UNZIP = Symbol("unzip");
var CONSUMECHUNK = Symbol("consumeChunk");
var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
var CONSUMEBODY = Symbol("consumeBody");
var CONSUMEMETA = Symbol("consumeMeta");
var CONSUMEHEADER = Symbol("consumeHeader");
var CONSUMING = Symbol("consuming");
var BUFFERCONCAT = Symbol("bufferConcat");
var MAYBEEND = Symbol("maybeEnd");
var WRITING = Symbol("writing");
var ABORTED2 = Symbol("aborted");
var DONE = Symbol("onDone");
var SAW_VALID_ENTRY = Symbol("sawValidEntry");
var SAW_NULL_BLOCK = Symbol("sawNullBlock");
var SAW_EOF = Symbol("sawEOF");
var CLOSESTREAM = Symbol("closeStream");
var noop = () => true;
var Parser = class extends EE2 {
  file;
  strict;
  maxMetaEntrySize;
  filter;
  brotli;
  writable = true;
  readable = false;
  [QUEUE] = new Yallist();
  [BUFFER2];
  [READENTRY];
  [WRITEENTRY];
  [STATE] = "begin";
  [META] = "";
  [EX];
  [GEX];
  [ENDED] = false;
  [UNZIP];
  [ABORTED2] = false;
  [SAW_VALID_ENTRY];
  [SAW_NULL_BLOCK] = false;
  [SAW_EOF] = false;
  [WRITING] = false;
  [CONSUMING] = false;
  [EMITTEDEND] = false;
  constructor(opt = {}) {
    super();
    this.file = opt.file || "";
    this.on(DONE, () => {
      if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
        this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
      }
    });
    if (opt.ondone) {
      this.on(DONE, opt.ondone);
    } else {
      this.on(DONE, () => {
        this.emit("prefinish");
        this.emit("finish");
        this.emit("end");
      });
    }
    this.strict = !!opt.strict;
    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
    this.filter = typeof opt.filter === "function" ? opt.filter : noop;
    const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
    this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : false;
    this.on("end", () => this[CLOSESTREAM]());
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    if (typeof opt.onentry === "function") {
      this.on("entry", opt.onentry);
    }
  }
  warn(code3, message3, data = {}) {
    warnMethod(this, code3, message3, data);
  }
  [CONSUMEHEADER](chunk, position2) {
    if (this[SAW_VALID_ENTRY] === void 0) {
      this[SAW_VALID_ENTRY] = false;
    }
    let header;
    try {
      header = new Header(chunk, position2, this[EX], this[GEX]);
    } catch (er) {
      return this.warn("TAR_ENTRY_INVALID", er);
    }
    if (header.nullBlock) {
      if (this[SAW_NULL_BLOCK]) {
        this[SAW_EOF] = true;
        if (this[STATE] === "begin") {
          this[STATE] = "header";
        }
        this[EMIT]("eof");
      } else {
        this[SAW_NULL_BLOCK] = true;
        this[EMIT]("nullBlock");
      }
    } else {
      this[SAW_NULL_BLOCK] = false;
      if (!header.cksumValid) {
        this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
      } else if (!header.path) {
        this.warn("TAR_ENTRY_INVALID", "path is required", { header });
      } else {
        const type = header.type;
        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
          this.warn("TAR_ENTRY_INVALID", "linkpath required", {
            header
          });
        } else if (!/^(Symbolic)?Link$/.test(type) && !/^(Global)?ExtendedHeader$/.test(type) && header.linkpath) {
          this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", {
            header
          });
        } else {
          const entry = this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]);
          if (!this[SAW_VALID_ENTRY]) {
            if (entry.remain) {
              const onend = () => {
                if (!entry.invalid) {
                  this[SAW_VALID_ENTRY] = true;
                }
              };
              entry.on("end", onend);
            } else {
              this[SAW_VALID_ENTRY] = true;
            }
          }
          if (entry.meta) {
            if (entry.size > this.maxMetaEntrySize) {
              entry.ignore = true;
              this[EMIT]("ignoredEntry", entry);
              this[STATE] = "ignore";
              entry.resume();
            } else if (entry.size > 0) {
              this[META] = "";
              entry.on("data", (c) => this[META] += c);
              this[STATE] = "meta";
            }
          } else {
            this[EX] = void 0;
            entry.ignore = entry.ignore || !this.filter(entry.path, entry);
            if (entry.ignore) {
              this[EMIT]("ignoredEntry", entry);
              this[STATE] = entry.remain ? "ignore" : "header";
              entry.resume();
            } else {
              if (entry.remain) {
                this[STATE] = "body";
              } else {
                this[STATE] = "header";
                entry.end();
              }
              if (!this[READENTRY]) {
                this[QUEUE].push(entry);
                this[NEXTENTRY]();
              } else {
                this[QUEUE].push(entry);
              }
            }
          }
        }
      }
    }
  }
  [CLOSESTREAM]() {
    queueMicrotask(() => this.emit("close"));
  }
  [PROCESSENTRY](entry) {
    let go = true;
    if (!entry) {
      this[READENTRY] = void 0;
      go = false;
    } else if (Array.isArray(entry)) {
      const [ev, ...args] = entry;
      this.emit(ev, ...args);
    } else {
      this[READENTRY] = entry;
      this.emit("entry", entry);
      if (!entry.emittedEnd) {
        entry.on("end", () => this[NEXTENTRY]());
        go = false;
      }
    }
    return go;
  }
  [NEXTENTRY]() {
    do {
    } while (this[PROCESSENTRY](this[QUEUE].shift()));
    if (!this[QUEUE].length) {
      const re = this[READENTRY];
      const drainNow = !re || re.flowing || re.size === re.remain;
      if (drainNow) {
        if (!this[WRITING]) {
          this.emit("drain");
        }
      } else {
        re.once("drain", () => this.emit("drain"));
      }
    }
  }
  [CONSUMEBODY](chunk, position2) {
    const entry = this[WRITEENTRY];
    if (!entry) {
      throw new Error("attempt to consume body without entry??");
    }
    const br = entry.blockRemain ?? 0;
    const c = br >= chunk.length && position2 === 0 ? chunk : chunk.subarray(position2, position2 + br);
    entry.write(c);
    if (!entry.blockRemain) {
      this[STATE] = "header";
      this[WRITEENTRY] = void 0;
      entry.end();
    }
    return c.length;
  }
  [CONSUMEMETA](chunk, position2) {
    const entry = this[WRITEENTRY];
    const ret = this[CONSUMEBODY](chunk, position2);
    if (!this[WRITEENTRY] && entry) {
      this[EMITMETA](entry);
    }
    return ret;
  }
  [EMIT](ev, data, extra) {
    if (!this[QUEUE].length && !this[READENTRY]) {
      this.emit(ev, data, extra);
    } else {
      this[QUEUE].push([ev, data, extra]);
    }
  }
  [EMITMETA](entry) {
    this[EMIT]("meta", this[META]);
    switch (entry.type) {
      case "ExtendedHeader":
      case "OldExtendedHeader":
        this[EX] = Pax.parse(this[META], this[EX], false);
        break;
      case "GlobalExtendedHeader":
        this[GEX] = Pax.parse(this[META], this[GEX], true);
        break;
      case "NextFileHasLongPath":
      case "OldGnuLongPath": {
        const ex = this[EX] ?? /* @__PURE__ */ Object.create(null);
        this[EX] = ex;
        ex.path = this[META].replace(/\0.*/, "");
        break;
      }
      case "NextFileHasLongLinkpath": {
        const ex = this[EX] || /* @__PURE__ */ Object.create(null);
        this[EX] = ex;
        ex.linkpath = this[META].replace(/\0.*/, "");
        break;
      }
      default:
        throw new Error("unknown meta: " + entry.type);
    }
  }
  abort(error5) {
    this[ABORTED2] = true;
    this.emit("abort", error5);
    this.warn("TAR_ABORT", error5, { recoverable: false });
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(
        chunk,
        /* c8 ignore next */
        typeof encoding === "string" ? encoding : "utf8"
      );
    }
    if (this[ABORTED2]) {
      cb?.();
      return false;
    }
    const needSniff = this[UNZIP] === void 0 || this.brotli === void 0 && this[UNZIP] === false;
    if (needSniff && chunk) {
      if (this[BUFFER2]) {
        chunk = Buffer.concat([this[BUFFER2], chunk]);
        this[BUFFER2] = void 0;
      }
      if (chunk.length < gzipHeader.length) {
        this[BUFFER2] = chunk;
        cb?.();
        return true;
      }
      for (let i = 0; this[UNZIP] === void 0 && i < gzipHeader.length; i++) {
        if (chunk[i] !== gzipHeader[i]) {
          this[UNZIP] = false;
        }
      }
      const maybeBrotli = this.brotli === void 0;
      if (this[UNZIP] === false && maybeBrotli) {
        if (chunk.length < 512) {
          if (this[ENDED]) {
            this.brotli = true;
          } else {
            this[BUFFER2] = chunk;
            cb?.();
            return true;
          }
        } else {
          try {
            new Header(chunk.subarray(0, 512));
            this.brotli = false;
          } catch (_) {
            this.brotli = true;
          }
        }
      }
      if (this[UNZIP] === void 0 || this[UNZIP] === false && this.brotli) {
        const ended = this[ENDED];
        this[ENDED] = false;
        this[UNZIP] = this[UNZIP] === void 0 ? new Unzip({}) : new BrotliDecompress({});
        this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
        this[UNZIP].on("error", (er) => this.abort(er));
        this[UNZIP].on("end", () => {
          this[ENDED] = true;
          this[CONSUMECHUNK]();
        });
        this[WRITING] = true;
        const ret2 = !!this[UNZIP][ended ? "end" : "write"](chunk);
        this[WRITING] = false;
        cb?.();
        return ret2;
      }
    }
    this[WRITING] = true;
    if (this[UNZIP]) {
      this[UNZIP].write(chunk);
    } else {
      this[CONSUMECHUNK](chunk);
    }
    this[WRITING] = false;
    const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
    if (!ret && !this[QUEUE].length) {
      this[READENTRY]?.once("drain", () => this.emit("drain"));
    }
    cb?.();
    return ret;
  }
  [BUFFERCONCAT](c) {
    if (c && !this[ABORTED2]) {
      this[BUFFER2] = this[BUFFER2] ? Buffer.concat([this[BUFFER2], c]) : c;
    }
  }
  [MAYBEEND]() {
    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED2] && !this[CONSUMING]) {
      this[EMITTEDEND] = true;
      const entry = this[WRITEENTRY];
      if (entry && entry.blockRemain) {
        const have = this[BUFFER2] ? this[BUFFER2].length : 0;
        this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
        if (this[BUFFER2]) {
          entry.write(this[BUFFER2]);
        }
        entry.end();
      }
      this[EMIT](DONE);
    }
  }
  [CONSUMECHUNK](chunk) {
    if (this[CONSUMING] && chunk) {
      this[BUFFERCONCAT](chunk);
    } else if (!chunk && !this[BUFFER2]) {
      this[MAYBEEND]();
    } else if (chunk) {
      this[CONSUMING] = true;
      if (this[BUFFER2]) {
        this[BUFFERCONCAT](chunk);
        const c = this[BUFFER2];
        this[BUFFER2] = void 0;
        this[CONSUMECHUNKSUB](c);
      } else {
        this[CONSUMECHUNKSUB](chunk);
      }
      while (this[BUFFER2] && this[BUFFER2]?.length >= 512 && !this[ABORTED2] && !this[SAW_EOF]) {
        const c = this[BUFFER2];
        this[BUFFER2] = void 0;
        this[CONSUMECHUNKSUB](c);
      }
      this[CONSUMING] = false;
    }
    if (!this[BUFFER2] || this[ENDED]) {
      this[MAYBEEND]();
    }
  }
  [CONSUMECHUNKSUB](chunk) {
    let position2 = 0;
    const length9 = chunk.length;
    while (position2 + 512 <= length9 && !this[ABORTED2] && !this[SAW_EOF]) {
      switch (this[STATE]) {
        case "begin":
        case "header":
          this[CONSUMEHEADER](chunk, position2);
          position2 += 512;
          break;
        case "ignore":
        case "body":
          position2 += this[CONSUMEBODY](chunk, position2);
          break;
        case "meta":
          position2 += this[CONSUMEMETA](chunk, position2);
          break;
        default:
          throw new Error("invalid state: " + this[STATE]);
      }
    }
    if (position2 < length9) {
      if (this[BUFFER2]) {
        this[BUFFER2] = Buffer.concat([
          chunk.subarray(position2),
          this[BUFFER2]
        ]);
      } else {
        this[BUFFER2] = chunk.subarray(position2);
      }
    }
  }
  end(chunk, encoding, cb) {
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = void 0;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding);
    }
    if (cb)
      this.once("finish", cb);
    if (!this[ABORTED2]) {
      if (this[UNZIP]) {
        if (chunk)
          this[UNZIP].write(chunk);
        this[UNZIP].end();
      } else {
        this[ENDED] = true;
        if (this.brotli === void 0)
          chunk = chunk || Buffer.alloc(0);
        if (chunk)
          this.write(chunk);
        this[MAYBEEND]();
      }
    }
    return this;
  }
};

// node_modules/tar/dist/esm/strip-trailing-slashes.js
var stripTrailingSlashes = (str2) => {
  let i = str2.length - 1;
  let slashesStart = -1;
  while (i > -1 && str2.charAt(i) === "/") {
    slashesStart = i;
    i--;
  }
  return slashesStart === -1 ? str2 : str2.slice(0, slashesStart);
};

// node_modules/tar/dist/esm/list.js
var onentryFunction = (opt) => {
  const onentry = opt.onentry;
  opt.onentry = onentry ? (e) => {
    onentry(e);
    e.resume();
  } : (e) => e.resume();
};
var filesFilter = (opt, files) => {
  const map154 = new Map(files.map((f) => [stripTrailingSlashes(f), true]));
  const filter11 = opt.filter;
  const mapHas = (file, r = "") => {
    const root2 = r || parse12(file).root || ".";
    let ret;
    if (file === root2)
      ret = false;
    else {
      const m = map154.get(file);
      if (m !== void 0) {
        ret = m;
      } else {
        ret = mapHas(dirname2(file), root2);
      }
    }
    map154.set(file, ret);
    return ret;
  };
  opt.filter = filter11 ? (file, entry) => filter11(file, entry) && mapHas(stripTrailingSlashes(file)) : (file) => mapHas(stripTrailingSlashes(file));
};
var listFileSync = (opt) => {
  const p = new Parser(opt);
  const file = opt.file;
  let fd;
  try {
    const stat6 = fs3.statSync(file);
    const readSize = opt.maxReadSize || 16 * 1024 * 1024;
    if (stat6.size < readSize) {
      p.end(fs3.readFileSync(file));
    } else {
      let pos2 = 0;
      const buf = Buffer.allocUnsafe(readSize);
      fd = fs3.openSync(file, "r");
      while (pos2 < stat6.size) {
        const bytesRead = fs3.readSync(fd, buf, 0, readSize, pos2);
        pos2 += bytesRead;
        p.write(buf.subarray(0, bytesRead));
      }
      p.end();
    }
  } finally {
    if (typeof fd === "number") {
      try {
        fs3.closeSync(fd);
      } catch (er) {
      }
    }
  }
};
var listFile = (opt, _files) => {
  const parse15 = new Parser(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve3, reject) => {
    parse15.on("error", reject);
    parse15.on("end", resolve3);
    fs3.stat(file, (er, stat6) => {
      if (er) {
        reject(er);
      } else {
        const stream3 = new ReadStream(file, {
          readSize,
          size: stat6.size
        });
        stream3.on("error", reject);
        stream3.pipe(parse15);
      }
    });
  });
  return p;
};
var list2 = makeCommand(listFileSync, listFile, (opt) => new Parser(opt), (opt) => new Parser(opt), (opt, files) => {
  if (files?.length)
    filesFilter(opt, files);
  if (!opt.noResume)
    onentryFunction(opt);
});

// node_modules/tar/dist/esm/pack.js
import fs5 from "fs";

// node_modules/tar/dist/esm/write-entry.js
import fs4 from "fs";
import path3 from "path";

// node_modules/tar/dist/esm/mode-fix.js
var modeFix = (mode2, isDir, portable) => {
  mode2 &= 4095;
  if (portable) {
    mode2 = (mode2 | 384) & ~18;
  }
  if (isDir) {
    if (mode2 & 256) {
      mode2 |= 64;
    }
    if (mode2 & 32) {
      mode2 |= 8;
    }
    if (mode2 & 4) {
      mode2 |= 1;
    }
  }
  return mode2;
};

// node_modules/tar/dist/esm/strip-absolute-path.js
import { win32 } from "node:path";
var { isAbsolute: isAbsolute2, parse: parse13 } = win32;
var stripAbsolutePath = (path14) => {
  let r = "";
  let parsed = parse13(path14);
  while (isAbsolute2(path14) || parsed.root) {
    const root2 = path14.charAt(0) === "/" && path14.slice(0, 4) !== "//?/" ? "/" : parsed.root;
    path14 = path14.slice(root2.length);
    r += root2;
    parsed = parse13(path14);
  }
  return [r, path14];
};

// node_modules/tar/dist/esm/winchars.js
var raw = ["|", "<", ">", "?", ":"];
var win = raw.map((char2) => String.fromCharCode(61440 + char2.charCodeAt(0)));
var toWin = new Map(raw.map((char2, i) => [char2, win[i]]));
var toRaw = new Map(win.map((char2, i) => [char2, raw[i]]));
var encode5 = (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s);
var decode3 = (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s);

// node_modules/tar/dist/esm/write-entry.js
var prefixPath = (path14, prefix4) => {
  if (!prefix4) {
    return normalizeWindowsPath(path14);
  }
  path14 = normalizeWindowsPath(path14).replace(/^\.(\/|$)/, "");
  return stripTrailingSlashes(prefix4) + "/" + path14;
};
var maxReadSize = 16 * 1024 * 1024;
var PROCESS = Symbol("process");
var FILE = Symbol("file");
var DIRECTORY = Symbol("directory");
var SYMLINK = Symbol("symlink");
var HARDLINK = Symbol("hardlink");
var HEADER = Symbol("header");
var READ2 = Symbol("read");
var LSTAT = Symbol("lstat");
var ONLSTAT = Symbol("onlstat");
var ONREAD = Symbol("onread");
var ONREADLINK = Symbol("onreadlink");
var OPENFILE = Symbol("openfile");
var ONOPENFILE = Symbol("onopenfile");
var CLOSE = Symbol("close");
var MODE = Symbol("mode");
var AWAITDRAIN = Symbol("awaitDrain");
var ONDRAIN = Symbol("ondrain");
var PREFIX = Symbol("prefix");
var WriteEntry = class extends Minipass {
  path;
  portable;
  myuid = process.getuid && process.getuid() || 0;
  // until node has builtin pwnam functions, this'll have to do
  myuser = process.env.USER || "";
  maxReadSize;
  linkCache;
  statCache;
  preservePaths;
  cwd;
  strict;
  mtime;
  noPax;
  noMtime;
  prefix;
  fd;
  blockLen = 0;
  blockRemain = 0;
  buf;
  pos = 0;
  remain = 0;
  length = 0;
  offset = 0;
  win32;
  absolute;
  header;
  type;
  linkpath;
  stat;
  /* c8 ignore start */
  #hadError = false;
  constructor(p, opt_ = {}) {
    const opt = dealias(opt_);
    super();
    this.path = normalizeWindowsPath(p);
    this.portable = !!opt.portable;
    this.maxReadSize = opt.maxReadSize || maxReadSize;
    this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
    this.statCache = opt.statCache || /* @__PURE__ */ new Map();
    this.preservePaths = !!opt.preservePaths;
    this.cwd = normalizeWindowsPath(opt.cwd || process.cwd());
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.noMtime = !!opt.noMtime;
    this.mtime = opt.mtime;
    this.prefix = opt.prefix ? normalizeWindowsPath(opt.prefix) : void 0;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    let pathWarn = false;
    if (!this.preservePaths) {
      const [root2, stripped] = stripAbsolutePath(this.path);
      if (root2 && typeof stripped === "string") {
        this.path = stripped;
        pathWarn = root2;
      }
    }
    this.win32 = !!opt.win32 || process.platform === "win32";
    if (this.win32) {
      this.path = decode3(this.path.replace(/\\/g, "/"));
      p = p.replace(/\\/g, "/");
    }
    this.absolute = normalizeWindowsPath(opt.absolute || path3.resolve(this.cwd, p));
    if (this.path === "") {
      this.path = "./";
    }
    if (pathWarn) {
      this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      });
    }
    const cs = this.statCache.get(this.absolute);
    if (cs) {
      this[ONLSTAT](cs);
    } else {
      this[LSTAT]();
    }
  }
  warn(code3, message3, data = {}) {
    return warnMethod(this, code3, message3, data);
  }
  emit(ev, ...data) {
    if (ev === "error") {
      this.#hadError = true;
    }
    return super.emit(ev, ...data);
  }
  [LSTAT]() {
    fs4.lstat(this.absolute, (er, stat6) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONLSTAT](stat6);
    });
  }
  [ONLSTAT](stat6) {
    this.statCache.set(this.absolute, stat6);
    this.stat = stat6;
    if (!stat6.isFile()) {
      stat6.size = 0;
    }
    this.type = getType(stat6);
    this.emit("stat", stat6);
    this[PROCESS]();
  }
  [PROCESS]() {
    switch (this.type) {
      case "File":
        return this[FILE]();
      case "Directory":
        return this[DIRECTORY]();
      case "SymbolicLink":
        return this[SYMLINK]();
      default:
        return this.end();
    }
  }
  [MODE](mode2) {
    return modeFix(mode2, this.type === "Directory", this.portable);
  }
  [PREFIX](path14) {
    return prefixPath(path14, this.prefix);
  }
  [HEADER]() {
    if (!this.stat) {
      throw new Error("cannot write header before stat");
    }
    if (this.type === "Directory" && this.portable) {
      this.noMtime = true;
    }
    this.header = new Header({
      path: this[PREFIX](this.path),
      // only apply the prefix to hard links.
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this[MODE](this.stat.mode),
      uid: this.portable ? void 0 : this.stat.uid,
      gid: this.portable ? void 0 : this.stat.gid,
      size: this.stat.size,
      mtime: this.noMtime ? void 0 : this.mtime || this.stat.mtime,
      /* c8 ignore next */
      type: this.type === "Unsupported" ? void 0 : this.type,
      uname: this.portable ? void 0 : this.stat.uid === this.myuid ? this.myuser : "",
      atime: this.portable ? void 0 : this.stat.atime,
      ctime: this.portable ? void 0 : this.stat.ctime
    });
    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? void 0 : this.header.atime,
        ctime: this.portable ? void 0 : this.header.ctime,
        gid: this.portable ? void 0 : this.header.gid,
        mtime: this.noMtime ? void 0 : this.mtime || this.header.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.header.size,
        uid: this.portable ? void 0 : this.header.uid,
        uname: this.portable ? void 0 : this.header.uname,
        dev: this.portable ? void 0 : this.stat.dev,
        ino: this.portable ? void 0 : this.stat.ino,
        nlink: this.portable ? void 0 : this.stat.nlink
      }).encode());
    }
    const block = this.header?.block;
    if (!block) {
      throw new Error("failed to encode header");
    }
    super.write(block);
  }
  [DIRECTORY]() {
    if (!this.stat) {
      throw new Error("cannot create directory entry without stat");
    }
    if (this.path.slice(-1) !== "/") {
      this.path += "/";
    }
    this.stat.size = 0;
    this[HEADER]();
    this.end();
  }
  [SYMLINK]() {
    fs4.readlink(this.absolute, (er, linkpath) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONREADLINK](linkpath);
    });
  }
  [ONREADLINK](linkpath) {
    this.linkpath = normalizeWindowsPath(linkpath);
    this[HEADER]();
    this.end();
  }
  [HARDLINK](linkpath) {
    if (!this.stat) {
      throw new Error("cannot create link entry without stat");
    }
    this.type = "Link";
    this.linkpath = normalizeWindowsPath(path3.relative(this.cwd, linkpath));
    this.stat.size = 0;
    this[HEADER]();
    this.end();
  }
  [FILE]() {
    if (!this.stat) {
      throw new Error("cannot create file entry without stat");
    }
    if (this.stat.nlink > 1) {
      const linkKey = `${this.stat.dev}:${this.stat.ino}`;
      const linkpath = this.linkCache.get(linkKey);
      if (linkpath?.indexOf(this.cwd) === 0) {
        return this[HARDLINK](linkpath);
      }
      this.linkCache.set(linkKey, this.absolute);
    }
    this[HEADER]();
    if (this.stat.size === 0) {
      return this.end();
    }
    this[OPENFILE]();
  }
  [OPENFILE]() {
    fs4.open(this.absolute, "r", (er, fd) => {
      if (er) {
        return this.emit("error", er);
      }
      this[ONOPENFILE](fd);
    });
  }
  [ONOPENFILE](fd) {
    this.fd = fd;
    if (this.#hadError) {
      return this[CLOSE]();
    }
    if (!this.stat) {
      throw new Error("should stat before calling onopenfile");
    }
    this.blockLen = 512 * Math.ceil(this.stat.size / 512);
    this.blockRemain = this.blockLen;
    const bufLen = Math.min(this.blockLen, this.maxReadSize);
    this.buf = Buffer.allocUnsafe(bufLen);
    this.offset = 0;
    this.pos = 0;
    this.remain = this.stat.size;
    this.length = this.buf.length;
    this[READ2]();
  }
  [READ2]() {
    const { fd, buf, offset, length: length9, pos: pos2 } = this;
    if (fd === void 0 || buf === void 0) {
      throw new Error("cannot read file without first opening");
    }
    fs4.read(fd, buf, offset, length9, pos2, (er, bytesRead) => {
      if (er) {
        return this[CLOSE](() => this.emit("error", er));
      }
      this[ONREAD](bytesRead);
    });
  }
  /* c8 ignore start */
  [CLOSE](cb = () => {
  }) {
    if (this.fd !== void 0)
      fs4.close(this.fd, cb);
  }
  [ONREAD](bytesRead) {
    if (bytesRead <= 0 && this.remain > 0) {
      const er = Object.assign(new Error("encountered unexpected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (bytesRead > this.remain) {
      const er = Object.assign(new Error("did not encounter expected EOF"), {
        path: this.absolute,
        syscall: "read",
        code: "EOF"
      });
      return this[CLOSE](() => this.emit("error", er));
    }
    if (!this.buf) {
      throw new Error("should have created buffer prior to reading");
    }
    if (bytesRead === this.remain) {
      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
        this.buf[i + this.offset] = 0;
        bytesRead++;
        this.remain++;
      }
    }
    const chunk = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.subarray(this.offset, this.offset + bytesRead);
    const flushed = this.write(chunk);
    if (!flushed) {
      this[AWAITDRAIN](() => this[ONDRAIN]());
    } else {
      this[ONDRAIN]();
    }
  }
  [AWAITDRAIN](cb) {
    this.once("drain", cb);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
    }
    if (this.blockRemain < chunk.length) {
      const er = Object.assign(new Error("writing more data than expected"), {
        path: this.absolute
      });
      return this.emit("error", er);
    }
    this.remain -= chunk.length;
    this.blockRemain -= chunk.length;
    this.pos += chunk.length;
    this.offset += chunk.length;
    return super.write(chunk, null, cb);
  }
  [ONDRAIN]() {
    if (!this.remain) {
      if (this.blockRemain) {
        super.write(Buffer.alloc(this.blockRemain));
      }
      return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
    }
    if (!this.buf) {
      throw new Error("buffer lost somehow in ONDRAIN");
    }
    if (this.offset >= this.length) {
      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
      this.offset = 0;
    }
    this.length = this.buf.length - this.offset;
    this[READ2]();
  }
};
var WriteEntrySync = class extends WriteEntry {
  sync = true;
  [LSTAT]() {
    this[ONLSTAT](fs4.lstatSync(this.absolute));
  }
  [SYMLINK]() {
    this[ONREADLINK](fs4.readlinkSync(this.absolute));
  }
  [OPENFILE]() {
    this[ONOPENFILE](fs4.openSync(this.absolute, "r"));
  }
  [READ2]() {
    let threw = true;
    try {
      const { fd, buf, offset, length: length9, pos: pos2 } = this;
      if (fd === void 0 || buf === void 0) {
        throw new Error("fd and buf must be set in READ method");
      }
      const bytesRead = fs4.readSync(fd, buf, offset, length9, pos2);
      this[ONREAD](bytesRead);
      threw = false;
    } finally {
      if (threw) {
        try {
          this[CLOSE](() => {
          });
        } catch (er) {
        }
      }
    }
  }
  [AWAITDRAIN](cb) {
    cb();
  }
  /* c8 ignore start */
  [CLOSE](cb = () => {
  }) {
    if (this.fd !== void 0)
      fs4.closeSync(this.fd);
    cb();
  }
};
var WriteEntryTar = class extends Minipass {
  blockLen = 0;
  blockRemain = 0;
  buf = 0;
  pos = 0;
  remain = 0;
  length = 0;
  preservePaths;
  portable;
  strict;
  noPax;
  noMtime;
  readEntry;
  type;
  prefix;
  path;
  mode;
  uid;
  gid;
  uname;
  gname;
  header;
  mtime;
  atime;
  ctime;
  linkpath;
  size;
  warn(code3, message3, data = {}) {
    return warnMethod(this, code3, message3, data);
  }
  constructor(readEntry, opt_ = {}) {
    const opt = dealias(opt_);
    super();
    this.preservePaths = !!opt.preservePaths;
    this.portable = !!opt.portable;
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.noMtime = !!opt.noMtime;
    this.readEntry = readEntry;
    const { type } = readEntry;
    if (type === "Unsupported") {
      throw new Error("writing entry that should be ignored");
    }
    this.type = type;
    if (this.type === "Directory" && this.portable) {
      this.noMtime = true;
    }
    this.prefix = opt.prefix;
    this.path = normalizeWindowsPath(readEntry.path);
    this.mode = readEntry.mode !== void 0 ? this[MODE](readEntry.mode) : void 0;
    this.uid = this.portable ? void 0 : readEntry.uid;
    this.gid = this.portable ? void 0 : readEntry.gid;
    this.uname = this.portable ? void 0 : readEntry.uname;
    this.gname = this.portable ? void 0 : readEntry.gname;
    this.size = readEntry.size;
    this.mtime = this.noMtime ? void 0 : opt.mtime || readEntry.mtime;
    this.atime = this.portable ? void 0 : readEntry.atime;
    this.ctime = this.portable ? void 0 : readEntry.ctime;
    this.linkpath = readEntry.linkpath !== void 0 ? normalizeWindowsPath(readEntry.linkpath) : void 0;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    let pathWarn = false;
    if (!this.preservePaths) {
      const [root2, stripped] = stripAbsolutePath(this.path);
      if (root2 && typeof stripped === "string") {
        this.path = stripped;
        pathWarn = root2;
      }
    }
    this.remain = readEntry.size;
    this.blockRemain = readEntry.startBlockSize;
    this.header = new Header({
      path: this[PREFIX](this.path),
      linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
      // only the permissions and setuid/setgid/sticky bitflags
      // not the higher-order bits that specify file type
      mode: this.mode,
      uid: this.portable ? void 0 : this.uid,
      gid: this.portable ? void 0 : this.gid,
      size: this.size,
      mtime: this.noMtime ? void 0 : this.mtime,
      type: this.type,
      uname: this.portable ? void 0 : this.uname,
      atime: this.portable ? void 0 : this.atime,
      ctime: this.portable ? void 0 : this.ctime
    });
    if (pathWarn) {
      this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
        entry: this,
        path: pathWarn + this.path
      });
    }
    if (this.header.encode() && !this.noPax) {
      super.write(new Pax({
        atime: this.portable ? void 0 : this.atime,
        ctime: this.portable ? void 0 : this.ctime,
        gid: this.portable ? void 0 : this.gid,
        mtime: this.noMtime ? void 0 : this.mtime,
        path: this[PREFIX](this.path),
        linkpath: this.type === "Link" && this.linkpath !== void 0 ? this[PREFIX](this.linkpath) : this.linkpath,
        size: this.size,
        uid: this.portable ? void 0 : this.uid,
        uname: this.portable ? void 0 : this.uname,
        dev: this.portable ? void 0 : this.readEntry.dev,
        ino: this.portable ? void 0 : this.readEntry.ino,
        nlink: this.portable ? void 0 : this.readEntry.nlink
      }).encode());
    }
    const b = this.header?.block;
    if (!b)
      throw new Error("failed to encode header");
    super.write(b);
    readEntry.pipe(this);
  }
  [PREFIX](path14) {
    return prefixPath(path14, this.prefix);
  }
  [MODE](mode2) {
    return modeFix(mode2, this.type === "Directory", this.portable);
  }
  write(chunk, encoding, cb) {
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, typeof encoding === "string" ? encoding : "utf8");
    }
    const writeLen = chunk.length;
    if (writeLen > this.blockRemain) {
      throw new Error("writing more to entry than is appropriate");
    }
    this.blockRemain -= writeLen;
    return super.write(chunk, cb);
  }
  end(chunk, encoding, cb) {
    if (this.blockRemain) {
      super.write(Buffer.alloc(this.blockRemain));
    }
    if (typeof chunk === "function") {
      cb = chunk;
      encoding = void 0;
      chunk = void 0;
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = void 0;
    }
    if (typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding ?? "utf8");
    }
    if (cb)
      this.once("finish", cb);
    chunk ? super.end(chunk, cb) : super.end(cb);
    return this;
  }
};
var getType = (stat6) => stat6.isFile() ? "File" : stat6.isDirectory() ? "Directory" : stat6.isSymbolicLink() ? "SymbolicLink" : "Unsupported";

// node_modules/tar/dist/esm/pack.js
import path4 from "path";
var PackJob = class {
  path;
  absolute;
  entry;
  stat;
  readdir;
  pending = false;
  ignore = false;
  piped = false;
  constructor(path14, absolute) {
    this.path = path14 || "./";
    this.absolute = absolute;
  }
};
var EOF2 = Buffer.alloc(1024);
var ONSTAT = Symbol("onStat");
var ENDED2 = Symbol("ended");
var QUEUE2 = Symbol("queue");
var CURRENT = Symbol("current");
var PROCESS2 = Symbol("process");
var PROCESSING = Symbol("processing");
var PROCESSJOB = Symbol("processJob");
var JOBS = Symbol("jobs");
var JOBDONE = Symbol("jobDone");
var ADDFSENTRY = Symbol("addFSEntry");
var ADDTARENTRY = Symbol("addTarEntry");
var STAT = Symbol("stat");
var READDIR = Symbol("readdir");
var ONREADDIR = Symbol("onreaddir");
var PIPE = Symbol("pipe");
var ENTRY = Symbol("entry");
var ENTRYOPT = Symbol("entryOpt");
var WRITEENTRYCLASS = Symbol("writeEntryClass");
var WRITE = Symbol("write");
var ONDRAIN2 = Symbol("ondrain");
var Pack = class extends Minipass {
  opt;
  cwd;
  maxReadSize;
  preservePaths;
  strict;
  noPax;
  prefix;
  linkCache;
  statCache;
  file;
  portable;
  zip;
  readdirCache;
  noDirRecurse;
  follow;
  noMtime;
  mtime;
  filter;
  jobs;
  [WRITEENTRYCLASS];
  [QUEUE2];
  [JOBS] = 0;
  [PROCESSING] = false;
  [ENDED2] = false;
  constructor(opt = {}) {
    super();
    this.opt = opt;
    this.file = opt.file || "";
    this.cwd = opt.cwd || process.cwd();
    this.maxReadSize = opt.maxReadSize;
    this.preservePaths = !!opt.preservePaths;
    this.strict = !!opt.strict;
    this.noPax = !!opt.noPax;
    this.prefix = normalizeWindowsPath(opt.prefix || "");
    this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
    this.statCache = opt.statCache || /* @__PURE__ */ new Map();
    this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
    this[WRITEENTRYCLASS] = WriteEntry;
    if (typeof opt.onwarn === "function") {
      this.on("warn", opt.onwarn);
    }
    this.portable = !!opt.portable;
    if (opt.gzip || opt.brotli) {
      if (opt.gzip && opt.brotli) {
        throw new TypeError("gzip and brotli are mutually exclusive");
      }
      if (opt.gzip) {
        if (typeof opt.gzip !== "object") {
          opt.gzip = {};
        }
        if (this.portable) {
          opt.gzip.portable = true;
        }
        this.zip = new Gzip(opt.gzip);
      }
      if (opt.brotli) {
        if (typeof opt.brotli !== "object") {
          opt.brotli = {};
        }
        this.zip = new BrotliCompress(opt.brotli);
      }
      if (!this.zip)
        throw new Error("impossible");
      const zip2 = this.zip;
      zip2.on("data", (chunk) => super.write(chunk));
      zip2.on("end", () => super.end());
      zip2.on("drain", () => this[ONDRAIN2]());
      this.on("resume", () => zip2.resume());
    } else {
      this.on("drain", this[ONDRAIN2]);
    }
    this.noDirRecurse = !!opt.noDirRecurse;
    this.follow = !!opt.follow;
    this.noMtime = !!opt.noMtime;
    if (opt.mtime)
      this.mtime = opt.mtime;
    this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
    this[QUEUE2] = new Yallist();
    this[JOBS] = 0;
    this.jobs = Number(opt.jobs) || 4;
    this[PROCESSING] = false;
    this[ENDED2] = false;
  }
  [WRITE](chunk) {
    return super.write(chunk);
  }
  add(path14) {
    this.write(path14);
    return this;
  }
  //@ts-ignore
  end(path14) {
    if (path14) {
      this.add(path14);
    }
    this[ENDED2] = true;
    this[PROCESS2]();
    return this;
  }
  //@ts-ignore
  write(path14) {
    if (this[ENDED2]) {
      throw new Error("write after end");
    }
    if (path14 instanceof ReadEntry) {
      this[ADDTARENTRY](path14);
    } else {
      this[ADDFSENTRY](path14);
    }
    return this.flowing;
  }
  [ADDTARENTRY](p) {
    const absolute = normalizeWindowsPath(path4.resolve(this.cwd, p.path));
    if (!this.filter(p.path, p)) {
      p.resume();
    } else {
      const job = new PackJob(p.path, absolute);
      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
      job.entry.on("end", () => this[JOBDONE](job));
      this[JOBS] += 1;
      this[QUEUE2].push(job);
    }
    this[PROCESS2]();
  }
  [ADDFSENTRY](p) {
    const absolute = normalizeWindowsPath(path4.resolve(this.cwd, p));
    this[QUEUE2].push(new PackJob(p, absolute));
    this[PROCESS2]();
  }
  [STAT](job) {
    job.pending = true;
    this[JOBS] += 1;
    const stat6 = this.follow ? "stat" : "lstat";
    fs5[stat6](job.absolute, (er, stat7) => {
      job.pending = false;
      this[JOBS] -= 1;
      if (er) {
        this.emit("error", er);
      } else {
        this[ONSTAT](job, stat7);
      }
    });
  }
  [ONSTAT](job, stat6) {
    this.statCache.set(job.absolute, stat6);
    job.stat = stat6;
    if (!this.filter(job.path, stat6)) {
      job.ignore = true;
    }
    this[PROCESS2]();
  }
  [READDIR](job) {
    job.pending = true;
    this[JOBS] += 1;
    fs5.readdir(job.absolute, (er, entries3) => {
      job.pending = false;
      this[JOBS] -= 1;
      if (er) {
        return this.emit("error", er);
      }
      this[ONREADDIR](job, entries3);
    });
  }
  [ONREADDIR](job, entries3) {
    this.readdirCache.set(job.absolute, entries3);
    job.readdir = entries3;
    this[PROCESS2]();
  }
  [PROCESS2]() {
    if (this[PROCESSING]) {
      return;
    }
    this[PROCESSING] = true;
    for (let w = this[QUEUE2].head; !!w && this[JOBS] < this.jobs; w = w.next) {
      this[PROCESSJOB](w.value);
      if (w.value.ignore) {
        const p = w.next;
        this[QUEUE2].removeNode(w);
        w.next = p;
      }
    }
    this[PROCESSING] = false;
    if (this[ENDED2] && !this[QUEUE2].length && this[JOBS] === 0) {
      if (this.zip) {
        this.zip.end(EOF2);
      } else {
        super.write(EOF2);
        super.end();
      }
    }
  }
  get [CURRENT]() {
    return this[QUEUE2] && this[QUEUE2].head && this[QUEUE2].head.value;
  }
  [JOBDONE](_job) {
    this[QUEUE2].shift();
    this[JOBS] -= 1;
    this[PROCESS2]();
  }
  [PROCESSJOB](job) {
    if (job.pending) {
      return;
    }
    if (job.entry) {
      if (job === this[CURRENT] && !job.piped) {
        this[PIPE](job);
      }
      return;
    }
    if (!job.stat) {
      const sc = this.statCache.get(job.absolute);
      if (sc) {
        this[ONSTAT](job, sc);
      } else {
        this[STAT](job);
      }
    }
    if (!job.stat) {
      return;
    }
    if (job.ignore) {
      return;
    }
    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
      const rc = this.readdirCache.get(job.absolute);
      if (rc) {
        this[ONREADDIR](job, rc);
      } else {
        this[READDIR](job);
      }
      if (!job.readdir) {
        return;
      }
    }
    job.entry = this[ENTRY](job);
    if (!job.entry) {
      job.ignore = true;
      return;
    }
    if (job === this[CURRENT] && !job.piped) {
      this[PIPE](job);
    }
  }
  [ENTRYOPT](job) {
    return {
      onwarn: (code3, msg, data) => this.warn(code3, msg, data),
      noPax: this.noPax,
      cwd: this.cwd,
      absolute: job.absolute,
      preservePaths: this.preservePaths,
      maxReadSize: this.maxReadSize,
      strict: this.strict,
      portable: this.portable,
      linkCache: this.linkCache,
      statCache: this.statCache,
      noMtime: this.noMtime,
      mtime: this.mtime,
      prefix: this.prefix
    };
  }
  [ENTRY](job) {
    this[JOBS] += 1;
    try {
      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
    } catch (er) {
      this.emit("error", er);
    }
  }
  [ONDRAIN2]() {
    if (this[CURRENT] && this[CURRENT].entry) {
      this[CURRENT].entry.resume();
    }
  }
  // like .pipe() but using super, because our write() is special
  [PIPE](job) {
    job.piped = true;
    if (job.readdir) {
      job.readdir.forEach((entry) => {
        const p = job.path;
        const base = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base + entry);
      });
    }
    const source2 = job.entry;
    const zip2 = this.zip;
    if (!source2)
      throw new Error("cannot pipe without source");
    if (zip2) {
      source2.on("data", (chunk) => {
        if (!zip2.write(chunk)) {
          source2.pause();
        }
      });
    } else {
      source2.on("data", (chunk) => {
        if (!super.write(chunk)) {
          source2.pause();
        }
      });
    }
  }
  pause() {
    if (this.zip) {
      this.zip.pause();
    }
    return super.pause();
  }
  warn(code3, message3, data = {}) {
    warnMethod(this, code3, message3, data);
  }
};
var PackSync = class extends Pack {
  sync = true;
  constructor(opt) {
    super(opt);
    this[WRITEENTRYCLASS] = WriteEntrySync;
  }
  // pause/resume are no-ops in sync streams.
  pause() {
  }
  resume() {
  }
  [STAT](job) {
    const stat6 = this.follow ? "statSync" : "lstatSync";
    this[ONSTAT](job, fs5[stat6](job.absolute));
  }
  [READDIR](job) {
    this[ONREADDIR](job, fs5.readdirSync(job.absolute));
  }
  // gotta get it all in this tick
  [PIPE](job) {
    const source2 = job.entry;
    const zip2 = this.zip;
    if (job.readdir) {
      job.readdir.forEach((entry) => {
        const p = job.path;
        const base = p === "./" ? "" : p.replace(/\/*$/, "/");
        this[ADDFSENTRY](base + entry);
      });
    }
    if (!source2)
      throw new Error("Cannot pipe without source");
    if (zip2) {
      source2.on("data", (chunk) => {
        zip2.write(chunk);
      });
    } else {
      source2.on("data", (chunk) => {
        super[WRITE](chunk);
      });
    }
  }
};

// node_modules/tar/dist/esm/create.js
var createFileSync = (opt, files) => {
  const p = new PackSync(opt);
  const stream3 = new WriteStreamSync(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream3);
  addFilesSync(p, files);
};
var createFile = (opt, files) => {
  const p = new Pack(opt);
  const stream3 = new WriteStream(opt.file, {
    mode: opt.mode || 438
  });
  p.pipe(stream3);
  const promise2 = new Promise((res, rej) => {
    stream3.on("error", rej);
    stream3.on("close", res);
    p.on("error", rej);
  });
  addFilesAsync(p, files);
  return promise2;
};
var addFilesSync = (p, files) => {
  files.forEach((file) => {
    if (file.charAt(0) === "@") {
      list2({
        file: path5.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onentry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
};
var addFilesAsync = async (p, files) => {
  for (let i = 0; i < files.length; i++) {
    const file = String(files[i]);
    if (file.charAt(0) === "@") {
      await list2({
        file: path5.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onentry: (entry) => {
          p.add(entry);
        }
      });
    } else {
      p.add(file);
    }
  }
  p.end();
};
var createSync = (opt, files) => {
  const p = new PackSync(opt);
  addFilesSync(p, files);
  return p;
};
var createAsync = (opt, files) => {
  const p = new Pack(opt);
  addFilesAsync(p, files);
  return p;
};
var create2 = makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files) => {
  if (!files?.length) {
    throw new TypeError("no paths specified to add to archive");
  }
});

// node_modules/tar/dist/esm/extract.js
import fs10 from "node:fs";

// node_modules/tar/dist/esm/unpack.js
import assert2 from "node:assert";
import { randomBytes } from "node:crypto";
import fs9 from "node:fs";
import path8 from "node:path";

// node_modules/tar/dist/esm/get-write-flag.js
import fs6 from "fs";
var platform4 = process.env.__FAKE_PLATFORM__ || process.platform;
var isWindows3 = platform4 === "win32";
var { O_CREAT, O_TRUNC, O_WRONLY } = fs6.constants;
var UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) || fs6.constants.UV_FS_O_FILEMAP || 0;
var fMapEnabled = isWindows3 && !!UV_FS_O_FILEMAP;
var fMapLimit = 512 * 1024;
var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
var getWriteFlag = !fMapEnabled ? () => "w" : (size8) => size8 < fMapLimit ? fMapFlag : "w";

// node_modules/chownr/dist/esm/index.js
import fs7 from "node:fs";
import path6 from "node:path";
var lchownSync = (path14, uid2, gid2) => {
  try {
    return fs7.lchownSync(path14, uid2, gid2);
  } catch (er) {
    if (er?.code !== "ENOENT")
      throw er;
  }
};
var chown3 = (cpath, uid2, gid2, cb) => {
  fs7.lchown(cpath, uid2, gid2, (er) => {
    cb(er && er?.code !== "ENOENT" ? er : null);
  });
};
var chownrKid = (p, child, uid2, gid2, cb) => {
  if (child.isDirectory()) {
    chownr(path6.resolve(p, child.name), uid2, gid2, (er) => {
      if (er)
        return cb(er);
      const cpath = path6.resolve(p, child.name);
      chown3(cpath, uid2, gid2, cb);
    });
  } else {
    const cpath = path6.resolve(p, child.name);
    chown3(cpath, uid2, gid2, cb);
  }
};
var chownr = (p, uid2, gid2, cb) => {
  fs7.readdir(p, { withFileTypes: true }, (er, children) => {
    if (er) {
      if (er.code === "ENOENT")
        return cb();
      else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
        return cb(er);
    }
    if (er || !children.length)
      return chown3(p, uid2, gid2, cb);
    let len = children.length;
    let errState = null;
    const then = (er2) => {
      if (errState)
        return;
      if (er2)
        return cb(errState = er2);
      if (--len === 0)
        return chown3(p, uid2, gid2, cb);
    };
    for (const child of children) {
      chownrKid(p, child, uid2, gid2, then);
    }
  });
};
var chownrKidSync = (p, child, uid2, gid2) => {
  if (child.isDirectory())
    chownrSync(path6.resolve(p, child.name), uid2, gid2);
  lchownSync(path6.resolve(p, child.name), uid2, gid2);
};
var chownrSync = (p, uid2, gid2) => {
  let children;
  try {
    children = fs7.readdirSync(p, { withFileTypes: true });
  } catch (er) {
    const e = er;
    if (e?.code === "ENOENT")
      return;
    else if (e?.code === "ENOTDIR" || e?.code === "ENOTSUP")
      return lchownSync(p, uid2, gid2);
    else
      throw e;
  }
  for (const child of children) {
    chownrKidSync(p, child, uid2, gid2);
  }
  return lchownSync(p, uid2, gid2);
};

// node_modules/tar/dist/esm/mkdir.js
import fs8 from "fs";

// node_modules/mkdirp/dist/mjs/mkdirp-manual.js
import { dirname as dirname3 } from "path";

// node_modules/mkdirp/dist/mjs/opts-arg.js
import { mkdir as mkdir4, mkdirSync as mkdirSync2, stat as stat5, statSync as statSync2 } from "fs";
var optsArg = (opts) => {
  if (!opts) {
    opts = { mode: 511 };
  } else if (typeof opts === "object") {
    opts = { mode: 511, ...opts };
  } else if (typeof opts === "number") {
    opts = { mode: opts };
  } else if (typeof opts === "string") {
    opts = { mode: parseInt(opts, 8) };
  } else {
    throw new TypeError("invalid options argument");
  }
  const resolved = opts;
  const optsFs = opts.fs || {};
  opts.mkdir = opts.mkdir || optsFs.mkdir || mkdir4;
  opts.mkdirAsync = opts.mkdirAsync ? opts.mkdirAsync : async (path14, options) => {
    return new Promise((res, rej) => resolved.mkdir(path14, options, (er, made) => er ? rej(er) : res(made)));
  };
  opts.stat = opts.stat || optsFs.stat || stat5;
  opts.statAsync = opts.statAsync ? opts.statAsync : async (path14) => new Promise((res, rej) => resolved.stat(path14, (err, stats) => err ? rej(err) : res(stats)));
  opts.statSync = opts.statSync || optsFs.statSync || statSync2;
  opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || mkdirSync2;
  return resolved;
};

// node_modules/mkdirp/dist/mjs/mkdirp-manual.js
var mkdirpManualSync = (path14, options, made) => {
  const parent = dirname3(path14);
  const opts = { ...optsArg(options), recursive: false };
  if (parent === path14) {
    try {
      return opts.mkdirSync(path14, opts);
    } catch (er) {
      const fer = er;
      if (fer && fer.code !== "EISDIR") {
        throw er;
      }
      return;
    }
  }
  try {
    opts.mkdirSync(path14, opts);
    return made || path14;
  } catch (er) {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManualSync(path14, opts, mkdirpManualSync(parent, opts, made));
    }
    if (fer && fer.code !== "EEXIST" && fer && fer.code !== "EROFS") {
      throw er;
    }
    try {
      if (!opts.statSync(path14).isDirectory())
        throw er;
    } catch (_) {
      throw er;
    }
  }
};
var mkdirpManual = Object.assign(async (path14, options, made) => {
  const opts = optsArg(options);
  opts.recursive = false;
  const parent = dirname3(path14);
  if (parent === path14) {
    return opts.mkdirAsync(path14, opts).catch((er) => {
      const fer = er;
      if (fer && fer.code !== "EISDIR") {
        throw er;
      }
    });
  }
  return opts.mkdirAsync(path14, opts).then(() => made || path14, async (er) => {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path14, opts, made2));
    }
    if (fer && fer.code !== "EEXIST" && fer.code !== "EROFS") {
      throw er;
    }
    return opts.statAsync(path14).then((st) => {
      if (st.isDirectory()) {
        return made;
      } else {
        throw er;
      }
    }, () => {
      throw er;
    });
  });
}, { sync: mkdirpManualSync });

// node_modules/mkdirp/dist/mjs/mkdirp-native.js
import { dirname as dirname5 } from "path";

// node_modules/mkdirp/dist/mjs/find-made.js
import { dirname as dirname4 } from "path";
var findMade = async (opts, parent, path14) => {
  if (path14 === parent) {
    return;
  }
  return opts.statAsync(parent).then(
    (st) => st.isDirectory() ? path14 : void 0,
    // will fail later
    // will fail later
    (er) => {
      const fer = er;
      return fer && fer.code === "ENOENT" ? findMade(opts, dirname4(parent), parent) : void 0;
    }
  );
};
var findMadeSync = (opts, parent, path14) => {
  if (path14 === parent) {
    return void 0;
  }
  try {
    return opts.statSync(parent).isDirectory() ? path14 : void 0;
  } catch (er) {
    const fer = er;
    return fer && fer.code === "ENOENT" ? findMadeSync(opts, dirname4(parent), parent) : void 0;
  }
};

// node_modules/mkdirp/dist/mjs/mkdirp-native.js
var mkdirpNativeSync = (path14, options) => {
  const opts = optsArg(options);
  opts.recursive = true;
  const parent = dirname5(path14);
  if (parent === path14) {
    return opts.mkdirSync(path14, opts);
  }
  const made = findMadeSync(opts, path14);
  try {
    opts.mkdirSync(path14, opts);
    return made;
  } catch (er) {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManualSync(path14, opts);
    } else {
      throw er;
    }
  }
};
var mkdirpNative = Object.assign(async (path14, options) => {
  const opts = { ...optsArg(options), recursive: true };
  const parent = dirname5(path14);
  if (parent === path14) {
    return await opts.mkdirAsync(path14, opts);
  }
  return findMade(opts, path14).then((made) => opts.mkdirAsync(path14, opts).then((m) => made || m).catch((er) => {
    const fer = er;
    if (fer && fer.code === "ENOENT") {
      return mkdirpManual(path14, opts);
    } else {
      throw er;
    }
  }));
}, { sync: mkdirpNativeSync });

// node_modules/mkdirp/dist/mjs/path-arg.js
import { parse as parse14, resolve as resolve2 } from "path";
var platform5 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
var pathArg = (path14) => {
  if (/\0/.test(path14)) {
    throw Object.assign(new TypeError("path must be a string without null bytes"), {
      path: path14,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path14 = resolve2(path14);
  if (platform5 === "win32") {
    const badWinChars = /[*|"<>?:]/;
    const { root: root2 } = parse14(path14);
    if (badWinChars.test(path14.substring(root2.length))) {
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path14,
        code: "EINVAL"
      });
    }
  }
  return path14;
};

// node_modules/mkdirp/dist/mjs/use-native.js
import { mkdir as mkdir5, mkdirSync as mkdirSync3 } from "fs";
var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
var versArr = version2.replace(/^v/, "").split(".");
var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
var useNativeSync = !hasNative ? () => false : (opts) => optsArg(opts).mkdirSync === mkdirSync3;
var useNative = Object.assign(!hasNative ? () => false : (opts) => optsArg(opts).mkdir === mkdir5, {
  sync: useNativeSync
});

// node_modules/mkdirp/dist/mjs/index.js
var mkdirpSync = (path14, opts) => {
  path14 = pathArg(path14);
  const resolved = optsArg(opts);
  return useNativeSync(resolved) ? mkdirpNativeSync(path14, resolved) : mkdirpManualSync(path14, resolved);
};
var mkdirp2 = Object.assign(async (path14, opts) => {
  path14 = pathArg(path14);
  const resolved = optsArg(opts);
  return useNative(resolved) ? mkdirpNative(path14, resolved) : mkdirpManual(path14, resolved);
}, {
  mkdirpSync,
  mkdirpNative,
  mkdirpNativeSync,
  mkdirpManual,
  mkdirpManualSync,
  sync: mkdirpSync,
  native: mkdirpNative,
  nativeSync: mkdirpNativeSync,
  manual: mkdirpManual,
  manualSync: mkdirpManualSync,
  useNative,
  useNativeSync
});

// node_modules/tar/dist/esm/mkdir.js
import path7 from "node:path";

// node_modules/tar/dist/esm/cwd-error.js
var CwdError = class extends Error {
  path;
  code;
  syscall = "chdir";
  constructor(path14, code3) {
    super(`${code3}: Cannot cd into '${path14}'`);
    this.path = path14;
    this.code = code3;
  }
  get name() {
    return "CwdError";
  }
};

// node_modules/tar/dist/esm/symlink-error.js
var SymlinkError = class extends Error {
  path;
  symlink;
  syscall = "symlink";
  code = "TAR_SYMLINK_ERROR";
  constructor(symlink3, path14) {
    super("TAR_SYMLINK_ERROR: Cannot extract through symbolic link");
    this.symlink = symlink3;
    this.path = path14;
  }
  get name() {
    return "SymlinkError";
  }
};

// node_modules/tar/dist/esm/mkdir.js
var cGet = (cache, key) => cache.get(normalizeWindowsPath(key));
var cSet = (cache, key, val) => cache.set(normalizeWindowsPath(key), val);
var checkCwd = (dir, cb) => {
  fs8.stat(dir, (er, st) => {
    if (er || !st.isDirectory()) {
      er = new CwdError(dir, er?.code || "ENOTDIR");
    }
    cb(er);
  });
};
var mkdir6 = (dir, opt, cb) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode2 = opt.mode | 448;
  const needChmod = (mode2 & umask) !== 0;
  const uid2 = opt.uid;
  const gid2 = opt.gid;
  const doChown = typeof uid2 === "number" && typeof gid2 === "number" && (uid2 !== opt.processUid || gid2 !== opt.processGid);
  const preserve = opt.preserve;
  const unlink4 = opt.unlink;
  const cache = opt.cache;
  const cwd3 = normalizeWindowsPath(opt.cwd);
  const done = (er, created) => {
    if (er) {
      cb(er);
    } else {
      cSet(cache, dir, true);
      if (created && doChown) {
        chownr(created, uid2, gid2, (er2) => done(er2));
      } else if (needChmod) {
        fs8.chmod(dir, mode2, cb);
      } else {
        cb();
      }
    }
  };
  if (cache && cGet(cache, dir) === true) {
    return done();
  }
  if (dir === cwd3) {
    return checkCwd(dir, done);
  }
  if (preserve) {
    return mkdirp2(dir, { mode: mode2 }).then(
      (made) => done(null, made ?? void 0),
      // oh, ts
      done
    );
  }
  const sub2 = normalizeWindowsPath(path7.relative(cwd3, dir));
  const parts = sub2.split("/");
  mkdir_(cwd3, parts, mode2, cache, unlink4, cwd3, void 0, done);
};
var mkdir_ = (base, parts, mode2, cache, unlink4, cwd3, created, cb) => {
  if (!parts.length) {
    return cb(null, created);
  }
  const p = parts.shift();
  const part = normalizeWindowsPath(path7.resolve(base + "/" + p));
  if (cGet(cache, part)) {
    return mkdir_(part, parts, mode2, cache, unlink4, cwd3, created, cb);
  }
  fs8.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink4, cwd3, created, cb));
};
var onmkdir = (part, parts, mode2, cache, unlink4, cwd3, created, cb) => (er) => {
  if (er) {
    fs8.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normalizeWindowsPath(statEr.path);
        cb(statEr);
      } else if (st.isDirectory()) {
        mkdir_(part, parts, mode2, cache, unlink4, cwd3, created, cb);
      } else if (unlink4) {
        fs8.unlink(part, (er2) => {
          if (er2) {
            return cb(er2);
          }
          fs8.mkdir(part, mode2, onmkdir(part, parts, mode2, cache, unlink4, cwd3, created, cb));
        });
      } else if (st.isSymbolicLink()) {
        return cb(new SymlinkError(part, part + "/" + parts.join("/")));
      } else {
        cb(er);
      }
    });
  } else {
    created = created || part;
    mkdir_(part, parts, mode2, cache, unlink4, cwd3, created, cb);
  }
};
var checkCwdSync = (dir) => {
  let ok = false;
  let code3 = void 0;
  try {
    ok = fs8.statSync(dir).isDirectory();
  } catch (er) {
    code3 = er?.code;
  } finally {
    if (!ok) {
      throw new CwdError(dir, code3 ?? "ENOTDIR");
    }
  }
};
var mkdirSync4 = (dir, opt) => {
  dir = normalizeWindowsPath(dir);
  const umask = opt.umask ?? 18;
  const mode2 = opt.mode | 448;
  const needChmod = (mode2 & umask) !== 0;
  const uid2 = opt.uid;
  const gid2 = opt.gid;
  const doChown = typeof uid2 === "number" && typeof gid2 === "number" && (uid2 !== opt.processUid || gid2 !== opt.processGid);
  const preserve = opt.preserve;
  const unlink4 = opt.unlink;
  const cache = opt.cache;
  const cwd3 = normalizeWindowsPath(opt.cwd);
  const done = (created2) => {
    cSet(cache, dir, true);
    if (created2 && doChown) {
      chownrSync(created2, uid2, gid2);
    }
    if (needChmod) {
      fs8.chmodSync(dir, mode2);
    }
  };
  if (cache && cGet(cache, dir) === true) {
    return done();
  }
  if (dir === cwd3) {
    checkCwdSync(cwd3);
    return done();
  }
  if (preserve) {
    return done(mkdirpSync(dir, mode2) ?? void 0);
  }
  const sub2 = normalizeWindowsPath(path7.relative(cwd3, dir));
  const parts = sub2.split("/");
  let created = void 0;
  for (let p = parts.shift(), part = cwd3; p && (part += "/" + p); p = parts.shift()) {
    part = normalizeWindowsPath(path7.resolve(part));
    if (cGet(cache, part)) {
      continue;
    }
    try {
      fs8.mkdirSync(part, mode2);
      created = created || part;
      cSet(cache, part, true);
    } catch (er) {
      const st = fs8.lstatSync(part);
      if (st.isDirectory()) {
        cSet(cache, part, true);
        continue;
      } else if (unlink4) {
        fs8.unlinkSync(part);
        fs8.mkdirSync(part, mode2);
        created = created || part;
        cSet(cache, part, true);
        continue;
      } else if (st.isSymbolicLink()) {
        return new SymlinkError(part, part + "/" + parts.join("/"));
      }
    }
  }
  return done(created);
};

// node_modules/tar/dist/esm/normalize-unicode.js
var normalizeCache = /* @__PURE__ */ Object.create(null);
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var normalizeUnicode = (s) => {
  if (!hasOwnProperty3.call(normalizeCache, s)) {
    normalizeCache[s] = s.normalize("NFD");
  }
  return normalizeCache[s];
};

// node_modules/tar/dist/esm/path-reservations.js
import { join as join8 } from "node:path";
var platform6 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var isWindows4 = platform6 === "win32";
var getDirs = (path14) => {
  const dirs = path14.split("/").slice(0, -1).reduce((set4, path15) => {
    const s = set4[set4.length - 1];
    if (s !== void 0) {
      path15 = join8(s, path15);
    }
    set4.push(path15 || "/");
    return set4;
  }, []);
  return dirs;
};
var PathReservations = class {
  // path => [function or Set]
  // A Set object means a directory reservation
  // A fn is a direct reservation on that path
  #queues = /* @__PURE__ */ new Map();
  // fn => {paths:[path,...], dirs:[path, ...]}
  #reservations = /* @__PURE__ */ new Map();
  // functions currently running
  #running = /* @__PURE__ */ new Set();
  reserve(paths2, fn) {
    paths2 = isWindows4 ? ["win32 parallelization disabled"] : paths2.map((p) => {
      return stripTrailingSlashes(join8(normalizeUnicode(p))).toLowerCase();
    });
    const dirs = new Set(paths2.map((path14) => getDirs(path14)).reduce((a, b) => a.concat(b)));
    this.#reservations.set(fn, { dirs, paths: paths2 });
    for (const p of paths2) {
      const q = this.#queues.get(p);
      if (!q) {
        this.#queues.set(p, [fn]);
      } else {
        q.push(fn);
      }
    }
    for (const dir of dirs) {
      const q = this.#queues.get(dir);
      if (!q) {
        this.#queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
      } else {
        const l = q[q.length - 1];
        if (l instanceof Set) {
          l.add(fn);
        } else {
          q.push(/* @__PURE__ */ new Set([fn]));
        }
      }
    }
    return this.#run(fn);
  }
  // return the queues for each path the function cares about
  // fn => {paths, dirs}
  #getQueues(fn) {
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("function does not have any path reservations");
    }
    return {
      paths: res.paths.map((path14) => this.#queues.get(path14)),
      dirs: [...res.dirs].map((path14) => this.#queues.get(path14))
    };
  }
  // check if fn is first in line for all its paths, and is
  // included in the first set for all its dir queues
  check(fn) {
    const { paths: paths2, dirs } = this.#getQueues(fn);
    return paths2.every((q) => q && q[0] === fn) && dirs.every((q) => q && q[0] instanceof Set && q[0].has(fn));
  }
  // run the function if it's first in line and not already running
  #run(fn) {
    if (this.#running.has(fn) || !this.check(fn)) {
      return false;
    }
    this.#running.add(fn);
    fn(() => this.#clear(fn));
    return true;
  }
  #clear(fn) {
    if (!this.#running.has(fn)) {
      return false;
    }
    const res = this.#reservations.get(fn);
    if (!res) {
      throw new Error("invalid reservation");
    }
    const { paths: paths2, dirs } = res;
    const next2 = /* @__PURE__ */ new Set();
    for (const path14 of paths2) {
      const q = this.#queues.get(path14);
      if (!q || q?.[0] !== fn) {
        continue;
      }
      const q0 = q[1];
      if (!q0) {
        this.#queues.delete(path14);
        continue;
      }
      q.shift();
      if (typeof q0 === "function") {
        next2.add(q0);
      } else {
        for (const f of q0) {
          next2.add(f);
        }
      }
    }
    for (const dir of dirs) {
      const q = this.#queues.get(dir);
      const q0 = q?.[0];
      if (!q || !(q0 instanceof Set))
        continue;
      if (q0.size === 1 && q.length === 1) {
        this.#queues.delete(dir);
        continue;
      } else if (q0.size === 1) {
        q.shift();
        const n = q[0];
        if (typeof n === "function") {
          next2.add(n);
        }
      } else {
        q0.delete(fn);
      }
    }
    this.#running.delete(fn);
    next2.forEach((fn2) => this.#run(fn2));
    return true;
  }
};

// node_modules/tar/dist/esm/unpack.js
var ONENTRY = Symbol("onEntry");
var CHECKFS = Symbol("checkFs");
var CHECKFS2 = Symbol("checkFs2");
var PRUNECACHE = Symbol("pruneCache");
var ISREUSABLE = Symbol("isReusable");
var MAKEFS = Symbol("makeFs");
var FILE2 = Symbol("file");
var DIRECTORY2 = Symbol("directory");
var LINK = Symbol("link");
var SYMLINK2 = Symbol("symlink");
var HARDLINK2 = Symbol("hardlink");
var UNSUPPORTED = Symbol("unsupported");
var CHECKPATH = Symbol("checkPath");
var MKDIR = Symbol("mkdir");
var ONERROR = Symbol("onError");
var PENDING = Symbol("pending");
var PEND = Symbol("pend");
var UNPEND = Symbol("unpend");
var ENDED3 = Symbol("ended");
var MAYBECLOSE = Symbol("maybeClose");
var SKIP = Symbol("skip");
var DOCHOWN = Symbol("doChown");
var UID = Symbol("uid");
var GID = Symbol("gid");
var CHECKED_CWD = Symbol("checkedCwd");
var platform7 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
var isWindows5 = platform7 === "win32";
var DEFAULT_MAX_DEPTH = 1024;
var unlinkFile = (path14, cb) => {
  if (!isWindows5) {
    return fs9.unlink(path14, cb);
  }
  const name5 = path14 + ".DELETE." + randomBytes(16).toString("hex");
  fs9.rename(path14, name5, (er) => {
    if (er) {
      return cb(er);
    }
    fs9.unlink(name5, cb);
  });
};
var unlinkFileSync = (path14) => {
  if (!isWindows5) {
    return fs9.unlinkSync(path14);
  }
  const name5 = path14 + ".DELETE." + randomBytes(16).toString("hex");
  fs9.renameSync(path14, name5);
  fs9.unlinkSync(name5);
};
var uint32 = (a, b, c) => a !== void 0 && a === a >>> 0 ? a : b !== void 0 && b === b >>> 0 ? b : c;
var cacheKeyNormalize = (path14) => stripTrailingSlashes(normalizeWindowsPath(normalizeUnicode(path14))).toLowerCase();
var pruneCache = (cache, abs5) => {
  abs5 = cacheKeyNormalize(abs5);
  for (const path14 of cache.keys()) {
    const pnorm = cacheKeyNormalize(path14);
    if (pnorm === abs5 || pnorm.indexOf(abs5 + "/") === 0) {
      cache.delete(path14);
    }
  }
};
var dropCache = (cache) => {
  for (const key of cache.keys()) {
    cache.delete(key);
  }
};
var Unpack = class extends Parser {
  [ENDED3] = false;
  [CHECKED_CWD] = false;
  [PENDING] = 0;
  reservations = new PathReservations();
  transform;
  writable = true;
  readable = false;
  dirCache;
  uid;
  gid;
  setOwner;
  preserveOwner;
  processGid;
  processUid;
  maxDepth;
  forceChown;
  win32;
  newer;
  keep;
  noMtime;
  preservePaths;
  unlink;
  cwd;
  strip;
  processUmask;
  umask;
  dmode;
  fmode;
  chmod;
  constructor(opt = {}) {
    opt.ondone = () => {
      this[ENDED3] = true;
      this[MAYBECLOSE]();
    };
    super(opt);
    this.transform = opt.transform;
    this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
    this.chmod = !!opt.chmod;
    if (typeof opt.uid === "number" || typeof opt.gid === "number") {
      if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
        throw new TypeError("cannot set owner without number uid and gid");
      }
      if (opt.preserveOwner) {
        throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
      }
      this.uid = opt.uid;
      this.gid = opt.gid;
      this.setOwner = true;
    } else {
      this.uid = void 0;
      this.gid = void 0;
      this.setOwner = false;
    }
    if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
      this.preserveOwner = !!(process.getuid && process.getuid() === 0);
    } else {
      this.preserveOwner = !!opt.preserveOwner;
    }
    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : void 0;
    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : void 0;
    this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
    this.forceChown = opt.forceChown === true;
    this.win32 = !!opt.win32 || isWindows5;
    this.newer = !!opt.newer;
    this.keep = !!opt.keep;
    this.noMtime = !!opt.noMtime;
    this.preservePaths = !!opt.preservePaths;
    this.unlink = !!opt.unlink;
    this.cwd = normalizeWindowsPath(path8.resolve(opt.cwd || process.cwd()));
    this.strip = Number(opt.strip) || 0;
    this.processUmask = !this.chmod ? 0 : typeof opt.processUmask === "number" ? opt.processUmask : process.umask();
    this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
    this.dmode = opt.dmode || 511 & ~this.umask;
    this.fmode = opt.fmode || 438 & ~this.umask;
    this.on("entry", (entry) => this[ONENTRY](entry));
  }
  // a bad or damaged archive is a warning for Parser, but an error
  // when extracting.  Mark those errors as unrecoverable, because
  // the Unpack contract cannot be met.
  warn(code3, msg, data = {}) {
    if (code3 === "TAR_BAD_ARCHIVE" || code3 === "TAR_ABORT") {
      data.recoverable = false;
    }
    return super.warn(code3, msg, data);
  }
  [MAYBECLOSE]() {
    if (this[ENDED3] && this[PENDING] === 0) {
      this.emit("prefinish");
      this.emit("finish");
      this.emit("end");
    }
  }
  [CHECKPATH](entry) {
    const p = normalizeWindowsPath(entry.path);
    const parts = p.split("/");
    if (this.strip) {
      if (parts.length < this.strip) {
        return false;
      }
      if (entry.type === "Link") {
        const linkparts = normalizeWindowsPath(String(entry.linkpath)).split("/");
        if (linkparts.length >= this.strip) {
          entry.linkpath = linkparts.slice(this.strip).join("/");
        } else {
          return false;
        }
      }
      parts.splice(0, this.strip);
      entry.path = parts.join("/");
    }
    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
      this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
        entry,
        path: p,
        depth: parts.length,
        maxDepth: this.maxDepth
      });
      return false;
    }
    if (!this.preservePaths) {
      if (parts.includes("..") || /* c8 ignore next */
      isWindows5 && /^[a-z]:\.\.$/i.test(parts[0] ?? "")) {
        this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
          entry,
          path: p
        });
        return false;
      }
      const [root2, stripped] = stripAbsolutePath(p);
      if (root2) {
        entry.path = String(stripped);
        this.warn("TAR_ENTRY_INFO", `stripping ${root2} from absolute path`, {
          entry,
          path: p
        });
      }
    }
    if (path8.isAbsolute(entry.path)) {
      entry.absolute = normalizeWindowsPath(path8.resolve(entry.path));
    } else {
      entry.absolute = normalizeWindowsPath(path8.resolve(this.cwd, entry.path));
    }
    if (!this.preservePaths && typeof entry.absolute === "string" && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
      this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
        entry,
        path: normalizeWindowsPath(entry.path),
        resolvedPath: entry.absolute,
        cwd: this.cwd
      });
      return false;
    }
    if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
      return false;
    }
    if (this.win32) {
      const { root: aRoot } = path8.win32.parse(String(entry.absolute));
      entry.absolute = aRoot + encode5(String(entry.absolute).slice(aRoot.length));
      const { root: pRoot } = path8.win32.parse(entry.path);
      entry.path = pRoot + encode5(entry.path.slice(pRoot.length));
    }
    return true;
  }
  [ONENTRY](entry) {
    if (!this[CHECKPATH](entry)) {
      return entry.resume();
    }
    assert2.equal(typeof entry.absolute, "string");
    switch (entry.type) {
      case "Directory":
      case "GNUDumpDir":
        if (entry.mode) {
          entry.mode = entry.mode | 448;
        }
      case "File":
      case "OldFile":
      case "ContiguousFile":
      case "Link":
      case "SymbolicLink":
        return this[CHECKFS](entry);
      case "CharacterDevice":
      case "BlockDevice":
      case "FIFO":
      default:
        return this[UNSUPPORTED](entry);
    }
  }
  [ONERROR](er, entry) {
    if (er.name === "CwdError") {
      this.emit("error", er);
    } else {
      this.warn("TAR_ENTRY_ERROR", er, { entry });
      this[UNPEND]();
      entry.resume();
    }
  }
  [MKDIR](dir, mode2, cb) {
    mkdir6(normalizeWindowsPath(dir), {
      uid: this.uid,
      gid: this.gid,
      processUid: this.processUid,
      processGid: this.processGid,
      umask: this.processUmask,
      preserve: this.preservePaths,
      unlink: this.unlink,
      cache: this.dirCache,
      cwd: this.cwd,
      mode: mode2
    }, cb);
  }
  [DOCHOWN](entry) {
    return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid;
  }
  [UID](entry) {
    return uint32(this.uid, entry.uid, this.processUid);
  }
  [GID](entry) {
    return uint32(this.gid, entry.gid, this.processGid);
  }
  [FILE2](entry, fullyDone) {
    const mode2 = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
    const stream3 = new WriteStream(String(entry.absolute), {
      // slight lie, but it can be numeric flags
      flags: getWriteFlag(entry.size),
      mode: mode2,
      autoClose: false
    });
    stream3.on("error", (er) => {
      if (stream3.fd) {
        fs9.close(stream3.fd, () => {
        });
      }
      stream3.write = () => true;
      this[ONERROR](er, entry);
      fullyDone();
    });
    let actions = 1;
    const done = (er) => {
      if (er) {
        if (stream3.fd) {
          fs9.close(stream3.fd, () => {
          });
        }
        this[ONERROR](er, entry);
        fullyDone();
        return;
      }
      if (--actions === 0) {
        if (stream3.fd !== void 0) {
          fs9.close(stream3.fd, (er2) => {
            if (er2) {
              this[ONERROR](er2, entry);
            } else {
              this[UNPEND]();
            }
            fullyDone();
          });
        }
      }
    };
    stream3.on("finish", () => {
      const abs5 = String(entry.absolute);
      const fd = stream3.fd;
      if (typeof fd === "number" && entry.mtime && !this.noMtime) {
        actions++;
        const atime = entry.atime || /* @__PURE__ */ new Date();
        const mtime = entry.mtime;
        fs9.futimes(fd, atime, mtime, (er) => er ? fs9.utimes(abs5, atime, mtime, (er2) => done(er2 && er)) : done());
      }
      if (typeof fd === "number" && this[DOCHOWN](entry)) {
        actions++;
        const uid2 = this[UID](entry);
        const gid2 = this[GID](entry);
        if (typeof uid2 === "number" && typeof gid2 === "number") {
          fs9.fchown(fd, uid2, gid2, (er) => er ? fs9.chown(abs5, uid2, gid2, (er2) => done(er2 && er)) : done());
        }
      }
      done();
    });
    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => {
        this[ONERROR](er, entry);
        fullyDone();
      });
      entry.pipe(tx);
    }
    tx.pipe(stream3);
  }
  [DIRECTORY2](entry, fullyDone) {
    const mode2 = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
    this[MKDIR](String(entry.absolute), mode2, (er) => {
      if (er) {
        this[ONERROR](er, entry);
        fullyDone();
        return;
      }
      let actions = 1;
      const done = () => {
        if (--actions === 0) {
          fullyDone();
          this[UNPEND]();
          entry.resume();
        }
      };
      if (entry.mtime && !this.noMtime) {
        actions++;
        fs9.utimes(String(entry.absolute), entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
      }
      if (this[DOCHOWN](entry)) {
        actions++;
        fs9.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);
      }
      done();
    });
  }
  [UNSUPPORTED](entry) {
    entry.unsupported = true;
    this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
    entry.resume();
  }
  [SYMLINK2](entry, done) {
    this[LINK](entry, String(entry.linkpath), "symlink", done);
  }
  [HARDLINK2](entry, done) {
    const linkpath = normalizeWindowsPath(path8.resolve(this.cwd, String(entry.linkpath)));
    this[LINK](entry, linkpath, "link", done);
  }
  [PEND]() {
    this[PENDING]++;
  }
  [UNPEND]() {
    this[PENDING]--;
    this[MAYBECLOSE]();
  }
  [SKIP](entry) {
    this[UNPEND]();
    entry.resume();
  }
  // Check if we can reuse an existing filesystem entry safely and
  // overwrite it, rather than unlinking and recreating
  // Windows doesn't report a useful nlink, so we just never reuse entries
  [ISREUSABLE](entry, st) {
    return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows5;
  }
  // check if a thing is there, and if so, try to clobber it
  [CHECKFS](entry) {
    this[PEND]();
    const paths2 = [entry.path];
    if (entry.linkpath) {
      paths2.push(entry.linkpath);
    }
    this.reservations.reserve(paths2, (done) => this[CHECKFS2](entry, done));
  }
  [PRUNECACHE](entry) {
    if (entry.type === "SymbolicLink") {
      dropCache(this.dirCache);
    } else if (entry.type !== "Directory") {
      pruneCache(this.dirCache, String(entry.absolute));
    }
  }
  [CHECKFS2](entry, fullyDone) {
    this[PRUNECACHE](entry);
    const done = (er) => {
      this[PRUNECACHE](entry);
      fullyDone(er);
    };
    const checkCwd2 = () => {
      this[MKDIR](this.cwd, this.dmode, (er) => {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        this[CHECKED_CWD] = true;
        start();
      });
    };
    const start = () => {
      if (entry.absolute !== this.cwd) {
        const parent = normalizeWindowsPath(path8.dirname(String(entry.absolute)));
        if (parent !== this.cwd) {
          return this[MKDIR](parent, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            afterMakeParent();
          });
        }
      }
      afterMakeParent();
    };
    const afterMakeParent = () => {
      fs9.lstat(String(entry.absolute), (lstatEr, st) => {
        if (st && (this.keep || /* c8 ignore next */
        this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
          this[SKIP](entry);
          done();
          return;
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry, done);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);
            if (!needChmod) {
              return afterChmod();
            }
            return fs9.chmod(String(entry.absolute), Number(entry.mode), afterChmod);
          }
          if (entry.absolute !== this.cwd) {
            return fs9.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
          }
        }
        if (entry.absolute === this.cwd) {
          return this[MAKEFS](null, entry, done);
        }
        unlinkFile(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));
      });
    };
    if (this[CHECKED_CWD]) {
      start();
    } else {
      checkCwd2();
    }
  }
  [MAKEFS](er, entry, done) {
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }
    switch (entry.type) {
      case "File":
      case "OldFile":
      case "ContiguousFile":
        return this[FILE2](entry, done);
      case "Link":
        return this[HARDLINK2](entry, done);
      case "SymbolicLink":
        return this[SYMLINK2](entry, done);
      case "Directory":
      case "GNUDumpDir":
        return this[DIRECTORY2](entry, done);
    }
  }
  [LINK](entry, linkpath, link4, done) {
    fs9[link4](linkpath, String(entry.absolute), (er) => {
      if (er) {
        this[ONERROR](er, entry);
      } else {
        this[UNPEND]();
        entry.resume();
      }
      done();
    });
  }
};
var callSync = (fn) => {
  try {
    return [null, fn()];
  } catch (er) {
    return [er, null];
  }
};
var UnpackSync = class extends Unpack {
  sync = true;
  [MAKEFS](er, entry) {
    return super[MAKEFS](er, entry, () => {
    });
  }
  [CHECKFS](entry) {
    this[PRUNECACHE](entry);
    if (!this[CHECKED_CWD]) {
      const er2 = this[MKDIR](this.cwd, this.dmode);
      if (er2) {
        return this[ONERROR](er2, entry);
      }
      this[CHECKED_CWD] = true;
    }
    if (entry.absolute !== this.cwd) {
      const parent = normalizeWindowsPath(path8.dirname(String(entry.absolute)));
      if (parent !== this.cwd) {
        const mkParent = this[MKDIR](parent, this.dmode);
        if (mkParent) {
          return this[ONERROR](mkParent, entry);
        }
      }
    }
    const [lstatEr, st] = callSync(() => fs9.lstatSync(String(entry.absolute)));
    if (st && (this.keep || /* c8 ignore next */
    this.newer && st.mtime > (entry.mtime ?? st.mtime))) {
      return this[SKIP](entry);
    }
    if (lstatEr || this[ISREUSABLE](entry, st)) {
      return this[MAKEFS](null, entry);
    }
    if (st.isDirectory()) {
      if (entry.type === "Directory") {
        const needChmod = this.chmod && entry.mode && (st.mode & 4095) !== entry.mode;
        const [er3] = needChmod ? callSync(() => {
          fs9.chmodSync(String(entry.absolute), Number(entry.mode));
        }) : [];
        return this[MAKEFS](er3, entry);
      }
      const [er2] = callSync(() => fs9.rmdirSync(String(entry.absolute)));
      this[MAKEFS](er2, entry);
    }
    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(String(entry.absolute)));
    this[MAKEFS](er, entry);
  }
  [FILE2](entry, done) {
    const mode2 = typeof entry.mode === "number" ? entry.mode & 4095 : this.fmode;
    const oner = (er) => {
      let closeError;
      try {
        fs9.closeSync(fd);
      } catch (e) {
        closeError = e;
      }
      if (er || closeError) {
        this[ONERROR](er || closeError, entry);
      }
      done();
    };
    let fd;
    try {
      fd = fs9.openSync(String(entry.absolute), getWriteFlag(entry.size), mode2);
    } catch (er) {
      return oner(er);
    }
    const tx = this.transform ? this.transform(entry) || entry : entry;
    if (tx !== entry) {
      tx.on("error", (er) => this[ONERROR](er, entry));
      entry.pipe(tx);
    }
    tx.on("data", (chunk) => {
      try {
        fs9.writeSync(fd, chunk, 0, chunk.length);
      } catch (er) {
        oner(er);
      }
    });
    tx.on("end", () => {
      let er = null;
      if (entry.mtime && !this.noMtime) {
        const atime = entry.atime || /* @__PURE__ */ new Date();
        const mtime = entry.mtime;
        try {
          fs9.futimesSync(fd, atime, mtime);
        } catch (futimeser) {
          try {
            fs9.utimesSync(String(entry.absolute), atime, mtime);
          } catch (utimeser) {
            er = futimeser;
          }
        }
      }
      if (this[DOCHOWN](entry)) {
        const uid2 = this[UID](entry);
        const gid2 = this[GID](entry);
        try {
          fs9.fchownSync(fd, Number(uid2), Number(gid2));
        } catch (fchowner) {
          try {
            fs9.chownSync(String(entry.absolute), Number(uid2), Number(gid2));
          } catch (chowner) {
            er = er || fchowner;
          }
        }
      }
      oner(er);
    });
  }
  [DIRECTORY2](entry, done) {
    const mode2 = typeof entry.mode === "number" ? entry.mode & 4095 : this.dmode;
    const er = this[MKDIR](String(entry.absolute), mode2);
    if (er) {
      this[ONERROR](er, entry);
      done();
      return;
    }
    if (entry.mtime && !this.noMtime) {
      try {
        fs9.utimesSync(String(entry.absolute), entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
      } catch (er2) {
      }
    }
    if (this[DOCHOWN](entry)) {
      try {
        fs9.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));
      } catch (er2) {
      }
    }
    done();
    entry.resume();
  }
  [MKDIR](dir, mode2) {
    try {
      return mkdirSync4(normalizeWindowsPath(dir), {
        uid: this.uid,
        gid: this.gid,
        processUid: this.processUid,
        processGid: this.processGid,
        umask: this.processUmask,
        preserve: this.preservePaths,
        unlink: this.unlink,
        cache: this.dirCache,
        cwd: this.cwd,
        mode: mode2
      });
    } catch (er) {
      return er;
    }
  }
  [LINK](entry, linkpath, link4, done) {
    const ls3 = `${link4}Sync`;
    try {
      fs9[ls3](linkpath, String(entry.absolute));
      done();
      entry.resume();
    } catch (er) {
      return this[ONERROR](er, entry);
    }
  }
};

// node_modules/tar/dist/esm/extract.js
var extractFileSync = (opt) => {
  const u = new UnpackSync(opt);
  const file = opt.file;
  const stat6 = fs10.statSync(file);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const stream3 = new ReadStreamSync(file, {
    readSize,
    size: stat6.size
  });
  stream3.pipe(u);
};
var extractFile = (opt, _) => {
  const u = new Unpack(opt);
  const readSize = opt.maxReadSize || 16 * 1024 * 1024;
  const file = opt.file;
  const p = new Promise((resolve3, reject) => {
    u.on("error", reject);
    u.on("close", resolve3);
    fs10.stat(file, (er, stat6) => {
      if (er) {
        reject(er);
      } else {
        const stream3 = new ReadStream(file, {
          readSize,
          size: stat6.size
        });
        stream3.on("error", reject);
        stream3.pipe(u);
      }
    });
  });
  return p;
};
var extract2 = makeCommand(extractFileSync, extractFile, (opt) => new UnpackSync(opt), (opt) => new Unpack(opt), (opt, files) => {
  if (files?.length)
    filesFilter(opt, files);
});

// node_modules/tar/dist/esm/replace.js
import fs11 from "node:fs";
import path9 from "node:path";
var replaceSync = (opt, files) => {
  const p = new PackSync(opt);
  let threw = true;
  let fd;
  let position2;
  try {
    try {
      fd = fs11.openSync(opt.file, "r+");
    } catch (er) {
      if (er?.code === "ENOENT") {
        fd = fs11.openSync(opt.file, "w+");
      } else {
        throw er;
      }
    }
    const st = fs11.fstatSync(fd);
    const headBuf = Buffer.alloc(512);
    POSITION:
      for (position2 = 0; position2 < st.size; position2 += 512) {
        for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
          bytes = fs11.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position2 + bufPos);
          if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            throw new Error("cannot append to compressed archives");
          }
          if (!bytes) {
            break POSITION;
          }
        }
        const h = new Header(headBuf);
        if (!h.cksumValid) {
          break;
        }
        const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);
        if (position2 + entryBlockSize + 512 > st.size) {
          break;
        }
        position2 += entryBlockSize;
        if (opt.mtimeCache && h.mtime) {
          opt.mtimeCache.set(String(h.path), h.mtime);
        }
      }
    threw = false;
    streamSync(opt, p, position2, fd, files);
  } finally {
    if (threw) {
      try {
        fs11.closeSync(fd);
      } catch (er) {
      }
    }
  }
};
var streamSync = (opt, p, position2, fd, files) => {
  const stream3 = new WriteStreamSync(opt.file, {
    fd,
    start: position2
  });
  p.pipe(stream3);
  addFilesSync2(p, files);
};
var replaceAsync = (opt, files) => {
  files = Array.from(files);
  const p = new Pack(opt);
  const getPos2 = (fd, size8, cb_) => {
    const cb = (er, pos2) => {
      if (er) {
        fs11.close(fd, (_) => cb_(er));
      } else {
        cb_(null, pos2);
      }
    };
    let position2 = 0;
    if (size8 === 0) {
      return cb(null, 0);
    }
    let bufPos = 0;
    const headBuf = Buffer.alloc(512);
    const onread = (er, bytes) => {
      if (er || typeof bytes === "undefined") {
        return cb(er);
      }
      bufPos += bytes;
      if (bufPos < 512 && bytes) {
        return fs11.read(fd, headBuf, bufPos, headBuf.length - bufPos, position2 + bufPos, onread);
      }
      if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
        return cb(new Error("cannot append to compressed archives"));
      }
      if (bufPos < 512) {
        return cb(null, position2);
      }
      const h = new Header(headBuf);
      if (!h.cksumValid) {
        return cb(null, position2);
      }
      const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);
      if (position2 + entryBlockSize + 512 > size8) {
        return cb(null, position2);
      }
      position2 += entryBlockSize + 512;
      if (position2 >= size8) {
        return cb(null, position2);
      }
      if (opt.mtimeCache && h.mtime) {
        opt.mtimeCache.set(String(h.path), h.mtime);
      }
      bufPos = 0;
      fs11.read(fd, headBuf, 0, 512, position2, onread);
    };
    fs11.read(fd, headBuf, 0, 512, position2, onread);
  };
  const promise2 = new Promise((resolve3, reject) => {
    p.on("error", reject);
    let flag2 = "r+";
    const onopen = (er, fd) => {
      if (er && er.code === "ENOENT" && flag2 === "r+") {
        flag2 = "w+";
        return fs11.open(opt.file, flag2, onopen);
      }
      if (er || !fd) {
        return reject(er);
      }
      fs11.fstat(fd, (er2, st) => {
        if (er2) {
          return fs11.close(fd, () => reject(er2));
        }
        getPos2(fd, st.size, (er3, position2) => {
          if (er3) {
            return reject(er3);
          }
          const stream3 = new WriteStream(opt.file, {
            fd,
            start: position2
          });
          p.pipe(stream3);
          stream3.on("error", reject);
          stream3.on("close", resolve3);
          addFilesAsync2(p, files);
        });
      });
    };
    fs11.open(opt.file, flag2, onopen);
  });
  return promise2;
};
var addFilesSync2 = (p, files) => {
  files.forEach((file) => {
    if (file.charAt(0) === "@") {
      list2({
        file: path9.resolve(p.cwd, file.slice(1)),
        sync: true,
        noResume: true,
        onentry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  });
  p.end();
};
var addFilesAsync2 = async (p, files) => {
  for (let i = 0; i < files.length; i++) {
    const file = String(files[i]);
    if (file.charAt(0) === "@") {
      await list2({
        file: path9.resolve(String(p.cwd), file.slice(1)),
        noResume: true,
        onentry: (entry) => p.add(entry)
      });
    } else {
      p.add(file);
    }
  }
  p.end();
};
var replace3 = makeCommand(
  replaceSync,
  replaceAsync,
  /* c8 ignore start */
  () => {
    throw new TypeError("file is required");
  },
  () => {
    throw new TypeError("file is required");
  },
  /* c8 ignore stop */
  (opt, entries3) => {
    if (!isFile3(opt)) {
      throw new TypeError("file is required");
    }
    if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
      throw new TypeError("cannot append to compressed archives");
    }
    if (!entries3?.length) {
      throw new TypeError("no paths specified to add/replace");
    }
  }
);

// node_modules/tar/dist/esm/update.js
var update2 = makeCommand(replace3.syncFile, replace3.asyncFile, replace3.syncNoFile, replace3.asyncNoFile, (opt, entries3 = []) => {
  replace3.validate?.(opt, entries3);
  mtimeFilter(opt);
});
var mtimeFilter = (opt) => {
  const filter11 = opt.filter;
  if (!opt.mtimeCache) {
    opt.mtimeCache = /* @__PURE__ */ new Map();
  }
  opt.filter = filter11 ? (path14, stat6) => filter11(path14, stat6) && !/* c8 ignore start */
  ((opt.mtimeCache?.get(path14) ?? stat6.mtime ?? 0) > (stat6.mtime ?? 0)) : (path14, stat6) => !/* c8 ignore start */
  ((opt.mtimeCache?.get(path14) ?? stat6.mtime ?? 0) > (stat6.mtime ?? 0));
};

// output/Spago.Tar/foreign.js
var extractImpl = (onError, onSuccess, cwd3, filename) => () => {
  try {
    extract2({
      sync: true,
      cwd: cwd3,
      file: filename
    });
    return onSuccess({});
  } catch (err) {
    return onError(err);
  }
};

// output/Spago.Tar/index.js
var extract3 = function(v) {
  return extractImpl(Left.create, Right.create, v.cwd, v.filename);
};

// output/Spago.Command.Fetch/index.js
var liftEffect8 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var union7 = /* @__PURE__ */ union2(ordPackageName);
var insert13 = /* @__PURE__ */ insert3(ordPackageName);
var bind46 = /* @__PURE__ */ bind(bindEffect);
var pure58 = /* @__PURE__ */ pure(applicativeEffect);
var bind119 = /* @__PURE__ */ bind(bindSpago);
var pure121 = /* @__PURE__ */ pure(applicativeSpago);
var discard21 = /* @__PURE__ */ discard(discardUnit);
var discard111 = /* @__PURE__ */ discard21(bindSpago);
var map75 = /* @__PURE__ */ map(functorMaybe);
var unlessM3 = /* @__PURE__ */ unlessM(monadSpago);
var exists7 = /* @__PURE__ */ exists2(monadEffectSpago);
var mkTemp$prime2 = /* @__PURE__ */ mkTemp$prime(monadAffSpago);
var logDebug6 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var append30 = /* @__PURE__ */ append(semigroupString);
var rightOrDie_2 = /* @__PURE__ */ rightOrDie_(monadEffectSpago)(monadAskSpago);
var loggableArray6 = /* @__PURE__ */ loggableArray(loggableString);
var rightOrDie_1 = /* @__PURE__ */ rightOrDie_2(loggableArray6);
var mkdirp3 = /* @__PURE__ */ mkdirp(monadAffSpago);
var moveSync3 = /* @__PURE__ */ moveSync2(monadEffectSpago);
var ask7 = /* @__PURE__ */ ask(monadAskSpago);
var die6 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die13 = /* @__PURE__ */ die6(loggableString);
var rightOrDie_22 = /* @__PURE__ */ rightOrDie_2(loggableString);
var copyTree2 = /* @__PURE__ */ copyTree(monadEffectSpago);
var rightOrDie3 = /* @__PURE__ */ rightOrDie(monadEffectSpago)(monadAskSpago)(loggableDocc);
var when13 = /* @__PURE__ */ when(applicativeSpago);
var map129 = /* @__PURE__ */ map(functorMap);
var mapFlipped12 = /* @__PURE__ */ mapFlipped(functorMaybe);
var unwrap14 = /* @__PURE__ */ unwrap();
var die24 = /* @__PURE__ */ die6(loggableArray6);
var loggableArray12 = /* @__PURE__ */ loggableArray(loggableDocc);
var die33 = /* @__PURE__ */ die6(loggableArray12);
var toDoc6 = /* @__PURE__ */ toDoc2(loggableString);
var toDoc14 = /* @__PURE__ */ toDoc2(loggableArray6);
var lookup11 = /* @__PURE__ */ lookup3(ordPackageName);
var fromFoldable31 = /* @__PURE__ */ fromFoldable(foldableSet);
var map222 = /* @__PURE__ */ map(functorSpago);
var fromFoldable113 = /* @__PURE__ */ fromFoldable7(ordVersion)(foldableArray);
var $$for7 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var loadAndSolve2 = /* @__PURE__ */ loadAndSolve(monadSpago);
var fromFoldable210 = /* @__PURE__ */ fromFoldable(foldableNonEmptyList);
var map311 = /* @__PURE__ */ map(functorNonEmptyList);
var logInfo5 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var bind214 = /* @__PURE__ */ bind(bindArray);
var toUnfoldable20 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var pure213 = /* @__PURE__ */ pure(applicativeArray);
var sequence4 = /* @__PURE__ */ sequence(traversableMap)(applicativeSpago);
var mapMaybeWithKey3 = /* @__PURE__ */ mapMaybeWithKey(ordPackageName);
var bind310 = /* @__PURE__ */ bind(bindMaybe);
var lookup12 = /* @__PURE__ */ lookup3(ordVersion);
var fromFoldable34 = /* @__PURE__ */ fromFoldable7(ordPackageName);
var fromFoldable43 = /* @__PURE__ */ fromFoldable34(foldableNonEmptyArray);
var bind47 = /* @__PURE__ */ bind(bindNonEmptyArray);
var map412 = /* @__PURE__ */ map(functorNonEmptyArray);
var pure311 = /* @__PURE__ */ pure(applicativeNonEmptyArray);
var mapFlipped13 = /* @__PURE__ */ mapFlipped(functorSpago);
var die42 = /* @__PURE__ */ die6(loggableDocc);
var liftAff5 = /* @__PURE__ */ liftAff(monadAffSpago);
var mapWithIndex5 = /* @__PURE__ */ mapWithIndex(functorWithIndexMap);
var mapFlipped22 = /* @__PURE__ */ mapFlipped(functorMap);
var typoSuggestions3 = /* @__PURE__ */ typoSuggestions(foldableSet);
var map510 = /* @__PURE__ */ map(functorArray);
var insert14 = /* @__PURE__ */ insert2(ordPackageName);
var cycleIsSymbol = {
  reflectSymbol: function() {
    return "cycle";
  }
};
var monoidSet2 = /* @__PURE__ */ monoidSet(ordPackageName);
var notInIndexIsSymbol = {
  reflectSymbol: function() {
    return "notInIndex";
  }
};
var notInPackageSetIsSymbol = {
  reflectSymbol: function() {
    return "notInPackageSet";
  }
};
var mempty20 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(cycleIsSymbol)(monoidSet2)()(/* @__PURE__ */ monoidRecordCons(notInIndexIsSymbol)(monoidSet2)()(/* @__PURE__ */ monoidRecordCons(notInPackageSetIsSymbol)(monoidSet2)()(monoidRecordNil)))));
var member8 = /* @__PURE__ */ member2(ordPackageName);
var monadStateStateT3 = /* @__PURE__ */ monadStateStateT(monadSpago);
var modify_5 = /* @__PURE__ */ modify_2(monadStateStateT3);
var bindStateT2 = /* @__PURE__ */ bindStateT(monadSpago);
var bind52 = /* @__PURE__ */ bind(bindStateT2);
var functorStateT2 = /* @__PURE__ */ functorStateT(functorSpago);
var map610 = /* @__PURE__ */ map(functorStateT2);
var member1 = /* @__PURE__ */ member(ordPackageName);
var gets2 = /* @__PURE__ */ gets(monadStateStateT3);
var applicativeStateT2 = /* @__PURE__ */ applicativeStateT(monadSpago);
var when1 = /* @__PURE__ */ when(applicativeStateT2);
var lift9 = /* @__PURE__ */ lift(monadTransStateT)(monadSpago);
var discard26 = /* @__PURE__ */ discard21(bindStateT2);
var $$void17 = /* @__PURE__ */ $$void(functorStateT2);
var forWithIndex3 = /* @__PURE__ */ forWithIndex(applicativeStateT2)(traversableWithIndexMap);
var eqSet2 = /* @__PURE__ */ eqSet(eqPackageName);
var eq31 = /* @__PURE__ */ eq(/* @__PURE__ */ eqRec()(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons(eqRowNil)()(notInPackageSetIsSymbol)(eqSet2))()(notInIndexIsSymbol)(eqSet2))()(cycleIsSymbol)(eqSet2)));
var execStateT2 = /* @__PURE__ */ execStateT(functorSpago);
var for1 = /* @__PURE__ */ $$for(applicativeStateT2)(traversableArray);
var mempty110 = /* @__PURE__ */ mempty(monoidSet2);
var foldMap10 = /* @__PURE__ */ foldMap(foldableArray)(monoidString);
var toUnfoldable110 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var foldMap17 = /* @__PURE__ */ foldMap(foldableSet)(monoidString);
var wrap4 = /* @__PURE__ */ wrap();
var fromFoldable53 = /* @__PURE__ */ fromFoldable34(foldableArray);
var filterWithKey4 = /* @__PURE__ */ filterWithKey(ordPackageName);
var fold18 = /* @__PURE__ */ fold2(monoidString);
var apply19 = /* @__PURE__ */ apply2(applySpago);
var justOrDieWith2 = /* @__PURE__ */ justOrDieWith(monadEffectSpago)(monadAskSpago)(loggableString);
var eq114 = /* @__PURE__ */ eq(eqPackageName);
var notEq13 = /* @__PURE__ */ notEq(eqPackageName);
var mempty25 = /* @__PURE__ */ mempty(monoidDependencies);
var intersection4 = /* @__PURE__ */ intersection2(ordPackageName);
var fromFoldable63 = /* @__PURE__ */ fromFoldable8(foldableArray)(ordPackageName);
var append117 = /* @__PURE__ */ append(semigroupDependencies);
var set2 = /* @__PURE__ */ set(ordPackageName);
var unless6 = /* @__PURE__ */ unless(applicativeSpago);
var logWarn5 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableArray12);
var append210 = /* @__PURE__ */ append(semigroupArray);
var local2 = /* @__PURE__ */ local(monadReaderSpago);
var traverse7 = /* @__PURE__ */ traverse(traversableMap)(applicativeSpago);
var for_8 = /* @__PURE__ */ for_(applicativeSpago)(foldableMaybe);
var show35 = /* @__PURE__ */ show(showInt);
var addPackagesToConfig2 = /* @__PURE__ */ addPackagesToConfig(monadAffAff);
var bind62 = /* @__PURE__ */ bind(bindEither);
var mkTemp2 = /* @__PURE__ */ mkTemp(monadAffSpago);
var bind72 = /* @__PURE__ */ bind(bindAff);
var discard33 = /* @__PURE__ */ discard21(bindAff);
var eq211 = /* @__PURE__ */ eq(eqStatusCode);
var pure410 = /* @__PURE__ */ pure(applicativeAff);
var notEq23 = /* @__PURE__ */ notEq(eqStatusCode);
var show115 = /* @__PURE__ */ show(showStatusCode);
var hashBuffer2 = /* @__PURE__ */ hashBuffer(monadEffectEffect);
var show212 = /* @__PURE__ */ show(showNumber);
var eq44 = /* @__PURE__ */ eq(eqSha256);
var writeFile5 = /* @__PURE__ */ writeFile4(monadAffSpago);
var show36 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "code";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "cwd";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "file";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "recoverable";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "tarCode";
  }
})(showString))(showBoolean))(showString))(showString))(showString)));
var updateCache = function(dictOrd) {
  var insert22 = insert2(dictOrd);
  return function(key) {
    return function(value4) {
      return function(cacheRef) {
        return liftEffect8(modify_(insert22(key)(value4))(cacheRef));
      };
    };
  };
};
var toAllDependencies = /* @__PURE__ */ function() {
  var $500 = foldl(foldableArray)(union7)(empty4);
  var $501 = foldMap(foldableList)(monoidArray)(function(m) {
    return [m.core, m.test];
  });
  return function($502) {
    return $500($501(values($502)));
  };
}();
var onEachEnvM = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map710 = map(dictApply.Functor0());
  return function(f) {
    return function(e) {
      return apply111(map710(function(v) {
        return function(v1) {
          return {
            core: v,
            test: v1
          };
        };
      })(f(e.core)))(f(e.test));
    };
  };
};
var onEachEnvM1 = /* @__PURE__ */ onEachEnvM(applySpago);
var onEachEnv = function(f) {
  return function(e) {
    return {
      core: f(e.core),
      test: f(e.test)
    };
  };
};
var notInPackageSetError = function(dep) {
  return function(result) {
    return {
      packages: result.packages,
      errors: {
        cycle: result.errors.cycle,
        notInIndex: result.errors.notInIndex,
        notInPackageSet: insert13(dep)(result.errors.notInPackageSet)
      }
    };
  };
};
var notInIndexError = function(dep) {
  return function(result) {
    return {
      packages: result.packages,
      errors: {
        cycle: result.errors.cycle,
        notInPackageSet: result.errors.notInPackageSet,
        notInIndex: insert13(dep)(result.errors.notInIndex)
      }
    };
  };
};
var lookupInCache = function(dictOrd) {
  var lookup22 = lookup3(dictOrd);
  return function(key) {
    return function(cacheRef) {
      return liftEffect8(bind46(read(cacheRef))(function() {
        var $503 = lookup22(key);
        return function($504) {
          return pure58($503($504));
        };
      }()));
    };
  };
};
var withCache = function(dictOrd) {
  var lookupInCache1 = lookupInCache(dictOrd);
  var updateCache1 = updateCache(dictOrd);
  return function(key) {
    return function(cacheRef) {
      return function(create3) {
        return bind119(lookupInCache1(key)(cacheRef))(function(v) {
          if (v instanceof Just) {
            return pure121(v.value0);
          }
          ;
          if (v instanceof Nothing) {
            return bind119(create3)(function(v1) {
              return discard111(updateCache1(key)(v1)(cacheRef))(function() {
                return pure121(v1);
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Fetch (line 289, column 34 - line 295, column 13): " + [v.constructor.name]);
        });
      };
    };
  };
};
var withCache1 = /* @__PURE__ */ withCache(ordPackageName);
var withCache2 = /* @__PURE__ */ withCache(ordString);
var getWorkspacePackageDeps = function(pkg) {
  return {
    core: pkg["package"].dependencies,
    test: fromMaybe(empty4)(function() {
      if (pkg.hasTests) {
        return map75(function(v) {
          return v.dependencies;
        })(pkg["package"].test);
      }
      ;
      return Nothing.value;
    }())
  };
};
var getVersionFromPackage = function(v) {
  if (v instanceof RegistryVersion) {
    return v.value0;
  }
  ;
  return unsafeFromRight(parse4("0.0.0"));
};
var getRangeFromPackage = function(v) {
  if (v instanceof RegistryVersion) {
    return caret(v.value0);
  }
  ;
  return widestRange;
};
var getGitPackageInLocalCache = function(name5) {
  return function($$package2) {
    var repoCacheLocation = concat3([localCacheGitPath, fileSystemCharEscape($$package2.git)]);
    var ensureRepoCloned = unlessM3(exists7(repoCacheLocation))(bind119(mkTemp$prime2(new Just(printJson(gitPackageCodec)($$package2))))(function(tempDir) {
      return discard111(logDebug6("Cloning repo in " + tempDir))(function() {
        return discard111(bind119(fetchRepo($$package2)(tempDir))(rightOrDie_1))(function() {
          return discard111(logDebug6("Repo cloned. Moving to " + repoCacheLocation))(function() {
            return discard111(mkdirp3(concat3([localCachePackagesPath, print5(name5)])))(function() {
              return moveSync3({
                src: tempDir,
                dst: repoCacheLocation
              });
            });
          });
        });
      });
    }));
    var ensureRefPresent = discard111(logDebug6("Verifying ref " + $$package2.ref))(function() {
      return bind119(ask7)(function(v) {
        return bind119(getRefType({
          repo: repoCacheLocation,
          ref: $$package2.ref
        }))(function(v1) {
          if (v1 instanceof Right) {
            return pure121(unit);
          }
          ;
          if (v1 instanceof Left && v.offline instanceof Offline) {
            return die13("Repo " + ($$package2.git + (" does not have ref " + ($$package2.ref + " in local cache. Cannot pull from origin in offline mode."))));
          }
          ;
          if (v1 instanceof Left && v.offline instanceof Online) {
            return discard111(logDebug6("Ref " + ($$package2.ref + " is not present, trying to pull from origin")))(function() {
              return bind119(fetch2({
                repo: repoCacheLocation,
                remote: "origin"
              }))(rightOrDie_22);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Fetch (line 467, column 70 - line 474, column 80): " + [v1.constructor.name, v.offline.constructor.name]);
        });
      });
    });
    return discard111(ensureRepoCloned)(function() {
      return discard111(ensureRefPresent)(function() {
        var localPackageLocation = getPackageLocation(name5)(new GitPackage($$package2));
        return discard111(logDebug6("Copying repo to " + localPackageLocation))(function() {
          return discard111(mkdirp3(concat3([localCachePackagesPath, print5(name5)])))(function() {
            return discard111(copyTree2({
              src: repoCacheLocation,
              dst: localPackageLocation
            }))(function() {
              return discard111(logDebug6("Checking out ref '" + ($$package2.ref + "'")))(function() {
                return discard111(bind119(checkout({
                  repo: localPackageLocation,
                  ref: $$package2.ref
                }))(rightOrDie_22))(function() {
                  return discard111(logDebug6("Checking if we need to copy the package to a commit hash location..."))(function() {
                    return bind119(bind119(getRef(new Just(localPackageLocation)))(rightOrDie3))(function(commitHash) {
                      return when13(commitHash !== $$package2.ref)(function() {
                        var commitHashLocation = getPackageLocation(name5)(new GitPackage({
                          git: $$package2.git,
                          subdir: $$package2.subdir,
                          dependencies: $$package2.dependencies,
                          ref: commitHash
                        }));
                        return discard111(logDebug6("Copying the repo also to " + commitHashLocation))(function() {
                          return copyTree2({
                            src: localPackageLocation,
                            dst: commitHashLocation
                          });
                        });
                      }());
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  };
};
var getPackageDependencies = function(packageName) {
  return function($$package2) {
    var readLocalDependencies = function(configLocation) {
      return bind119(readConfig(concat3([configLocation, "spago.yaml"])))(function(v) {
        if (v instanceof Right && v["value0"]["yaml"]["package"] instanceof Just) {
          return pure121(new Just({
            core: map129(fromMaybe(widestRange))(v["value0"]["yaml"]["package"].value0.dependencies),
            test: map129(fromMaybe(widestRange))(fromMaybe(empty4)(mapFlipped12(mapFlipped12(v["value0"]["yaml"]["package"].value0.test)(function(v1) {
              return v1.dependencies;
            }))(unwrap14)))
          }));
        }
        ;
        if (v instanceof Right) {
          return die24(["Read the configuration at path " + configLocation, "However, it didn't contain a `package` section."]);
        }
        ;
        if (v instanceof Left) {
          return die33([toDoc6("Could not read config at " + configLocation), toDoc6("Error: "), indent(toDoc14(v.value0))]);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 503, column 74 - line 517, column 10): " + [v.constructor.name]);
      });
    };
    if ($$package2 instanceof RegistryVersion) {
      return bind119(getManifestFromIndex(packageName)($$package2.value0))(function(maybeManifest) {
        return pure121(mapFlipped12(maybeManifest)(function(v1) {
          return {
            core: v1.dependencies,
            test: empty4
          };
        }));
      });
    }
    ;
    if ($$package2 instanceof GitPackage) {
      var packageLocation = getPackageLocation(packageName)($$package2);
      return discard111(unlessM3(exists7(packageLocation))(getGitPackageInLocalCache(packageName)($$package2.value0)))(function() {
        if ($$package2.value0.dependencies instanceof Just) {
          return pure121(new Just({
            core: map129(fromMaybe(widestRange))($$package2.value0.dependencies.value0),
            test: empty4
          }));
        }
        ;
        if ($$package2.value0.dependencies instanceof Nothing) {
          return readLocalDependencies(function() {
            if ($$package2.value0.subdir instanceof Nothing) {
              return packageLocation;
            }
            ;
            if ($$package2.value0.subdir instanceof Just) {
              return concat3([packageLocation, $$package2.value0.subdir.value0]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Fetch (line 491, column 31 - line 493, column 55): " + [$$package2.value0.subdir.constructor.name]);
          }());
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 487, column 5 - line 493, column 55): " + [$$package2.value0.dependencies.constructor.name]);
      });
    }
    ;
    if ($$package2 instanceof LocalPackage) {
      return readLocalDependencies($$package2.value0.path);
    }
    ;
    if ($$package2 instanceof WorkspacePackage) {
      return pure121(new Just(onEachEnv(function() {
        var $505 = map129(fromMaybe(widestRange));
        return function($506) {
          return $505(unwrap14($506));
        };
      }())(getWorkspacePackageDeps($$package2.value0))));
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Fetch (line 477, column 46 - line 497, column 104): " + [$$package2.constructor.name]);
  };
};
var getTransitiveDepsFromRegistry = function(depsRanges) {
  return function(extraPackages) {
    var loader = function(packageName) {
      var v = lookup11(packageName)(extraPackages);
      if (v instanceof Just) {
        return bind119(getPackageDependencies(packageName)(v.value0))(function(deps) {
          var coreDeps = fromMaybe(empty4)(mapFlipped12(deps)(function(v1) {
            return v1.core;
          }));
          return pure121(singleton10(getVersionFromPackage(v.value0))(coreDeps));
        });
      }
      ;
      if (v instanceof Nothing) {
        return bind119(getMetadata(packageName))(function(maybeMetadata) {
          var versions = function() {
            if (maybeMetadata instanceof Right) {
              return fromFoldable31(keys3(maybeMetadata.value0.published));
            }
            ;
            if (maybeMetadata instanceof Left) {
              return [];
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Fetch (line 632, column 24 - line 634, column 30): " + [maybeMetadata.constructor.name]);
          }();
          return map222(fromFoldable113)($$for7(versions)(function(v1) {
            return bind119(getManifestFromIndex(packageName)(v1))(function(maybeManifest) {
              var deps = fromMaybe(empty4)(map75(function($507) {
                return function(v2) {
                  return v2.dependencies;
                }(unwrap14($507));
              })(maybeManifest));
              return pure121(new Tuple(v1, deps));
            });
          }));
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Fetch (line 624, column 7 - line 638, column 32): " + [v.constructor.name]);
    };
    return bind119(loadAndSolve2(loader)(depsRanges))(function(maybePlan) {
      if (maybePlan instanceof Left) {
        return die33([toDoc6("Could not solve the package dependencies, errors:"), indent(toDoc14(fromFoldable210(map311(printSolverError)(maybePlan.value0))))]);
      }
      ;
      if (maybePlan instanceof Right) {
        return pure121(maybePlan.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Fetch (line 642, column 3 - line 648, column 21): " + [maybePlan.constructor.name]);
    });
  };
};
var writeNewLockfile = function(reason) {
  return function(allTransitiveDeps) {
    return discard111(logInfo5(reason + ", generating it..."))(function() {
      return bind119(ask7)(function(v) {
        return bind119(liftEffect8($$new(empty4)))(function(packageDependenciesCache) {
          return bind119(liftEffect8($$new(empty4)))(function(gitRefCache) {
            return bind119(liftEffect8($$new(empty4)))(function(metadataRefCache) {
              var allDependencies = toAllDependencies(allTransitiveDeps);
              var uniqueRegistryPackageNames = bind214(toUnfoldable20(allDependencies))(function(v1) {
                if (v1.value1 instanceof RegistryVersion) {
                  return pure213(v1.value0);
                }
                ;
                return [];
              });
              return bind119(bind119(getMetadataForPackages2(uniqueRegistryPackageNames))(function(v1) {
                if (v1 instanceof Left) {
                  return die13("Couldn't read metadata, reason:\n  " + v1.value0);
                }
                ;
                if (v1 instanceof Right) {
                  return pure121(v1.value0);
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Fetch (line 320, column 81 - line 322, column 24): " + [v1.constructor.name]);
              }))(function(metadataMap) {
                return bind119(sequence4(mapMaybeWithKey3(function(name5) {
                  return function($$package2) {
                    if ($$package2 instanceof RegistryVersion) {
                      return new Just(function() {
                        var metadata = lookup11(name5)(metadataMap);
                        var v1 = bind310(metadata)(function(v2) {
                          return lookup12($$package2.value0)(v2.published);
                        });
                        if (v1 instanceof Nothing && isNothing(metadata)) {
                          return die13("Couldn't read metadata for " + print5(name5));
                        }
                        ;
                        if (v1 instanceof Nothing) {
                          return die13("Couldn't read metadata for " + (print5(name5) + ": didn't find version in the metadata file"));
                        }
                        ;
                        if (v1 instanceof Just) {
                          return pure121(v1.value0.hash);
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 329, column 11 - line 336, column 29): " + [v1.constructor.name]);
                      }());
                    }
                    ;
                    return Nothing.value;
                  };
                })(allDependencies)))(function(v1) {
                  var workspacePackageLockEntries = fromFoldable43(bind47(map412(workspacePackageToLockfilePackage)(getWorkspacePackages(v.workspace.packageSet)))(function(v2) {
                    var deps = fromMaybe({
                      core: empty4,
                      test: empty4
                    })(lookup11(v2.value0)(allTransitiveDeps));
                    return pure311(new Tuple(v2.value0, {
                      path: v2.value1.path,
                      core: {
                        dependencies: v2.value1.core.dependencies,
                        build_plan: keys3(deps.core)
                      },
                      test: {
                        dependencies: v2.value1.test.dependencies,
                        build_plan: keys3(deps.test)
                      }
                    }));
                  }));
                  var corePackageDepsOrEmpty = function(packageName) {
                    return function($$package2) {
                      return withCache1(packageName)(packageDependenciesCache)(mapFlipped13(getPackageDependencies(packageName)($$package2))(function(v2) {
                        if (v2 instanceof Just) {
                          return fromFoldable31(keys3(v2.value0.core));
                        }
                        ;
                        if (v2 instanceof Nothing) {
                          return [];
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 348, column 56 - line 350, column 24): " + [v2.constructor.name]);
                      }));
                    };
                  };
                  var packageToLockEntry = function(packageName) {
                    return function($$package2) {
                      if ($$package2 instanceof WorkspacePackage) {
                        return Nothing.value;
                      }
                      ;
                      if ($$package2 instanceof GitPackage) {
                        return new Just(function() {
                          var packageLocation = getPackageLocation(packageName)($$package2);
                          return withCache2(packageLocation)(gitRefCache)(bind119(getRef(new Just(packageLocation)))(function(v2) {
                            if (v2 instanceof Left) {
                              return die42(v2.value0);
                            }
                            ;
                            if (v2 instanceof Right) {
                              return bind119(corePackageDepsOrEmpty(packageName)($$package2))(function(dependencies) {
                                return pure121(new FromGit({
                                  rev: v2.value0,
                                  dependencies,
                                  url: $$package2.value0.git,
                                  subdir: $$package2.value0.subdir
                                }));
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Fetch (line 358, column 49 - line 363, column 99): " + [v2.constructor.name]);
                          }));
                        }());
                      }
                      ;
                      if ($$package2 instanceof RegistryVersion) {
                        return new Just(withCache1(packageName)(metadataRefCache)(map222(FromRegistry.create)(function() {
                          var v2 = lookup11(packageName)(v1);
                          if (v2 instanceof Nothing) {
                            return die13("Couldn't read metadata");
                          }
                          ;
                          if (v2 instanceof Just) {
                            return bind119(corePackageDepsOrEmpty(packageName)($$package2))(function(dependencies) {
                              return pure121({
                                version: $$package2.value0,
                                integrity: v2.value0,
                                dependencies
                              });
                            });
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Command.Fetch (line 366, column 28 - line 372, column 56): " + [v2.constructor.name]);
                        }())));
                      }
                      ;
                      if ($$package2 instanceof LocalPackage) {
                        return new Just(bind119(corePackageDepsOrEmpty(packageName)($$package2))(function(dependencies) {
                          return pure121(new FromPath({
                            path: $$package2.value0.path,
                            dependencies
                          }));
                        }));
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Fetch (line 352, column 46 - line 375, column 47): " + [$$package2.constructor.name]);
                    };
                  };
                  return bind119(sequence4(mapMaybeWithKey3(packageToLockEntry)(allDependencies)))(function(nonWorkspacePackageLockEntries) {
                    var lockfile = {
                      packages: nonWorkspacePackageLockEntries,
                      workspace: {
                        package_set: function() {
                          if (v.workspace.packageSet.buildType instanceof RegistrySolverBuild) {
                            return Nothing.value;
                          }
                          ;
                          if (v.workspace.packageSet.buildType instanceof PackageSetBuild) {
                            return new Just(v.workspace.packageSet.buildType.value0);
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Command.Fetch (line 398, column 26 - line 400, column 50): " + [v.workspace.packageSet.buildType.constructor.name]);
                        }(),
                        packages: workspacePackageLockEntries,
                        extra_packages: fromMaybe(empty4)(v.workspace.workspaceConfig.extraPackages)
                      }
                    };
                    return discard111(liftAff5(writeYamlFile(lockfileCodec)("spago.lock")(lockfile)))(function() {
                      return discard111(logInfo5("Lockfile written to spago.lock. Please commit this file."))(function() {
                        var updateGitDependencyRefsToCommitHashes = mapWithIndex5(function(name5) {
                          return function($$package2) {
                            if ($$package2 instanceof GitPackage) {
                              var v2 = lookup11(name5)(nonWorkspacePackageLockEntries);
                              if (v2 instanceof Nothing) {
                                return $$package2;
                              }
                              ;
                              if (v2 instanceof Just && v2.value0 instanceof FromGit) {
                                return new GitPackage({
                                  git: $$package2.value0.git,
                                  subdir: $$package2.value0.subdir,
                                  dependencies: $$package2.value0.dependencies,
                                  ref: v2.value0.value0.rev
                                });
                              }
                              ;
                              if (v2 instanceof Just) {
                                return $$package2;
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Command.Fetch (line 413, column 34 - line 416, column 28): " + [v2.constructor.name]);
                            }
                            ;
                            return $$package2;
                          };
                        });
                        return pure121(mapFlipped22(allTransitiveDeps)(onEachEnv(updateGitDependencyRefsToCommitHashes)));
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  };
};
var cycleError = function(dep) {
  return function(result) {
    return {
      packages: result.packages,
      errors: {
        notInIndex: result.errors.notInIndex,
        notInPackageSet: result.errors.notInPackageSet,
        cycle: insert13(dep)(result.errors.cycle)
      }
    };
  };
};
var getTransitiveDepsFromPackageSet = function(packageSet) {
  return function(deps) {
    return discard111(logDebug6("Getting transitive deps"))(function() {
      return bind119(liftEffect8($$new(empty4)))(function(packageDependenciesCache) {
        var printPackageError = function(p) {
          return "  - " + (print5(p) + "\n");
        };
        var printNotInPackageSetError = function(p) {
          var strSuggestions = function() {
            var v = typoSuggestions3(print5)(p)(keys3(packageSet));
            if (v.length === 0) {
              return "\n";
            }
            ;
            return " (did you mean: " + (joinWith(", ")(map510(print5)(v)) + ")\n");
          }();
          return "  - " + (print5(p) + strSuggestions);
        };
        var memoisedGetPackageDependencies = function(packageName) {
          return function($$package2) {
            return bind119(liftEffect8(read(packageDependenciesCache)))(function(cache) {
              var v = lookup11(packageName)(cache);
              if (v instanceof Just) {
                return pure121(v.value0);
              }
              ;
              if (v instanceof Nothing) {
                return bind119(map222(map75(function(v1) {
                  return v1.core;
                }))(getPackageDependencies(packageName)($$package2)))(function(coreDeps) {
                  return discard111(liftEffect8(modify_(insert14(packageName)(coreDeps))(packageDependenciesCache)))(function() {
                    return pure121(coreDeps);
                  });
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 659, column 7 - line 665, column 24): " + [v.constructor.name]);
            });
          };
        };
        var init4 = {
          packages: empty4,
          errors: mempty20
        };
        var go = function(seen) {
          return function(dep) {
            var $379 = member8(dep)(seen);
            if ($379) {
              return modify_5(cycleError(dep));
            }
            ;
            return bind52(map610(member1(dep))(gets2(function(v) {
              return v.packages;
            })))(function(alreadyRun) {
              return when1(!alreadyRun)(function() {
                var v = lookup11(dep)(packageSet);
                if (v instanceof Nothing) {
                  return modify_5(notInPackageSetError(dep));
                }
                ;
                if (v instanceof Just) {
                  return bind52(lift9(memoisedGetPackageDependencies(dep)(v.value0)))(function(maybeDeps) {
                    if (maybeDeps instanceof Nothing) {
                      return modify_5(notInIndexError(dep));
                    }
                    ;
                    if (maybeDeps instanceof Just) {
                      return bind52(gets2(function(v1) {
                        return v1.errors;
                      }))(function(errors) {
                        return discard26($$void17(forWithIndex3(maybeDeps.value0)(function(dependency2) {
                          return function(v1) {
                            return go(insert13(dep)(seen))(dependency2);
                          };
                        })))(function() {
                          return bind52(gets2(function(v1) {
                            return v1.errors;
                          }))(function(errorsAfterTransitiveDeps) {
                            return when1(eq31(errors)(errorsAfterTransitiveDeps))(modify_5(function(st) {
                              var $382 = {};
                              for (var $383 in st) {
                                if ({}.hasOwnProperty.call(st, $383)) {
                                  $382[$383] = st[$383];
                                }
                                ;
                              }
                              ;
                              $382.packages = insert14(dep)(v.value0)(st.packages);
                              return $382;
                            }));
                          });
                        });
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Fetch (line 698, column 15 - line 713, column 94): " + [maybeDeps.constructor.name]);
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Fetch (line 694, column 11 - line 713, column 94): " + [v.constructor.name]);
              }());
            });
          };
        };
        return bind119(execStateT2(for1(deps)(go(mempty110)))(init4))(function(v) {
          return discard111(when13(!isEmpty2(v.errors.cycle))(die13("The following packages have circular dependencies:\n" + foldMap10(printPackageError)(toUnfoldable110(v.errors.cycle)))))(function() {
            return discard111(when13(!isEmpty2(v.errors.notInPackageSet))(die13("The following packages do not exist in your package set:\n" + foldMap17(printNotInPackageSetError)(v.errors.notInPackageSet))))(function() {
              return discard111(when13(!isEmpty2(v.errors.notInIndex))(die13("The following packages do not exist in the package index:\n" + foldMap17(printPackageError)(v.errors.notInIndex))))(function() {
                return pure121(v.packages);
              });
            });
          });
        });
      });
    });
  };
};
var getTransitiveDeps = function(workspacePackage) {
  var fromLockEntry = function(v) {
    if (v instanceof FromPath) {
      return new LocalPackage({
        path: v.value0.path
      });
    }
    ;
    if (v instanceof FromRegistry) {
      return new RegistryVersion(v.value0.version);
    }
    ;
    if (v instanceof FromGit) {
      return new GitPackage({
        ref: v.value0.rev,
        dependencies: new Just(wrap4(fromFoldable53(map510(function(p) {
          return new Tuple(p, Nothing.value);
        })(v.value0.dependencies)))),
        git: v.value0.url,
        subdir: v.value0.subdir
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Fetch (line 607, column 19 - line 615, column 8): " + [v.constructor.name]);
  };
  var depsRanges = onEachEnv(function() {
    var $508 = map129(fromMaybe(widestRange));
    return function($509) {
      return $508(unwrap14($509));
    };
  }())(getWorkspacePackageDeps(workspacePackage));
  return bind119(ask7)(function(v) {
    if (v.workspace.packageSet.lockfile instanceof Right) {
      var v1 = lookup11(workspacePackage["package"].name)(v.workspace.packageSet.lockfile.value0.workspace.packages);
      if (v1 instanceof Nothing) {
        return die13("Package " + (print5(workspacePackage["package"].name) + " not found in lockfile"));
      }
      ;
      if (v1 instanceof Just) {
        var fromBuildPlan = function(bp) {
          var isInBuildPlan = function(name5) {
            return function(_package) {
              return member8(name5)(bp);
            };
          };
          var otherPackages = map129(fromLockEntry)(filterWithKey4(isInBuildPlan)(v.workspace.packageSet.lockfile.value0.packages));
          var allWorkspacePackages = fromFoldable43(map412(function(p) {
            return new Tuple(p["package"].name, new WorkspacePackage(p));
          })(getWorkspacePackages(v.workspace.packageSet)));
          var workspacePackagesWeNeed = filterWithKey4(isInBuildPlan)(allWorkspacePackages);
          return union7(otherPackages)(workspacePackagesWeNeed);
        };
        return pure121({
          core: fromBuildPlan(v1.value0.core.build_plan),
          test: fromBuildPlan(v1.value0.test.build_plan)
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Fetch (line 559, column 7 - line 576, column 98): " + [v1.constructor.name]);
    }
    ;
    if (v.workspace.packageSet.lockfile instanceof Left) {
      if (v.workspace.packageSet.buildType instanceof RegistrySolverBuild) {
        var forEnv = function(envName) {
          return function(depsRanges$prime) {
            return bind119(getTransitiveDepsFromRegistry(depsRanges$prime)(v.workspace.packageSet.buildType.value0))(function(plan) {
              return discard111(logDebug6(fold18(["Got a plan from the Solver for ", envName, " deps: ", printJson(packageMap(codec3))(plan)])))(function() {
                return pure121(mapMaybeWithKey3(function(packageName) {
                  return function(version4) {
                    var v12 = lookup11(packageName)(v.workspace.packageSet.buildType.value0);
                    if (v12 instanceof Just) {
                      return new Just(v12.value0);
                    }
                    ;
                    if (v12 instanceof Nothing) {
                      return new Just(new RegistryVersion(version4));
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Fetch (line 590, column 71 - line 592, column 56): " + [v12.constructor.name]);
                  };
                })(plan));
              });
            });
          };
        };
        return apply19(map222(function(v12) {
          return function(v2) {
            return {
              core: v12,
              test: v2
            };
          };
        })(forEnv("core")(depsRanges.core)))(forEnv("test")(depsRanges.test));
      }
      ;
      if (v.workspace.packageSet.buildType instanceof PackageSetBuild) {
        return onEachEnvM1(function(depsRanges$prime) {
          return getTransitiveDepsFromPackageSet(v.workspace.packageSet.buildType.value1)(fromFoldable31(keys3(depsRanges$prime)));
        })(depsRanges);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Fetch (line 579, column 15 - line 600, column 92): " + [v.workspace.packageSet.buildType.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Fetch (line 555, column 3 - line 600, column 92): " + [v.workspace.packageSet.lockfile.constructor.name]);
  });
};
var run3 = function(v) {
  return discard111(logDebug6("Requested to install these packages: " + printJson(array(codec2))(v.packages)))(function() {
    return bind119(ask7)(function(v1) {
      var getPackageConfigPath = function(errorMessageEnd) {
        if (v1.workspace.selected instanceof Just) {
          return pure121({
            configPath: concat3([v1.workspace.selected.value0.path, "spago.yaml"]),
            yamlDoc: v1.workspace.selected.value0.doc,
            "package": v1["workspace"]["selected"]["value0"]["package"]
          });
        }
        ;
        if (v1.workspace.rootPackage instanceof Just) {
          return pure121({
            configPath: "spago.yaml",
            yamlDoc: v1.workspace.doc,
            "package": v1.workspace.rootPackage.value0
          });
        }
        ;
        if (v1.workspace.selected instanceof Nothing && v1.workspace.rootPackage instanceof Nothing) {
          return die24(["No package found in the root configuration.", "Please use the `-p` flag to select a package " + errorMessageEnd]);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 90, column 7 - line 98, column 12): " + [v1.workspace.selected.constructor.name, v1.workspace.rootPackage.constructor.name]);
      };
      return bind119(function() {
        if (v.packages.length === 0) {
          return pure121(Nothing.value);
        }
        ;
        return bind119(getPackageConfigPath("to install your packages in."))(function(v2) {
          return bind119(justOrDieWith2(find3(function(p) {
            return eq114(p["package"].name)(v2["package"].name);
          })(getWorkspacePackages(v1.workspace.packageSet)))("Impossible: package must be in workspace packages"))(function(currentWorkspacePackage) {
            var packages3 = filter(function(p) {
              return notEq13(p)(v2["package"].name);
            })(v.packages);
            var packageDependencies = keys3(function() {
              if (!v.isTest) {
                return unwrap14(v2["package"].dependencies);
              }
              ;
              if (v.isTest) {
                return unwrap14(maybe(mempty25)(function(v3) {
                  return v3.dependencies;
                })(v2["package"].test));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 108, column 44 - line 110, column 70): " + [v.isTest.constructor.name]);
            }());
            var overlappingPackages = intersection4(packageDependencies)(fromFoldable63(packages3));
            var actualPackagesToInstall = filter(function(p) {
              return !member8(p)(overlappingPackages);
            })(packages3);
            var newPackageDependencies = wrap4(fromFoldable53(map510(function(p) {
              return new Tuple(p, Nothing.value);
            })(actualPackagesToInstall)));
            var newWorkspacePackage = function() {
              if (!v.isTest) {
                return {
                  doc: currentWorkspacePackage.doc,
                  hasTests: currentWorkspacePackage.hasTests,
                  path: currentWorkspacePackage.path,
                  "package": {
                    build: currentWorkspacePackage["package"].build,
                    bundle: currentWorkspacePackage["package"].bundle,
                    description: currentWorkspacePackage["package"].description,
                    name: currentWorkspacePackage["package"].name,
                    publish: currentWorkspacePackage["package"].publish,
                    run: currentWorkspacePackage["package"].run,
                    test: currentWorkspacePackage["package"].test,
                    dependencies: append117(v2["package"].dependencies)(newPackageDependencies)
                  }
                };
              }
              ;
              if (v.isTest) {
                return {
                  doc: currentWorkspacePackage.doc,
                  hasTests: currentWorkspacePackage.hasTests,
                  path: currentWorkspacePackage.path,
                  "package": {
                    build: currentWorkspacePackage["package"].build,
                    bundle: currentWorkspacePackage["package"].bundle,
                    dependencies: currentWorkspacePackage["package"].dependencies,
                    description: currentWorkspacePackage["package"].description,
                    name: currentWorkspacePackage["package"].name,
                    publish: currentWorkspacePackage["package"].publish,
                    run: currentWorkspacePackage["package"].run,
                    test: map75(function(t) {
                      return {
                        censorTestWarnings: t.censorTestWarnings,
                        execArgs: t.execArgs,
                        main: t.main,
                        pedanticPackages: t.pedanticPackages,
                        strict: t.strict,
                        dependencies: append117(t.dependencies)(newPackageDependencies)
                      };
                    })(v2["package"].test)
                  }
                };
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 116, column 33 - line 118, column 156): " + [v.isTest.constructor.name]);
            }();
            return discard111(logDebug6("Overlapping packages: " + printJson(set2(codec2))(overlappingPackages)))(function() {
              return discard111(logDebug6("Actual packages to install: " + printJson(array(codec2))(actualPackagesToInstall)))(function() {
                return discard111(unless6(isEmpty2(overlappingPackages))(logWarn5(append210([toDoc6("You tried to install some packages that are already present in the configuration, proceeding anyways:")])(map510(function() {
                  var $510 = append30("- ");
                  return function($511) {
                    return indent(toDoc6($510(print5($511))));
                  };
                }())(fromFoldable31(overlappingPackages))))))(function() {
                  var v3 = $$null(actualPackagesToInstall);
                  if (v3) {
                    return pure121(Nothing.value);
                  }
                  ;
                  if (!v3) {
                    return discard111(logDebug6("Packages to install: " + printJson(array(codec2))(actualPackagesToInstall)))(function() {
                      return pure121(new Just({
                        configPath: v2.configPath,
                        yamlDoc: v2.yamlDoc,
                        actualPackagesToInstall,
                        newWorkspacePackage
                      }));
                    });
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Command.Fetch (line 127, column 9 - line 131, column 94): " + [v3.constructor.name]);
                });
              });
            });
          });
        });
      }())(function(installingPackagesData) {
        var workspace = function() {
          if (installingPackagesData instanceof Nothing) {
            return v1.workspace;
          }
          ;
          if (installingPackagesData instanceof Just) {
            var $435 = {};
            for (var $436 in v1.workspace) {
              if ({}.hasOwnProperty.call(v1.workspace, $436)) {
                $435[$436] = v1["workspace"][$436];
              }
              ;
            }
            ;
            $435.packageSet = {
              lockfile: new Left("Lockfile is out of date (installing new packages)"),
              buildType: function() {
                if (v1.workspace.packageSet.buildType instanceof RegistrySolverBuild) {
                  return new RegistrySolverBuild(insert14(installingPackagesData["value0"]["newWorkspacePackage"]["package"].name)(new WorkspacePackage(installingPackagesData.value0.newWorkspacePackage))(v1.workspace.packageSet.buildType.value0));
                }
                ;
                if (v1.workspace.packageSet.buildType instanceof PackageSetBuild) {
                  return new PackageSetBuild(v1.workspace.packageSet.buildType.value0, insert14(installingPackagesData["value0"]["newWorkspacePackage"]["package"].name)(new WorkspacePackage(installingPackagesData.value0.newWorkspacePackage))(v1.workspace.packageSet.buildType.value1));
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Fetch (line 141, column 27 - line 143, column 168): " + [v1.workspace.packageSet.buildType.constructor.name]);
              }()
            };
            $435.selected = new Just(installingPackagesData.value0.newWorkspacePackage);
            return $435;
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Fetch (line 135, column 17 - line 146, column 10): " + [installingPackagesData.constructor.name]);
        }();
        return local2(function(v2) {
          var $440 = {};
          for (var $441 in v2) {
            if ({}.hasOwnProperty.call(v2, $441)) {
              $440[$441] = v2[$441];
            }
            ;
          }
          ;
          $440.workspace = workspace;
          return $440;
        })(bind119(traverse7(getTransitiveDeps)(fromFoldable43(map412(function(p) {
          return new Tuple(p["package"].name, p);
        })(getWorkspacePackages(workspace.packageSet)))))(function(dependencies) {
          return discard111(for_8(installingPackagesData)(function(v2) {
            var countString = function() {
              var v3 = length(v2.actualPackagesToInstall);
              if (v3 === 1) {
                return "1 package";
              }
              ;
              return show35(v3) + " packages";
            }();
            return discard111(logInfo5("Adding " + (countString + (" to the config in " + v2.configPath))))(function() {
              return liftAff5(addPackagesToConfig2(v2.configPath)(v2.yamlDoc)(v.isTest)(v2.actualPackagesToInstall));
            });
          }))(function() {
            return discard111(when13(v.ensureRanges)(bind119(getPackageConfigPath("in which to add ranges."))(function(v2) {
              return discard111(logInfo5("Adding ranges to core dependencies to the config in " + v2.configPath))(function() {
                return bind119(justOrDieWith2(lookup11(v2["package"].name)(dependencies))("Impossible: package dependencies must be in dependencies map"))(function(packageDeps) {
                  var rangeMap = map129(getRangeFromPackage)(packageDeps.core);
                  return discard111(liftEffect8(addRangesToConfig(v2.yamlDoc)(rangeMap)))(function() {
                    return liftAff5(writeYamlDocFile(v2.configPath)(v2.yamlDoc));
                  });
                });
              });
            })))(function() {
              return bind119(supportPackage(workspace.packageSet))(function(supportPackage2) {
                var allTransitiveDeps = function() {
                  if (!v.isRepl) {
                    return dependencies;
                  }
                  ;
                  if (v.isRepl) {
                    return map129(onEachEnv(function(packageMap2) {
                      return union7(packageMap2)(supportPackage2);
                    }))(dependencies);
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Command.Fetch (line 178, column 27 - line 182, column 96): " + [v.isRepl.constructor.name]);
                }();
                return bind119(function() {
                  if (workspace.selected instanceof Nothing) {
                    return pure121(toAllDependencies(allTransitiveDeps));
                  }
                  ;
                  if (workspace.selected instanceof Just) {
                    var v2 = lookup11(workspace["selected"]["value0"]["package"].name)(dependencies);
                    if (v2 instanceof Nothing) {
                      return die13("Impossible: package dependencies must be in dependencies map");
                    }
                    ;
                    if (v2 instanceof Just) {
                      var supportDeps = function() {
                        if (v.isRepl) {
                          return supportPackage2;
                        }
                        ;
                        return empty4;
                      }();
                      return pure121(union7(supportDeps)(union7(v2.value0.test)(v2.value0.core)));
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Fetch (line 186, column 17 - line 191, column 71): " + [v2.constructor.name]);
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Command.Fetch (line 183, column 20 - line 191, column 71): " + [workspace.selected.constructor.name]);
                }())(function(depsToFetch) {
                  return discard111(logInfo5("Downloading dependencies..."))(function() {
                    return discard111(parallelise(flip(map510)(toUnfoldable20(depsToFetch))(function(v2) {
                      var localPackageLocation = getPackageLocation(v2.value0)(v2.value1);
                      return unlessM3(exists7(localPackageLocation))(function() {
                        if (v2.value1 instanceof GitPackage) {
                          return getGitPackageInLocalCache(v2.value0)(v2.value1.value0);
                        }
                        ;
                        if (v2.value1 instanceof RegistryVersion) {
                          var versionString = print6(v2.value1.value0);
                          var packageVersion = print5(v2.value0) + ("@" + versionString);
                          return bind119(getMetadata(v2.value0))(function(metadata) {
                            var v4 = bind62(metadata)(function(v5) {
                              return note("Didn't find version in the metadata file")(lookup12(v2.value1.value0)(v5.published));
                            });
                            if (v4 instanceof Left) {
                              return die13("Couldn't read metadata, reason:\n  " + v4.value0);
                            }
                            ;
                            if (v4 instanceof Right) {
                              return discard111(logDebug6("Metadata read: " + printJson(publishedMetadataCodec)(v4.value0)))(function() {
                                var globalCachePackagePath = concat3([globalCachePath, "packages", print5(v2.value0)]);
                                var archivePath = concat3([globalCachePackagePath, versionString + ".tar.gz"]);
                                return discard111(mkdirp3(globalCachePackagePath))(function() {
                                  return bind119(exists7(archivePath))(function(tarExists) {
                                    var tarInnerFolder = print5(v2.value0) + ("-" + print6(v2.value1.value0));
                                    return bind119(mkTemp2)(function(tempDir) {
                                      return discard111(mkdirp3(tempDir))(function() {
                                        return bind119(function() {
                                          if (tarExists) {
                                            return discard111(logDebug6("Trying to unpack archive to temp folder: " + tempDir))(function() {
                                              return map222(either($$const(false))($$const(true)))(liftEffect8(extract3({
                                                filename: archivePath,
                                                cwd: tempDir
                                              })));
                                            });
                                          }
                                          ;
                                          return pure121(false);
                                        }())(function(tarIsGood) {
                                          return discard111(function() {
                                            if (tarExists && tarIsGood) {
                                              return pure121(unit);
                                            }
                                            ;
                                            if (v1.offline instanceof Offline) {
                                              return die13("Package " + (packageVersion + " is not in the local cache, and Spago is running in offline mode - can't make progress."));
                                            }
                                            ;
                                            if (v1.offline instanceof Online) {
                                              var packageUrl = "https://packages.registry.purescript.org/" + (print5(v2.value0) + ("/" + (versionString + ".tar.gz")));
                                              return discard111(logInfo5("Fetching package " + packageVersion))(function() {
                                                return bind119(liftAff5(withBackoff$prime(bind72(request2({
                                                  headers: defaultRequest.headers,
                                                  content: defaultRequest.content,
                                                  username: defaultRequest.username,
                                                  password: defaultRequest.password,
                                                  withCredentials: defaultRequest.withCredentials,
                                                  timeout: defaultRequest.timeout,
                                                  method: new Left(GET.value),
                                                  responseFormat: arrayBuffer,
                                                  url: packageUrl
                                                }))(function(res) {
                                                  return discard33(function() {
                                                    if (res instanceof Right && eq211(res.value0.status)(503)) {
                                                      return delay(3e4);
                                                    }
                                                    ;
                                                    return pure410(unit);
                                                  }())(function() {
                                                    return pure410(res);
                                                  });
                                                }))))(function(response) {
                                                  if (response instanceof Nothing) {
                                                    return die13("Couldn't reach the registry at " + packageUrl);
                                                  }
                                                  ;
                                                  if (response instanceof Just && response.value0 instanceof Left) {
                                                    return die13("Couldn't fetch package " + (packageVersion + (":\n  " + printError2(response.value0.value0))));
                                                  }
                                                  ;
                                                  if (response instanceof Just && (response.value0 instanceof Right && notEq23(response.value0.value0.status)(200))) {
                                                    return bind119(liftEffect8(fromArrayBuffer2(response.value0.value0.body)))(function(v5) {
                                                      return bind119(liftEffect8(toString6(UTF8.value)(v5)))(function(bodyString) {
                                                        return die13("Couldn't fetch package " + (packageVersion + (", status was not ok " + (show115(response.value0.value0.status) + (", got answer:\n  " + bodyString)))));
                                                      });
                                                    });
                                                  }
                                                  ;
                                                  if (response instanceof Just && response.value0 instanceof Right) {
                                                    return discard111(logDebug6("Got status: " + show115(response.value0.value0.status)))(function() {
                                                      return bind119(liftEffect8(fromArrayBuffer2(response.value0.value0.body)))(function(archiveBuffer) {
                                                        return bind119(liftEffect8(size5(archiveBuffer)))(function(archiveSize) {
                                                          return bind119(liftEffect8(hashBuffer2(archiveBuffer)))(function(archiveSha) {
                                                            return discard111(unless6(toNumber(archiveSize) === v4.value0.bytes)(die13("Archive fetched for " + (packageVersion + (" has a different size (" + (show35(archiveSize) + (") than expected (" + (show212(v4.value0.bytes) + ")"))))))))(function() {
                                                              return discard111(unless6(eq44(archiveSha)(v4.value0.hash))(die13("Archive fetched for " + (packageVersion + (" has a different hash (" + (print9(archiveSha) + (") than expected (" + (print9(v4.value0.hash) + ")"))))))))(function() {
                                                                return discard111(logDebug6("Fetched archive for " + (packageVersion + (", saving it in the global cache: " + archivePath))))(function() {
                                                                  return discard111(writeFile5(archivePath)(archiveBuffer))(function() {
                                                                    return discard111(logDebug6("Unpacking archive to temp folder: " + tempDir))(function() {
                                                                      return bind119(liftEffect8(extract3({
                                                                        filename: archivePath,
                                                                        cwd: tempDir
                                                                      })))(function(v5) {
                                                                        if (v5 instanceof Right) {
                                                                          return pure121(unit);
                                                                        }
                                                                        ;
                                                                        if (v5 instanceof Left) {
                                                                          return die24(["Failed to decode downloaded package " + (packageVersion + ", error:"), show36(v5.value0)]);
                                                                        }
                                                                        ;
                                                                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 269, column 94 - line 271, column 125): " + [v5.constructor.name]);
                                                                      });
                                                                    });
                                                                  });
                                                                });
                                                              });
                                                            });
                                                          });
                                                        });
                                                      });
                                                    });
                                                  }
                                                  ;
                                                  throw new Error("Failed pattern match at Spago.Command.Fetch (line 248, column 19 - line 271, column 125): " + [response.constructor.name]);
                                                });
                                              });
                                            }
                                            ;
                                            throw new Error("Failed pattern match at Spago.Command.Fetch (line 229, column 15 - line 271, column 125): " + [tarExists.constructor.name, tarIsGood.constructor.name, v1.offline.constructor.name]);
                                          }())(function() {
                                            return discard111(logDebug6("Moving extracted file to local cache:" + localPackageLocation))(function() {
                                              return moveSync3({
                                                src: concat3([tempDir, tarInnerFolder]),
                                                dst: localPackageLocation
                                              });
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Fetch (line 207, column 11 - line 273, column 104): " + [v4.constructor.name]);
                          });
                        }
                        ;
                        if (v2.value1 instanceof LocalPackage) {
                          return pure121(unit);
                        }
                        ;
                        if (v2.value1 instanceof WorkspacePackage) {
                          return pure121(unit);
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 199, column 48 - line 276, column 40): " + [v2.value1.constructor.name]);
                      }());
                    })))(function() {
                      if (workspace.packageSet.lockfile instanceof Right) {
                        return pure121(dependencies);
                      }
                      ;
                      if (workspace.packageSet.lockfile instanceof Left) {
                        return writeNewLockfile(workspace.packageSet.lockfile.value0)(dependencies);
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Fetch (line 280, column 5 - line 282, column 58): " + [workspace.packageSet.lockfile.constructor.name]);
                    });
                  });
                });
              });
            });
          });
        }));
      });
    });
  });
};

// output/Spago.Psa.Types/index.js
var compare8 = /* @__PURE__ */ compare(ordString);
var object6 = /* @__PURE__ */ object2();
var rowListCodecCons5 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var compare15 = /* @__PURE__ */ compare(/* @__PURE__ */ ordTuple(ordInt)(ordInt));
var IsLib = /* @__PURE__ */ function() {
  function IsLib2() {
  }
  ;
  IsLib2.value = new IsLib2();
  return IsLib2;
}();
var IsSrc = /* @__PURE__ */ function() {
  function IsSrc2() {
  }
  ;
  IsSrc2.value = new IsSrc2();
  return IsSrc2;
}();
var Unknown = /* @__PURE__ */ function() {
  function Unknown2() {
  }
  ;
  Unknown2.value = new Unknown2();
  return Unknown2;
}();
var Lib = /* @__PURE__ */ function() {
  function Lib2(value0) {
    this.value0 = value0;
  }
  ;
  Lib2.create = function(value0) {
    return new Lib2(value0);
  };
  return Lib2;
}();
var Src = /* @__PURE__ */ function() {
  function Src2(value0) {
    this.value0 = value0;
  }
  ;
  Src2.create = function(value0) {
    return new Src2(value0);
  };
  return Src2;
}();
var eqPsaPath = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Unknown && y instanceof Unknown) {
        return true;
      }
      ;
      if (x instanceof Lib && y instanceof Lib) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof Src && y instanceof Src) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var ordPsaPath = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Unknown && y instanceof Unknown) {
        return EQ.value;
      }
      ;
      if (x instanceof Unknown) {
        return LT.value;
      }
      ;
      if (y instanceof Unknown) {
        return GT.value;
      }
      ;
      if (x instanceof Lib && y instanceof Lib) {
        return compare8(x.value0)(y.value0);
      }
      ;
      if (x instanceof Lib) {
        return LT.value;
      }
      ;
      if (y instanceof Lib) {
        return GT.value;
      }
      ;
      if (x instanceof Src && y instanceof Src) {
        return compare8(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqPsaPath;
  }
};
var compare23 = /* @__PURE__ */ compare(ordPsaPath);
var positionCodec = /* @__PURE__ */ named("Position")(/* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5({
  reflectSymbol: function() {
    return "startLine";
  }
}))()()({
  reflectSymbol: function() {
    return "startColumn";
  }
}))()()({
  reflectSymbol: function() {
    return "endLine";
  }
}))()()({
  reflectSymbol: function() {
    return "endColumn";
  }
}))({
  startLine: $$int,
  startColumn: $$int,
  endLine: $$int,
  endColumn: $$int
}));
var suggestionCodec = /* @__PURE__ */ named("Suggestion")(/* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5({
  reflectSymbol: function() {
    return "replacement";
  }
}))()()({
  reflectSymbol: function() {
    return "replaceRange";
  }
}))({
  replacement: string,
  replaceRange: /* @__PURE__ */ nullable(positionCodec)
}));
var psaErrorCodec = /* @__PURE__ */ named("PsaError")(/* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5({
  reflectSymbol: function() {
    return "suggestion";
  }
}))()()({
  reflectSymbol: function() {
    return "position";
  }
}))()()({
  reflectSymbol: function() {
    return "moduleName";
  }
}))()()({
  reflectSymbol: function() {
    return "message";
  }
}))()()({
  reflectSymbol: function() {
    return "filename";
  }
}))()()({
  reflectSymbol: function() {
    return "errorLink";
  }
}))()()({
  reflectSymbol: function() {
    return "errorCode";
  }
}))({
  moduleName: /* @__PURE__ */ nullable(string),
  errorCode: string,
  errorLink: string,
  message: string,
  filename: /* @__PURE__ */ nullable(string),
  position: /* @__PURE__ */ nullable(positionCodec),
  suggestion: /* @__PURE__ */ nullable(suggestionCodec)
}));
var psaResultCodec = /* @__PURE__ */ named("PsaResult")(/* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5({
  reflectSymbol: function() {
    return "warnings";
  }
}))()()({
  reflectSymbol: function() {
    return "errors";
  }
}))({
  warnings: /* @__PURE__ */ array(psaErrorCodec),
  errors: /* @__PURE__ */ array(psaErrorCodec)
}));
var compareByLocation = function(err1) {
  return function(err2) {
    var v = compare23(err1.path)(err2.path);
    if (v instanceof EQ) {
      if (err1.position instanceof Nothing && err2.position instanceof Nothing) {
        return EQ.value;
      }
      ;
      if (err1.position instanceof Nothing) {
        return LT.value;
      }
      ;
      if (err2.position instanceof Nothing) {
        return GT.value;
      }
      ;
      if (err1.position instanceof Just && err2.position instanceof Just) {
        return compare15(new Tuple(err1.position.value0.startLine, err1.position.value0.startColumn))(new Tuple(err2.position.value0.startLine, err2.position.value0.startColumn));
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Types (line 132, column 7 - line 138, column 46): " + [err1.position.constructor.name, err2.position.constructor.name]);
    }
    ;
    return v;
  };
};

// output/Spago.Psa.Output/index.js
var disj2 = /* @__PURE__ */ disj(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var eq35 = /* @__PURE__ */ eq(eqCodePoint);
var foldl7 = /* @__PURE__ */ foldl(foldableArray);
var identity29 = /* @__PURE__ */ identity(categoryFn);
var apply20 = /* @__PURE__ */ apply2(applyMaybe);
var map76 = /* @__PURE__ */ map(functorMaybe);
var pure59 = /* @__PURE__ */ pure(applicativeSpago);
var append31 = /* @__PURE__ */ append(semigroupArray);
var bind48 = /* @__PURE__ */ bind(bindSpago);
var map130 = /* @__PURE__ */ map(functorArray);
var foldM5 = /* @__PURE__ */ foldM(monadSpago);
var $$Error2 = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var Warning = /* @__PURE__ */ function() {
  function Warning2() {
  }
  ;
  Warning2.value = new Warning2();
  return Warning2;
}();
var trimPosition = function($copy_lines) {
  return function($copy_pos) {
    var $tco_var_lines = $copy_lines;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(lines8, pos2) {
      var isPunc = disj2(function(v2) {
        return eq35(v2)(codePointFromChar(" "));
      })(function(v2) {
        return eq35(v2)(codePointFromChar(","));
      });
      var trimComment = function(col) {
        return function(l) {
          var v2 = indexOf2("--")(l);
          if (v2 instanceof Just && v2.value0 === 0) {
            return Nothing.value;
          }
          ;
          if (v2 instanceof Just && v2.value0 < (col - 1 | 0)) {
            return trimCol(v2.value0 + 1 | 0)(l);
          }
          ;
          return new Just(col);
        };
      };
      var trimCol = function($copy_col) {
        return function($copy_l) {
          var $tco_var_col = $copy_col;
          var $tco_done1 = false;
          var $tco_result2;
          function $tco_loop2(col, l) {
            var v2 = codePointAt(col - 2 | 0)(l);
            if (v2 instanceof Just && isPunc(v2.value0)) {
              $tco_var_col = col - 1 | 0;
              $copy_l = l;
              return;
            }
            ;
            if (v2 instanceof Just) {
              $tco_done1 = true;
              return trimComment(col)(l);
            }
            ;
            $tco_done1 = true;
            return Nothing.value;
          }
          ;
          while (!$tco_done1) {
            $tco_result2 = $tco_loop2($tco_var_col, $copy_l);
          }
          ;
          return $tco_result2;
        };
      };
      var trimPos = function($copy_v) {
        var $tco_done2 = false;
        var $tco_result2;
        function $tco_loop2(v2) {
          if (v2.col <= 1) {
            var v1 = index(lines8)((v2.row - pos2.startLine | 0) - 1 | 0);
            if (v1 instanceof Just) {
              $copy_v = {
                row: v2.row - 1 | 0,
                col: length5(v1.value0) + 1 | 0
              };
              return;
            }
            ;
            $tco_done2 = true;
            return Nothing.value;
          }
          ;
          if (otherwise) {
            var v1 = index(lines8)(v2.row - pos2.startLine | 0);
            if (v1 instanceof Just) {
              var v22 = trimCol(v2.col)(v1.value0);
              if (v22 instanceof Just) {
                $tco_done2 = true;
                return new Just({
                  row: v2.row,
                  col: v22.value0
                });
              }
              ;
              if (v22 instanceof Nothing) {
                $copy_v = {
                  row: v2.row,
                  col: 1
                };
                return;
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa.Output (line 222, column 13 - line 224, column 49): " + [v22.constructor.name]);
            }
            ;
            $tco_done2 = true;
            return Nothing.value;
          }
          ;
          throw new Error("Failed pattern match at Spago.Psa.Output (line 213, column 3 - line 226, column 23): " + [v2.constructor.name]);
        }
        ;
        while (!$tco_done2) {
          $tco_result2 = $tco_loop2($copy_v);
        }
        ;
        return $tco_result2;
      };
      if (lines8.length === 0) {
        $tco_done = true;
        return {
          startLine: pos2.startLine,
          startColumn: pos2.startColumn,
          endLine: pos2.startLine,
          endColumn: pos2.startColumn
        };
      }
      ;
      if (lines8.length === 1) {
        var v = trimCol(pos2.endColumn)(lines8[0]);
        if (v instanceof Just) {
          $tco_done = true;
          return {
            startLine: pos2.startLine,
            startColumn: pos2.startColumn,
            endLine: pos2.startLine,
            endColumn: v.value0
          };
        }
        ;
        if (v instanceof Nothing) {
          $tco_done = true;
          return {
            startLine: pos2.startLine,
            startColumn: pos2.startColumn,
            endLine: pos2.startLine,
            endColumn: pos2.startColumn
          };
        }
        ;
        throw new Error("Failed pattern match at Spago.Psa.Output (line 201, column 7 - line 203, column 80): " + [v.constructor.name]);
      }
      ;
      var v = trimPos({
        row: pos2.endLine,
        col: pos2.endColumn
      });
      if (v instanceof Just) {
        $tco_done = true;
        return {
          startLine: pos2.startLine,
          startColumn: pos2.startColumn,
          endLine: v.value0.row,
          endColumn: v.value0.col
        };
      }
      ;
      if (v instanceof Nothing) {
        $tco_var_lines = [];
        $copy_pos = pos2;
        return;
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Output (line 206, column 7 - line 208, column 39): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_lines, $copy_pos);
    }
    ;
    return $tco_result;
  };
};
var trimMessage = /* @__PURE__ */ function() {
  var dedent = function(v) {
    return function(l) {
      if (l === "") {
        return {
          lines: snoc(v.lines)(l),
          indent: v.indent
        };
      }
      ;
      if (otherwise) {
        var indent$prime = length5(takeWhile3(function(v1) {
          return eq35(v1)(codePointFromChar(" "));
        })(l));
        var $90 = indent$prime < v.indent;
        if ($90) {
          return {
            lines: snoc(v.lines)(drop3(indent$prime)(l)),
            indent: indent$prime
          };
        }
        ;
        return {
          lines: snoc(v.lines)(drop3(v.indent)(l)),
          indent: v.indent
        };
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Output (line 255, column 3 - line 262, column 71): " + [v.constructor.name, l.constructor.name]);
    };
  };
  var collapse = function(lines8) {
    return function(l) {
      var v = last(lines8);
      if (v instanceof Just && (v.value0 === "" && l === "")) {
        return lines8;
      }
      ;
      return snoc(lines8)(l);
    };
  };
  var $127 = joinWith("\n");
  var $128 = foldl7(collapse)([]);
  var $129 = foldl7(dedent)({
    lines: [],
    indent: top(boundedInt)
  });
  var $130 = split("\n");
  return function($131) {
    return trim($127($128(function(v) {
      return v.lines;
    }($129($130($131))))));
  };
}();
var onTag = function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        if (v2 instanceof $$Error2) {
          return v(v3);
        }
        ;
        if (v2 instanceof Warning) {
          return v1(v3);
        }
        ;
        throw new Error("Failed pattern match at Spago.Psa.Output (line 178, column 1 - line 178, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
      };
    };
  };
};
var onPath = function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        if (v2 instanceof Src) {
          return v(v3);
        }
        ;
        if (v2 instanceof Lib) {
          return v1(v3);
        }
        ;
        return v3;
      };
    };
  };
};
var updateStats = function(tag) {
  return function(path14) {
    return function(code3) {
      return function(printed) {
        return function(s) {
          var bump = function(v) {
            return new Tuple(function() {
              if (printed) {
                return v.value0 + 1 | 0;
              }
              ;
              return v.value0;
            }(), v.value1 + 1 | 0);
          };
          var alterStat = function(v) {
            if (v instanceof Nothing) {
              return new Just(bump(new Tuple(0, 0)));
            }
            ;
            if (v instanceof Just) {
              return new Just(bump(v.value0));
            }
            ;
            throw new Error("Failed pattern match at Spago.Psa.Output (line 175, column 3 - line 175, column 46): " + [v.constructor.name]);
          };
          var bumpCode = alter2(alterStat)(code3);
          return {
            allWarnings: onTag(identity29)(bumpCode)(tag)(s.allWarnings),
            allErrors: onTag(bumpCode)(identity29)(tag)(s.allErrors),
            srcWarnings: onTag(identity29)(onPath(bumpCode)(identity29)(path14))(tag)(s.srcWarnings),
            srcErrors: onTag(onPath(bumpCode)(identity29)(path14))(identity29)(tag)(s.srcErrors),
            libWarnings: onTag(identity29)(onPath(identity29)(bumpCode)(path14))(tag)(s.libWarnings),
            libErrors: onTag(onPath(identity29)(bumpCode)(path14))(identity29)(tag)(s.libErrors)
          };
        };
      };
    };
  };
};
var initialStats = {
  allWarnings: empty6,
  allErrors: empty6,
  srcWarnings: empty6,
  srcErrors: empty6,
  libWarnings: empty6,
  libErrors: empty6
};
var annotatedError = function(path14) {
  return function(lines8) {
    return function(error5) {
      var position2 = apply20(map76(trimPosition)(lines8))(error5.position);
      var source2 = apply20(map76(function(p) {
        return take((p.endLine - p.startLine | 0) + 1 | 0);
      })(position2))(lines8);
      var message3 = trimMessage(error5.message);
      return {
        path: path14,
        position: position2,
        message: message3,
        source: source2,
        error: error5
      };
    };
  };
};
var buildOutput = function(loadLines) {
  return function(options) {
    return function(result) {
      var pathOf = function(x) {
        var unknownPathInfo = {
          path: Unknown.value,
          shouldPromoteWarningToError: false,
          shouldShowError: function(v) {
            return function(v1) {
              return true;
            };
          }
        };
        var toPathInfo = function($$short4) {
          return function(v) {
            return {
              path: function() {
                if (v.pathType instanceof IsLib) {
                  return new Lib($$short4);
                }
                ;
                if (v.pathType instanceof IsSrc) {
                  return new Src($$short4);
                }
                ;
                throw new Error("Failed pattern match at Spago.Psa.Output (line 109, column 15 - line 111, column 29): " + [v.pathType.constructor.name]);
              }(),
              shouldPromoteWarningToError: v.shouldPromoteWarningToError,
              shouldShowError: v.shouldShowError
            };
          };
        };
        var pathDecision = function() {
          if (x.filename instanceof Just && x.filename.value0 !== "") {
            var path14 = function() {
              if (isAbsolute(x.filename.value0)) {
                return x.filename.value0;
              }
              ;
              if (otherwise) {
                return concat3([cwd2, x.filename.value0]);
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa.Output (line 100, column 11 - line 102, column 59): ");
            }();
            return fromMaybe(unknownPathInfo)(findMap(function(p) {
              return map76(toPathInfo(x.filename.value0))(p(path14));
            })(options.decisions));
          }
          ;
          return unknownPathInfo;
        }();
        return new Tuple(pathDecision, x);
      };
      var onError = function(tag) {
        return function(state2) {
          return function(v) {
            var update3 = function(log5) {
              var printed = !$$null(log5);
              var tag$prime = function() {
                var $122 = printed && v.value0.shouldPromoteWarningToError;
                if ($122) {
                  return $$Error2.value;
                }
                ;
                return tag;
              }();
              var stats = updateStats(tag$prime)(v.value0.path)(v.value1.errorCode)(printed)(state2.stats);
              return pure59(onTag(function(v1) {
                return {
                  warnings: v1.warnings,
                  stats,
                  errors: append31(state2.errors)(log5)
                };
              })(function(v1) {
                return {
                  errors: v1.errors,
                  stats,
                  warnings: append31(state2.warnings)(log5)
                };
              })(tag$prime)(state2));
            };
            var shouldShowError = function() {
              if (tag instanceof $$Error2) {
                return true;
              }
              ;
              if (tag instanceof Warning) {
                return v.value0.shouldShowError(v.value1.errorCode)(v.value1.message);
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa.Output (line 133, column 23 - line 135, column 72): " + [tag.constructor.name]);
            }();
            if (shouldShowError) {
              return bind48(fromMaybe(pure59(Nothing.value))(apply20(map76(loadLines)(v.value1.filename))(v.value1.position)))(function(source2) {
                return update3([annotatedError(v.value0.path)(source2)(v.value1)]);
              });
            }
            ;
            return update3([]);
          };
        };
      };
      var result$prime = {
        warnings: map130(pathOf)(result.warnings),
        errors: map130(pathOf)(result.errors)
      };
      var initialState = {
        warnings: [],
        errors: [],
        stats: initialStats
      };
      return bind48(foldM5(onError(Warning.value))(initialState)(result$prime.warnings))(function(state2) {
        return bind48(foldM5(onError($$Error2.value))(state2)(result$prime.errors))(function(state$prime) {
          return pure59({
            stats: state$prime.stats,
            warnings: sortBy(compareByLocation)(state$prime.warnings),
            errors: sortBy(compareByLocation)(state$prime.errors)
          });
        });
      });
    };
  };
};

// output/Spago.Psa.Printer/index.js
var lines5 = /* @__PURE__ */ lines(foldableArray);
var map77 = /* @__PURE__ */ map(functorArray);
var show37 = /* @__PURE__ */ show(showInt);
var maximum2 = /* @__PURE__ */ maximum(ordInt)(foldableArray);
var maximumBy2 = /* @__PURE__ */ maximumBy(foldableArray);
var comparing2 = /* @__PURE__ */ comparing(ordInt);
var foldWithSeparator2 = /* @__PURE__ */ foldWithSeparator(foldableArray);
var bind49 = /* @__PURE__ */ bind(bindMaybe);
var power4 = /* @__PURE__ */ power(monoidString);
var pure60 = /* @__PURE__ */ pure(applicativeMaybe);
var append118 = /* @__PURE__ */ append(semigroupDoc);
var discard27 = /* @__PURE__ */ discard(discardUnit);
var discard112 = /* @__PURE__ */ discard27(bindMaybe);
var guard13 = /* @__PURE__ */ guard(alternativeMaybe);
var unfoldr3 = /* @__PURE__ */ unfoldr(unfoldableArray);
var mempty21 = /* @__PURE__ */ mempty(monoidDoc);
var fold19 = /* @__PURE__ */ fold(foldableArray)(monoidDoc);
var sort5 = /* @__PURE__ */ sort(ordString);
var append211 = /* @__PURE__ */ append(semigroupArray);
var words3 = /* @__PURE__ */ words(foldableArray);
var foldMap18 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidDoc);
var apply21 = /* @__PURE__ */ apply2(applyMaybe);
var map131 = /* @__PURE__ */ map(functorMaybe);
var mempty111 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidFn(monoidDoc));
var forWithIndex_4 = /* @__PURE__ */ forWithIndex_(applicativeEffect)(foldableWithIndexArray);
var toLines = /* @__PURE__ */ function() {
  var $97 = map77(text);
  var $98 = split("\n");
  return function($99) {
    return lines5($97($98($99)));
  };
}();
var renderStatus = function(color) {
  return function(total) {
    return function(index5) {
      return function(code3) {
        return foreground(color)(text("[" + (show37(index5) + ("/" + (show37(total) + (" " + (code3 + "]")))))));
      };
    };
  };
};
var renderStatCols$prime = function(v) {
  var numOfRows = fromMaybe(0)(maximum2(map77(length)([v.col1, v.col2, v.col3, v.col4])));
  var maxColWidth = function() {
    var $100 = maybe(0)(function(v1) {
      return v1.width;
    });
    var $101 = maximumBy2(comparing2(function(v1) {
      return v1.width;
    }));
    return function($102) {
      return $100($101($102));
    };
  }();
  var guttered = foldWithSeparator2(text("   "));
  var col4Width = maxColWidth(v.col4);
  var col3Width = maxColWidth(v.col3);
  var col2Width = maxColWidth(v.col2);
  var col1Width = maxColWidth(v.col1);
  var buildColumn = function(column2) {
    return function(colWidth) {
      return function(rowIdx) {
        return bind49(index(column2)(rowIdx))(function(v1) {
          var padding = colWidth - v1.width | 0;
          var padText = text(power4(" ")(padding));
          var $56 = padding === 0;
          if ($56) {
            return pure60(v1.doc);
          }
          ;
          if (v1.alignLeft) {
            return pure60(append118(v1.doc)(padText));
          }
          ;
          return pure60(append118(padText)(v1.doc));
        });
      };
    };
  };
  var buildRow = function(rowIdx) {
    return discard112(guard13(rowIdx !== numOfRows))(function() {
      return bind49(buildColumn(v.col1)(col1Width)(rowIdx))(function(c1) {
        return bind49(buildColumn(v.col2)(col2Width)(rowIdx))(function(c2) {
          return bind49(buildColumn(v.col3)(col3Width)(rowIdx))(function(c3) {
            return bind49(buildColumn(v.col4)(col4Width)(rowIdx))(function(c4) {
              return pure60(flip(Tuple.create)(rowIdx + 1 | 0)(guttered([c1, c2, c3, c4])));
            });
          });
        });
      });
    });
  };
  var rows = flip(unfoldr3)(0)(buildRow);
  return lines5(rows);
};
var renderStatCols = function(columns) {
  return renderStatCols$prime({
    col1: cons({
      width: 0,
      alignLeft: true,
      doc: mempty21
    })(columns.col1),
    col2: cons({
      width: 3,
      alignLeft: true,
      doc: text("Src")
    })(columns.col2),
    col3: cons({
      width: 3,
      alignLeft: true,
      doc: text("Lib")
    })(columns.col3),
    col4: cons({
      width: 3,
      alignLeft: true,
      doc: text("All")
    })(columns.col4)
  });
};
var renderStat = function(v) {
  if (v.value0 === 0 && v.value1 === 0) {
    return {
      width: 1,
      alignLeft: false,
      doc: foreground(BrightGreen.value)(text("0"))
    };
  }
  ;
  if (v.value0 === v.value1) {
    var aText = show37(v.value0);
    return {
      width: length5(aText),
      alignLeft: false,
      doc: text(aText)
    };
  }
  ;
  if (otherwise) {
    var aText = show37(v.value0);
    var bText = show37(v.value1);
    var width2 = (1 + length5(aText) | 0) + length5(bText) | 0;
    return {
      width: width2,
      alignLeft: false,
      doc: fold19([text(aText), dim(text("/")), text(bText)])
    };
  }
  ;
  throw new Error("Failed pattern match at Spago.Psa.Printer (line 235, column 1 - line 235, column 41): " + [v.constructor.name]);
};
var renderStats = function(stats) {
  var sumRatio = function(v) {
    return function(v1) {
      return function(v2) {
        return new Tuple(v.value0 + v2.value0 | 0, v.value1 + v2.value1 | 0);
      };
    };
  };
  var srcWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.srcWarnings);
  var srcErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.srcErrors);
  var renderLabel = function(color) {
    return function(lbl) {
      return {
        width: length5(lbl),
        alignLeft: true,
        doc: foreground(color)(text(lbl))
      };
    };
  };
  var libWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.libWarnings);
  var libErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.libErrors);
  var allWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.allWarnings);
  var allErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.allErrors);
  return renderStatCols({
    col1: [renderLabel(BrightYellow.value)("Warnings"), renderLabel(BrightRed.value)("Errors")],
    col2: [renderStat(srcWarnings), renderStat(srcErrors)],
    col3: [renderStat(libWarnings), renderStat(libErrors)],
    col4: [renderStat(allWarnings), renderStat(allErrors)]
  });
};
var renderVerboseStats = function(stats) {
  var warnings = sort5(keys2(stats.allWarnings));
  var renderLabel = function(color) {
    return function(lbl) {
      return {
        width: length5(lbl),
        alignLeft: true,
        doc: foreground(color)(text(lbl))
      };
    };
  };
  var warningLabels = map77(renderLabel(BrightYellow.value))(warnings);
  var getStat = function(key) {
    return function(x) {
      return fromMaybe(new Tuple(0, 0))(lookup4(key)(x));
    };
  };
  var getStats = function(ks) {
    return function(x) {
      return map77(function(k) {
        return renderStat(getStat(k)(x));
      })(ks);
    };
  };
  var libWarnings = getStats(warnings)(stats.libWarnings);
  var srcWarnings = getStats(warnings)(stats.srcWarnings);
  var errors = sort5(keys2(stats.allErrors));
  var libErrors = getStats(errors)(stats.libErrors);
  var srcErrors = getStats(errors)(stats.srcErrors);
  var errorLabels = map77(renderLabel(BrightRed.value))(errors);
  var allWarnings = getStats(warnings)(stats.allWarnings);
  var allErrors = getStats(errors)(stats.allErrors);
  var $77 = $$null(warnings) && $$null(errors);
  if ($77) {
    return renderStats(stats);
  }
  ;
  return renderStatCols({
    col1: append211(warningLabels)(errorLabels),
    col2: append211(srcWarnings)(srcErrors),
    col3: append211(libWarnings)(libErrors),
    col4: append211(allWarnings)(allErrors)
  });
};
var renderPosition = function(pos2) {
  return fold19([dim(text(":")), text(show37(pos2.startLine)), dim(text(":")), text(show37(pos2.startColumn))]);
};
var renderModuleName = function(v) {
  if (v instanceof Nothing) {
    return dim(text("(unknown module)"));
  }
  ;
  if (v instanceof Just) {
    return text(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Spago.Psa.Printer (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var renderPath = function(v) {
  return function(v1) {
    if (v instanceof Src) {
      return text(v.value0);
    }
    ;
    if (v instanceof Lib) {
      return text(v.value0);
    }
    ;
    return renderModuleName(v1);
  };
};
var renderErrorTick = function(start) {
  return function($$char6) {
    return fold19([text(power4(" ")(start - 1 | 0)), foreground(BrightRed.value)(text($$char6))]);
  };
};
var renderErrorRange = function(start) {
  return function(len) {
    return fold19([text(power4(" ")(start - 1 | 0)), foreground(BrightRed.value)(text(power4("^")(len)))]);
  };
};
var renderAnnotation = function(offset) {
  return function(pos2) {
    return function(lines1) {
      return lines5(function() {
        if (lines1.length === 1) {
          return [lines1[0], renderErrorRange(pos2.startColumn + offset | 0)(pos2.endColumn - pos2.startColumn | 0)];
        }
        ;
        return [renderErrorTick(pos2.startColumn + offset | 0)("v"), lines5(lines1), renderErrorTick((pos2.endColumn + offset | 0) - 1 | 0)("^")];
      }());
    };
  };
};
var printJsonOutputToOut = function(output8) {
  var result = encode2(psaResultCodec)({
    warnings: map77(function(v) {
      return v.error;
    })(output8.warnings),
    errors: map77(function(v) {
      return v.error;
    })(output8.errors)
  });
  return log2(print(result));
};
var padLeft = function(width2) {
  return function(str2) {
    return power4(" ")(width2 - length5(str2) | 0) + str2;
  };
};
var sourceLine = function(gutter) {
  return function(sep3) {
    return function(num) {
      return function(code3) {
        return fold19([dim(text(padLeft(gutter)(show37(num)) + sep3)), text(code3)]);
      };
    };
  };
};
var renderSource = function(pos2) {
  return function(lines1) {
    var lineNums = range2(pos2.startLine)(pos2.endLine);
    var gutter = length5(show37(pos2.endLine));
    var source2 = map77(uncurry(sourceLine(gutter)("  ")))(zip(lineNums)(lines1));
    var source$prime = function() {
      var $86 = length(source2) > 7;
      if ($86) {
        return append211(take(3)(source2))(append211([append118(text(power4(" ")(gutter + 2 | 0)))(dim(text("...")))])(drop(length(source2) - 3 | 0)(source2)));
      }
      ;
      return source2;
    }();
    return renderAnnotation(gutter + 2 | 0)(pos2)(source$prime);
  };
};
var renderSource$prime = function(pos2) {
  return function(lines1) {
    return append118(renderSource(pos2)(lines1))($$break);
  };
};
var renderWrapper = function(color) {
  return function(total) {
    return function(index5) {
      return function(v) {
        return foldWithSeparator2(append118($$break)($$break))([words3([renderStatus(color)(total)(index5)(v.error.errorCode), append118(renderPath(v.path)(v.error.moduleName))(foldMap18(renderPosition)(v.position))]), indent(lines5([fromMaybe(mempty21)(apply21(map131(renderSource$prime)(v.position))(v.source)), toLines(v.message)]))]);
      };
    };
  };
};
var renderError = /* @__PURE__ */ function() {
  return renderWrapper(BrightRed.value);
}();
var renderWarning = /* @__PURE__ */ function() {
  return renderWrapper(BrightYellow.value);
}();
var printDefaultOutputToErr = function(options) {
  return function(output8) {
    var renderStats$prime = function() {
      if (options.statVerbosity instanceof NoStats) {
        return mempty111;
      }
      ;
      if (options.statVerbosity instanceof CompactStats) {
        return renderStats;
      }
      ;
      if (options.statVerbosity instanceof VerboseStats) {
        return renderVerboseStats;
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Printer (line 68, column 18 - line 71, column 44): " + [options.statVerbosity.constructor.name]);
    }();
    var printDoc = function() {
      if (options.color) {
        return print4(ansiGraphics)(twoSpaces);
      }
      ;
      if (otherwise) {
        return print4(plainText)(twoSpaces);
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Printer (line 63, column 3 - line 65, column 50): ");
    }();
    var lenWarnings = length(output8.warnings);
    var lenErrors = length(output8.errors);
    return function __do3() {
      forWithIndex_4(output8.warnings)(function(i) {
        return function(warning) {
          return function __do4() {
            error3(printDoc(renderWarning(lenWarnings)(i + 1 | 0)(warning)))();
            return error3("")();
          };
        };
      })();
      forWithIndex_4(output8.errors)(function(i) {
        return function(error5) {
          return function __do4() {
            error3(printDoc(renderError(lenErrors)(i + 1 | 0)(error5)))();
            return error3("")();
          };
        };
      })();
      return error3(printDoc(renderStats$prime(output8.stats)))();
    };
  };
};

// output/Spago.Purs/index.js
var bind50 = /* @__PURE__ */ bind(bindSpago);
var ask8 = /* @__PURE__ */ ask(monadAskSpago);
var append34 = /* @__PURE__ */ append(semigroupArray);
var toUnfoldable21 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var exec7 = /* @__PURE__ */ exec5(monadAffSpago);
var die7 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die14 = /* @__PURE__ */ die7(loggableString);
var pure61 = /* @__PURE__ */ pure(applicativeSpago);
var loggableArray7 = /* @__PURE__ */ loggableArray(loggableString);
var die25 = /* @__PURE__ */ die7(loggableArray7);
var discard28 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug7 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug15 = /* @__PURE__ */ logDebug7(loggableArray7);
var logDebug25 = /* @__PURE__ */ logDebug7(loggableString);
var ModuleGraph = function(x) {
  return x;
};
var Html = /* @__PURE__ */ function() {
  function Html2() {
  }
  ;
  Html2.value = new Html2();
  return Html2;
}();
var Markdown = /* @__PURE__ */ function() {
  function Markdown2() {
  }
  ;
  Markdown2.value = new Markdown2();
  return Markdown2;
}();
var Ctags = /* @__PURE__ */ function() {
  function Ctags2() {
  }
  ;
  Ctags2.value = new Ctags2();
  return Ctags2;
}();
var Etags = /* @__PURE__ */ function() {
  function Etags2() {
  }
  ;
  Etags2.value = new Etags2();
  return Etags2;
}();
var eqDocsFormat = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Html && y instanceof Html) {
        return true;
      }
      ;
      if (x instanceof Markdown && y instanceof Markdown) {
        return true;
      }
      ;
      if (x instanceof Ctags && y instanceof Ctags) {
        return true;
      }
      ;
      if (x instanceof Etags && y instanceof Etags) {
        return true;
      }
      ;
      return false;
    };
  }
};
var repl = function(globs) {
  return function(pursArgs2) {
    return bind50(ask8)(function(v) {
      var args = append34(["repl"])(append34(pursArgs2)(toUnfoldable21(globs)));
      return exec7(v.purs.cmd)(args)({
        cwd: defaultExecOptions.cwd,
        pipeStdout: true,
        pipeStderr: true,
        pipeStdin: StdinPipeParent.value
      });
    });
  };
};
var printDocsFormat = function(v) {
  if (v instanceof Html) {
    return "html";
  }
  ;
  if (v instanceof Markdown) {
    return "markdown";
  }
  ;
  if (v instanceof Ctags) {
    return "ctags";
  }
  ;
  if (v instanceof Etags) {
    return "etags";
  }
  ;
  throw new Error("Failed pattern match at Spago.Purs (line 84, column 19 - line 88, column 19): " + [v.constructor.name]);
};
var parseVersionOutput = function(v) {
  var dropStuff = function(pattern) {
    var $78 = fromMaybe("");
    var $79 = split(pattern);
    return function($80) {
      return $78(head($79($80)));
    };
  };
  var v1 = parseLenientVersion(dropStuff("-")(dropStuff(" ")(v.output)));
  if (v1 instanceof Left) {
    return die14("Failed to parse purs version. Was: " + v.output);
  }
  ;
  if (v1 instanceof Right) {
    var $64 = minor(v1.value0) >= 15 && patch(v1.value0) >= 4;
    if ($64) {
      return pure61({
        cmd: v.cmd,
        version: v1.value0
      });
    }
    ;
    return die25(["Unsupported PureScript version " + print6(v1.value0), "Please install PureScript v0.15.4 or higher."]);
  }
  ;
  throw new Error("Failed pattern match at Spago.Purs (line 33, column 46 - line 40, column 115): " + [v1.constructor.name]);
};
var parseDocsFormat = function(v) {
  if (v === "html") {
    return new Just(Html.value);
  }
  ;
  if (v === "markdown") {
    return new Just(Markdown.value);
  }
  ;
  if (v === "ctags") {
    return new Just(Ctags.value);
  }
  ;
  if (v === "etags") {
    return new Just(Etags.value);
  }
  ;
  return Nothing.value;
};
var moduleGraphNodeCodec = /* @__PURE__ */ named("ModuleGraphNode")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "path";
  }
}))()()({
  reflectSymbol: function() {
    return "depends";
  }
}))({
  path: string,
  depends: /* @__PURE__ */ array(string)
}));
var moduleGraphCodec = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorExceptT(functorIdentity)))()(ModuleGraph)(strMap(ordString)("ModuleGraph")(Right.create)(identity(categoryFn))(moduleGraphNodeCodec));
}();
var graph = function(globs) {
  return function(pursArgs2) {
    return bind50(ask8)(function(v) {
      var args = append34(["graph"])(append34(pursArgs2)(toUnfoldable21(globs)));
      return discard28(logDebug15(["Running command:", "purs " + joinWith(" ")(args)]))(function() {
        var execOpts2 = {
          cwd: defaultExecOptions.cwd,
          pipeStdin: defaultExecOptions.pipeStdin,
          pipeStdout: false,
          pipeStderr: false
        };
        return bind50(exec7(v.purs.cmd)(args)(execOpts2))(function(v1) {
          if (v1 instanceof Right) {
            return discard28(logDebug25("Called `purs graph`, decoding.."))(function() {
              return pure61(parseJson(moduleGraphCodec)(v1.value0.stdout));
            });
          }
          ;
          if (v1 instanceof Left) {
            return discard28(logDebug25(printExecResult(v1.value0)))(function() {
              return die25(["Failed to call `purs graph`, error: " + v1.value0.shortMessage]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Purs (line 129, column 39 - line 135, column 71): " + [v1.constructor.name]);
        });
      });
    });
  };
};
var getPurs = /* @__PURE__ */ bind50(/* @__PURE__ */ getExecutable("purs"))(parseVersionOutput);
var docs = function(globs) {
  return function(format2) {
    return bind50(ask8)(function(v) {
      var args = append34(["docs", "--format", printDocsFormat(format2)])(toUnfoldable21(globs));
      return exec7(v.purs.cmd)(args)({
        cwd: defaultExecOptions.cwd,
        pipeStdout: true,
        pipeStderr: true,
        pipeStdin: StdinPipeParent.value
      });
    });
  };
};
var compile = function(globs) {
  return function(pursArgs2) {
    return bind50(ask8)(function(v) {
      var args = append34(["compile"])(append34(pursArgs2)(toUnfoldable21(globs)));
      return discard28(logDebug15(["Running command:", "purs " + joinWith(" ")(args)]))(function() {
        return exec7(v.purs.cmd)(args)({
          pipeStdin: defaultExecOptions.pipeStdin,
          pipeStderr: defaultExecOptions.pipeStderr,
          cwd: defaultExecOptions.cwd,
          pipeStdout: false
        });
      });
    });
  };
};

// output/Spago.Psa/index.js
var mapFlipped14 = /* @__PURE__ */ mapFlipped(functorNonEmptyArray);
var discard29 = /* @__PURE__ */ discard(discardUnit);
var discard113 = /* @__PURE__ */ discard29(bindMaybe);
var guard14 = /* @__PURE__ */ guard(alternativeMaybe);
var pure62 = /* @__PURE__ */ pure(applicativeMaybe);
var alt25 = /* @__PURE__ */ alt(altMaybe);
var bind120 = /* @__PURE__ */ bind(bindMaybe);
var mapFlipped15 = /* @__PURE__ */ mapFlipped(functorArray);
var foldMap19 = /* @__PURE__ */ foldMap(foldableArray)(/* @__PURE__ */ monoidSet(ordPackageName));
var map78 = /* @__PURE__ */ map(functorArray);
var toUnfoldable24 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var filterKeys3 = /* @__PURE__ */ filterKeys(ordPackageName);
var member9 = /* @__PURE__ */ member2(ordPackageName);
var append35 = /* @__PURE__ */ append(semigroupArray);
var pure214 = /* @__PURE__ */ pure(applicativeSpago);
var bind215 = /* @__PURE__ */ bind(bindSpago);
var $$try8 = /* @__PURE__ */ $$try2(monadErrorErrorSpago);
var liftEffect9 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var map132 = /* @__PURE__ */ map(functorEffect);
var liftAff6 = /* @__PURE__ */ liftAff(monadAffSpago);
var map223 = /* @__PURE__ */ map(functorAff);
var discard210 = /* @__PURE__ */ discard29(bindSpago);
var forWithIndex4 = /* @__PURE__ */ forWithIndex(applicativeSpago)(traversableWithIndexArray);
var bind311 = /* @__PURE__ */ bind(bindEither);
var lmap16 = /* @__PURE__ */ lmap(bifunctorEither);
var logWarn6 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var intercalate13 = /* @__PURE__ */ intercalate2(monoidString);
var show38 = /* @__PURE__ */ show(showInt);
var identity30 = /* @__PURE__ */ identity(categoryFn);
var logSuccess3 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var logDebug8 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var prepareToDie2 = /* @__PURE__ */ prepareToDie(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var shouldPrintWarning = function(v) {
  if (v instanceof Nothing) {
    return function(v1) {
      return function(v2) {
        return true;
      };
    };
  }
  ;
  if (v instanceof Just) {
    if (v.value0 instanceof CensorAllWarnings) {
      return function(v1) {
        return function(v2) {
          return false;
        };
      };
    }
    ;
    if (v.value0 instanceof CensorSpecificWarnings) {
      var tests = mapFlipped14(v.value0.value0)(function(v1) {
        if (v1 instanceof ByCode) {
          return function(code3) {
            return function(v2) {
              return v1.value0 === code3;
            };
          };
        }
        ;
        if (v1 instanceof ByMessagePrefix) {
          return function(v2) {
            return function(msg) {
              return isJust(stripPrefix2(trim(v1.value0))(trim(msg)));
            };
          };
        }
        ;
        throw new Error("Failed pattern match at Spago.Psa (line 181, column 25 - line 183, column 130): " + [v1.constructor.name]);
      });
      return function(code3) {
        return function(msg) {
          return isNothing(find3(function(f) {
            return f(code3)(msg);
          })(tests));
        };
      };
    }
    ;
    throw new Error("Failed pattern match at Spago.Psa (line 177, column 13 - line 187, column 75): " + [v.value0.constructor.name]);
  }
  ;
  throw new Error("Failed pattern match at Spago.Psa (line 175, column 22 - line 187, column 75): " + [v.constructor.name]);
};
var toPathDecision = function(options) {
  return function(pathToFile) {
    return discard113(guard14(options.pathIsFromPackage(pathToFile)))(function() {
      return pure62({
        pathType: options.pathType,
        shouldPromoteWarningToError: options.strict,
        shouldShowError: shouldPrintWarning(options.censorWarnings)
      });
    });
  };
};
var toWorkspacePackagePathDecision = function(v) {
  return function __do3() {
    var pkgPath = resolve([])(v.selected.path)();
    var srcPath = concat3([pkgPath, "src"]);
    var testPath = concat3([pkgPath, "test"]);
    return [toPathDecision({
      pathIsFromPackage: function() {
        var $102 = stripPrefix2(srcPath);
        return function($103) {
          return isJust($102($103));
        };
      }(),
      pathType: IsSrc.value,
      strict: fromMaybe(false)(alt25(v.psaCliFlags.strict)(bind120(v["selected"]["package"].build)(function(v1) {
        return v1.strict;
      }))),
      censorWarnings: bind120(v["selected"]["package"].build)(function(v1) {
        return v1.censorProjectWarnings;
      })
    }), toPathDecision({
      pathIsFromPackage: function() {
        var $104 = stripPrefix2(testPath);
        return function($105) {
          return isJust($104($105));
        };
      }(),
      pathType: IsSrc.value,
      strict: fromMaybe(false)(alt25(v.psaCliFlags.strict)(bind120(v["selected"]["package"].test)(function(v1) {
        return v1.strict;
      }))),
      censorWarnings: bind120(v["selected"]["package"].test)(function(v1) {
        return v1.censorTestWarnings;
      })
    })];
  };
};
var toPathDecisions = function(v) {
  var toDependencyDecision = function(dep) {
    var v1 = snd(dep);
    if (v1 instanceof WorkspacePackage) {
      return toWorkspacePackagePathDecision({
        selected: v1.value0,
        psaCliFlags: v.psaCliFlags
      });
    }
    ;
    return function __do3() {
      var pkgLocation = resolve([])(uncurry(getPackageLocation)(dep))();
      return [toPathDecision({
        pathIsFromPackage: function() {
          var $106 = stripPrefix2(pkgLocation);
          return function($107) {
            return isJust($106($107));
          };
        }(),
        pathType: IsLib.value,
        strict: false,
        censorWarnings: v.censorLibWarnings
      })];
    };
  };
  var projectDecisions = mapFlipped15(v.selectedPackages)(function(selected) {
    return toWorkspacePackagePathDecision({
      selected,
      psaCliFlags: v.psaCliFlags
    });
  });
  var pkgsInProject = foldMap19(function(p) {
    return singleton11(p["package"].name);
  })(v.selectedPackages);
  var dependencyDecisions = map78(toDependencyDecision)(toUnfoldable24(filterKeys3(function(pkgName) {
    return !member9(pkgName)(pkgsInProject);
  })(v.allDependencies)));
  return append35(projectDecisions)(dependencyDecisions);
};
var psaCompile = function(globs) {
  return function(pursArgs2) {
    return function(psaArgs) {
      var isEmptySpan = function(filename) {
        return function(pos2) {
          return filename === "" || pos2.startLine === 0 && (pos2.endLine === 0 && (pos2.startColumn === 0 && pos2.endColumn === 0));
        };
      };
      var loadLines = function(files) {
        return function(filename) {
          return function(pos2) {
            if (isEmptySpan(filename)(pos2)) {
              return pure214(Nothing.value);
            }
            ;
            if (otherwise) {
              return bind215($$try8(bind215(liftEffect9(map132(lookup4(filename))(read(files))))(function(cache) {
                return bind215(function() {
                  if (cache instanceof Just) {
                    return pure214(cache.value0);
                  }
                  ;
                  if (cache instanceof Nothing) {
                    return bind215(liftAff6(map223(split("\n"))(readTextFile2(UTF8.value)(filename))))(function(lines8) {
                      return discard210(liftEffect9(modify_(insert4(filename)(lines8))(files)))(function() {
                        return pure214(lines8);
                      });
                    });
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Psa (line 84, column 13 - line 89, column 27): " + [cache.constructor.name]);
                }())(function(contents) {
                  var source2 = slice(pos2.startLine - 1 | 0)(pos2.endLine)(contents);
                  return pure214(new Just(source2));
                });
              })))(function(result) {
                return either($$const(pure214(Nothing.value)))(pure214)(result);
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Psa (line 78, column 3 - line 92, column 50): " + [files.constructor.name, filename.constructor.name, pos2.constructor.name]);
          };
        };
      };
      return bind215(compile(globs)(snoc(pursArgs2)("--json-errors")))(function(result) {
        var resultStdout = getStdout(result);
        return bind215(forWithIndex4(split("\n")(resultStdout))(function(idx) {
          return function(err) {
            var v = bind311(parse(err))(function() {
              var $108 = lmap16(print3);
              var $109 = decode2(psaResultCodec);
              return function($110) {
                return $108($109($110));
              };
            }());
            if (v instanceof Left) {
              return discard210(logWarn6(intercalate13("\n")(["Failed to decode PsaResult at index '" + (show38(idx) + ("': " + v.value0)), "Json was: " + err])))(function() {
                return pure214(true);
              });
            }
            ;
            if (v instanceof Right) {
              return bind215(liftEffect9($$new(empty6)))(function(files) {
                return bind215(buildOutput(loadLines(files))(psaArgs)(v.value0))(function(out$prime) {
                  return discard210(liftEffect9(function() {
                    if (psaArgs.jsonErrors) {
                      return printJsonOutputToOut(out$prime);
                    }
                    ;
                    return printDefaultOutputToErr(psaArgs)(out$prime);
                  }()))(function() {
                    return pure214(isEmpty3(out$prime.stats.allErrors));
                  });
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Psa (line 46, column 5 - line 61, column 47): " + [v.constructor.name]);
          };
        }))(function(arrErrorsIsEmpty) {
          var $99 = all2(identity30)(arrErrorsIsEmpty);
          if ($99) {
            return discard210(logSuccess3("Build succeeded."))(function() {
              return pure214(true);
            });
          }
          ;
          return discard210(function() {
            if (result instanceof Left) {
              return logDebug8(printExecResult(result.value0));
            }
            ;
            return pure214(unit);
          }())(function() {
            return discard210(prepareToDie2(["Failed to build."]))(function() {
              return pure214(false);
            });
          });
        });
      });
    };
  };
};
var defaultStatVerbosity = /* @__PURE__ */ function() {
  return CompactStats.value;
}();

// output/Spago.Purs.Graph/index.js
var map79 = /* @__PURE__ */ map(functorArray);
var toUnfoldable25 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var toDoc7 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc15 = /* @__PURE__ */ toDoc2(loggableString);
var append36 = /* @__PURE__ */ append(semigroupString);
var toDoc23 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableString));
var fromFoldable35 = /* @__PURE__ */ fromFoldable(foldableSet);
var toUnfoldable111 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var map133 = /* @__PURE__ */ map(functorSpago);
var lmap17 = /* @__PURE__ */ lmap(bifunctorEither);
var object7 = /* @__PURE__ */ object2();
var rowListCodecCons6 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var dependsIsSymbol = {
  reflectSymbol: function() {
    return "depends";
  }
};
var foldMap20 = /* @__PURE__ */ foldMap(foldableArray)(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "errors";
  }
})(monoidArray)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "fixes";
  }
})(monoidArray)()(monoidRecordNil))));
var append119 = /* @__PURE__ */ append(semigroupDoc);
var fold20 = /* @__PURE__ */ fold2(monoidDoc);
var intercalate14 = /* @__PURE__ */ intercalate2(monoidDoc);
var lines6 = /* @__PURE__ */ lines(foldableArray);
var liftAff7 = /* @__PURE__ */ liftAff(monadAffSpago);
var bind51 = /* @__PURE__ */ bind(bindSpago);
var ask9 = /* @__PURE__ */ ask(monadAskSpago);
var fromFoldable114 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableNonEmptyArray);
var map224 = /* @__PURE__ */ map(functorNonEmptyArray);
var union8 = /* @__PURE__ */ union2(ordPackageName);
var discard30 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug9 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var fromFoldable211 = /* @__PURE__ */ fromFoldable7(ordString)(foldableArray);
var fold110 = /* @__PURE__ */ fold2(monoidArray);
var $$for8 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var member10 = /* @__PURE__ */ member2(ordPackageName);
var traverse8 = /* @__PURE__ */ traverse(traversableArray)(applicativeSpago);
var pure63 = /* @__PURE__ */ pure(applicativeSpago);
var bind121 = /* @__PURE__ */ bind(bindMaybe);
var lookup13 = /* @__PURE__ */ lookup3(ordString);
var pure122 = /* @__PURE__ */ pure(applicativeMaybe);
var insert15 = /* @__PURE__ */ insert2(ordString);
var foldl9 = /* @__PURE__ */ foldl(foldableArray);
var map312 = /* @__PURE__ */ map(functorMaybe);
var filter8 = /* @__PURE__ */ filter5(ordPackageName);
var notEq8 = /* @__PURE__ */ notEq(eqPackageName);
var fromFoldable36 = /* @__PURE__ */ fromFoldable8(foldableArray);
var fromFoldable44 = /* @__PURE__ */ fromFoldable36(ordPackageName);
var filterKeys4 = /* @__PURE__ */ filterKeys(ordPackageName);
var notEq14 = /* @__PURE__ */ notEq(/* @__PURE__ */ eqEither(eqString)(eqPackageName));
var foldl14 = /* @__PURE__ */ foldl(foldableList);
var unionWith3 = /* @__PURE__ */ unionWith(ordPackageName);
var union1 = /* @__PURE__ */ union3(ordPackageName);
var map413 = /* @__PURE__ */ map(functorList);
var fromFoldable54 = /* @__PURE__ */ fromFoldable36(ordString);
var filterWithKey5 = /* @__PURE__ */ filterWithKey(ordString);
var member12 = /* @__PURE__ */ member2(ordString);
var eq36 = /* @__PURE__ */ eq(eqPackageName);
var alter4 = /* @__PURE__ */ alter(ordPackageName);
var alter1 = /* @__PURE__ */ alter(ordString);
var insert16 = /* @__PURE__ */ insert3(ordString);
var intersection5 = /* @__PURE__ */ intersection(ordPackageName);
var difference6 = /* @__PURE__ */ difference2(ordPackageName);
var runSpago4 = /* @__PURE__ */ runSpago(monadAffSpago);
var union22 = /* @__PURE__ */ union5();
var unwrap15 = /* @__PURE__ */ unwrap();
var mapMaybe5 = /* @__PURE__ */ mapMaybe3(ordPackageName);
var member22 = /* @__PURE__ */ member(ordPackageName);
var difference1 = /* @__PURE__ */ difference3(ordPackageName);
var unusedError = function(isTest) {
  return function(selected) {
    return function(unused) {
      var unusedPkgs = map79(print5)(toUnfoldable25(unused));
      return {
        errorMessage: toDoc7([toDoc15(function() {
          if (isTest) {
            return "Tests for package '";
          }
          ;
          return "Sources for package '";
        }() + (print5(selected["package"].name) + "' declares unused dependencies - please remove them from the project config:")), indent(toDoc23(map79(append36("- "))(unusedPkgs)))]),
        correction: toDoc15("spago uninstall -p " + (print5(selected["package"].name) + (function() {
          if (isTest) {
            return " --test-deps";
          }
          ;
          return "";
        }() + (" " + joinWith(" ")(unusedPkgs)))))
      };
    };
  };
};
var transitiveError = function(isTest) {
  return function(selected) {
    return function(transitive2) {
      return {
        errorMessage: toDoc7([toDoc15(function() {
          if (isTest) {
            return "Tests for package '";
          }
          ;
          return "Sources for package '";
        }() + (print5(selected["package"].name) + "' import the following transitive dependencies - please add them to the project dependencies, or remove the imports:")), indent(toDoc7(map79(function(v) {
          return toDoc7([toDoc15(print5(v.value0)), indent(toDoc7(map79(function(v1) {
            return toDoc7([toDoc15("from `" + (v1.value0 + "`, which imports:")), indent(toDoc23(fromFoldable35(v1.value1)))]);
          })(toUnfoldable111(v.value1))))]);
        })(toUnfoldable111(transitive2))))]),
        correction: toDoc15("spago install -p " + (print5(selected["package"].name) + (function() {
          if (isTest) {
            return " --test-deps";
          }
          ;
          return "";
        }() + (" " + joinWith(" ")(map79(print5)(toUnfoldable25(keys3(transitive2))))))))
      };
    };
  };
};
var toImportErrors = function(selected) {
  return function(opts) {
    return function(v) {
      return catMaybes([function() {
        var $145 = opts.reportSrc && !isEmpty2(v.unused);
        if ($145) {
          return new Just(unusedError(false)(selected)(v.unused));
        }
        ;
        return Nothing.value;
      }(), function() {
        var $146 = opts.reportSrc && !isEmpty(v.transitive);
        if ($146) {
          return new Just(transitiveError(false)(selected)(v.transitive));
        }
        ;
        return Nothing.value;
      }(), function() {
        var $147 = opts.reportTest && !isEmpty2(v.unusedTest);
        if ($147) {
          return new Just(unusedError(true)(selected)(v.unusedTest));
        }
        ;
        return Nothing.value;
      }(), function() {
        var $148 = opts.reportTest && !isEmpty(v.transitiveTest);
        if ($148) {
          return new Just(transitiveError(true)(selected)(v.transitiveTest));
        }
        ;
        return Nothing.value;
      }()]);
    };
  };
};
var runGraph = function(globs) {
  return function(pursArgs2) {
    var toErrorMessage = function() {
      var $207 = append36("Could not decode the output of `purs graph`, error: ");
      return function($208) {
        return $207(print3($208));
      };
    }();
    return map133(lmap17(toErrorMessage))(graph(globs)(pursArgs2));
  };
};
var packageGraphCodec = /* @__PURE__ */ packageMap(/* @__PURE__ */ named("PackageGraphNode")(/* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons6(dependsIsSymbol))({
  depends: /* @__PURE__ */ set(ordPackageName)(codec2)
})));
var moduleGraphWithPackageNodeCodec = /* @__PURE__ */ named("ModuleGraphNode")(/* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons6({
  reflectSymbol: function() {
    return "path";
  }
}))()()({
  reflectSymbol: function() {
    return "package";
  }
}))()()(dependsIsSymbol))({
  path: string,
  depends: /* @__PURE__ */ array(string),
  "package": codec2
}));
var moduleGraphCodec2 = /* @__PURE__ */ function() {
  return strMap(ordString)("ModuleGraphWithPackage")(Right.create)(identity(categoryFn))(moduleGraphWithPackageNodeCodec);
}();
var formatImportErrors = function(checkResults) {
  var separate2 = function(v2) {
    return {
      errors: [v2.errorMessage],
      fixes: [v2.correction]
    };
  };
  var v = foldMap20(separate2)(checkResults);
  var blankLine = append119($$break)($$break);
  return fold20([toDoc15("Found unused and/or undeclared transitive dependencies:"), blankLine, intercalate14(blankLine)(v.errors), blankLine, lines6([toDoc15("These errors can be fixed by running the below command(s):"), intercalate14($$break)(v.fixes)])]);
};
var compileGlob = function(sourcePath) {
  return liftAff7(gitignoringGlob(cwd2)([withForwardSlashes(sourcePath)]));
};
var getModuleGraphWithPackage = function(v) {
  return bind51(ask9)(function(v1) {
    var mkTestPackageEntry = function(p) {
      return new Tuple(print5(p["package"].name) + ":test", new WorkspacePackage(p));
    };
    var testPackages = fromFoldable114(map224(mkTestPackageEntry)(v1.selected));
    var mkPackageEntry = function(p) {
      return new Tuple(p["package"].name, new WorkspacePackage(p));
    };
    var allDependencies = toAllDependencies(v1.dependencies);
    var allPackages = union8(testPackages)(union8(fromFoldable114(map224(mkPackageEntry)(v1.selected)))(allDependencies));
    return discard30(logDebug9("Calling pathToPackage..."))(function() {
      return bind51(map133(function($209) {
        return fromFoldable211(fold110($209));
      })($$for8(toUnfoldable111(allPackages))(function(v2) {
        var withTestGlobs = function() {
          var $162 = member10(v2.value0)(keys3(testPackages));
          if ($162) {
            return OnlyTestGlobs.value;
          }
          ;
          return NoTestGlobs.value;
        }();
        return discard30(logDebug9("Getting globs for package " + print5(v2.value0)))(function() {
          return bind51(map133(fold110)(traverse8(compileGlob)(sourceGlob(withTestGlobs)(v2.value0)(v2.value1))))(function(v3) {
            return pure63(map79(function(p) {
              return new Tuple(p, v2.value0);
            })(v3));
          });
        });
      })))(function(v2) {
        return discard30(logDebug9("Got the pathToPackage map, calling packageGraph"))(function() {
          var addPackageInfo = function(pkgGraph) {
            return function(v3) {
              var newPath = withForwardSlashes(v3.value1.path);
              var newVal = bind121(lookup13(newPath)(v2))(function($$package2) {
                return pure122({
                  path: newPath,
                  depends: v3.value1.depends,
                  "package": $$package2
                });
              });
              return maybe(pkgGraph)(function(v4) {
                return insert15(v3.value0)(v4)(pkgGraph);
              })(newVal);
            };
          };
          var packageGraph = foldl9(addPackageInfo)(empty4)(toUnfoldable111(v));
          return pure63(packageGraph);
        });
      });
    });
  });
};
var getPackageGraph = function(graph2) {
  return bind51(getModuleGraphWithPackage(graph2))(function(moduleGraphWithPackage) {
    var moduleToPackage = function(moduleName3) {
      return map312(function(v) {
        return v["package"];
      })(lookup13(moduleName3)(moduleGraphWithPackage));
    };
    var moduleTupleToPackage = function(v) {
      return singleton10(v["package"])({
        depends: filter8(function(p) {
          return notEq8(p)(v["package"]);
        })(fromFoldable44(mapMaybe(moduleToPackage)(v.depends)))
      });
    };
    var packageGraph = filterKeys4(function(k) {
      return notEq14(new Right(k))(parse3("psci-support"));
    })(foldl14(unionWith3(function(v1) {
      return function(v2) {
        return {
          depends: union1(v1.depends)(v2.depends)
        };
      };
    }))(empty4)(map413(moduleTupleToPackage)(values(moduleGraphWithPackage))));
    return pure63(packageGraph);
  });
};
var checkImports = function(graph2) {
  var getUsedUnusedTransitiveFor = function(v) {
    var testPackageName = print5(v.packageName) + ":test";
    var testGlobOption = function() {
      if (v.isSrc) {
        return NoTestGlobs.value;
      }
      ;
      if (otherwise) {
        return OnlyTestGlobs.value;
      }
      ;
      throw new Error("Failed pattern match at Spago.Purs.Graph (line 229, column 7 - line 231, column 36): ");
    }();
    return bind51(map133(fromFoldable54)(map133(fold110)(traverse8(compileGlob)(sourceGlob(testGlobOption)(v.packageName)(new WorkspacePackage(v.selected))))))(function(v1) {
      var projectGraph = filterWithKey5(function(v2) {
        return function(v3) {
          return member12(v3.path)(v1);
        };
      })(v.packageGraph);
      var accumulateImported = function(importedPkgs$prime) {
        return function(v2) {
          var accumulateDep = function(importedPkgs) {
            return function(importedModule) {
              var v3 = lookup13(importedModule)(v.packageGraph);
              if (v3 instanceof Nothing) {
                return importedPkgs;
              }
              ;
              if (v3 instanceof Just && eq36(v3["value0"]["package"])(v.packageName)) {
                return importedPkgs;
              }
              ;
              if (v3 instanceof Just && eq36(v3["value0"]["package"])(testPackageName)) {
                return importedPkgs;
              }
              ;
              if (v3 instanceof Just) {
                return alter4(function(v4) {
                  if (v4 instanceof Nothing) {
                    return new Just(singleton10(v2.value0)(singleton11(importedModule)));
                  }
                  ;
                  if (v4 instanceof Just) {
                    return new Just(alter1(function(v5) {
                      if (v5 instanceof Nothing) {
                        return new Just(singleton11(importedModule));
                      }
                      ;
                      if (v5 instanceof Just) {
                        return new Just(insert16(importedModule)(v5.value0));
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Purs.Graph (line 254, column 23 - line 256, column 73): " + [v5.constructor.name]);
                    })(v2.value0)(v4.value0));
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Purs.Graph (line 251, column 17 - line 259, column 22): " + [v4.constructor.name]);
                })(v3["value0"]["package"])(importedPkgs);
              }
              ;
              throw new Error("Failed pattern match at Spago.Purs.Graph (line 245, column 55 - line 262, column 27): " + [v3.constructor.name]);
            };
          };
          return foldl9(accumulateDep)(importedPkgs$prime)(v2.value1.depends);
        };
      };
      var importedPackages = foldl9(accumulateImported)(empty4)(toUnfoldable111(projectGraph));
      return pure63({
        used: function() {
          if (v.isSrc) {
            return intersection5(v.dependencyPackages)(importedPackages);
          }
          ;
          return empty4;
        }(),
        unused: keys3(difference6(v.dependencyPackages)(importedPackages)),
        transitive: difference6(importedPackages)(v.dependencyPackages)
      });
    });
  };
  var differenceAll = function(sourceMap) {
    return function(removalsArray) {
      return foldl9(difference6)(sourceMap)(removalsArray);
    };
  };
  return bind51(ask9)(function(v) {
    return bind51(runSpago4(union22({
      selected: v.workspacePackages
    })(v))(getModuleGraphWithPackage(graph2)))(function(packageGraph) {
      return discard30(logDebug9("Got the package graph for package " + print5(v["selected"]["package"].name)))(function() {
        var srcDeps = unwrap15(v["selected"]["package"].dependencies);
        var dropValues = mapMaybe5($$const(new Just(empty4)));
        return bind51(getUsedUnusedTransitiveFor({
          selected: v.selected,
          packageName: v["selected"]["package"].name,
          dependencyPackages: dropValues(srcDeps),
          isSrc: true,
          packageGraph
        }))(function(srcResult) {
          var srcDepsUsed = filterKeys4(flip(member22)(srcResult.used))(srcDeps);
          return bind51(getUsedUnusedTransitiveFor({
            selected: v.selected,
            packageName: v["selected"]["package"].name,
            dependencyPackages: dropValues(unionWith3($$const)(srcDepsUsed)(maybe(empty4)(function($210) {
              return unwrap15(function(v1) {
                return v1.dependencies;
              }($210));
            })(v["selected"]["package"].test))),
            isSrc: false,
            packageGraph
          }))(function(testResult) {
            return pure63({
              unused: srcResult.unused,
              transitive: srcResult.transitive,
              unusedTest: difference1(testResult.unused)(keys3(srcResult.used)),
              transitiveTest: differenceAll(testResult.transitive)([srcResult.used, srcResult.transitive])
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Build/index.js
var bindFlipped11 = /* @__PURE__ */ bindFlipped(bindArray);
var partition4 = /* @__PURE__ */ partition3(filterableArray);
var toUnfoldable26 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var fromFoldable37 = /* @__PURE__ */ fromFoldable8(foldableArray)(ordString);
var append37 = /* @__PURE__ */ append(semigroupArray);
var discard31 = /* @__PURE__ */ discard(discardUnit);
var discard114 = /* @__PURE__ */ discard31(bindSpago);
var logInfo6 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var bind53 = /* @__PURE__ */ bind(bindSpago);
var ask10 = /* @__PURE__ */ ask(monadAskSpago);
var when14 = /* @__PURE__ */ when(applicativeSpago);
var loggableArray8 = /* @__PURE__ */ loggableArray(loggableString);
var die8 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableArray8);
var lookup14 = /* @__PURE__ */ lookup3(ordPackageName);
var union9 = /* @__PURE__ */ union2(ordPackageName);
var liftEffect10 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var sequence5 = /* @__PURE__ */ sequence(traversableArray)(applicativeEffect);
var join9 = /* @__PURE__ */ join(bindArray);
var pure64 = /* @__PURE__ */ pure(applicativeSpago);
var logDebug10 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var exec8 = /* @__PURE__ */ exec5(monadAffSpago);
var voidLeft8 = /* @__PURE__ */ voidLeft(functorSpago);
var prepareToDie3 = /* @__PURE__ */ prepareToDie(monadEffectSpago)(monadAskSpago);
var prepareToDie1 = /* @__PURE__ */ prepareToDie3(loggableArray8);
var logSuccess4 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var bind122 = /* @__PURE__ */ bind(bindMaybe);
var discard211 = /* @__PURE__ */ discard31(bindMaybe);
var guard15 = /* @__PURE__ */ guard(alternativeMaybe);
var pure123 = /* @__PURE__ */ pure(applicativeMaybe);
var prepareToDie22 = /* @__PURE__ */ prepareToDie3(loggableString);
var map80 = /* @__PURE__ */ map(functorSpago);
var fold21 = /* @__PURE__ */ fold2(monoidArray);
var $$for9 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var runSpago5 = /* @__PURE__ */ runSpago(monadAffSpago);
var union12 = /* @__PURE__ */ union5();
var prepareToDie32 = /* @__PURE__ */ prepareToDie3(loggableDocc);
var isWorkspacePackage = function(v) {
  if (v.value1 instanceof WorkspacePackage) {
    return true;
  }
  ;
  return false;
};
var getBuildGlobs = function(v) {
  var testGlobs = function() {
    if (v.withTests) {
      return WithTestGlobs.value;
    }
    ;
    if (!v.withTests) {
      return NoTestGlobs.value;
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 198, column 15 - line 200, column 25): " + [v.withTests.constructor.name]);
  }();
  var workspacePackageGlob = function(p) {
    return sourceGlob(testGlobs)(p["package"].name)(new WorkspacePackage(p));
  };
  var projectGlobs = function() {
    if (v.depsOnly) {
      return [];
    }
    ;
    if (!v.depsOnly) {
      return bindFlipped11(workspacePackageGlob)(toArray(v.selected));
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 192, column 18 - line 196, column 52): " + [v.depsOnly.constructor.name]);
  }();
  var v1 = partition4(isWorkspacePackage)(toUnfoldable26(v.dependencies));
  var monorepoPkgGlobs = function() {
    if (v.depsOnly) {
      return [];
    }
    ;
    if (otherwise) {
      return bindFlipped11(uncurry(sourceGlob(NoTestGlobs.value)))(v1.yes);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 208, column 3 - line 210, column 83): ");
  }();
  var dependencyGlobs = bindFlipped11(uncurry(sourceGlob(NoTestGlobs.value)))(v1.no);
  return fromFoldable37(append37(projectGlobs)(append37(monorepoPkgGlobs)(append37(dependencyGlobs)([buildInfoPath]))));
};
var run4 = function(opts) {
  return discard114(logInfo6("Building..."))(function() {
    return bind53(ask10)(function(v) {
      return discard114(writeBuildInfo)(function() {
        return discard114(when14(isJust(findFlag({
          flags: ["-o", "--output"],
          args: opts.pursArgs
        })))(die8(["Can't pass `--output` option directly to purs.", "Use the --output flag for Spago, or add it to your config file."])))(function() {
          var addOutputArgs = function(args) {
            if (v.workspace.buildOptions.output instanceof Nothing) {
              return args;
            }
            ;
            if (v.workspace.buildOptions.output instanceof Just) {
              return append37(args)(["--output", v.workspace.buildOptions.output.value0]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Build (line 65, column 26 - line 67, column 52): " + [v.workspace.buildOptions.output.constructor.name]);
          };
          return discard114(when14(isJust(findFlag({
            flags: ["--json-errors"],
            args: opts.pursArgs
          })))(die8(["Can't pass `--json-errors` option directly to purs.", "Use the --json-errors flag for Spago."])))(function() {
            return discard114(when14(isJust(findFlag({
              flags: ["-g", "--codegen"],
              args: opts.pursArgs
            })))(die8(["Can't pass the `--codegen` option to purs, Spago already does that for you.", "Remove the argument to make this error go away!"])))(function() {
              var args = append37(addOutputArgs(opts.pursArgs))(["--codegen", "corefn,docs" + function() {
                if (v.workspace.backend instanceof Nothing) {
                  return ",js,sourcemaps";
                }
                ;
                if (v.workspace.backend instanceof Just) {
                  return "";
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Build (line 93, column 26 - line 97, column 23): " + [v.workspace.backend.constructor.name]);
              }()]);
              var selectedPackages = function() {
                if (v.workspace.selected instanceof Just) {
                  return singleton4(v.workspace.selected.value0);
                }
                ;
                if (v.workspace.selected instanceof Nothing) {
                  return getWorkspacePackages(v.workspace.packageSet);
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Build (line 102, column 24 - line 104, column 66): " + [v.workspace.selected.constructor.name]);
              }();
              var allDependencies = toAllDependencies(v.dependencies);
              var globs = getBuildGlobs({
                dependencies: function() {
                  if (v.workspace.selected instanceof Just) {
                    var v1 = unsafeFromJust(lookup14(v["workspace"]["selected"]["value0"]["package"].name)(v.dependencies));
                    return union9(v1.core)(v1.test);
                  }
                  ;
                  if (v.workspace.selected instanceof Nothing) {
                    return allDependencies;
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Command.Build (line 106, column 23 - line 113, column 28): " + [v.workspace.selected.constructor.name]);
                }(),
                depsOnly: opts.depsOnly,
                withTests: true,
                selected: selectedPackages
              });
              return bind53(liftEffect10(sequence5(toPathDecisions({
                allDependencies,
                selectedPackages: toArray(selectedPackages),
                psaCliFlags: {
                  strict: v.strictWarnings,
                  statVerbosity: v.workspace.buildOptions.statVerbosity
                },
                censorLibWarnings: v.workspace.buildOptions.censorLibWarnings
              }))))(function(pathDecisions) {
                var psaArgs = {
                  color: v.logOptions.color,
                  jsonErrors: opts.jsonErrors,
                  decisions: join9(pathDecisions),
                  statVerbosity: fromMaybe(defaultStatVerbosity)(v.workspace.buildOptions.statVerbosity)
                };
                return bind53(psaCompile(globs)(args)(psaArgs))(function(built) {
                  return bind53(function() {
                    if (!built) {
                      return pure64(false);
                    }
                    ;
                    if (v.workspace.backend instanceof Nothing) {
                      return pure64(true);
                    }
                    ;
                    if (v.workspace.backend instanceof Just) {
                      return discard114(logInfo6('Compiling with backend "' + (v.workspace.backend.value0.cmd + '"')))(function() {
                        return discard114(logDebug10("Running command `" + (v.workspace.backend.value0.cmd + " build`")))(function() {
                          var moreBackendArgs = function() {
                            if (v.workspace.backend.value0.args instanceof Just && length(v.workspace.backend.value0.args.value0) > 0) {
                              return v.workspace.backend.value0.args.value0;
                            }
                            ;
                            return [];
                          }();
                          return bind53(exec8(v.workspace.backend.value0.cmd)(addOutputArgs(moreBackendArgs))(defaultExecOptions))(function(v1) {
                            if (v1 instanceof Left) {
                              return discard114(logDebug10(printExecResult(v1.value0)))(function() {
                                return voidLeft8(prepareToDie1(["Failed to build with backend " + v.workspace.backend.value0.cmd]))(false);
                              });
                            }
                            ;
                            if (v1 instanceof Right) {
                              return voidLeft8(logSuccess4("Backend build succeeded."))(true);
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Build (line 143, column 87 - line 148, column 56): " + [v1.constructor.name]);
                          });
                        });
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Build (line 133, column 19 - line 148, column 56): " + [v.workspace.backend.constructor.name]);
                  }())(function(backendBuilt) {
                    var $96 = !backendBuilt;
                    if ($96) {
                      return pure64(false);
                    }
                    ;
                    var pedanticPkgs = mapMaybe(function(p) {
                      var reportSrc = v.pedanticPackages || fromMaybe(false)(bind122(p["package"].build)(function(v1) {
                        return v1.pedanticPackages;
                      }));
                      var reportTest = v.pedanticPackages || fromMaybe(false)(bind122(p["package"].test)(function(v1) {
                        return v1.pedanticPackages;
                      }));
                      return discard211(guard15(reportSrc || reportTest))(function() {
                        return pure123(new Tuple(p, {
                          reportSrc,
                          reportTest
                        }));
                      });
                    })(toArray(selectedPackages));
                    var $97 = $$null(pedanticPkgs) || opts.depsOnly;
                    if ($97) {
                      return pure64(true);
                    }
                    ;
                    return discard114(logInfo6("Looking for unused and undeclared transitive dependencies..."))(function() {
                      return bind53(runGraph(globs)(opts.pursArgs))(function(eitherGraph) {
                        return discard114(logDebug10("Decoded the output of `purs graph` successfully. Analyzing dependencies..."))(function() {
                          return either(function($107) {
                            return function(v1) {
                              return voidLeft8(v1)(false);
                            }(prepareToDie22($107));
                          })(function(graph2) {
                            return bind53(ask10)(function(env3) {
                              return bind53(map80(fold21)($$for9(pedanticPkgs)(function(v1) {
                                return discard114(logDebug10("Checking imports for " + print5(v1["value0"]["package"].name)))(function() {
                                  return map80(toImportErrors(v1.value0)(v1.value1))(runSpago5(union12({
                                    selected: v1.value0,
                                    workspacePackages: selectedPackages
                                  })(env3))(checkImports(graph2)));
                                });
                              })))(function(checkResults) {
                                return discard114(logDebug10("Finished checking imports."))(function() {
                                  var $101 = $$null(checkResults);
                                  if ($101) {
                                    return pure64(true);
                                  }
                                  ;
                                  return voidLeft8(prepareToDie32(formatImportErrors(checkResults)))(false);
                                });
                              });
                            });
                          })(eitherGraph);
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Bundle/index.js
var bind54 = /* @__PURE__ */ bind(bindSpago);
var exists8 = /* @__PURE__ */ exists2(monadEffectSpago);
var pure65 = /* @__PURE__ */ pure(applicativeSpago);
var mapFlipped16 = /* @__PURE__ */ mapFlipped(functorSpago);
var readTextFile7 = /* @__PURE__ */ readTextFile4(monadAffSpago);
var not12 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean)));
var discard34 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug11 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var showArray2 = /* @__PURE__ */ showArray(showString);
var show39 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "extraArgs";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "force";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "minify";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "module";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "outfile";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "platform";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "sourceMaps";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "type";
  }
})(showBundleType))(showBoolean))(showBundlePlatform))(showString))(showString))(showBoolean))(showBoolean))(showArray2)));
var fold22 = /* @__PURE__ */ fold2(monoidString);
var fold111 = /* @__PURE__ */ fold2(monoidArray);
var show116 = /* @__PURE__ */ show(showBundlePlatform);
var whenM3 = /* @__PURE__ */ whenM(monadSpago);
var unless7 = /* @__PURE__ */ unless(applicativeSpago);
var die9 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var logInfo7 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var show213 = /* @__PURE__ */ show(showArray2);
var exec9 = /* @__PURE__ */ exec5(monadAffSpago);
var logSuccess5 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var nodeTargetPolyfill = /* @__PURE__ */ joinWith(";")(["import __module from 'module'", "import __path from 'path'", "import __url from 'url'", "const require = __module.createRequire(import.meta.url)", "const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url))", "const __filename=new URL(import.meta.url).pathname"]);
var checkWatermarkMarkerFileName = ".check-bundle-watermark";
var bundleWatermarkPrefix = "/* Generated by Spago v";
var isNotSpagoGeneratedFile = function(path14) {
  return bind54(exists8(path14))(function(exists13) {
    var $74 = !exists13;
    if ($74) {
      return pure65(false);
    }
    ;
    return mapFlipped16(readTextFile7(path14))(function() {
      var $92 = all2(not12(startsWith2)(bundleWatermarkPrefix));
      var $93 = take(2);
      var $94 = split("\n");
      return function($95) {
        return $92($93($94($95)));
      };
    }());
  });
};
var run5 = /* @__PURE__ */ bind54(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  return discard34(logDebug11("Bundle options: " + show39(v.bundleOptions)))(function() {
    var sourceMap = function() {
      if (v.bundleOptions.sourceMaps) {
        return ["--sourcemap"];
      }
      ;
      return [];
    }();
    var output8 = fromMaybe("output")(v.workspace.buildOptions.output);
    var outfile2 = concat3([v.selected.path, v.bundleOptions.outfile]);
    var onlyForNode = function(s) {
      if (v.bundleOptions.platform instanceof BundleNode) {
        return s;
      }
      ;
      if (v.bundleOptions.platform instanceof BundleBrowser) {
        return "";
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Bundle (line 56, column 21 - line 58, column 26): " + [v.bundleOptions.platform.constructor.name]);
    };
    var minify2 = function() {
      if (v.bundleOptions.minify) {
        return ["--minify"];
      }
      ;
      return [];
    }();
    var mainPath = withForwardSlashes(concat3([output8, v.bundleOptions.module, "index.js"]));
    var format2 = function() {
      if (v.bundleOptions.platform instanceof BundleBrowser && v.bundleOptions.type instanceof BundleApp) {
        return "--format=iife";
      }
      ;
      return "--format=esm";
    }();
    var v1 = function() {
      if (v.bundleOptions.type instanceof BundleApp) {
        return {
          entrypoint: [],
          input: new StdinWrite(fold22([onlyForNode("#!/usr/bin/env node\n\n"), "import { main } from './", mainPath, "';main();"]))
        };
      }
      ;
      if (v.bundleOptions.type instanceof BundleModule) {
        return {
          entrypoint: [mainPath],
          input: StdinNewPipe.value
        };
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Bundle (line 64, column 29 - line 72, column 10): " + [v.bundleOptions.type.constructor.name]);
    }();
    var execOptions = {
      cwd: defaultExecOptions.cwd,
      pipeStderr: defaultExecOptions.pipeStderr,
      pipeStdout: defaultExecOptions.pipeStdout,
      pipeStdin: v1.input
    };
    var banner = fold22([bundleWatermarkPrefix, packages2["spago-bin"], " */", onlyForNode(nodeTargetPolyfill)]);
    var args = fold111([["--bundle", "--outfile=" + outfile2, "--platform=" + show116(v.bundleOptions.platform), "--banner:js=" + banner, "--loader:.node=file", format2], v.bundleOptions.extraArgs, minify2, sourceMap, v1.entrypoint]);
    return discard34(whenM3(exists8(checkWatermarkMarkerFileName))(unless7(v.bundleOptions.force)(whenM3(isNotSpagoGeneratedFile(outfile2))(die9(["Target file " + (v.bundleOptions.outfile + " was not previously generated by Spago. Use --force to overwrite anyway.")])))))(function() {
      return discard34(logInfo7("Bundling..."))(function() {
        return discard34(logDebug11("Running esbuild: " + show213(args)))(function() {
          return bind54(exec9(v.esbuild.cmd)(args)(execOptions))(function(v2) {
            if (v2 instanceof Right) {
              return logSuccess5("Bundle succeeded.");
            }
            ;
            if (v2 instanceof Left) {
              return discard34(logDebug11(printExecResult(v2.value0)))(function() {
                return die9(["Failed to bundle."]);
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Bundle (line 105, column 45 - line 109, column 34): " + [v2.constructor.name]);
          });
        });
      });
    });
  });
});

// node_modules/open/index.js
import process10 from "node:process";
import { Buffer as Buffer4 } from "node:buffer";
import path10 from "node:path";
import { fileURLToPath } from "node:url";
import childProcess from "node:child_process";
import fs15, { constants as fsConstants } from "node:fs/promises";

// node_modules/is-wsl/index.js
import process6 from "node:process";
import os3 from "node:os";
import fs14 from "node:fs";

// node_modules/is-inside-container/index.js
import fs13 from "node:fs";

// node_modules/is-docker/index.js
import fs12 from "node:fs";
var isDockerCached;
function hasDockerEnv() {
  try {
    fs12.statSync("/.dockerenv");
    return true;
  } catch {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs12.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch {
    return false;
  }
}
function isDocker() {
  if (isDockerCached === void 0) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup();
  }
  return isDockerCached;
}

// node_modules/is-inside-container/index.js
var cachedResult;
var hasContainerEnv = () => {
  try {
    fs13.statSync("/run/.containerenv");
    return true;
  } catch {
    return false;
  }
};
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}

// node_modules/is-wsl/index.js
var isWsl = () => {
  if (process6.platform !== "linux") {
    return false;
  }
  if (os3.release().toLowerCase().includes("microsoft")) {
    if (isInsideContainer()) {
      return false;
    }
    return true;
  }
  try {
    return fs14.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isInsideContainer() : false;
  } catch {
    return false;
  }
};
var is_wsl_default = process6.env.__IS_WSL_TEST__ ? isWsl : isWsl();

// node_modules/define-lazy-prop/index.js
function defineLazyProperty(object15, propertyName, valueGetter) {
  const define2 = (value4) => Object.defineProperty(object15, propertyName, { value: value4, enumerable: true, writable: true });
  Object.defineProperty(object15, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = valueGetter();
      define2(result);
      return result;
    },
    set(value4) {
      define2(value4);
    }
  });
  return object15;
}

// node_modules/default-browser/index.js
import { promisify as promisify4 } from "node:util";
import process9 from "node:process";
import { execFile as execFile8 } from "node:child_process";

// node_modules/default-browser-id/index.js
import { promisify } from "node:util";
import process7 from "node:process";
import { execFile as execFile5 } from "node:child_process";
var execFileAsync = promisify(execFile5);
async function defaultBrowserId() {
  if (process7.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const { stdout: stdout2 } = await execFileAsync("defaults", ["read", "com.apple.LaunchServices/com.apple.launchservices.secure", "LSHandlers"]);
  const match5 = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout2);
  return match5?.groups.id ?? "com.apple.Safari";
}

// node_modules/run-applescript/index.js
import process8 from "node:process";
import { promisify as promisify2 } from "node:util";
import { execFile as execFile6, execFileSync as execFileSync3 } from "node:child_process";
var execFileAsync2 = promisify2(execFile6);
async function runAppleScript(script, { humanReadableOutput = true } = {}) {
  if (process8.platform !== "darwin") {
    throw new Error("macOS only");
  }
  const outputArguments = humanReadableOutput ? [] : ["-ss"];
  const { stdout: stdout2 } = await execFileAsync2("osascript", ["-e", script, outputArguments]);
  return stdout2.trim();
}

// node_modules/bundle-name/index.js
async function bundleName(bundleId) {
  return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string
tell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}

// node_modules/default-browser/windows.js
import { promisify as promisify3 } from "node:util";
import { execFile as execFile7 } from "node:child_process";
var execFileAsync3 = promisify3(execFile7);
var windowsBrowserProgIds = {
  AppXq0fevzme2pys62n3e0fbqa7peapykr8v: { name: "Edge", id: "com.microsoft.edge.old" },
  MSEdgeDHTML: { name: "Edge", id: "com.microsoft.edge" },
  // On macOS, it's "com.microsoft.edgemac"
  MSEdgeHTM: { name: "Edge", id: "com.microsoft.edge" },
  // Newer Edge/Win10 releases
  "IE.HTTP": { name: "Internet Explorer", id: "com.microsoft.ie" },
  FirefoxURL: { name: "Firefox", id: "org.mozilla.firefox" },
  ChromeHTML: { name: "Chrome", id: "com.google.chrome" },
  BraveHTML: { name: "Brave", id: "com.brave.Browser" },
  BraveBHTML: { name: "Brave Beta", id: "com.brave.Browser.beta" },
  BraveSSHTM: { name: "Brave Nightly", id: "com.brave.Browser.nightly" }
};
var UnknownBrowserError = class extends Error {
};
async function defaultBrowser(_execFileAsync = execFileAsync3) {
  const { stdout: stdout2 } = await _execFileAsync("reg", [
    "QUERY",
    " HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice",
    "/v",
    "ProgId"
  ]);
  const match5 = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout2);
  if (!match5) {
    throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout2)}`);
  }
  const { id: id2 } = match5.groups;
  const browser = windowsBrowserProgIds[id2];
  if (!browser) {
    throw new UnknownBrowserError(`Unknown browser ID: ${id2}`);
  }
  return browser;
}

// node_modules/default-browser/index.js
var execFileAsync4 = promisify4(execFile8);
var titleize = (string8) => string8.toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x) => x.toUpperCase());
async function defaultBrowser2() {
  if (process9.platform === "darwin") {
    const id2 = await defaultBrowserId();
    const name5 = await bundleName(id2);
    return { name: name5, id: id2 };
  }
  if (process9.platform === "linux") {
    const { stdout: stdout2 } = await execFileAsync4("xdg-mime", ["query", "default", "x-scheme-handler/http"]);
    const id2 = stdout2.trim();
    const name5 = titleize(id2.replace(/.desktop$/, "").replace("-", " "));
    return { name: name5, id: id2 };
  }
  if (process9.platform === "win32") {
    return defaultBrowser();
  }
  throw new Error("Only macOS, Linux, and Windows are supported");
}

// node_modules/open/index.js
var __dirname2 = path10.dirname(fileURLToPath(import.meta.url));
var localXdgOpenPath = path10.join(__dirname2, "xdg-open");
var { platform: platform8, arch } = process10;
var getWslDrivesMountPoint = /* @__PURE__ */ (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs15.access(configFilePath, fsConstants.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs15.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var pTryEach = async (array2, mapper) => {
  let latestError;
  for (const item of array2) {
    try {
      return await mapper(item);
    } catch (error5) {
      latestError = error5;
    }
  }
  throw latestError;
};
var baseOpen = async (options) => {
  options = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options
  };
  if (Array.isArray(options.app)) {
    return pTryEach(options.app, (singleApp) => baseOpen({
      ...options,
      app: singleApp
    }));
  }
  let { name: app, arguments: appArguments = [] } = options.app ?? {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return pTryEach(app, (appName) => baseOpen({
      ...options,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  }
  if (app === "browser" || app === "browserPrivate") {
    const ids = {
      "com.google.chrome": "chrome",
      "google-chrome.desktop": "chrome",
      "org.mozilla.firefox": "firefox",
      "firefox.desktop": "firefox",
      "com.microsoft.msedge": "edge",
      "com.microsoft.edge": "edge",
      "microsoft-edge.desktop": "edge"
    };
    const flags = {
      chrome: "--incognito",
      firefox: "--private-window",
      edge: "--inPrivate"
    };
    const browser = await defaultBrowser2();
    if (browser.id in ids) {
      const browserName = ids[browser.id];
      if (app === "browserPrivate") {
        appArguments.push(flags[browserName]);
      }
      return baseOpen({
        ...options,
        app: {
          name: apps[browserName],
          arguments: appArguments
        }
      });
    }
    throw new Error(`${browser.name} is not supported as a default browser`);
  }
  let command2;
  const cliArguments = [];
  const childProcessOptions = {};
  if (platform8 === "darwin") {
    command2 = "open";
    if (options.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options.background) {
      cliArguments.push("--background");
    }
    if (options.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform8 === "win32" || is_wsl_default && !isInsideContainer() && !app) {
    const mountPoint = await getWslDrivesMountPoint();
    command2 = is_wsl_default ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process10.env.SYSTEMROOT || process10.env.windir || "C:\\Windows"}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
    cliArguments.push(
      "-NoProfile",
      "-NonInteractive",
      "-ExecutionPolicy",
      "Bypass",
      "-EncodedCommand"
    );
    if (!is_wsl_default) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    const encodedArguments = ["Start"];
    if (options.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(`"\`"${app}\`""`);
      if (options.target) {
        appArguments.push(options.target);
      }
    } else if (options.target) {
      encodedArguments.push(`"${options.target}"`);
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((argument2) => `"\`"${argument2}\`""`);
      encodedArguments.push("-ArgumentList", appArguments.join(","));
    }
    options.target = Buffer4.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app) {
      command2 = app;
    } else {
      const isBundled = !__dirname2 || __dirname2 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs15.access(localXdgOpenPath, fsConstants.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process10.versions.electron ?? (platform8 === "android" || isBundled || !exeLocalXdgOpen);
      command2 = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (platform8 === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  if (options.target) {
    cliArguments.push(options.target);
  }
  const subprocess = childProcess.spawn(command2, cliArguments, childProcessOptions);
  if (options.wait) {
    return new Promise((resolve3, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode2) => {
        if (!options.allowNonzeroExitCode && exitCode2 > 0) {
          reject(new Error(`Exited with code ${exitCode2}`));
          return;
        }
        resolve3(subprocess);
      });
    });
  }
  subprocess.unref();
  return subprocess;
};
var open2 = (target, options) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options,
    target
  });
};
function detectArchBinary(binary) {
  if (typeof binary === "string" || Array.isArray(binary)) {
    return binary;
  }
  const { [arch]: archBinary } = binary;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform8]: platformBinary }, { wsl }) {
  if (wsl && is_wsl_default) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform8} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
defineLazyProperty(apps, "browser", () => "browser");
defineLazyProperty(apps, "browserPrivate", () => "browserPrivate");
var open_default = open2;

// output/Spago.Command.Docs/foreign.js
var openImpl = open_default;

// output/Control.Promise/foreign.js
function thenImpl(promise2) {
  return function(errCB) {
    return function(succCB) {
      return function() {
        promise2.then(succCB, errCB);
      };
    };
  };
}

// output/Control.Promise/index.js
var voidRight6 = /* @__PURE__ */ voidRight(functorEffect);
var mempty26 = /* @__PURE__ */ mempty(monoidCanceler);
var identity31 = /* @__PURE__ */ identity(categoryFn);
var alt26 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var unsafeReadTagged3 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
var map81 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var readString3 = /* @__PURE__ */ readString2(monadIdentity);
var bind55 = /* @__PURE__ */ bind(bindAff);
var liftEffect11 = /* @__PURE__ */ liftEffect(monadEffectAff);
var toAff$prime = function(customCoerce) {
  return function(p) {
    return makeAff(function(cb) {
      return voidRight6(mempty26)(thenImpl(p)(function($14) {
        return cb(Left.create(customCoerce($14)))();
      })(function($15) {
        return cb(Right.create($15))();
      }));
    });
  };
};
var coerce10 = function(fn) {
  return either(function(v) {
    return error("Promise failed, couldn't extract JS Error or String");
  })(identity31)(runExcept(alt26(unsafeReadTagged3("Error")(fn))(map81(error)(readString3(fn)))));
};
var toAff4 = /* @__PURE__ */ toAff$prime(coerce10);
var toAffE = function(f) {
  return bind55(liftEffect11(f))(toAff4);
};

// output/Data.Variant/index.js
var onMatch = function() {
  return function() {
    return function() {
      return function(r) {
        return function(k) {
          return function(v) {
            if (unsafeHas(v.type)(r)) {
              return unsafeGet(v.type)(r)(v.value);
            }
            ;
            return k(v);
          };
        };
      };
    };
  };
};
var onMatch1 = /* @__PURE__ */ onMatch()()();
var on3 = function() {
  return function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return function(p) {
      return function(f) {
        return function(g) {
          return function(r) {
            if (r.type === reflectSymbol2(p)) {
              return f(r.value);
            }
            ;
            return g(r);
          };
        };
      };
    };
  };
};
var inj = function() {
  return function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    return function(p) {
      return function(value4) {
        return {
          type: reflectSymbol2(p),
          value: value4
        };
      };
    };
  };
};
var case_ = function(r) {
  return unsafeCrashWith("Data.Variant: pattern match failure [" + (r.type + "]"));
};
var match2 = function() {
  return function() {
    return function() {
      return function(r) {
        return onMatch1(r)(case_);
      };
    };
  };
};

// output/Data.Codec.JSON.Variant/index.js
var on4 = /* @__PURE__ */ on3();
var map83 = /* @__PURE__ */ map(functorMaybe);
var voidLeft9 = /* @__PURE__ */ voidLeft(functorTuple);
var bind56 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadIdentity));
var pure66 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
var inj2 = /* @__PURE__ */ inj();
var map134 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var from3 = /* @__PURE__ */ from2(refl);
var except7 = /* @__PURE__ */ except(applicativeIdentity);
var variantCodec = function(dict) {
  return dict.variantCodec;
};
var variantMatch = function() {
  return function(dictVariantCodec) {
    return variantCodec(dictVariantCodec)($$Proxy.value);
  };
};
var variantCase = function(dictIsSymbol) {
  var on1 = on4(dictIsSymbol);
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  var inj1 = inj2(dictIsSymbol);
  return function() {
    return function(proxy) {
      return function(eacodec) {
        return function(v) {
          var enc$prime = function(v1) {
            return on1(proxy)(function(v$prime) {
              return flip(Tuple.create)(v1)(encode(jobject)(fromEntries(catMaybes([new Just(new Tuple("tag", encode(string)(reflectSymbol2(proxy)))), map83(function() {
                var $43 = Tuple.create("value");
                var $44 = flip(encode)(v$prime);
                return function($45) {
                  return $43($44($45));
                };
              }())(hush(eacodec))]))));
            })(function(v$prime) {
              return voidLeft9(v.value1(v$prime))(v1);
            })(v1);
          };
          var dec$prime = function(j) {
            return bind56(decode(jobject)(j))(function(obj) {
              return bind56(decode(prop("tag")(string))(obj))(function(tag) {
                var $37 = tag === reflectSymbol2(proxy);
                if ($37) {
                  if (eacodec instanceof Left) {
                    return pure66(inj1(proxy)(eacodec.value0));
                  }
                  ;
                  if (eacodec instanceof Right) {
                    return bind56(decode(prop("value")(json))(obj))(function(value4) {
                      return map134(inj1(proxy))(decode(eacodec.value0)(value4));
                    });
                  }
                  ;
                  throw new Error("Failed pattern match at Data.Codec.JSON.Variant (line 107, column 7 - line 111, column 49): " + [eacodec.constructor.name]);
                }
                ;
                return map134(unsafeCoerce2)(v.value0(j));
              });
            });
          };
          return new Codec(dec$prime, enc$prime);
        };
      };
    };
  };
};
var variantCodecCons = function(dictVariantCodec) {
  var variantCodec1 = variantCodec(dictVariantCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get6 = get3(dictIsSymbol)();
        var variantCase1 = variantCase(dictIsSymbol)();
        return function(dictTypeEquals) {
          return {
            variantCodec: function(v) {
              return function(codecs) {
                var tail4 = variantCodec1($$Proxy.value)(codecs);
                var codec12 = from3(get6($$Proxy.value)(codecs));
                return variantCase1($$Proxy.value)(codec12)(tail4);
              };
            }
          };
        };
      };
    };
  };
};
var variant = /* @__PURE__ */ function() {
  return new Codec(function(v) {
    return except7(new Left(basic("Unexpected value")));
  }, case_);
}();
var variantCodecNil = {
  variantCodec: function(v) {
    return function(v1) {
      return variant;
    };
  }
};

// output/Codec.Json.Unidirectional.Value/index.js
var show40 = /* @__PURE__ */ show(showString);
var show117 = /* @__PURE__ */ show(showInt);
var foldMap21 = /* @__PURE__ */ foldMap(foldableNonEmptyList)(monoidString);
var power5 = /* @__PURE__ */ power(monoidString);
var foldMap110 = /* @__PURE__ */ foldMap(foldableList)(monoidString);
var lmap18 = /* @__PURE__ */ lmap(bifunctorEither);
var pure67 = /* @__PURE__ */ pure(applicativeEither);
var map84 = /* @__PURE__ */ map(functorFn);
var map135 = /* @__PURE__ */ map(functorEither);
var composeKleisli2 = /* @__PURE__ */ composeKleisli(bindEither);
var bind57 = /* @__PURE__ */ bind(bindEither);
var apply22 = /* @__PURE__ */ apply2(applyEither);
var toUnfoldable27 = /* @__PURE__ */ toUnfoldable7(unfoldableArray);
var traverse9 = /* @__PURE__ */ traverse(traversableArray)(applicativeEither);
var coerce11 = /* @__PURE__ */ coerce();
var traverseWithIndex12 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);
var top3 = /* @__PURE__ */ top(boundedInt);
var map225 = /* @__PURE__ */ map(functorMaybe);
var foldl10 = /* @__PURE__ */ foldl(foldableArray);
var append120 = /* @__PURE__ */ append(semigroupOrdering);
var compare9 = /* @__PURE__ */ compare(ordInt);
var compare16 = /* @__PURE__ */ compare(ordString);
var unwrap16 = /* @__PURE__ */ unwrap();
var map414 = /* @__PURE__ */ map(functorArray);
var voidRight7 = /* @__PURE__ */ voidRight(functorEither);
var AtKey2 = /* @__PURE__ */ function() {
  function AtKey3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtKey3.create = function(value0) {
    return function(value12) {
      return new AtKey3(value0, value12);
    };
  };
  return AtKey3;
}();
var AtIndex2 = /* @__PURE__ */ function() {
  function AtIndex3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtIndex3.create = function(value0) {
    return function(value12) {
      return new AtIndex3(value0, value12);
    };
  };
  return AtIndex3;
}();
var DecodeError2 = /* @__PURE__ */ function() {
  function DecodeError3(value0) {
    this.value0 = value0;
  }
  ;
  DecodeError3.create = function(value0) {
    return new DecodeError3(value0);
  };
  return DecodeError3;
}();
var AccumulateError = /* @__PURE__ */ function() {
  function AccumulateError2(value0) {
    this.value0 = value0;
  }
  ;
  AccumulateError2.create = function(value0) {
    return new AccumulateError2(value0);
  };
  return AccumulateError2;
}();
var unsafePrintDecodeError = function(applyIndent) {
  return function(indent3) {
    return function(sep3) {
      return function(acc) {
        return function(v) {
          if (v instanceof DecodeError2) {
            return acc + (" - " + v.value0);
          }
          ;
          if (v instanceof AtKey2) {
            return unsafePrintDecodeError(true)(indent3)(sep3)(acc + ("." + show40(v.value0)))(v.value1);
          }
          ;
          if (v instanceof AtIndex2) {
            return unsafePrintDecodeError(true)(indent3)(sep3)(acc + ("[" + (show117(v.value0) + "]")))(v.value1);
          }
          ;
          if (v instanceof AccumulateError) {
            if (applyIndent) {
              return acc + foldMap21(unsafePrintDecodeError(false)(indent3 + 1 | 0)(sep3)("\n" + power5(sep3)(indent3)))(v.value0);
            }
            ;
            if (otherwise) {
              return acc + (unsafePrintDecodeError(false)(indent3)(sep3)("")(head4(v.value0)) + foldMap110(unsafePrintDecodeError(false)(indent3)(sep3)("\n" + power5(sep3)(indent3 - 1 | 0)))(tail3(v.value0)));
            }
            ;
          }
          ;
          throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 271, column 53 - line 285, column 110): " + [v.constructor.name]);
        };
      };
    };
  };
};
var underKey = function(key) {
  return function(f) {
    return function(obj) {
      return lmap18(AtKey2.create(key))(function() {
        var v = lookup4(key)(obj);
        if (v instanceof Nothing) {
          return new Left(new DecodeError2("Missing key"));
        }
        ;
        if (v instanceof Just) {
          return f(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 577, column 39 - line 579, column 16): " + [v.constructor.name]);
      }());
    };
  };
};
var toString8 = function(json4) {
  return caseJson(function(v) {
    return new Left(new DecodeError2("Expected a value of type String but got Null"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type String but got Boolean"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type String but got Number"));
  })(pure67)(function(v) {
    return new Left(new DecodeError2("Expected a value of type String but got Array"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type String but got Object"));
  })(json4);
};
var toStatic = function(a) {
  return function(v, v1) {
    return pure67(a);
  };
};
var toRequiredRename = function(jsonLbl) {
  return function(f) {
    return function(lookupFn, v) {
      return lmap18(AtKey2.create(jsonLbl))(function() {
        var v1 = lookupFn(jsonLbl);
        if (v1 instanceof Nothing) {
          return new Left(new DecodeError2("Missing field"));
        }
        ;
        if (v1 instanceof Just) {
          return f(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 939, column 24 - line 941, column 20): " + [v1.constructor.name]);
      }());
    };
  };
};
var toRequired = function(f) {
  return function(lookupFn, recLabel) {
    return lmap18(AtKey2.create(recLabel))(function() {
      var v = lookupFn(recLabel);
      if (v instanceof Nothing) {
        return new Left(new DecodeError2("Missing field"));
      }
      ;
      if (v instanceof Just) {
        return f(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 927, column 25 - line 929, column 20): " + [v.constructor.name]);
    }());
  };
};
var toRecordObjNil = {
  toRecordObj: function(v) {
    return function(v1) {
      return function(v2) {
        return pure67({});
      };
    };
  }
};
var toRecordObj = function(dict) {
  return dict.toRecordObj;
};
var toOptionDefaultRename = function(jsonLbl) {
  return function(a) {
    return function(f) {
      return function(lookupFn, v) {
        var v1 = lookupFn(jsonLbl);
        if (v1 instanceof Nothing) {
          return pure67(a);
        }
        ;
        if (v1 instanceof Just) {
          return lmap18(AtKey2.create(jsonLbl))(f(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 972, column 3 - line 974, column 43): " + [v1.constructor.name]);
      };
    };
  };
};
var toOptionDefault = function(a) {
  return function(f) {
    return function(lookupFn, recLabel) {
      var v = lookupFn(recLabel);
      if (v instanceof Nothing) {
        return pure67(a);
      }
      ;
      if (v instanceof Just) {
        return lmap18(AtKey2.create(recLabel))(f(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 966, column 3 - line 968, column 44): " + [v.constructor.name]);
    };
  };
};
var toOption = function(f) {
  return toOptionDefault(Nothing.value)(map84(map135(Just.create))(f));
};
var toNumber3 = function(json4) {
  return caseJson(function(v) {
    return new Left(new DecodeError2("Expected a value of type Number but got Null"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Number but got Boolean"));
  })(pure67)(function(v) {
    return new Left(new DecodeError2("Expected a value of type Number but got String"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Number but got Array"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Number but got Object"));
  })(json4);
};
var toJObject2 = function(json4) {
  return caseJson(function(v) {
    return new Left(new DecodeError2("Expected a value of type Object but got Null"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Object but got Boolean"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Object but got Number"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Object but got String"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Object but got Array"));
  })(pure67)(json4);
};
var toObjSingleton = function(k) {
  return function(f) {
    return composeKleisli2(toJObject2)(function(j) {
      return underKey(k)(f)(j);
    });
  };
};
var toOptionAssocArray = function(k$prime) {
  return function(v$prime) {
    return function(lookupFn, recLabel) {
      var v = lookupFn(recLabel);
      if (v instanceof Nothing) {
        return pure67([]);
      }
      ;
      if (v instanceof Just) {
        return lmap18(AtKey2.create(recLabel))(bind57(map135(toUnfoldable27)(toJObject2(v.value0)))(traverse9(function(v1) {
          return lmap18(AtKey2.create(v1.value0))(apply22(map135(Tuple.create)(lmap18(function(v3) {
            if (v3 instanceof DecodeError2) {
              return new DecodeError2("while decoding the key " + (show40(v1.value0) + (" - " + v3.value0)));
            }
            ;
            return v3;
          })(k$prime(v1.value0))))(v$prime(v1.value1)));
        })));
      }
      ;
      throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 1004, column 3 - line 1016, column 8): " + [v.constructor.name]);
    };
  };
};
var toRecord2 = function() {
  return function(dictToRecordObj) {
    var toRecordObj1 = toRecordObj(dictToRecordObj);
    return function(codecs) {
      return composeKleisli2(toJObject2)(toRecordObj1($$Proxy.value)(codecs));
    };
  };
};
var toRecord1 = /* @__PURE__ */ toRecord2();
var toJNull = function(json4) {
  return caseJson(pure67)(function(v) {
    return new Left(new DecodeError2("Expected a value of type Null but got Boolean"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Null but got Number"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Null but got String"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Null but got Array"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Null but got Object"));
  })(json4);
};
var toJArray2 = function(json4) {
  return caseJson(function(v) {
    return new Left(new DecodeError2("Expected a value of type Array but got Null"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Array but got Boolean"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Array but got Number"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Array but got String"));
  })(pure67)(function(v) {
    return new Left(new DecodeError2("Expected a value of type Array but got Object"));
  })(json4);
};
var toInt = /* @__PURE__ */ composeKleisli2(toNumber3)(function(n) {
  return note(new DecodeError2("Could not convert Number to Int"))(fromNumber(n));
});
var toBoolean2 = function(json4) {
  return caseJson(function(v) {
    return new Left(new DecodeError2("Expected a value of type Boolean but got Null"));
  })(pure67)(function(v) {
    return new Left(new DecodeError2("Expected a value of type Boolean but got Number"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Boolean but got String"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Boolean but got Array"));
  })(function(v) {
    return new Left(new DecodeError2("Expected a value of type Boolean but got Object"));
  })(json4);
};
var toArray42 = function(a$prime) {
  return function(b$prime) {
    return function(c$prime) {
      return function(d$prime) {
        return function(x) {
          return composeKleisli2(toJArray2)(function(v) {
            if (v.length === 4) {
              return apply22(apply22(apply22(map135(x)(lmap18(AtIndex2.create(0))(a$prime(v[0]))))(lmap18(AtIndex2.create(1))(b$prime(v[1]))))(lmap18(AtIndex2.create(2))(c$prime(v[2]))))(lmap18(AtIndex2.create(3))(d$prime(v[3])));
            }
            ;
            return new Left(new DecodeError2("Expected array of length 4"));
          });
        };
      };
    };
  };
};
var toArray32 = function(a$prime) {
  return function(b$prime) {
    return function(c$prime) {
      return function(x) {
        return composeKleisli2(toJArray2)(function(v) {
          if (v.length === 3) {
            return apply22(apply22(map135(x)(lmap18(AtIndex2.create(0))(a$prime(v[0]))))(lmap18(AtIndex2.create(1))(b$prime(v[1]))))(lmap18(AtIndex2.create(2))(c$prime(v[2])));
          }
          ;
          return new Left(new DecodeError2("Expected array of length 3"));
        });
      };
    };
  };
};
var toArray22 = function(a$prime) {
  return function(b$prime) {
    return function(x) {
      return composeKleisli2(toJArray2)(function(v) {
        if (v.length === 2) {
          return apply22(map135(x)(lmap18(AtIndex2.create(0))(a$prime(v[0]))))(lmap18(AtIndex2.create(1))(b$prime(v[1])));
        }
        ;
        return new Left(new DecodeError2("Expected array of length 2"));
      });
    };
  };
};
var toTuple = function(toA) {
  return function(toB) {
    return toArray22(toA)(toB)(Tuple.create);
  };
};
var toArray5 = function(toElem) {
  return composeKleisli2(toJArray2)(traverseWithIndex12(function(i) {
    return function(j) {
      return lmap18(AtIndex2.create(i))(toElem(j));
    };
  }));
};
var toOptionArray = function(f) {
  return function(lookupFn, recLabel) {
    var v = lookupFn(recLabel);
    if (v instanceof Nothing) {
      return pure67([]);
    }
    ;
    if (v instanceof Just) {
      return lmap18(AtKey2.create(recLabel))(toArray5(f)(v.value0));
    }
    ;
    throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 988, column 3 - line 990, column 52): " + [v.constructor.name]);
  };
};
var printDecodeError = /* @__PURE__ */ unsafePrintDecodeError(true)(1)("  ")("ROOT");
var fromString8 = id;
var fromRequiredRename = function(str2) {
  return function(f) {
    return map84(function($379) {
      return Just.create(function(v) {
        return {
          key: new Just(str2),
          insertionOrder: Nothing.value,
          value: v
        };
      }($379));
    })(f);
  };
};
var fromRequired = function(f) {
  return map84(function($381) {
    return Just.create(function(v) {
      return {
        key: Nothing.value,
        insertionOrder: Nothing.value,
        value: v
      };
    }($381));
  })(f);
};
var fromRecordPropArrayNil = {
  fromRecordPropArray: function(v) {
    return function(v1) {
      return function(v2) {
        return [];
      };
    };
  }
};
var fromRecordPropArray = function(dict) {
  return dict.fromRecordPropArray;
};
var fromRecordPropArrayCons = function(dictFromRecordPropArray) {
  var fromRecordPropArray1 = fromRecordPropArray(dictFromRecordPropArray);
  return function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    var get6 = get3(dictIsSymbol)();
    return function() {
      return function() {
        return {
          fromRecordPropArray: function(v) {
            return function(codecs) {
              return function(values4) {
                var lbl = reflectSymbol2($$Proxy.value);
                var v1 = get6($$Proxy.value)(codecs);
                var a$prime = get6($$Proxy.value)(values4);
                var arr = fromRecordPropArray1($$Proxy.value)(codecs)(values4);
                var v2 = v1(a$prime);
                if (v2 instanceof Nothing) {
                  return arr;
                }
                ;
                if (v2 instanceof Just) {
                  return cons({
                    key: fromMaybe(lbl)(v2.value0.key),
                    insertionOrder: fromMaybe(top3)(v2.value0.insertionOrder),
                    value: v2.value0.value
                  })(arr);
                }
                ;
                throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 1079, column 5 - line 1081, column 124): " + [v2.constructor.name]);
              };
            };
          }
        };
      };
    };
  };
};
var fromOptionAssocArray = function(k$prime) {
  return function(v$prime) {
    return function(arr) {
      var $315 = length(arr) === 0;
      if ($315) {
        return Nothing.value;
      }
      ;
      return new Just(function(v) {
        return {
          key: Nothing.value,
          insertionOrder: Nothing.value,
          value: v
        };
      }(id(foldl2(function(acc) {
        return function(v) {
          return insert4(k$prime(v.value0))(v$prime(v.value1))(acc);
        };
      })(empty6)(arr))));
    };
  };
};
var fromOption = function(f) {
  return map225(function($385) {
    return function(v) {
      return {
        key: Nothing.value,
        insertionOrder: Nothing.value,
        value: v
      };
    }(f($385));
  });
};
var fromNumber3 = id;
var fromNullNothingOrJust = function(f) {
  return maybe(jsonNull)(f);
};
var fromJObject2 = id;
var fromObjSingleton = function(k) {
  return function(v) {
    return fromJObject2(singleton13(k)(v));
  };
};
var fromPropArray = /* @__PURE__ */ function() {
  var $394 = foldl2(function(acc) {
    return function(v) {
      return insert4(v.value0)(v.value1)(acc);
    };
  })(empty6);
  return function($395) {
    return fromJObject2($394($395));
  };
}();
var fromRecord2 = function() {
  return function(dictFromRecordPropArray) {
    var fromRecordPropArray1 = fromRecordPropArray(dictFromRecordPropArray);
    return function(codecs) {
      return function(values4) {
        return fromJObject2(flip(foldl10)(empty6)(function(acc) {
          return function(r) {
            return insert4(r.key)(r.value)(acc);
          };
        })(sortBy(function(l) {
          return function(r) {
            return append120(compare9(l.insertionOrder)(r.insertionOrder))(compare16(l.key)(r.key));
          };
        })(fromRecordPropArray1($$Proxy.value)(codecs)(values4))));
      };
    };
  };
};
var fromRecord1 = /* @__PURE__ */ fromRecord2();
var fromRecordN = function() {
  return function(dictFromRecordPropArray) {
    var fromRecord23 = fromRecord1(dictFromRecordPropArray);
    return function() {
      return function(v) {
        return function(codecs) {
          var $396 = fromRecord23(codecs);
          return function($397) {
            return $396(unwrap16($397));
          };
        };
      };
    };
  };
};
var fromJNull = jsonNull;
var fromJArray2 = id;
var fromInt2 = function($420) {
  return fromNumber3(toNumber($420));
};
var fromBoolean2 = id;
var fromArray42 = function(a) {
  return function(b) {
    return function(c) {
      return function(d) {
        return fromJArray2([a, b, c, d]);
      };
    };
  };
};
var fromArray32 = function(a) {
  return function(b) {
    return function(c) {
      return fromJArray2([a, b, c]);
    };
  };
};
var fromArray22 = function(a) {
  return function(b) {
    return fromJArray2([a, b]);
  };
};
var fromArray5 = function(fromA) {
  var $433 = map414(fromA);
  return function($434) {
    return fromJArray2($433($434));
  };
};
var fromOptionArray = function(f) {
  return function(arr) {
    var $335 = length(arr) === 0;
    if ($335) {
      return Nothing.value;
    }
    ;
    return new Just(function(v) {
      return {
        key: Nothing.value,
        insertionOrder: Nothing.value,
        value: v
      };
    }(fromArray5(f)(arr)));
  };
};
var coerce1 = function() {
  return function(v) {
    return coerce11;
  };
};
var coerce112 = /* @__PURE__ */ coerce1();
var toRecordN = function() {
  return function(dictToRecordObj) {
    var toRecord22 = toRecord1(dictToRecordObj);
    return function() {
      return function(f) {
        return function(codecs) {
          var $437 = coerce112(f);
          var $438 = toRecord22(codecs);
          return function($439) {
            return $437($438($439));
          };
        };
      };
    };
  };
};
var accumulateErrors = function(v) {
  return function(v1) {
    if (v instanceof AccumulateError) {
      return new AccumulateError(nelCons(v1)(v.value0));
    }
    ;
    return new AccumulateError(nelCons(v1)(singleton9(v)));
  };
};
var altAccumulate = function(f) {
  return function(g) {
    return function(j) {
      var v = f(j);
      if (v instanceof Right) {
        return v;
      }
      ;
      if (v instanceof Left) {
        var v1 = g(j);
        if (v1 instanceof Right) {
          return v1;
        }
        ;
        if (v1 instanceof Left) {
          return new Left(accumulateErrors(v.value0)(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 292, column 16 - line 294, column 45): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 290, column 23 - line 294, column 45): " + [v.constructor.name]);
    };
  };
};
var toEitherSingle = function(toLeft) {
  return function(toRight) {
    return altAccumulate(function() {
      var $440 = map135(Left.create);
      var $441 = toObjSingleton("Left")(toLeft);
      return function($442) {
        return $440($441($442));
      };
    }())(function() {
      var $443 = map135(Right.create);
      var $444 = toObjSingleton("Right")(toRight);
      return function($445) {
        return $443($444($445));
      };
    }());
  };
};
var toNullDefaultOrA = function(def) {
  return function(f) {
    return altAccumulate(function(j) {
      return voidRight7(def)(toJNull(j));
    })(f);
  };
};
var toNullNothingOrJust = function(f) {
  return toNullDefaultOrA(Nothing.value)(map84(map135(Just.create))(f));
};
var toRecordObjCons = function(dictToRecordObj) {
  var toRecordObj1 = toRecordObj(dictToRecordObj);
  return function(dictIsSymbol) {
    var reflectSymbol2 = reflectSymbol(dictIsSymbol);
    var get6 = get3(dictIsSymbol)();
    var insert22 = insert5(dictIsSymbol)()();
    return function() {
      return function() {
        return function() {
          return {
            toRecordObj: function(v) {
              return function(codecs) {
                return function(j) {
                  var onLeft = function(l) {
                    return function(f) {
                      if (l instanceof Left) {
                        return f(l.value0);
                      }
                      ;
                      if (l instanceof Right) {
                        return l;
                      }
                      ;
                      throw new Error("Failed pattern match at Codec.Json.Unidirectional.Value (line 1042, column 18 - line 1044, column 23): " + [l.constructor.name]);
                    };
                  };
                  var lbl = reflectSymbol2($$Proxy.value);
                  var v1 = get6($$Proxy.value)(codecs);
                  return bind57(onLeft(toRecordObj1($$Proxy.value)(codecs)(j))(function(e1) {
                    var v2 = v1(function(k) {
                      return lookup4(k)(j);
                    }, lbl);
                    if (v2 instanceof Left) {
                      return new Left(accumulateErrors(e1)(v2.value0));
                    }
                    ;
                    return new Left(e1);
                  }))(function(rec) {
                    return bind57(v1(function(k) {
                      return lookup4(k)(j);
                    }, lbl))(function(a) {
                      return pure67(insert22($$Proxy.value)(a)(rec));
                    });
                  });
                };
              };
            }
          };
        };
      };
    };
  };
};

// output/Docs.Search.JsonCodec/index.js
var inj3 = /* @__PURE__ */ inj();
var except8 = /* @__PURE__ */ except(applicativeIdentity);
var lmap19 = /* @__PURE__ */ lmap(bifunctorEither);
var inject = function() {
  return function(dictIsSymbol) {
    return inj3(dictIsSymbol)($$Proxy.value);
  };
};
var fromUni = function(fn) {
  var convertError = function($7) {
    return basic(printDecodeError($7));
  };
  var $8 = lmap19(convertError);
  return function($9) {
    return except8($8(fn($9)));
  };
};

// output/Language.PureScript.AST.SourcePos/index.js
var endIsSymbol = {
  reflectSymbol: function() {
    return "end";
  }
};
var nameIsSymbol = {
  reflectSymbol: function() {
    return "name";
  }
};
var startIsSymbol = {
  reflectSymbol: function() {
    return "start";
  }
};
var SourcePos = function(x) {
  return x;
};
var SourceSpan = function(x) {
  return x;
};
var toSourcePos = /* @__PURE__ */ toArray22(toInt)(toInt)(function(line2) {
  return function(column2) {
    return {
      line: line2,
      column: column2
    };
  };
});
var toSourceSpan = /* @__PURE__ */ toRecordN()(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(toRecordObjNil)(startIsSymbol)()()())(nameIsSymbol)()()())(endIsSymbol)()()())()(SourceSpan)({
  name: /* @__PURE__ */ toRequired(toString8),
  start: /* @__PURE__ */ toRequired(toSourcePos),
  end: /* @__PURE__ */ toRequired(toSourcePos)
});
var nullSourcePos = {
  line: 0,
  column: 0
};
var nullSourceSpan = {
  name: "",
  start: nullSourcePos,
  end: nullSourcePos
};
var nullSourceAnn = {
  span: nullSourceSpan,
  comments: []
};
var fromSourcePos = function(v) {
  return fromArray22(fromInt2(v.line))(fromInt2(v.column));
};

// output/Language.PureScript.Names/index.js
var compare10 = /* @__PURE__ */ compare(ordString);
var coerce12 = /* @__PURE__ */ coerce();
var map85 = /* @__PURE__ */ map(functorEither);
var pure68 = /* @__PURE__ */ pure(applicativeEither);
var unwrap17 = /* @__PURE__ */ unwrap();
var ModuleName = function(x) {
  return x;
};
var BySourcePos = /* @__PURE__ */ function() {
  function BySourcePos2(value0) {
    this.value0 = value0;
  }
  ;
  BySourcePos2.create = function(value0) {
    return new BySourcePos2(value0);
  };
  return BySourcePos2;
}();
var ByModuleName = /* @__PURE__ */ function() {
  function ByModuleName2(value0) {
    this.value0 = value0;
  }
  ;
  ByModuleName2.create = function(value0) {
    return new ByModuleName2(value0);
  };
  return ByModuleName2;
}();
var Qualified = /* @__PURE__ */ function() {
  function Qualified2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Qualified2.create = function(value0) {
    return function(value12) {
      return new Qualified2(value0, value12);
    };
  };
  return Qualified2;
}();
var RuntimeLazyFactory = /* @__PURE__ */ function() {
  function RuntimeLazyFactory2() {
  }
  ;
  RuntimeLazyFactory2.value = new RuntimeLazyFactory2();
  return RuntimeLazyFactory2;
}();
var Lazy = /* @__PURE__ */ function() {
  function Lazy2(value0) {
    this.value0 = value0;
  }
  ;
  Lazy2.create = function(value0) {
    return new Lazy2(value0);
  };
  return Lazy2;
}();
var Ident = /* @__PURE__ */ function() {
  function Ident2(value0) {
    this.value0 = value0;
  }
  ;
  Ident2.create = function(value0) {
    return new Ident2(value0);
  };
  return Ident2;
}();
var GenIdent = /* @__PURE__ */ function() {
  function GenIdent2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  GenIdent2.create = function(value0) {
    return function(value12) {
      return new GenIdent2(value0, value12);
    };
  };
  return GenIdent2;
}();
var UnusedIdent = /* @__PURE__ */ function() {
  function UnusedIdent2() {
  }
  ;
  UnusedIdent2.value = new UnusedIdent2();
  return UnusedIdent2;
}();
var InternalIdent = /* @__PURE__ */ function() {
  function InternalIdent2(value0) {
    this.value0 = value0;
  }
  ;
  InternalIdent2.create = function(value0) {
    return new InternalIdent2(value0);
  };
  return InternalIdent2;
}();
var eqModuleName = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordModuleName = {
  compare: function(x) {
    return function(y) {
      return compare10(x)(y);
    };
  },
  Eq0: function() {
    return eqModuleName;
  }
};
var toProperName = function($572) {
  return coerce12(toString8($572));
};
var toOpName = function($573) {
  return coerce12(toString8($573));
};
var toModuleName = /* @__PURE__ */ function() {
  var $574 = map85(function() {
    var $577 = wrap();
    var $578 = intercalate2(monoidString)(".");
    return function($579) {
      return $577($578($579));
    };
  }());
  var $575 = toArray5(toString8);
  return function($576) {
    return $574($575($576));
  };
}();
var toInternalIdentData = /* @__PURE__ */ function() {
  var runtimeLazy = toObjSingleton("RuntimeLazyFactory")($$const(pure68(RuntimeLazyFactory.value)));
  var lazyStr = toObjSingleton("Lazy")(function() {
    var $580 = map85(Lazy.create);
    return function($581) {
      return $580(toString8($581));
    };
  }());
  return altAccumulate(runtimeLazy)(lazyStr);
}();
var toIdent = /* @__PURE__ */ function() {
  var jUnusedIdent = toObjSingleton("UnusedIdent")($$const(pure68(UnusedIdent.value)));
  var jInternalIdent = toObjSingleton("InternalIdent")(function() {
    var $582 = map85(InternalIdent.create);
    return function($583) {
      return $582(toInternalIdentData($583));
    };
  }());
  var jIdent = toObjSingleton("Ident")(function() {
    var $584 = map85(Ident.create);
    return function($585) {
      return $584(toString8($585));
    };
  }());
  var jGenIdent = toObjSingleton("GenIdent")(toArray22(toNullNothingOrJust(toString8))(toInt)(GenIdent.create));
  return altAccumulate(altAccumulate(altAccumulate(jIdent)(jGenIdent))(jUnusedIdent))(jInternalIdent);
}();
var fromProperName = function($586) {
  return fromString8(unwrap17($586));
};
var fromOpName = function($587) {
  return fromString8(unwrap17($587));
};
var fromModuleName = /* @__PURE__ */ function() {
  var $588 = fromArray5(fromString8);
  var $589 = split(".");
  return function($590) {
    return $588($589(unwrap17($590)));
  };
}();
var fromQualifiedBy = function(v) {
  if (v instanceof ByModuleName) {
    return fromModuleName(v.value0);
  }
  ;
  if (v instanceof BySourcePos) {
    return fromSourcePos(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Language.PureScript.Names (line 173, column 19 - line 175, column 37): " + [v.constructor.name]);
};
var fromQualified = function(f) {
  return function(v) {
    return fromArray22(fromQualifiedBy(v.value0))(f(v.value1));
  };
};
var byNullSourcePos = /* @__PURE__ */ function() {
  return new BySourcePos({
    line: 0,
    column: 0
  });
}();
var toQualifiedBy = /* @__PURE__ */ function() {
  var bySourcePos = function(j) {
    return map85(BySourcePos.create)(toSourcePos(j));
  };
  var byModule = function(j) {
    return map85(ByModuleName.create)(toModuleName(j));
  };
  var byMaybeModuleName = toNullDefaultOrA(byNullSourcePos)(byModule);
  return altAccumulate(altAccumulate(byModule)(bySourcePos))(byMaybeModuleName);
}();
var toQualified = function(f) {
  return toArray22(toQualifiedBy)(f)(Qualified.create);
};

// output/Data.Bounded.Generic/index.js
var genericTopNoArguments = /* @__PURE__ */ function() {
  return {
    "genericTop'": NoArguments.value
  };
}();
var genericTop$prime = function(dict) {
  return dict["genericTop'"];
};
var genericTopConstructor = function(dictGenericTop) {
  return {
    "genericTop'": genericTop$prime(dictGenericTop)
  };
};
var genericTopSum = function(dictGenericTop) {
  return {
    "genericTop'": new Inr(genericTop$prime(dictGenericTop))
  };
};
var genericTop = function(dictGeneric) {
  var to2 = to(dictGeneric);
  return function(dictGenericTop) {
    return to2(genericTop$prime(dictGenericTop));
  };
};
var genericBottomNoArguments = /* @__PURE__ */ function() {
  return {
    "genericBottom'": NoArguments.value
  };
}();
var genericBottom$prime = function(dict) {
  return dict["genericBottom'"];
};
var genericBottomConstructor = function(dictGenericBottom) {
  return {
    "genericBottom'": genericBottom$prime(dictGenericBottom)
  };
};
var genericBottomSum = function(dictGenericBottom) {
  return {
    "genericBottom'": new Inl(genericBottom$prime(dictGenericBottom))
  };
};
var genericBottom = function(dictGeneric) {
  var to2 = to(dictGeneric);
  return function(dictGenericBottom) {
    return to2(genericBottom$prime(dictGenericBottom));
  };
};

// output/Data.Enum.Generic/index.js
var map86 = /* @__PURE__ */ map(functorMaybe);
var genericSucc$prime = function(dict) {
  return dict["genericSucc'"];
};
var genericSucc = function(dictGeneric) {
  var to2 = to(dictGeneric);
  var from4 = from(dictGeneric);
  return function(dictGenericEnum) {
    var $156 = map86(to2);
    var $157 = genericSucc$prime(dictGenericEnum);
    return function($158) {
      return $156($157(from4($158)));
    };
  };
};
var genericPred$prime = function(dict) {
  return dict["genericPred'"];
};
var genericPred = function(dictGeneric) {
  var to2 = to(dictGeneric);
  var from4 = from(dictGeneric);
  return function(dictGenericEnum) {
    var $159 = map86(to2);
    var $160 = genericPred$prime(dictGenericEnum);
    return function($161) {
      return $159($160(from4($161)));
    };
  };
};
var genericEnumSum = function(dictGenericEnum) {
  var genericPred$prime1 = genericPred$prime(dictGenericEnum);
  var genericSucc$prime1 = genericSucc$prime(dictGenericEnum);
  return function(dictGenericTop) {
    var genericTop$prime2 = genericTop$prime(dictGenericTop);
    return function(dictGenericEnum1) {
      var genericPred$prime2 = genericPred$prime(dictGenericEnum1);
      var genericSucc$prime2 = genericSucc$prime(dictGenericEnum1);
      return function(dictGenericBottom) {
        var genericBottom$prime2 = genericBottom$prime(dictGenericBottom);
        return {
          "genericPred'": function(v) {
            if (v instanceof Inl) {
              return map86(Inl.create)(genericPred$prime1(v.value0));
            }
            ;
            if (v instanceof Inr) {
              var v1 = genericPred$prime2(v.value0);
              if (v1 instanceof Nothing) {
                return new Just(new Inl(genericTop$prime2));
              }
              ;
              if (v1 instanceof Just) {
                return new Just(new Inr(v1.value0));
              }
              ;
              throw new Error("Failed pattern match at Data.Enum.Generic (line 30, column 14 - line 32, column 31): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Data.Enum.Generic (line 28, column 18 - line 32, column 31): " + [v.constructor.name]);
          },
          "genericSucc'": function(v) {
            if (v instanceof Inl) {
              var v1 = genericSucc$prime1(v.value0);
              if (v1 instanceof Nothing) {
                return new Just(new Inr(genericBottom$prime2));
              }
              ;
              if (v1 instanceof Just) {
                return new Just(new Inl(v1.value0));
              }
              ;
              throw new Error("Failed pattern match at Data.Enum.Generic (line 34, column 14 - line 36, column 31): " + [v1.constructor.name]);
            }
            ;
            if (v instanceof Inr) {
              return map86(Inr.create)(genericSucc$prime2(v.value0));
            }
            ;
            throw new Error("Failed pattern match at Data.Enum.Generic (line 33, column 18 - line 37, column 36): " + [v.constructor.name]);
          }
        };
      };
    };
  };
};
var genericEnumNoArguments = {
  "genericPred'": function(v) {
    return Nothing.value;
  },
  "genericSucc'": function(v) {
    return Nothing.value;
  }
};
var genericEnumConstructor = function(dictGenericEnum) {
  var genericPred$prime1 = genericPred$prime(dictGenericEnum);
  var genericSucc$prime1 = genericSucc$prime(dictGenericEnum);
  return {
    "genericPred'": function(v) {
      return map86(Constructor)(genericPred$prime1(v));
    },
    "genericSucc'": function(v) {
      return map86(Constructor)(genericSucc$prime1(v));
    }
  };
};

// output/Web.Bower.PackageMeta/index.js
var typeIsSymbol2 = {
  reflectSymbol: function() {
    return "type";
  }
};
var urlIsSymbol = {
  reflectSymbol: function() {
    return "url";
  }
};
var genericShowConstructor1 = /* @__PURE__ */ genericShowConstructor(genericShowArgsNoArguments);
var emailIsSymbol = {
  reflectSymbol: function() {
    return "email";
  }
};
var homepageIsSymbol = {
  reflectSymbol: function() {
    return "homepage";
  }
};
var nameIsSymbol2 = {
  reflectSymbol: function() {
    return "name";
  }
};
var authorsIsSymbol = {
  reflectSymbol: function() {
    return "authors";
  }
};
var dependenciesIsSymbol3 = {
  reflectSymbol: function() {
    return "dependencies";
  }
};
var descriptionIsSymbol = {
  reflectSymbol: function() {
    return "description";
  }
};
var devDependenciesIsSymbol = {
  reflectSymbol: function() {
    return "devDependencies";
  }
};
var ignoreIsSymbol = {
  reflectSymbol: function() {
    return "ignore";
  }
};
var keywordsIsSymbol = {
  reflectSymbol: function() {
    return "keywords";
  }
};
var licenceIsSymbol = {
  reflectSymbol: function() {
    return "licence";
  }
};
var mainIsSymbol2 = {
  reflectSymbol: function() {
    return "main";
  }
};
var moduleTypeIsSymbol = {
  reflectSymbol: function() {
    return "moduleType";
  }
};
var privateIsSymbol = {
  reflectSymbol: function() {
    return "private";
  }
};
var repositoryIsSymbol = {
  reflectSymbol: function() {
    return "repository";
  }
};
var resolutionsIsSymbol = {
  reflectSymbol: function() {
    return "resolutions";
  }
};
var compare11 = /* @__PURE__ */ compare(ordString);
var genericEnumConstructor2 = /* @__PURE__ */ genericEnumConstructor(genericEnumNoArguments);
var genericTopConstructor2 = /* @__PURE__ */ genericTopConstructor(genericTopNoArguments);
var genericEnumSum2 = /* @__PURE__ */ genericEnumSum(genericEnumConstructor2)(genericTopConstructor2);
var genericBottomConstructor2 = /* @__PURE__ */ genericBottomConstructor(genericBottomNoArguments);
var genericBottomSum2 = /* @__PURE__ */ genericBottomSum(genericBottomConstructor2);
var genericEnumSum1 = /* @__PURE__ */ genericEnumSum2(/* @__PURE__ */ genericEnumSum2(/* @__PURE__ */ genericEnumSum2(/* @__PURE__ */ genericEnumSum2(genericEnumConstructor2)(genericBottomConstructor2))(genericBottomSum2))(genericBottomSum2))(genericBottomSum2);
var coerce13 = /* @__PURE__ */ coerce();
var toRecordN2 = /* @__PURE__ */ toRecordN();
var toRecordObjCons2 = /* @__PURE__ */ toRecordObjCons(toRecordObjNil);
var composeKleisli3 = /* @__PURE__ */ composeKleisli(bindMaybe);
var foldr14 = /* @__PURE__ */ foldr(foldableList);
var composeKleisli1 = /* @__PURE__ */ composeKleisli(bindEither);
var fromFoldable38 = /* @__PURE__ */ fromFoldable6(foldableArray);
var pure69 = /* @__PURE__ */ pure(applicativeEither);
var intercalate15 = /* @__PURE__ */ intercalate(foldableList)(monoidString);
var toRecordN1 = /* @__PURE__ */ toRecordN2(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons2(nameIsSymbol2)()()())(homepageIsSymbol)()()())(emailIsSymbol)()()())();
var alt27 = /* @__PURE__ */ alt(altEither);
var applySecond6 = /* @__PURE__ */ applySecond(applyMaybe);
var traverse_5 = /* @__PURE__ */ traverse_(applicativeMaybe)(foldableArray);
var pure124 = /* @__PURE__ */ pure(applicativeMaybe);
var elem5 = /* @__PURE__ */ elem2(eqCodePoint);
var unwrap18 = /* @__PURE__ */ unwrap();
var fromRecordN2 = /* @__PURE__ */ fromRecordN();
var fromRecordPropArrayCons2 = /* @__PURE__ */ fromRecordPropArrayCons(fromRecordPropArrayNil);
var Repository = function(x) {
  return x;
};
var PackageName = function(x) {
  return x;
};
var Globals = /* @__PURE__ */ function() {
  function Globals2() {
  }
  ;
  Globals2.value = new Globals2();
  return Globals2;
}();
var AMD = /* @__PURE__ */ function() {
  function AMD2() {
  }
  ;
  AMD2.value = new AMD2();
  return AMD2;
}();
var Node3 = /* @__PURE__ */ function() {
  function Node4() {
  }
  ;
  Node4.value = new Node4();
  return Node4;
}();
var ES6 = /* @__PURE__ */ function() {
  function ES62() {
  }
  ;
  ES62.value = new ES62();
  return ES62;
}();
var YUI = /* @__PURE__ */ function() {
  function YUI2() {
  }
  ;
  YUI2.value = new YUI2();
  return YUI2;
}();
var Author = function(x) {
  return x;
};
var PackageMeta = function(x) {
  return x;
};
var genericModuleType_ = {
  to: function(x) {
    if (x instanceof Inl) {
      return Globals.value;
    }
    ;
    if (x instanceof Inr && x.value0 instanceof Inl) {
      return AMD.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && x.value0.value0 instanceof Inl)) {
      return Node3.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inl))) {
      return ES6.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inr))) {
      return YUI.value;
    }
    ;
    throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 214, column 1 - line 214, column 37): " + [x.constructor.name]);
  },
  from: function(x) {
    if (x instanceof Globals) {
      return new Inl(NoArguments.value);
    }
    ;
    if (x instanceof AMD) {
      return new Inr(new Inl(NoArguments.value));
    }
    ;
    if (x instanceof Node3) {
      return new Inr(new Inr(new Inl(NoArguments.value)));
    }
    ;
    if (x instanceof ES6) {
      return new Inr(new Inr(new Inr(new Inl(NoArguments.value))));
    }
    ;
    if (x instanceof YUI) {
      return new Inr(new Inr(new Inr(new Inr(NoArguments.value))));
    }
    ;
    throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 214, column 1 - line 214, column 37): " + [x.constructor.name]);
  }
};
var genericShow5 = /* @__PURE__ */ genericShow(genericModuleType_)(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor1({
  reflectSymbol: function() {
    return "Globals";
  }
}))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor1({
  reflectSymbol: function() {
    return "AMD";
  }
}))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor1({
  reflectSymbol: function() {
    return "Node";
  }
}))(/* @__PURE__ */ genericShowSum(/* @__PURE__ */ genericShowConstructor1({
  reflectSymbol: function() {
    return "ES6";
  }
}))(/* @__PURE__ */ genericShowConstructor1({
  reflectSymbol: function() {
    return "YUI";
  }
}))))));
var genericSucc2 = /* @__PURE__ */ genericSucc(genericModuleType_)(genericEnumSum1);
var genericPred2 = /* @__PURE__ */ genericPred(genericModuleType_)(genericEnumSum1);
var showModuleType = {
  show: function(x) {
    return genericShow5(x);
  }
};
var show41 = /* @__PURE__ */ show(showModuleType);
var eqPackageName2 = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordPackageName2 = {
  compare: function(x) {
    return function(y) {
      return compare11(x)(y);
    };
  },
  Eq0: function() {
    return eqPackageName2;
  }
};
var eqModuleType = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Globals && y instanceof Globals) {
        return true;
      }
      ;
      if (x instanceof AMD && y instanceof AMD) {
        return true;
      }
      ;
      if (x instanceof Node3 && y instanceof Node3) {
        return true;
      }
      ;
      if (x instanceof ES6 && y instanceof ES6) {
        return true;
      }
      ;
      if (x instanceof YUI && y instanceof YUI) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordModuleType = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Globals && y instanceof Globals) {
        return EQ.value;
      }
      ;
      if (x instanceof Globals) {
        return LT.value;
      }
      ;
      if (y instanceof Globals) {
        return GT.value;
      }
      ;
      if (x instanceof AMD && y instanceof AMD) {
        return EQ.value;
      }
      ;
      if (x instanceof AMD) {
        return LT.value;
      }
      ;
      if (y instanceof AMD) {
        return GT.value;
      }
      ;
      if (x instanceof Node3 && y instanceof Node3) {
        return EQ.value;
      }
      ;
      if (x instanceof Node3) {
        return LT.value;
      }
      ;
      if (y instanceof Node3) {
        return GT.value;
      }
      ;
      if (x instanceof ES6 && y instanceof ES6) {
        return EQ.value;
      }
      ;
      if (x instanceof ES6) {
        return LT.value;
      }
      ;
      if (y instanceof ES6) {
        return GT.value;
      }
      ;
      if (x instanceof YUI && y instanceof YUI) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqModuleType;
  }
};
var enumModuleType = {
  succ: function(x) {
    return genericSucc2(x);
  },
  pred: function(x) {
    return genericPred2(x);
  },
  Ord0: function() {
    return ordModuleType;
  }
};
var boundedModuleType = {
  bottom: /* @__PURE__ */ genericBottom(genericModuleType_)(genericBottomSum2),
  top: /* @__PURE__ */ genericTop(genericModuleType_)(/* @__PURE__ */ genericTopSum(/* @__PURE__ */ genericTopSum(/* @__PURE__ */ genericTopSum(/* @__PURE__ */ genericTopSum(genericTopConstructor2))))),
  Ord0: function() {
    return ordModuleType;
  }
};
var toVersionRange = function($779) {
  return coerce13(toString8($779));
};
var toVersion = function($780) {
  return coerce13(toString8($780));
};
var toRepository = /* @__PURE__ */ toRecordN2(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons2(urlIsSymbol)()()())(typeIsSymbol2)()()())()(Repository)({
  url: /* @__PURE__ */ toRequired(toString8),
  type: /* @__PURE__ */ toRequired(toString8)
});
var toAuthor = function(j) {
  var decodeAuthorString = function() {
    var stripWrapper = function(l) {
      return function(r) {
        return composeKleisli3(stripPrefix2(l))(stripSuffix(r));
      };
    };
    var takeDelim = function(l) {
      return function(r) {
        var go = function(v) {
          return function(v1) {
            if (v1.value0 instanceof Just) {
              return new Tuple(new Just(v1.value0.value0), new Cons(v, v1.value1));
            }
            ;
            if (v1.value0 instanceof Nothing) {
              var v2 = stripWrapper(l)(r)(v);
              if (v2 instanceof Just) {
                return new Tuple(new Just(v2.value0), v1.value1);
              }
              ;
              if (v2 instanceof Nothing) {
                return new Tuple(Nothing.value, new Cons(v, v1.value1));
              }
              ;
              throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 191, column 9 - line 193, column 53): " + [v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 188, column 7 - line 189, column 41): " + [v.constructor.name, v1.constructor.name]);
          };
        };
        return foldr14(go)(new Tuple(Nothing.value, Nil.value));
      };
    };
    return composeKleisli1(toString8)(function(str2) {
      var v = takeDelim("<")(">")(fromFoldable38(split(" ")(str2)));
      var v1 = takeDelim("(")(")")(v.value1);
      return pure69({
        name: intercalate15(" ")(v1.value1),
        email: v.value0,
        homepage: v1.value0
      });
    });
  }();
  var decodeAuthorObj = toRecordN1(Author)({
    name: toRequired(toString8),
    email: toOption(toString8),
    homepage: toOption(toString8)
  });
  return alt27(decodeAuthorString(j))(decodeAuthorObj(j));
};
var parsePackageName = /* @__PURE__ */ function() {
  var mkPackageName = function() {
    var validateWith = function(x) {
      return function(p) {
        if (p(x)) {
          return new Just(x);
        }
        ;
        if (otherwise) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Web.Bower.PackageMeta (line 131, column 5 - line 131, column 95): " + [x.constructor.name, p.constructor.name]);
      };
    };
    var validateAll = function(vs) {
      return function(x) {
        return applySecond6(traverse_5(validateWith(x))(vs))(pure124(fromCodePointArray(x)));
      };
    };
    var dashOrDot = toCodePointArray("-.");
    var validChar = function(c) {
      return isAscii(c) && (isLower(c) || (isDecDigit(c) || elem5(c)(dashOrDot)));
    };
    var validators = [function($781) {
      return !$$null($781);
    }, all2(validChar), function() {
      var $782 = maybe(false)(function(x) {
        return !elem5(x)(dashOrDot);
      });
      return function($783) {
        return $782(head($783));
      };
    }(), function() {
      var $784 = maybe(false)(function(x) {
        return !elem5(x)(dashOrDot);
      });
      return function($785) {
        return $784(last($785));
      };
    }(), function() {
      var $786 = contains("--");
      return function($787) {
        return !$786(fromCodePointArray($787));
      };
    }(), function() {
      var $788 = contains("..");
      return function($789) {
        return !$788(fromCodePointArray($789));
      };
    }(), function($790) {
      return function(v) {
        return v <= 50;
      }(length($790));
    }];
    var $791 = validateAll(validators);
    return function($792) {
      return $791(toCodePointArray($792));
    };
  }();
  return mkPackageName;
}();
var toPackageName = /* @__PURE__ */ composeKleisli1(toString8)(/* @__PURE__ */ function() {
  var $793 = note(new DecodeError2("Invalid package name"));
  return function($794) {
    return $793(parsePackageName($794));
  };
}());
var moduleTypes = /* @__PURE__ */ fromFoldable7(ordString)(foldableArray)(/* @__PURE__ */ map(functorArray)(function(t) {
  return new Tuple(toLower(show41(t)), t);
})(/* @__PURE__ */ enumFromTo(enumModuleType)(unfoldable1Array)(/* @__PURE__ */ bottom(boundedModuleType))(/* @__PURE__ */ top(boundedModuleType))));
var toModuleType = /* @__PURE__ */ composeKleisli1(toString8)(/* @__PURE__ */ function() {
  var $795 = note(new DecodeError2("Key not found in 'moduleTypes' map"));
  var $796 = flip(lookup3(ordString))(moduleTypes);
  return function($797) {
    return $795($796($797));
  };
}());
var toPackageMeta = /* @__PURE__ */ function() {
  var toPkgName = function() {
    var $798 = note(new DecodeError2("Invalid package name"));
    return function($799) {
      return $798(parsePackageName($799));
    };
  }();
  return toRecordN2(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons2(resolutionsIsSymbol)()()())(repositoryIsSymbol)()()())(privateIsSymbol)()()())(nameIsSymbol2)()()())(moduleTypeIsSymbol)()()())(mainIsSymbol2)()()())(licenceIsSymbol)()()())(keywordsIsSymbol)()()())(ignoreIsSymbol)()()())(homepageIsSymbol)()()())(devDependenciesIsSymbol)()()())(descriptionIsSymbol)()()())(dependenciesIsSymbol3)()()())(authorsIsSymbol)()()())()(PackageMeta)({
    name: toRequired(toPackageName),
    description: toOption(toString8),
    main: toOptionArray(toString8),
    moduleType: toOptionArray(toModuleType),
    licence: toOptionArray(toString8),
    ignore: toOptionArray(toString8),
    keywords: toOptionArray(toString8),
    authors: toOptionArray(toAuthor),
    homepage: toOption(toString8),
    repository: toOption(toRepository),
    dependencies: toOptionAssocArray(toPkgName)(toVersionRange),
    devDependencies: toOptionAssocArray(toPkgName)(toVersionRange),
    resolutions: toOptionAssocArray(toPkgName)(toVersion),
    "private": toOptionDefault(false)(toBoolean2)
  });
}();
var fromVersionRange = function($800) {
  return fromString8(unwrap18($800));
};
var fromVersion = function($801) {
  return fromString8(unwrap18($801));
};
var fromRepository = /* @__PURE__ */ fromRecordN2(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons2(urlIsSymbol)()())(typeIsSymbol2)()())()(Repository)({
  url: /* @__PURE__ */ fromRequired(fromString8),
  type: /* @__PURE__ */ fromRequired(fromString8)
});
var fromPackageName = function($802) {
  return fromString8(unwrap18($802));
};
var fromModuleType = function($803) {
  return fromString8(toLower(show41($803)));
};
var fromAuthor = /* @__PURE__ */ fromRecordN2(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons2(nameIsSymbol2)()())(homepageIsSymbol)()())(emailIsSymbol)()())()(Author)({
  name: /* @__PURE__ */ fromRequired(fromString8),
  email: /* @__PURE__ */ fromOption(fromString8),
  homepage: /* @__PURE__ */ fromOption(fromString8)
});
var fromPackageMeta = /* @__PURE__ */ fromRecordN2(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons2(resolutionsIsSymbol)()())(repositoryIsSymbol)()())(privateIsSymbol)()())(nameIsSymbol2)()())(moduleTypeIsSymbol)()())(mainIsSymbol2)()())(licenceIsSymbol)()())(keywordsIsSymbol)()())(ignoreIsSymbol)()())(homepageIsSymbol)()())(devDependenciesIsSymbol)()())(descriptionIsSymbol)()())(dependenciesIsSymbol3)()())(authorsIsSymbol)()())()(PackageMeta)({
  name: /* @__PURE__ */ fromRequired(fromPackageName),
  description: /* @__PURE__ */ fromOption(fromString8),
  main: /* @__PURE__ */ fromOptionArray(fromString8),
  moduleType: /* @__PURE__ */ fromOptionArray(fromModuleType),
  licence: /* @__PURE__ */ fromOptionArray(fromString8),
  ignore: /* @__PURE__ */ fromOptionArray(fromString8),
  keywords: /* @__PURE__ */ fromOptionArray(fromString8),
  authors: /* @__PURE__ */ fromOptionArray(fromAuthor),
  homepage: /* @__PURE__ */ fromOption(fromString8),
  repository: /* @__PURE__ */ fromOption(fromRepository),
  dependencies: /* @__PURE__ */ fromOptionAssocArray(unwrap18)(fromVersionRange),
  devDependencies: /* @__PURE__ */ fromOptionAssocArray(unwrap18)(fromVersionRange),
  resolutions: /* @__PURE__ */ fromOptionAssocArray(unwrap18)(fromVersion),
  "private": function(b) {
    if (b) {
      return new Just({
        key: Nothing.value,
        insertionOrder: Nothing.value,
        value: fromBoolean2(b)
      });
    }
    ;
    return Nothing.value;
  }
});

// output/Docs.Search.Types/index.js
var profunctorCodec3 = /* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity));
var wrapIso3 = /* @__PURE__ */ wrapIso(profunctorCodec3)();
var inject2 = /* @__PURE__ */ inject();
var localIsSymbol = {
  reflectSymbol: function() {
    return "local";
  }
};
var inject1 = /* @__PURE__ */ inject2(localIsSymbol);
var builtinIsSymbol = {
  reflectSymbol: function() {
    return "builtin";
  }
};
var inject22 = /* @__PURE__ */ inject2(builtinIsSymbol);
var packageIsSymbol2 = {
  reflectSymbol: function() {
    return "package";
  }
};
var inject3 = /* @__PURE__ */ inject2(packageIsSymbol2);
var unknownIsSymbol = {
  reflectSymbol: function() {
    return "unknown";
  }
};
var inject4 = /* @__PURE__ */ inject2(unknownIsSymbol);
var eq37 = /* @__PURE__ */ eq(eqPackageName2);
var compare17 = /* @__PURE__ */ compare(ordPackageName2);
var PackageScore = function(x) {
  return x;
};
var LocalPackage2 = /* @__PURE__ */ function() {
  function LocalPackage3() {
  }
  ;
  LocalPackage3.value = new LocalPackage3();
  return LocalPackage3;
}();
var Builtin = /* @__PURE__ */ function() {
  function Builtin2() {
  }
  ;
  Builtin2.value = new Builtin2();
  return Builtin2;
}();
var Package = /* @__PURE__ */ function() {
  function Package3(value0) {
    this.value0 = value0;
  }
  ;
  Package3.create = function(value0) {
    return new Package3(value0);
  };
  return Package3;
}();
var UnknownPackage = /* @__PURE__ */ function() {
  function UnknownPackage2() {
  }
  ;
  UnknownPackage2.value = new UnknownPackage2();
  return UnknownPackage2;
}();
var Identifier = function(x) {
  return x;
};
var showPartId = showInt;
var semiringPackageScore = semiringInt;
var packageNameCodec = /* @__PURE__ */ wrapIso3(PackageName)(string);
var packageInfoCodec = /* @__PURE__ */ function() {
  var toVariant = function(v) {
    if (v instanceof LocalPackage2) {
      return inject1(unit);
    }
    ;
    if (v instanceof Builtin) {
      return inject22(unit);
    }
    ;
    if (v instanceof Package) {
      return inject3(v.value0);
    }
    ;
    if (v instanceof UnknownPackage) {
      return inject4(unit);
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.Types (line 63, column 15 - line 67, column 45): " + [v.constructor.name]);
  };
  var fromVariant = match2()()()({
    local: function(v) {
      return LocalPackage2.value;
    },
    builtin: function(v) {
      return Builtin.value;
    },
    unknown: function(v) {
      return UnknownPackage.value;
    },
    "package": function(name5) {
      return new Package(name5);
    }
  });
  return dimap(profunctorCodec3)(toVariant)(fromVariant)(variantMatch()(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecNil)()()(unknownIsSymbol)(refl))()()(packageIsSymbol2)(refl))()()(localIsSymbol)(refl))()()(builtinIsSymbol)(refl))({
    local: new Left(unit),
    builtin: new Left(unit),
    unknown: new Left(unit),
    "package": new Right(packageNameCodec)
  }));
}();
var ordPartId = ordInt;
var ordIdentifier = ordString;
var packageScoreCodec = /* @__PURE__ */ wrapIso3(PackageScore)($$int);
var moduleNameCodec = /* @__PURE__ */ wrapIso3(ModuleName)(string);
var eqPackageInfo = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LocalPackage2 && y instanceof LocalPackage2) {
        return true;
      }
      ;
      if (x instanceof Builtin && y instanceof Builtin) {
        return true;
      }
      ;
      if (x instanceof Package && y instanceof Package) {
        return eq37(x.value0)(y.value0);
      }
      ;
      if (x instanceof UnknownPackage && y instanceof UnknownPackage) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordPackageInfo = {
  compare: function(x) {
    return function(y) {
      if (x instanceof LocalPackage2 && y instanceof LocalPackage2) {
        return EQ.value;
      }
      ;
      if (x instanceof LocalPackage2) {
        return LT.value;
      }
      ;
      if (y instanceof LocalPackage2) {
        return GT.value;
      }
      ;
      if (x instanceof Builtin && y instanceof Builtin) {
        return EQ.value;
      }
      ;
      if (x instanceof Builtin) {
        return LT.value;
      }
      ;
      if (y instanceof Builtin) {
        return GT.value;
      }
      ;
      if (x instanceof Package && y instanceof Package) {
        return compare17(x.value0)(y.value0);
      }
      ;
      if (x instanceof Package) {
        return LT.value;
      }
      ;
      if (y instanceof Package) {
        return GT.value;
      }
      ;
      if (x instanceof UnknownPackage && y instanceof UnknownPackage) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Docs.Search.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqPackageInfo;
  }
};

// output/Docs.Search.Config/index.js
var wrap5 = /* @__PURE__ */ wrap();
var show44 = /* @__PURE__ */ show(showPartId);
var mod6 = /* @__PURE__ */ mod(euclideanRingInt);
var typeIndexDirectory = /* @__PURE__ */ wrap5("generated-docs/html/index/types");
var packageInfoPath = /* @__PURE__ */ wrap5("generated-docs/html/index/packages.js");
var numberOfIndexParts = 50;
var moduleIndexPath = /* @__PURE__ */ wrap5("generated-docs/html/index/modules.js");
var mkIndexPartPath = function(partId) {
  return "html/index/declarations/" + (show44(partId) + ".js");
};
var metaPath = /* @__PURE__ */ wrap5("generated-docs/html/index/meta.js");
var metaItem = /* @__PURE__ */ wrap5("DocsSearchMeta");
var getPartId = function(v) {
  if (v instanceof Cons && v.value1 instanceof Cons) {
    return mod6(toCharCode2(v.value0) + toCharCode2(v.value1.value0) | 0)(numberOfIndexParts);
  }
  ;
  if (v instanceof Cons) {
    return mod6(toCharCode2(v.value0))(numberOfIndexParts);
  }
  ;
  return 0;
};
var defaultSourceFiles = ["src/**/*.purs"];
var defaultPackageName = /* @__PURE__ */ wrap5("<local package>");
var defaultDocsFiles = ["output/**/docs.json"];
var defaultBowerFiles = [".spago/*/*/bower.json", "bower_components/purescript-*/bower.json"];

// node_modules/minimatch/dist/esm/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// node_modules/minimatch/dist/esm/assert-valid-pattern.js
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};

// node_modules/minimatch/dist/esm/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var rangesToString = (ranges) => ranges.join("");
var parseClass = (glob3, position2) => {
  const pos2 = position2;
  if (glob3.charAt(pos2) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i = pos2 + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate4 = false;
  let endPos = pos2;
  let rangeStart = "";
  WHILE:
    while (i < glob3.length) {
      const c = glob3.charAt(i);
      if ((c === "!" || c === "^") && i === pos2 + 1) {
        negate4 = true;
        i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      sawStart = true;
      if (c === "\\") {
        if (!escaping) {
          escaping = true;
          i++;
          continue;
        }
      }
      if (c === "[" && !escaping) {
        for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
          if (glob3.startsWith(cls, i)) {
            if (rangeStart) {
              return ["$.", false, glob3.length - pos2, true];
            }
            i += cls.length;
            if (neg)
              negs.push(unip);
            else
              ranges.push(unip);
            uflag = uflag || u;
            continue WHILE;
          }
        }
      }
      escaping = false;
      if (rangeStart) {
        if (c > rangeStart) {
          ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
        } else if (c === rangeStart) {
          ranges.push(braceEscape(c));
        }
        rangeStart = "";
        i++;
        continue;
      }
      if (glob3.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-"));
        i += 2;
        continue;
      }
      if (glob3.startsWith("-", i + 1)) {
        rangeStart = c;
        i += 2;
        continue;
      }
      ranges.push(braceEscape(c));
      i++;
    }
  if (endPos < i) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob3.length - pos2, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate4) {
    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), false, endPos - pos2, false];
  }
  const sranges = "[" + (negate4 ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate4 ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos2, true];
};

// node_modules/minimatch/dist/esm/unescape.js
var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
};

// node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
var isExtglobType = (c) => types.has(c);
var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
var startNoDot = "(?!\\.)";
var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
var justDots = /* @__PURE__ */ new Set(["..", "."]);
var reSpecials = new Set("().*{}+?[]^$\\!");
var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var qmark = "[^/]";
var star = qmark + "*?";
var starNoEmpty = qmark + "+?";
var AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = false;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = false;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = false;
  constructor(type, parent, options = {}) {
    this.type = type;
    if (type)
      this.#hasMagic = true;
    this.#parent = parent;
    this.#root = this.#parent ? this.#parent.#root : this;
    this.#options = this.#root === this ? options : this.#root.#options;
    this.#negs = this.#root === this ? [] : this.#root.#negs;
    if (type === "!" && !this.#root.#filledNegs)
      this.#negs.push(this);
    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (const p of this.#parts) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return this.#hasMagic = true;
    }
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    if (this.#toString !== void 0)
      return this.#toString;
    if (!this.type) {
      return this.#toString = this.#parts.map((p) => String(p)).join("");
    } else {
      return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString();
    this.#filledNegs = true;
    let n;
    while (n = this.#negs.pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = p.#parent;
      while (pp) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
          for (const part of n.#parts) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(pp.#parts[i]);
          }
        }
        p = pp;
        pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
        throw new Error("invalid part: " + p);
      }
      this.#parts.push(p);
    }
  }
  toJSON() {
    const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    if (this.#root === this)
      return true;
    if (!this.#parent?.isStart())
      return false;
    if (this.#parentIndex === 0)
      return true;
    const p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      const pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    if (this.#root === this)
      return true;
    if (this.#parent?.type === "!")
      return true;
    if (!this.#parent?.isEnd())
      return false;
    if (!this.type)
      return this.#parent?.isEnd();
    const pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of this.#parts) {
      c.copyIn(p);
    }
    return c;
  }
  static #parseAST(str2, ast, pos2, opt) {
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos2;
      let acc2 = "";
      while (i2 < str2.length) {
        const c = str2.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str2, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos2 + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str2.length) {
      const c = str2.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str2.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = _AST.#parseAST(str2, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && ast.#parts.length === 0) {
          ast.#emptyExt = true;
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    ast.#hasMagic = void 0;
    ast.#parts = [str2.substring(pos2 - 1)];
    return i;
  }
  static fromGlob(pattern, options = {}) {
    const ast = new _AST(null, void 0, options);
    _AST.#parseAST(pattern, ast, 0, options);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    const glob3 = this.toString();
    const [re, body, hasMagic2, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob3.toUpperCase() !== glob3.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob3
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    const dot2 = allowDot ?? !!this.#options.dot;
    if (this.#root === this)
      this.#fillNegs();
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd();
      const src = this.#parts.map((p) => {
        const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        this.#hasMagic = this.#hasMagic || hasMagic2;
        this.#uflag = this.#uflag || uflag;
        return re;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof this.#parts[0] === "string") {
          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot2 && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot2 && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end4 = "";
      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
        end4 = "(?:$|\\/)";
      }
      const final2 = start2 + src + end4;
      return [
        final2,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = this.#partsToRegExp(dot2);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s = this.toString();
      this.#parts = [s];
      this.type = null;
      this.#hasMagic = void 0;
      return [s, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot2 || !startNoDot ? "" : this.#partsToRegExp(true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && this.#emptyExt) {
      final = (this.isStart() && !dot2 ? startNoDot : "") + starNoEmpty;
    } else {
      const close2 = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot2 && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close2;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot2) {
    return this.#parts.map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot2);
      this.#uflag = this.#uflag || uflag;
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob3, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob3.length; i++) {
      const c = glob3.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob3.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob3, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob3 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob3), !!hasMagic2, uflag];
  }
};

// node_modules/minimatch/dist/esm/escape.js
var escape = (s, { windowsPathsNoEscape = false } = {}) => {
  return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
};

// node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => {
  assertValidPattern(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
};
var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
var starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
};
var starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f) => f.toLowerCase().endsWith(ext2);
};
var starDotStarRE = /^\*+\.\*+$/;
var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
var dotStarRE = /^\.\*+$/;
var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
var starRE = /^\*+$/;
var starTest = (f) => f.length !== 0 && !f.startsWith(".");
var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
var qmarksTestNocase = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
};
var qmarksTestDot = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTest = ([$0, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$0]);
  return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
};
var qmarksTestNoExt = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
};
var qmarksTestNoExtDot = ([$0]) => {
  const len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
};
var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
var path11 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
var sep2 = defaultPlatform === "win32" ? path11.win32.sep : path11.posix.sep;
minimatch.sep = sep2;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]";
var star2 = qmark2 + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var filter9 = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter9;
var ext = (a, b = {}) => Object.assign({}, a, b);
var defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list3, pattern, options = {}) => orig.match(list3, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return (0, import_brace_expansion.default)(pattern);
};
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match3 = (list3, pattern, options = {}) => {
  const mm2 = new Minimatch(pattern, options);
  list3 = list3.filter((f) => mm2.match(f));
  if (mm2.options.nonull && !list3.length) {
    list3.push(pattern);
  }
  return list3;
};
minimatch.match = match3;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern);
    options = options || {};
    this.options = options;
    this.pattern = pattern;
    this.platform = options.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._) {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set4 = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
        const isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC) {
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        } else if (isDrive) {
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
      }
      return s.map((ss) => this.parse(ss));
    });
    this.debug(this.pattern, set4);
    this.set = set4.filter((s) => s.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i = 0; i < this.set.length; i++) {
        const p = this.set[i];
        if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i = 0; i < globParts.length; i++) {
        for (let j = 0; j < globParts[i].length; j++) {
          if (globParts[i][j] === "**") {
            globParts[i][j] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
        let i = gs;
        while (parts[i + 1] === "**") {
          i++;
        }
        if (i !== gs) {
          parts.splice(gs, i - gs);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set4, part) => {
        const prev = set4[set4.length - 1];
        if (part === "**" && prev === "**") {
          return set4;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set4.pop();
            return set4;
          }
        }
        set4.push(part);
        return set4;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          const p = parts[i];
          if (i === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i, 1);
            i--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd = 0;
      while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
        const p = parts[dd - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd - 1, 2);
          dd -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let gss = gs;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs) {
            parts.splice(gs + 1, gss - gs);
          }
          let next2 = parts[gs + 1];
          const p = parts[gs + 2];
          const p2 = parts[gs + 3];
          if (next2 !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs, 1);
          const other = parts.slice(0);
          other[gs] = "**";
          globParts.push(other);
          gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd === 1 && parts[dd + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++) {
      for (let j = i + 1; j < globParts.length; j++) {
        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (!matched)
          continue;
        globParts[i] = matched;
        globParts[j] = [];
      }
    }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai = 0;
    let bi = 0;
    let result = [];
    let which = "";
    while (ai < a.length && bi < b.length) {
      if (a[ai] === b[bi]) {
        result.push(which === "b" ? b[bi] : a[ai]);
        ai++;
        bi++;
      } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
        result.push(a[ai]);
        ai++;
      } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
        result.push(b[bi]);
        bi++;
      } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai]);
        ai++;
        bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi]);
        ai++;
        bi++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate4 = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate4 = !negate4;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate4;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd, pd] = [file[fdi], pattern[pdi]];
        if (fd.toLowerCase() === pd.toLowerCase()) {
          pattern[pdi] = fd;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = p.test(f);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re === "object") {
      Reflect.defineProperty(re, "test", { value: fastTest });
    }
    return re;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set4 = this.set;
    if (!set4.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options.nocase ? ["i"] : []);
    let re = set4.map((pattern) => {
      const pp = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f of p.flags.split(""))
            flags.add(f);
        }
        return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp.forEach((p, i) => {
        const next2 = pp[i + 1];
        const prev = pp[i - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp[i] = twoStar;
          }
        } else if (next2 === void 0) {
          pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp[i + 1] = GLOBSTAR;
        }
      });
      return pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|");
    const [open3, close2] = set4.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open3 + re + close2 + "$";
    if (this.negate)
      re = "^(?!" + re + ").+$";
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f === "";
    }
    if (f === "/" && partial) {
      return true;
    }
    const options = this.options;
    if (this.isWindows) {
      f = f.split("\\").join("/");
    }
    const ff2 = this.slashSplit(f);
    this.debug(this.pattern, "split", ff2);
    const set4 = this.set;
    this.debug(this.pattern, "set", set4);
    let filename = ff2[ff2.length - 1];
    if (!filename) {
      for (let i = ff2.length - 2; !filename && i >= 0; i--) {
        filename = ff2[i];
      }
    }
    for (let i = 0; i < set4.length; i++) {
      const pattern = set4[i];
      let file = ff2;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// node_modules/glob/dist/esm/glob.js
import { fileURLToPath as fileURLToPath3 } from "node:url";

// node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS3 = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code3, fn) => {
  typeof PROCESS3.emitWarning === "function" ? PROCESS3.emitWarning(msg, type, code3, fn) : console.error(`[${code3}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS3.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code3) => !warned.has(code3);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max8) => !isPosInt(max8) ? null : max8 <= Math.pow(2, 8) ? Uint8Array : max8 <= Math.pow(2, 16) ? Uint16Array : max8 <= Math.pow(2, 32) ? Uint32Array : max8 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size8) {
    super(size8);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max8) {
    const HeapCls = getUintArray(max8);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max8, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max8, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max8);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index5, options, context) => c.#backgroundFetch(k, index5, options, context),
      moveToTail: (index5) => c.#moveToTail(index5),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index5) => c.#isStale(index5)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max: max8 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max8 !== 0 && !isPosInt(max8)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max8 ? getUintArray(max8) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max8);
    }
    this.#max = max8;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max8).fill(void 0);
    this.#valList = new Array(max8).fill(void 0);
    this.#next = new UintArray(max8);
    this.#prev = new UintArray(max8);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max8);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code3 = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code3)) {
        warned.add(code3);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code3, _LRUCache);
      }
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index5, ttl, start = perf.now()) => {
      starts[index5] = ttl !== 0 ? start : 0;
      ttls[index5] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index5)) {
            this.delete(this.#keyList[index5]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index5) => {
      starts[index5] = ttls[index5] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status2, index5) => {
      if (ttls[index5]) {
        const ttl = ttls[index5];
        const start = starts[index5];
        if (!ttl || !start)
          return;
        status2.ttl = ttl;
        status2.start = start;
        status2.now = cachedNow || getNow();
        const age = status2.now - start;
        status2.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index5 = this.#keyMap.get(key);
      if (index5 === void 0) {
        return 0;
      }
      const ttl = ttls[index5];
      const start = starts[index5];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index5) => {
      const s = starts[index5];
      const t = ttls[index5];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index5) => {
      this.#calculatedSize -= sizes[index5];
      sizes[index5] = 0;
    };
    this.#requireSize = (k, v, size8, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size8)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size8 = sizeCalculation(v, k);
          if (!isPosInt(size8)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size8;
    };
    this.#addItemSize = (index5, size8, status2) => {
      sizes[index5] = size8;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index5];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index5];
      if (status2) {
        status2.entrySize = size8;
        status2.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size8, sizeCalculation) => {
    if (size8 || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index5) {
    return index5 !== void 0 && this.#keyMap.get(this.#keyList[index5]) === index5;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string description of an object.
   * Called by the built-in method Object.prototype.toString.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value4 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value4 === void 0)
        continue;
      if (fn(value4, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value4 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value4 === void 0)
        continue;
      fn.call(thisp, value4, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value4 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value4 === void 0)
        continue;
      fn.call(thisp, value4, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value4 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value4 === void 0)
      return void 0;
    const entry = { value: value4 };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value4 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value4 === void 0 || key === void 0)
        continue;
      const entry = { value: value4 };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status: status2 } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size8 = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size8 > this.maxEntrySize) {
      if (status2) {
        status2.set = "miss";
        status2.maxEntrySizeExceeded = true;
      }
      this.delete(k);
      return this;
    }
    let index5 = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index5 === void 0) {
      index5 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index5] = k;
      this.#valList[index5] = v;
      this.#keyMap.set(k, index5);
      this.#next[this.#tail] = index5;
      this.#prev[index5] = this.#tail;
      this.#tail = index5;
      this.#size++;
      this.#addItemSize(index5, size8, status2);
      if (status2)
        status2.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index5);
      const oldVal = this.#valList[index5];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index5);
        this.#addItemSize(index5, size8, status2);
        this.#valList[index5] = v;
        if (status2) {
          status2.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status2.oldValue = oldValue;
        }
      } else if (status2) {
        status2.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index5, ttl, start);
      }
      if (status2)
        this.#statusTTL(status2, index5);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head6 = this.#head;
    const k = this.#keyList[head6];
    const v = this.#valList[head6];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head6);
    if (free) {
      this.#keyList[head6] = void 0;
      this.#valList[head6] = void 0;
      this.#free.push(head6);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head6];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head6;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status: status2 } = hasOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 !== void 0) {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index5)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index5);
        }
        if (status2) {
          status2.has = "hit";
          this.#statusTTL(status2, index5);
        }
        return true;
      } else if (status2) {
        status2.has = "stale";
        this.#statusTTL(status2, index5);
      }
    } else if (status2) {
      status2.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 === void 0 || !allowStale && this.#isStale(index5)) {
      return;
    }
    const v = this.#valList[index5];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index5, options, context) {
    const v = index5 === void 0 ? void 0 : this.#valList[index5];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache2 = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache2) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache2) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index5] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index5] = bf2.__staleWhileFetching;
          } else {
            this.delete(k);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index5] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k);
        } else if (!allowStaleAborted) {
          this.#valList[index5] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index5 === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index5 = this.#keyMap.get(k);
    } else {
      this.#valList[index5] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size: size8 = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status: status2,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status2)
        status2.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status: status2
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size: size8,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status: status2,
      signal
    };
    let index5 = this.#keyMap.get(k);
    if (index5 === void 0) {
      if (status2)
        status2.fetch = "miss";
      const p = this.#backgroundFetch(k, index5, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status2) {
          status2.fetch = "inflight";
          if (stale)
            status2.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index5);
      if (!forceRefresh && !isStale) {
        if (status2)
          status2.fetch = "hit";
        this.#moveToTail(index5);
        if (updateAgeOnGet) {
          this.#updateItemAge(index5);
        }
        if (status2)
          this.#statusTTL(status2, index5);
        return v;
      }
      const p = this.#backgroundFetch(k, index5, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status2) {
        status2.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status2.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status: status2 } = getOptions;
    const index5 = this.#keyMap.get(k);
    if (index5 !== void 0) {
      const value4 = this.#valList[index5];
      const fetching = this.#isBackgroundFetch(value4);
      if (status2)
        this.#statusTTL(status2, index5);
      if (this.#isStale(index5)) {
        if (status2)
          status2.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k);
          }
          if (status2 && allowStale)
            status2.returnedStale = true;
          return allowStale ? value4 : void 0;
        } else {
          if (status2 && allowStale && value4.__staleWhileFetching !== void 0) {
            status2.returnedStale = true;
          }
          return allowStale ? value4.__staleWhileFetching : void 0;
        }
      } else {
        if (status2)
          status2.get = "hit";
        if (fetching) {
          return value4.__staleWhileFetching;
        }
        this.#moveToTail(index5);
        if (updateAgeOnGet) {
          this.#updateItemAge(index5);
        }
        return value4;
      }
    } else if (status2) {
      status2.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index5) {
    if (index5 !== this.#tail) {
      if (index5 === this.#head) {
        this.#head = this.#next[index5];
      } else {
        this.#connect(this.#prev[index5], this.#next[index5]);
      }
      this.#connect(this.#tail, index5);
      this.#tail = index5;
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    let deleted = false;
    if (this.#size !== 0) {
      const index5 = this.#keyMap.get(k);
      if (index5 !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index5);
          const v = this.#valList[index5];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index5] = void 0;
          this.#valList[index5] = void 0;
          if (index5 === this.#tail) {
            this.#tail = this.#prev[index5];
          } else if (index5 === this.#head) {
            this.#head = this.#next[index5];
          } else {
            const pi = this.#prev[index5];
            this.#next[pi] = this.#next[index5];
            const ni = this.#next[index5];
            this.#prev[ni] = this.#prev[index5];
          }
          this.#size--;
          this.#free.push(index5);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    for (const index5 of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index5];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index5];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/path-scurry/dist/esm/index.js
import { posix, win32 as win322 } from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";
import { lstatSync as lstatSync2, readdir as readdirCB, readdirSync as readdirSync2, readlinkSync as readlinkSync2, realpathSync as rps } from "fs";
import * as actualFS from "node:fs";
import { lstat as lstat4, readdir as readdir4, readlink as readlink3, realpath as realpath3 } from "node:fs/promises";
var realpathSync2 = rps.native;
var defaultFS = {
  lstatSync: lstatSync2,
  readdir: readdirCB,
  readdirSync: readdirSync2,
  readlinkSync: readlinkSync2,
  realpathSync: realpathSync2,
  promises: {
    lstat: lstat4,
    readdir: readdir4,
    readlink: readlink3,
    realpath: realpath3
  }
};
var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
};
var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
var eitherSep = /[\\\/]/;
var UNKNOWN = 0;
var IFIFO = 1;
var IFCHR = 2;
var IFDIR = 4;
var IFBLK = 6;
var IFREG = 8;
var IFLNK = 10;
var IFSOCK = 12;
var IFMT = 15;
var IFMT_UNKNOWN = ~IFMT;
var READDIR_CALLED = 16;
var LSTAT_CALLED = 32;
var ENOTDIR = 64;
var ENOENT = 128;
var ENOREADLINK = 256;
var ENOREALPATH = 512;
var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
var TYPEMASK = 1023;
var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
var normalizeCache2 = /* @__PURE__ */ new Map();
var normalize2 = (s) => {
  const c = normalizeCache2.get(s);
  if (c)
    return c;
  const n = s.normalize("NFKD");
  normalizeCache2.set(s, n);
  return n;
};
var normalizeNocaseCache = /* @__PURE__ */ new Map();
var normalizeNocase = (s) => {
  const c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  const n = normalize2(s.toLowerCase());
  normalizeNocaseCache.set(s, n);
  return n;
};
var ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
};
var ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
};
var setAsCwd = Symbol("PathScurry setAsCwd");
var PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  /**
   * boolean indicating that this path is the current working directory
   * of the PathScurry collection that contains it.
   */
  isCWD = false;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['parentPath'] refers to the path of the
   * directory that was passed to readdir. For root entries, it's the path
   * to the entry itself.
   */
  get parentPath() {
    return (this.parent || this).fullpath();
  }
  /**
   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
   * this property refers to the *parent* path, not the path object itself.
   */
  get path() {
    return this.parentPath;
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name5, type = UNKNOWN, root2, roots, nocase, children, opts) {
    this.name = name5;
    this.#matchName = nocase ? normalizeNocase(name5) : normalize2(name5);
    this.#type = type & TYPEMASK;
    this.nocase = nocase;
    this.roots = roots;
    this.root = root2 || this;
    this.#children = children;
    this.#fullpath = opts.fullpath;
    this.#relative = opts.relative;
    this.#relativePosix = opts.relativePosix;
    this.parent = opts.parent;
    if (this.parent) {
      this.#fs = this.parent.#fs;
    } else {
      this.#fs = fsFromOption(opts.fs);
    }
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    if (this.#depth !== void 0)
      return this.#depth;
    if (!this.parent)
      return this.#depth = 0;
    return this.#depth = this.parent.depth() + 1;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path14) {
    if (!path14) {
      return this;
    }
    const rootPath = this.getRootString(path14);
    const dir = path14.substring(rootPath.length);
    const dirParts = dir.split(this.splitSep);
    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    return result;
  }
  #resolveParts(dirParts) {
    let p = this;
    for (const part of dirParts) {
      p = p.child(part);
    }
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    const cached = this.#children.get(this);
    if (cached) {
      return cached;
    }
    const children = Object.assign([], { provisional: 0 });
    this.#children.set(this, children);
    this.#type &= ~READDIR_CALLED;
    return children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".") {
      return this;
    }
    if (pathPart === "..") {
      return this.parent || this;
    }
    const children = this.children();
    const name5 = this.nocase ? normalizeNocase(pathPart) : normalize2(pathPart);
    for (const p of children) {
      if (p.#matchName === name5) {
        return p;
      }
    }
    const s = this.parent ? this.sep : "";
    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
    const pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    if (!this.canReaddir()) {
      pchild.#type |= ENOENT;
    }
    children.push(pchild);
    return pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.isCWD)
      return "";
    if (this.#relative !== void 0) {
      return this.#relative;
    }
    const name5 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relative = this.name;
    }
    const pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name5;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.isCWD)
      return "";
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    const name5 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#relativePosix = this.fullpathPosix();
    }
    const pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name5;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0) {
      return this.#fullpath;
    }
    const name5 = this.name;
    const p = this.parent;
    if (!p) {
      return this.#fullpath = this.name;
    }
    const pv = p.fullpath();
    const fp = pv + (!p.parent ? "" : this.sep) + name5;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      const p2 = this.fullpath().replace(/\\/g, "/");
      if (/^[a-z]:\//i.test(p2)) {
        return this.#fullpathPosix = `//?/${p2}`;
      } else {
        return this.#fullpathPosix = p2;
      }
    }
    const p = this.parent;
    const pfpp = p.fullpathPosix();
    const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    const children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return true;
    if (!this.parent)
      return false;
    const ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return !this.nocase ? this.#matchName === normalize2(n) : this.#matchName === normalizeNocase(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read7 = await this.#fs.promises.readlink(this.fullpath());
      const linkTarget = (await this.parent.realpath())?.resolve(read7);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    const target = this.#linkTarget;
    if (target) {
      return target;
    }
    if (!this.canReadlink()) {
      return void 0;
    }
    if (!this.parent) {
      return void 0;
    }
    try {
      const read7 = this.#fs.readlinkSync(this.fullpath());
      const linkTarget = this.parent.realpathSync()?.resolve(read7);
      if (linkTarget) {
        return this.#linkTarget = linkTarget;
      }
    } catch (er) {
      this.#readlinkFail(er.code);
      return void 0;
    }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++) {
      const c = children[p];
      if (c)
        c.#markENOENT();
    }
  }
  #markENOENT() {
    if (this.#type & ENOENT)
      return;
    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
    this.#markChildrenENOENT();
  }
  #markChildrenENOENT() {
    const children = this.children();
    children.provisional = 0;
    for (const p of children) {
      p.#markENOENT();
    }
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH;
    this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    if ((t & IFMT) === IFDIR)
      t &= IFMT_UNKNOWN;
    this.#type = t | ENOTDIR;
    this.#markChildrenENOENT();
  }
  #readdirFail(code3 = "") {
    if (code3 === "ENOTDIR" || code3 === "EPERM") {
      this.#markENOTDIR();
    } else if (code3 === "ENOENT") {
      this.#markENOENT();
    } else {
      this.children().provisional = 0;
    }
  }
  #lstatFail(code3 = "") {
    if (code3 === "ENOTDIR") {
      const p = this.parent;
      p.#markENOTDIR();
    } else if (code3 === "ENOENT") {
      this.#markENOENT();
    }
  }
  #readlinkFail(code3 = "") {
    let ter = this.#type;
    ter |= ENOREADLINK;
    if (code3 === "ENOENT")
      ter |= ENOENT;
    if (code3 === "EINVAL" || code3 === "UNKNOWN") {
      ter &= IFMT_UNKNOWN;
    }
    this.#type = ter;
    if (code3 === "ENOTDIR" && this.parent) {
      this.parent.#markENOTDIR();
    }
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    const type = entToType(e);
    const child = this.newChild(e.name, type, { parent: this });
    const ifmt = child.#type & IFMT;
    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
      child.#type |= ENOTDIR;
    }
    c.unshift(child);
    c.provisional++;
    return child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      const pchild = c[p];
      const name5 = this.nocase ? normalizeNocase(e.name) : normalize2(e.name);
      if (name5 !== pchild.#matchName) {
        continue;
      }
      return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index5, c) {
    const v = p.name;
    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
    if (v !== e.name)
      p.name = e.name;
    if (index5 !== c.provisional) {
      if (index5 === c.length - 1)
        c.pop();
      else
        c.splice(index5, 1);
      c.unshift(p);
    }
    c.provisional++;
    return p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if ((this.#type & ENOENT) === 0) {
      try {
        this.#applyStat(this.#fs.lstatSync(this.fullpath()));
        return this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
    }
  }
  #applyStat(st) {
    const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid: gid2, ino, mode: mode2, mtime, mtimeMs, nlink, rdev, size: size8, uid: uid2 } = st;
    this.#atime = atime;
    this.#atimeMs = atimeMs;
    this.#birthtime = birthtime;
    this.#birthtimeMs = birthtimeMs;
    this.#blksize = blksize;
    this.#blocks = blocks;
    this.#ctime = ctime;
    this.#ctimeMs = ctimeMs;
    this.#dev = dev;
    this.#gid = gid2;
    this.#ino = ino;
    this.#mode = mode2;
    this.#mtime = mtime;
    this.#mtimeMs = mtimeMs;
    this.#nlink = nlink;
    this.#rdev = rdev;
    this.#size = size8;
    this.#uid = uid2;
    const ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
      this.#type |= ENOTDIR;
    }
  }
  #onReaddirCB = [];
  #readdirCBInFlight = false;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = false;
    const cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0;
    cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = false) {
    if (!this.canReaddir()) {
      if (allowZalgo)
        cb(null, []);
      else
        queueMicrotask(() => cb(null, []));
      return;
    }
    const children = this.children();
    if (this.calledReaddir()) {
      const c = children.slice(0, children.provisional);
      if (allowZalgo)
        cb(null, c);
      else
        queueMicrotask(() => cb(null, c));
      return;
    }
    this.#onReaddirCB.push(cb);
    if (this.#readdirCBInFlight) {
      return;
    }
    this.#readdirCBInFlight = true;
    const fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries3) => {
      if (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      } else {
        for (const e of entries3) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
      return;
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight) {
      await this.#asyncReaddirInFlight;
    } else {
      let resolve3 = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve3 = res);
      try {
        for (const e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0;
      resolve3();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir()) {
      return [];
    }
    const children = this.children();
    if (this.calledReaddir()) {
      return children.slice(0, children.provisional);
    }
    const fullpath = this.fullpath();
    try {
      for (const e of this.#fs.readdirSync(fullpath, {
        withFileTypes: true
      })) {
        this.#readdirAddChild(e, children);
      }
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code);
      children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return false;
    const ifmt = IFMT & this.#type;
    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
      return false;
    }
    return true;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = await this.#fs.promises.realpath(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
      return void 0;
    try {
      const rp = this.#fs.realpathSync(this.fullpath());
      return this.#realpath = this.resolve(rp);
    } catch (_) {
      this.#markENOREALPATH();
    }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    oldCwd.isCWD = false;
    this.isCWD = true;
    const changed = /* @__PURE__ */ new Set([]);
    let rp = [];
    let p = this;
    while (p && p.parent) {
      changed.add(p);
      p.#relative = rp.join(this.sep);
      p.#relativePosix = rp.join("/");
      p = p.parent;
      rp.push("..");
    }
    p = oldCwd;
    while (p && p.parent && !changed.has(p)) {
      p.#relative = void 0;
      p.#relativePosix = void 0;
      p = p.parent;
    }
  }
};
var PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name5, type = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name5, type, root2, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name5, type = UNKNOWN, opts = {}) {
    return new _PathWin32(name5, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path14) {
    return win322.parse(path14).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    rootPath = uncToDrive(rootPath.toUpperCase());
    if (rootPath === this.root.name) {
      return this.root;
    }
    for (const [compare21, root2] of Object.entries(this.roots)) {
      if (this.sameRoot(rootPath, compare21)) {
        return this.roots[rootPath] = root2;
      }
    }
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare21 = this.root.name) {
    rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    return rootPath === compare21;
  }
};
var PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name5, type = UNKNOWN, root2, roots, nocase, children, opts) {
    super(name5, type, root2, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path14) {
    return path14.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name5, type = UNKNOWN, opts = {}) {
    return new _PathPosix(name5, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
};
var PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd3 = process.cwd(), pathImpl, sep3, { nocase, childrenCacheSize = 16 * 1024, fs: fs16 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs16);
    if (cwd3 instanceof URL || cwd3.startsWith("file://")) {
      cwd3 = fileURLToPath2(cwd3);
    }
    const cwdPath = pathImpl.resolve(cwd3);
    this.roots = /* @__PURE__ */ Object.create(null);
    this.rootPath = this.parseRootPath(cwdPath);
    this.#resolveCache = new ResolveCache();
    this.#resolvePosixCache = new ResolveCache();
    this.#children = new ChildrenCache(childrenCacheSize);
    const split3 = cwdPath.substring(this.rootPath.length).split(sep3);
    if (split3.length === 1 && !split3[0]) {
      split3.pop();
    }
    if (nocase === void 0) {
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    }
    this.nocase = nocase;
    this.root = this.newRoot(this.#fs);
    this.roots[this.rootPath] = this.root;
    let prev = this.root;
    let len = split3.length - 1;
    const joinSep = pathImpl.sep;
    let abs5 = this.rootPath;
    let sawFirst = false;
    for (const part of split3) {
      const l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs5 += (sawFirst ? "" : joinSep) + part
      });
      sawFirst = true;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path14 = this.cwd) {
    if (typeof path14 === "string") {
      path14 = this.cwd.resolve(path14);
    }
    return path14.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths2) {
    let r = "";
    for (let i = paths2.length - 1; i >= 0; i--) {
      const p = paths2[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolveCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpath();
    this.#resolveCache.set(r, result);
    return result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths2) {
    let r = "";
    for (let i = paths2.length - 1; i >= 0; i--) {
      const p = paths2[i];
      if (!p || p === ".")
        continue;
      r = r ? `${p}/${r}` : p;
      if (this.isAbsolute(p)) {
        break;
      }
    }
    const cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0) {
      return cached;
    }
    const result = this.cwd.resolve(r).fullpathPosix();
    this.#resolvePosixCache.set(r, result);
    return result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else {
      const p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    }
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: true
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true } = opts;
    if (!entry.canReaddir()) {
      return [];
    } else if (withFileTypes) {
      return entry.readdirSync();
    } else {
      return entry.readdirSync().map((e) => e.name);
    }
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    }
    return entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.readlink();
    return withFileTypes ? e : e?.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.readlinkSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = await entry.realpath();
    return withFileTypes ? e : e?.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: false
  }) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      withFileTypes = entry.withFileTypes;
      entry = this.cwd;
    }
    const e = entry.realpathSync();
    return withFileTypes ? e : e?.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter11, walkFilter } = opts;
    const results = [];
    if (!filter11 || filter11(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const walk2 = (dir, cb) => {
      dirs.add(dir);
      dir.readdirCB((er, entries3) => {
        if (er) {
          return cb(er);
        }
        let len = entries3.length;
        if (!len)
          return cb();
        const next2 = () => {
          if (--len === 0) {
            cb();
          }
        };
        for (const e of entries3) {
          if (!filter11 || filter11(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          if (follow && e.isSymbolicLink()) {
            e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk2(r, next2) : next2());
          } else {
            if (e.shouldWalk(dirs, walkFilter)) {
              walk2(e, next2);
            } else {
              next2();
            }
          }
        }
      }, true);
    };
    const start = entry;
    return new Promise((res, rej) => {
      walk2(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter11, walkFilter } = opts;
    const results = [];
    if (!filter11 || filter11(entry)) {
      results.push(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries3 = dir.readdirSync();
      for (const e of entries3) {
        if (!filter11 || filter11(e)) {
          results.push(withFileTypes ? e : e.fullpath());
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      options = entry;
      entry = this.cwd;
    }
    return this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter11, walkFilter } = opts;
    if (!filter11 || filter11(entry)) {
      yield withFileTypes ? entry : entry.fullpath();
    }
    const dirs = /* @__PURE__ */ new Set([entry]);
    for (const dir of dirs) {
      const entries3 = dir.readdirSync();
      for (const e of entries3) {
        if (!filter11 || filter11(e)) {
          yield withFileTypes ? e : e.fullpath();
        }
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          if (r.isUnknown())
            r.lstatSync();
        }
        if (r.shouldWalk(dirs, walkFilter)) {
          dirs.add(r);
        }
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter11, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    if (!filter11 || filter11(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const dirs = /* @__PURE__ */ new Set();
    const queue = [entry];
    let processing = 0;
    const process11 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const onReaddir = (er, entries3, didRealpaths = false) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            const promises = [];
            for (const e of entries3) {
              if (e.isSymbolicLink()) {
                promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              }
            }
            if (promises.length) {
              Promise.all(promises).then(() => onReaddir(null, entries3, true));
              return;
            }
          }
          for (const e of entries3) {
            if (e && (!filter11 || filter11(e))) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries3) {
            const r = e.realpathCached() || e;
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
          if (paused && !results.flowing) {
            results.once("drain", process11);
          } else if (!sync2) {
            process11();
          }
        };
        let sync2 = true;
        dir.readdirCB(onReaddir, true);
        sync2 = false;
      }
    };
    process11();
    return results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    if (typeof entry === "string") {
      entry = this.cwd.resolve(entry);
    } else if (!(entry instanceof PathBase)) {
      opts = entry;
      entry = this.cwd;
    }
    const { withFileTypes = true, follow = false, filter: filter11, walkFilter } = opts;
    const results = new Minipass({ objectMode: true });
    const dirs = /* @__PURE__ */ new Set();
    if (!filter11 || filter11(entry)) {
      results.write(withFileTypes ? entry : entry.fullpath());
    }
    const queue = [entry];
    let processing = 0;
    const process11 = () => {
      let paused = false;
      while (!paused) {
        const dir = queue.shift();
        if (!dir) {
          if (processing === 0)
            results.end();
          return;
        }
        processing++;
        dirs.add(dir);
        const entries3 = dir.readdirSync();
        for (const e of entries3) {
          if (!filter11 || filter11(e)) {
            if (!results.write(withFileTypes ? e : e.fullpath())) {
              paused = true;
            }
          }
        }
        processing--;
        for (const e of entries3) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            queue.push(r);
          }
        }
      }
      if (paused && !results.flowing)
        results.once("drain", process11);
    };
    process11();
    return results;
  }
  chdir(path14 = this.cwd) {
    const oldCwd = this.cwd;
    this.cwd = typeof path14 === "string" ? this.cwd.resolve(path14) : path14;
    this.cwd[setAsCwd](oldCwd);
  }
};
var PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd3 = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd3, win322, "\\", { ...opts, nocase });
    this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent) {
      p.nocase = this.nocase;
    }
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return win322.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs16) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs16 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
};
var PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd3 = process.cwd(), opts = {}) {
    const { nocase = false } = opts;
    super(cwd3, posix, "/", { ...opts, nocase });
    this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs16) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs16 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
};
var PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd3 = process.cwd(), opts = {}) {
    const { nocase = true } = opts;
    super(cwd3, { ...opts, nocase });
  }
};
var Path = process.platform === "win32" ? PathWin32 : PathPosix;
var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// node_modules/glob/dist/esm/pattern.js
var isPatternList = (pl) => pl.length >= 1;
var isGlobList = (gl) => gl.length >= 1;
var Pattern = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = true;
  constructor(patternList, globList, index5, platform9) {
    if (!isPatternList(patternList)) {
      throw new TypeError("empty pattern list");
    }
    if (!isGlobList(globList)) {
      throw new TypeError("empty glob list");
    }
    if (globList.length !== patternList.length) {
      throw new TypeError("mismatched pattern list and glob list lengths");
    }
    this.length = patternList.length;
    if (index5 < 0 || index5 >= this.length) {
      throw new TypeError("index out of range");
    }
    this.#patternList = patternList;
    this.#globList = globList;
    this.#index = index5;
    this.#platform = platform9;
    if (this.#index === 0) {
      if (this.isUNC()) {
        const [p0, p1, p2, p3, ...prest] = this.#patternList;
        const [g0, g1, g2, g3, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = [p0, p1, p2, p3, ""].join("/");
        const g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        const [p1, ...prest] = this.#patternList;
        const [g1, ...grest] = this.#globList;
        if (prest[0] === "") {
          prest.shift();
          grest.shift();
        }
        const p = p1 + "/";
        const g = g1 + "/";
        this.#patternList = [p, ...prest];
        this.#globList = [g, ...grest];
        this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] === "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    if (this.#rest !== void 0)
      return this.#rest;
    if (!this.hasMore())
      return this.#rest = null;
    this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
    this.#rest.#isAbsolute = this.#isAbsolute;
    this.#rest.#isUNC = this.#isUNC;
    this.#rest.#isDrive = this.#isDrive;
    return this.#rest;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    const pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    const pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    const pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    const p = this.#patternList[0];
    return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
      return false;
    this.#followGlobstar = false;
    return true;
  }
};

// node_modules/glob/dist/esm/ignore.js
var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Ignore3 = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  platform;
  mmopts;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform9 = defaultPlatform2 }) {
    this.relative = [];
    this.absolute = [];
    this.relativeChildren = [];
    this.absoluteChildren = [];
    this.platform = platform9;
    this.mmopts = {
      dot: true,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform: platform9,
      nocomment: true,
      nonegate: true
    };
    for (const ign of ignored)
      this.add(ign);
  }
  add(ign) {
    const mm2 = new Minimatch(ign, this.mmopts);
    for (let i = 0; i < mm2.set.length; i++) {
      const parsed = mm2.set[i];
      const globParts = mm2.globParts[i];
      if (!parsed || !globParts) {
        throw new Error("invalid pattern object");
      }
      while (parsed[0] === "." && globParts[0] === ".") {
        parsed.shift();
        globParts.shift();
      }
      const p = new Pattern(parsed, globParts, 0, this.platform);
      const m = new Minimatch(p.globString(), this.mmopts);
      const children = globParts[globParts.length - 1] === "**";
      const absolute = p.isAbsolute();
      if (absolute)
        this.absolute.push(m);
      else
        this.relative.push(m);
      if (children) {
        if (absolute)
          this.absoluteChildren.push(m);
        else
          this.relativeChildren.push(m);
      }
    }
  }
  ignored(p) {
    const fullpath = p.fullpath();
    const fullpaths = `${fullpath}/`;
    const relative2 = p.relative() || ".";
    const relatives = `${relative2}/`;
    for (const m of this.relative) {
      if (m.match(relative2) || m.match(relatives))
        return true;
    }
    for (const m of this.absolute) {
      if (m.match(fullpath) || m.match(fullpaths))
        return true;
    }
    return false;
  }
  childrenIgnored(p) {
    const fullpath = p.fullpath() + "/";
    const relative2 = (p.relative() || ".") + "/";
    for (const m of this.relativeChildren) {
      if (m.match(relative2))
        return true;
    }
    for (const m of this.absoluteChildren) {
      if (m.match(fullpath))
        return true;
    }
    return false;
  }
};

// node_modules/glob/dist/esm/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    return this.store.get(target.fullpath())?.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    const fullpath = target.fullpath();
    const cached = this.store.get(fullpath);
    if (cached)
      cached.add(pattern.globString());
    else
      this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
};
var MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
    const current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path14, n]) => [
      path14,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
};
var SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir()) {
      return;
    }
    const subs = this.store.get(target);
    if (subs) {
      if (!subs.find((p) => p.globString() === pattern.globString())) {
        subs.push(pattern);
      }
    } else
      this.store.set(target, [pattern]);
  }
  get(target) {
    const subs = this.store.get(target);
    if (!subs) {
      throw new Error("attempting to walk unknown path");
    }
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
};
var Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    const processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      const root2 = pattern.root();
      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
      if (root2) {
        t = t.resolve(root2 === "/" && this.opts.root !== void 0 ? this.opts.root : root2);
        const rest3 = pattern.rest();
        if (!rest3) {
          this.matches.add(t, true, false);
          continue;
        } else {
          pattern = rest3;
        }
      }
      if (t.isENOENT())
        continue;
      let p;
      let rest2;
      let changed = false;
      while (typeof (p = pattern.pattern()) === "string" && (rest2 = pattern.rest())) {
        const c = t.resolve(p);
        t = c;
        pattern = rest2;
        changed = true;
      }
      p = pattern.pattern();
      rest2 = pattern.rest();
      if (changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p === "string") {
        const ifDir = p === ".." || p === "" || p === ".";
        this.matches.add(t.resolve(p), absolute, ifDir);
        continue;
      } else if (p === GLOBSTAR) {
        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
          this.subwalks.add(t, pattern);
        }
        const rp = rest2?.pattern();
        const rrest = rest2?.rest();
        if (!rest2 || (rp === "" || rp === ".") && !rrest) {
          this.matches.add(t, absolute, rp === "" || rp === ".");
        } else {
          if (rp === "..") {
            const tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, true);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
              this.subwalks.add(tp, rrest);
            }
          }
        }
      } else if (p instanceof RegExp) {
        this.subwalks.add(t, pattern);
      }
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries3) {
    const patterns = this.subwalks.get(parent);
    const results = this.child();
    for (const e of entries3) {
      for (const pattern of patterns) {
        const absolute = pattern.isAbsolute();
        const p = pattern.pattern();
        const rest2 = pattern.rest();
        if (p === GLOBSTAR) {
          results.testGlobstar(e, pattern, rest2, absolute);
        } else if (p instanceof RegExp) {
          results.testRegExp(e, p, rest2, absolute);
        } else {
          results.testString(e, p, rest2, absolute);
        }
      }
    }
    return results;
  }
  testGlobstar(e, pattern, rest2, absolute) {
    if (this.dot || !e.name.startsWith(".")) {
      if (!pattern.hasMore()) {
        this.matches.add(e, absolute, false);
      }
      if (e.canReaddir()) {
        if (this.follow || !e.isSymbolicLink()) {
          this.subwalks.add(e, pattern);
        } else if (e.isSymbolicLink()) {
          if (rest2 && pattern.checkFollowGlobstar()) {
            this.subwalks.add(e, rest2);
          } else if (pattern.markFollowGlobstar()) {
            this.subwalks.add(e, pattern);
          }
        }
      }
    }
    if (rest2) {
      const rp = rest2.pattern();
      if (typeof rp === "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".") {
        this.testString(e, rp, rest2.rest(), absolute);
      } else if (rp === "..") {
        const ep = e.parent || e;
        this.subwalks.add(ep, rest2);
      } else if (rp instanceof RegExp) {
        this.testRegExp(e, rp, rest2.rest(), absolute);
      }
    }
  }
  testRegExp(e, p, rest2, absolute) {
    if (!p.test(e.name))
      return;
    if (!rest2) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest2);
    }
  }
  testString(e, p, rest2, absolute) {
    if (!e.isNamed(p))
      return;
    if (!rest2) {
      this.matches.add(e, absolute, false);
    } else {
      this.subwalks.add(e, rest2);
    }
  }
};

// node_modules/glob/dist/esm/walker.js
var makeIgnore = (ignore2, opts) => typeof ignore2 === "string" ? new Ignore3([ignore2], opts) : Array.isArray(ignore2) ? new Ignore3(ignore2, opts) : ignore2;
var GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = false;
  aborted = false;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  includeChildMatches;
  constructor(patterns, path14, opts) {
    this.patterns = patterns;
    this.path = path14;
    this.opts = opts;
    this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
    this.includeChildMatches = opts.includeChildMatches !== false;
    if (opts.ignore || !this.includeChildMatches) {
      this.#ignore = makeIgnore(opts.ignore ?? [], opts);
      if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
        const m = "cannot ignore child matches, ignore lacks add() method.";
        throw new Error(m);
      }
    }
    this.maxDepth = opts.maxDepth || Infinity;
    if (opts.signal) {
      this.signal = opts.signal;
      this.signal.addEventListener("abort", () => {
        this.#onResume.length = 0;
      });
    }
  }
  #ignored(path14) {
    return this.seen.has(path14) || !!this.#ignore?.ignored?.(path14);
  }
  #childrenIgnored(path14) {
    return !!this.#ignore?.childrenIgnored?.(path14);
  }
  // backpressure mechanism
  pause() {
    this.paused = true;
  }
  resume() {
    if (this.signal?.aborted)
      return;
    this.paused = false;
    let fn = void 0;
    while (!this.paused && (fn = this.#onResume.shift())) {
      fn();
    }
  }
  onResume(fn) {
    if (this.signal?.aborted)
      return;
    if (!this.paused) {
      fn();
    } else {
      this.#onResume.push(fn);
    }
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || await e.realpath();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? await e.lstat() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = await s.realpath();
      if (target && (target.isUnknown() || this.opts.stat)) {
        await target.lstat();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return void 0;
    let rpc;
    if (this.opts.realpath) {
      rpc = e.realpathCached() || e.realpathSync();
      if (!rpc)
        return void 0;
      e = rpc;
    }
    const needStat = e.isUnknown() || this.opts.stat;
    const s = needStat ? e.lstatSync() : e;
    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
      const target = s.realpathSync();
      if (target && (target?.isUnknown() || this.opts.stat)) {
        target.lstatSync();
      }
    }
    return this.matchCheckTest(s, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    if (!this.includeChildMatches && this.#ignore?.add) {
      const ign = `${e.relativePosix()}/**`;
      this.#ignore.add(ign);
    }
    const abs5 = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes) {
      this.matchEmit(e);
    } else if (abs5) {
      const abs6 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs6 + mark);
    } else {
      const rel = this.opts.posix ? e.relativePosix() : e.relative();
      const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(!rel ? "." + mark : pre + rel + mark);
    }
  }
  async match(e, absolute, ifDir) {
    const p = await this.matchCheck(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    const p = this.matchCheckSync(e, ifDir);
    if (p)
      this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next2());
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const childrenCached = t.readdirCached();
      if (t.calledReaddir())
        this.walkCB3(t, childrenCached, processor, next2);
      else {
        t.readdirCB((_, entries3) => this.walkCB3(t, entries3, processor, next2), true);
      }
    }
    next2();
  }
  walkCB3(target, entries3, processor, cb) {
    processor = processor.filterEntries(target, entries3);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      tasks++;
      this.match(m, absolute, ifDir).then(() => next2());
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2(target2, patterns, processor.child(), next2);
    }
    next2();
  }
  walkCBSync(target, patterns, cb) {
    if (this.signal?.aborted)
      cb();
    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    if (this.#childrenIgnored(target))
      return cb();
    if (this.signal?.aborted)
      cb();
    if (this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const t of processor.subwalkTargets()) {
      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
        continue;
      }
      tasks++;
      const children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next2);
    }
    next2();
  }
  walkCB3Sync(target, entries3, processor, cb) {
    processor = processor.filterEntries(target, entries3);
    let tasks = 1;
    const next2 = () => {
      if (--tasks === 0)
        cb();
    };
    for (const [m, absolute, ifDir] of processor.matches.entries()) {
      if (this.#ignored(m))
        continue;
      this.matchSync(m, absolute, ifDir);
    }
    for (const [target2, patterns] of processor.subwalks.entries()) {
      tasks++;
      this.walkCB2Sync(target2, patterns, processor.child(), next2);
    }
    next2();
  }
};
var GlobWalker = class extends GlobUtil {
  matches = /* @__PURE__ */ new Set();
  constructor(patterns, path14, opts) {
    super(patterns, path14, opts);
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      await this.path.lstat();
    }
    await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        if (this.signal?.aborted) {
          rej(this.signal.reason);
        } else {
          res(this.matches);
        }
      });
    });
    return this.matches;
  }
  walkSync() {
    if (this.signal?.aborted)
      throw this.signal.reason;
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => {
      if (this.signal?.aborted)
        throw this.signal.reason;
    });
    return this.matches;
  }
};
var GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path14, opts) {
    super(patterns, path14, opts);
    this.results = new Minipass({
      signal: this.signal,
      objectMode: true
    });
    this.results.on("drain", () => this.resume());
    this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e);
    if (!this.results.flowing)
      this.pause();
  }
  stream() {
    const target = this.path;
    if (target.isUnknown()) {
      target.lstat().then(() => {
        this.walkCB(target, this.patterns, () => this.results.end());
      });
    } else {
      this.walkCB(target, this.patterns, () => this.results.end());
    }
    return this.results;
  }
  streamSync() {
    if (this.path.isUnknown()) {
      this.path.lstatSync();
    }
    this.walkCBSync(this.path, this.patterns, () => this.results.end());
    return this.results;
  }
};

// node_modules/glob/dist/esm/glob.js
var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
var Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  includeChildMatches;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    this.withFileTypes = !!opts.withFileTypes;
    this.signal = opts.signal;
    this.follow = !!opts.follow;
    this.dot = !!opts.dot;
    this.dotRelative = !!opts.dotRelative;
    this.nodir = !!opts.nodir;
    this.mark = !!opts.mark;
    if (!opts.cwd) {
      this.cwd = "";
    } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
      opts.cwd = fileURLToPath3(opts.cwd);
    }
    this.cwd = opts.cwd || "";
    this.root = opts.root;
    this.magicalBraces = !!opts.magicalBraces;
    this.nobrace = !!opts.nobrace;
    this.noext = !!opts.noext;
    this.realpath = !!opts.realpath;
    this.absolute = opts.absolute;
    this.includeChildMatches = opts.includeChildMatches !== false;
    this.noglobstar = !!opts.noglobstar;
    this.matchBase = !!opts.matchBase;
    this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
    this.stat = !!opts.stat;
    this.ignore = opts.ignore;
    if (this.withFileTypes && this.absolute !== void 0) {
      throw new Error("cannot set absolute and withFileTypes:true");
    }
    if (typeof pattern === "string") {
      pattern = [pattern];
    }
    this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      pattern = pattern.map((p) => p.replace(/\\/g, "/"));
    }
    if (this.matchBase) {
      if (opts.noglobstar) {
        throw new TypeError("base matching requires globstar");
      }
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    this.pattern = pattern;
    this.platform = opts.platform || defaultPlatform3;
    this.opts = { ...opts, platform: this.platform };
    if (opts.scurry) {
      this.scurry = opts.scurry;
      if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
        throw new Error("nocase option contradicts provided scurry option");
      }
    } else {
      const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
    const mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: true,
      noext: this.noext,
      nonegate: true,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    };
    const mms = this.pattern.map((p) => new Minimatch(p, mmo));
    const [matchSet, globParts] = mms.reduce((set4, m) => {
      set4[0].push(...m.set);
      set4[1].push(...m.globParts);
      return set4;
    }, [[], []]);
    this.patterns = matchSet.map((set4, i) => {
      const g = globParts[i];
      if (!g)
        throw new Error("invalid pattern object");
      return new Pattern(set4, g, 0, this.platform);
    });
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
      platform: this.platform,
      nocase: this.nocase,
      includeChildMatches: this.includeChildMatches
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// node_modules/glob/dist/esm/has-magic.js
var hasMagic = (pattern, options = {}) => {
  if (!Array.isArray(pattern)) {
    pattern = [pattern];
  }
  for (const p of pattern) {
    if (new Minimatch(p, options).hasMagic())
      return true;
  }
  return false;
};

// node_modules/glob/dist/esm/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync2 = globStreamSync;
var stream2 = Object.assign(globStream, { sync: globStreamSync });
var iterateSync = globIterateSync;
var iterate2 = Object.assign(globIterate, {
  sync: globIterateSync
});
var sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
});
var glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream: stream2,
  globStreamSync,
  streamSync: streamSync2,
  globIterate,
  iterate: iterate2,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// output/Docs.Search.IndexBuilder/foreign.js
import path12 from "node:path";
import { fileURLToPath as fileURLToPath4 } from "node:url";
function getDocsSearchAppPath() {
  const fileName = fileURLToPath4(import.meta.url);
  const absoluteDir = path12.dirname(fileName);
  const basename3 = path12.basename(absoluteDir);
  if (basename3 == "Docs.Search.IndexBuilder") {
    return path12.join(absoluteDir, "..", "..", "bin", "docs-search-app.js");
  }
  if (basename3 === "bin") {
    return path12.join(absoluteDir, "docs-search-app.js");
  }
  throw new Error("cannot locate halogen bundle path");
}
function glob2(pattern) {
  return function() {
    return globSync(pattern);
  };
}

// output/Data.Profunctor.Choice/index.js
var left = function(dict) {
  return dict.left;
};
var choiceFn = {
  left: function(v) {
    return function(v1) {
      if (v1 instanceof Left) {
        return new Left(v(v1.value0));
      }
      ;
      if (v1 instanceof Right) {
        return new Right(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Profunctor.Choice (line 32, column 1 - line 35, column 16): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  right: /* @__PURE__ */ map(functorEither),
  Profunctor0: function() {
    return profunctorFn;
  }
};

// output/Data.Search.Trie.Internal/index.js
var append38 = /* @__PURE__ */ append(semigroupList);
var map87 = /* @__PURE__ */ map(functorList);
var toUnfoldableUnordered2 = /* @__PURE__ */ toUnfoldableUnordered(unfoldableList);
var map136 = /* @__PURE__ */ map(functorMaybe);
var mapFlipped17 = /* @__PURE__ */ mapFlipped(functorList);
var lmap20 = /* @__PURE__ */ lmap(bifunctorTuple);
var foldl11 = /* @__PURE__ */ foldl(foldableList);
var Branch = /* @__PURE__ */ function() {
  function Branch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Branch2.create = function(value0) {
    return function(value12) {
      return new Branch2(value0, value12);
    };
  };
  return Branch2;
}();
var Arc = /* @__PURE__ */ function() {
  function Arc2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Arc2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Arc2(value0, value12, value22);
      };
    };
  };
  return Arc2;
}();
var BranchCtx = /* @__PURE__ */ function() {
  function BranchCtx2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BranchCtx2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BranchCtx2(value0, value12, value22);
      };
    };
  };
  return BranchCtx2;
}();
var ArcCtx = /* @__PURE__ */ function() {
  function ArcCtx2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ArcCtx2.create = function(value0) {
    return function(value12) {
      return new ArcCtx2(value0, value12);
    };
  };
  return ArcCtx2;
}();
var Zipper = /* @__PURE__ */ function() {
  function Zipper2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Zipper2.create = function(value0) {
    return function(value12) {
      return new Zipper2(value0, value12);
    };
  };
  return Zipper2;
}();
var values3 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons && v1.value0 instanceof Branch) {
          $tco_var_v = function() {
            if (v1.value0.value0 instanceof Just) {
              return new Cons(v1.value0.value0.value0, v);
            }
            ;
            if (v1.value0.value0 instanceof Nothing) {
              return v;
            }
            ;
            throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 522, column 13 - line 524, column 29): " + [v1.value0.value0.constructor.name]);
          }();
          $copy_v1 = append38(values(v1.value0.value1))(v1.value1);
          return;
        }
        ;
        if (v1 instanceof Cons && v1.value0 instanceof Arc) {
          $tco_var_v = v;
          $copy_v1 = new Cons(v1.value0.value2, v1.value1);
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 520, column 5 - line 520, column 21): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  var $354 = go(Nil.value);
  return function($355) {
    return reverse2($354(singleton8($355)));
  };
}();
var size7 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons && v1.value0 instanceof Branch) {
          $tco_var_v = maybe(v)($$const(v + 1 | 0))(v1.value0.value0);
          $copy_v1 = append38(map87(snd)(toUnfoldableUnordered2(v1.value0.value1)))(v1.value1);
          return;
        }
        ;
        if (v1 instanceof Cons && v1.value0 instanceof Arc) {
          $tco_var_v = v;
          $copy_v1 = new Cons(v1.value0.value2, v1.value1);
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 137, column 5 - line 137, column 21): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  var $356 = go(0);
  return function($357) {
    return $356(singleton8($357));
  };
}();
var mkZipper = function(trie) {
  return new Zipper(trie, Nil.value);
};
var mkArc = function(v) {
  return function(v1) {
    if (v instanceof Nil) {
      return v1;
    }
    ;
    return new Arc(length6(v), v, v1);
  };
};
var longestCommonPrefixLength = function(dictEq) {
  var eq116 = eq(dictEq);
  var go = function($copy_n) {
    return function($copy_xs) {
      return function($copy_ys) {
        var $tco_var_n = $copy_n;
        var $tco_var_xs = $copy_xs;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(n, xs, ys) {
          var v = uncons4(ys);
          var v1 = uncons4(xs);
          if (v1 instanceof Just && v instanceof Just) {
            var $184 = eq116(v1.value0.head)(v.value0.head);
            if ($184) {
              $tco_var_n = n + 1 | 0;
              $tco_var_xs = v1.value0.tail;
              $copy_ys = v.value0.tail;
              return;
            }
            ;
            $tco_done = true;
            return n;
          }
          ;
          $tco_done = true;
          return n;
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_n, $tco_var_xs, $copy_ys);
        }
        ;
        return $tco_result;
      };
    };
  };
  return go(0);
};
var subtrie = function(dictOrd) {
  var longestCommonPrefixLength1 = longestCommonPrefixLength(dictOrd.Eq0());
  var lookup110 = lookup3(dictOrd);
  return function(v) {
    return function(v1) {
      if (v instanceof Nil) {
        return new Just(v1);
      }
      ;
      if (v1 instanceof Arc) {
        var prefixLength = longestCommonPrefixLength1(v)(v1.value1);
        var $189 = prefixLength === 0;
        if ($189) {
          return Nothing.value;
        }
        ;
        return subtrie(dictOrd)(drop4(prefixLength)(v))(function() {
          var $190 = prefixLength === v1.value0;
          if ($190) {
            return v1.value2;
          }
          ;
          return mkArc(drop4(prefixLength)(v1.value1))(v1.value2);
        }());
      }
      ;
      if (v instanceof Cons && v1 instanceof Branch) {
        var v2 = lookup110(v.value0)(v1.value1);
        if (v2 instanceof Just) {
          return subtrie(dictOrd)(v.value1)(v2.value0);
        }
        ;
        if (v2 instanceof Nothing) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 364, column 3 - line 366, column 23): " + [v2.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 348, column 1 - line 353, column 22): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var fromZipper = function(dictOrd) {
  var insert111 = insert2(dictOrd);
  return function(v) {
    if (v.value1 instanceof Cons) {
      if (v.value1.value0 instanceof BranchCtx) {
        return fromZipper(dictOrd)(new Zipper(new Branch(v.value1.value0.value0, insert111(v.value1.value0.value1)(v.value0)(v.value1.value0.value2)), v.value1.value1));
      }
      ;
      if (v.value1.value0 instanceof ArcCtx && v.value0 instanceof Arc) {
        return fromZipper(dictOrd)(new Zipper(new Arc(v.value1.value0.value0 + v.value0.value0 | 0, append38(v.value1.value0.value1)(v.value0.value1), v.value0.value2), v.value1.value1));
      }
      ;
      if (v.value1.value0 instanceof ArcCtx) {
        return fromZipper(dictOrd)(new Zipper(new Arc(v.value1.value0.value0, v.value1.value0.value1, v.value0), v.value1.value1));
      }
      ;
      throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 169, column 3 - line 177, column 51): " + [v.value1.value0.constructor.name, v.value0.constructor.name]);
    }
    ;
    if (v.value1 instanceof Nil) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 163, column 1 - line 167, column 14): " + [v.constructor.name]);
  };
};
var withZipper = function(dictOrd) {
  var fromZipper1 = fromZipper(dictOrd);
  return function(f) {
    return function(trie) {
      return fromZipper1(f(mkZipper(trie)));
    };
  };
};
var entriesWith = function(mapToUnfoldable) {
  return function(trie) {
    var go = function($copy_v) {
      return function($copy_v1) {
        var $tco_var_v = $copy_v;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1) {
          if (v instanceof Cons && v.value0.value0 instanceof Branch) {
            var childrenQueue = mapFlipped17(mapToUnfoldable(v.value0.value0.value1))(function(v2) {
              return new Tuple(v2.value1, new Cons(singleton8(v2.value0), v.value0.value1));
            });
            $tco_var_v = append38(childrenQueue)(v.value1);
            $copy_v1 = function() {
              if (v.value0.value0.value0 instanceof Just) {
                return new Cons(new Tuple(v.value0.value1, v.value0.value0.value0.value0), v1);
              }
              ;
              if (v.value0.value0.value0 instanceof Nothing) {
                return v1;
              }
              ;
              throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 497, column 11 - line 500, column 28): " + [v.value0.value0.value0.constructor.name]);
            }();
            return;
          }
          ;
          if (v instanceof Cons && v.value0.value0 instanceof Arc) {
            $tco_var_v = new Cons(new Tuple(v.value0.value0.value2, new Cons(v.value0.value0.value1, v.value0.value1)), v.value1);
            $copy_v1 = v1;
            return;
          }
          ;
          if (v instanceof Nil) {
            $tco_done = true;
            return v1;
          }
          ;
          throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 488, column 5 - line 490, column 41): " + [v.constructor.name, v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $copy_v1);
        }
        ;
        return $tco_result;
      };
    };
    return reverse2(map87(lmap20(function($359) {
      return concat2(reverse2($359));
    }))(go(singleton8(new Tuple(trie, Nil.value)))(Nil.value)));
  };
};
var entriesUnordered = /* @__PURE__ */ entriesWith(toUnfoldableUnordered2);
var entries2 = /* @__PURE__ */ entriesWith(/* @__PURE__ */ toUnfoldable5(unfoldableList));
var empty13 = function(dictOrd) {
  return new Branch(Nothing.value, empty4);
};
var descend = function(dictOrd) {
  var lookup110 = lookup3(dictOrd);
  var longestCommonPrefixLength1 = longestCommonPrefixLength(dictOrd.Eq0());
  return function(v) {
    return function(v1) {
      if (v instanceof Nil && v1.value0 instanceof Branch) {
        return {
          mbValue: v1.value0.value0,
          children: v1.value0.value1,
          ctxs: v1.value1
        };
      }
      ;
      if (v instanceof Cons && v1.value0 instanceof Branch) {
        var v2 = lookup110(v.value0)(v1.value0.value1);
        if (v2 instanceof Just) {
          return descend(dictOrd)(v.value1)(new Zipper(v2.value0, new Cons(new BranchCtx(v1.value0.value0, v.value0, v1.value0.value1), v1.value1)));
        }
        ;
        if (v2 instanceof Nothing) {
          var branchCtxs = new Cons(new BranchCtx(v1.value0.value0, v.value0, v1.value0.value1), v1.value1);
          var ctxs$prime = function() {
            var $308 = $$null5(v.value1);
            if ($308) {
              return branchCtxs;
            }
            ;
            return new Cons(new ArcCtx(length6(v.value1), v.value1), branchCtxs);
          }();
          return {
            mbValue: Nothing.value,
            children: empty4,
            ctxs: ctxs$prime
          };
        }
        ;
        throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 212, column 3 - line 221, column 62): " + [v2.constructor.name]);
      }
      ;
      if (v1.value0 instanceof Arc) {
        var prefixLength = longestCommonPrefixLength1(v)(v1.value0.value1);
        var $315 = prefixLength === v1.value0.value0;
        if ($315) {
          var newPath = drop4(prefixLength)(v);
          return descend(dictOrd)(newPath)(new Zipper(v1.value0.value2, new Cons(new ArcCtx(v1.value0.value0, v1.value0.value1), v1.value1)));
        }
        ;
        var $316 = prefixLength === 0;
        if ($316) {
          var v2 = uncons4(v1.value0.value1);
          if (v2 instanceof Just) {
            var len$prime = v1.value0.value0 - 1 | 0;
            var children = singleton10(v2.value0.head)(function() {
              var $318 = len$prime > 0;
              if ($318) {
                return new Arc(len$prime, v2.value0.tail, v1.value0.value2);
              }
              ;
              return v1.value0.value2;
            }());
            return descend(dictOrd)(v)(new Zipper(new Branch(Nothing.value, children), v1.value1));
          }
          ;
          if (v2 instanceof Nothing) {
            return {
              mbValue: Nothing.value,
              children: empty4,
              ctxs: v1.value1
            };
          }
          ;
          throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 232, column 7 - line 249, column 12): " + [v2.constructor.name]);
        }
        ;
        var outerArc = take4(prefixLength)(v);
        var outerArcLength = length6(outerArc);
        var newPath = drop4(prefixLength)(v);
        var innerArcLength = v1.value0.value0 - prefixLength | 0;
        var innerArc = drop4(prefixLength)(v1.value0.value1);
        return descend(dictOrd)(newPath)(new Zipper(new Arc(innerArcLength, innerArc, v1.value0.value2), function() {
          var $322 = outerArcLength === 0;
          if ($322) {
            return v1.value1;
          }
          ;
          return new Cons(new ArcCtx(outerArcLength, outerArc), v1.value1);
        }()));
      }
      ;
      throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 200, column 1 - line 208, column 7): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var insert17 = function(dictOrd) {
  var descend1 = descend(dictOrd);
  var fromZipper1 = fromZipper(dictOrd);
  return function(path14) {
    return function(value4) {
      return function(trie) {
        var v = descend1(path14)(mkZipper(trie));
        return fromZipper1(new Zipper(new Branch(new Just(value4), v.children), v.ctxs));
      };
    };
  };
};
var fromFoldable39 = function(dictOrd) {
  var insert111 = insert17(dictOrd);
  var empty1 = empty13(dictOrd);
  return function(dictFoldable) {
    var foldl110 = foldl(dictFoldable);
    return function(dictFoldable1) {
      return foldl110(flip(function() {
        var $360 = uncurry(insert111);
        var $361 = lmap20(fromFoldable6(dictFoldable1));
        return function($362) {
          return $360($361($362));
        };
      }()))(empty1);
    };
  };
};
var subtrieWithPrefixes = function(dictOrd) {
  var fromFoldable122 = fromFoldable39(dictOrd)(foldableList)(foldableList);
  var subtrie1 = subtrie(dictOrd);
  return function(path14) {
    return function(trie) {
      return map136(function() {
        var $363 = map87(lmap20(function(v) {
          return append38(path14)(v);
        }));
        return function($364) {
          return fromFoldable122($363(entriesUnordered($364)));
        };
      }())(subtrie1(path14)(trie));
    };
  };
};
var query = function(dictOrd) {
  var empty1 = empty13(dictOrd);
  var subtrieWithPrefixes1 = subtrieWithPrefixes(dictOrd);
  return function(path14) {
    var $365 = fromMaybe(empty1);
    var $366 = subtrieWithPrefixes1(path14);
    return function($367) {
      return entries2($365($366($367)));
    };
  };
};
var semigroupTrie = function(dictOrd) {
  var insert111 = insert17(dictOrd);
  return {
    append: function(a) {
      return function(b) {
        return foldl11(flip(uncurry(insert111)))(b)(entries2(a));
      };
    }
  };
};
var monoidTrie = function(dictOrd) {
  var semigroupTrie1 = semigroupTrie(dictOrd);
  return {
    mempty: empty13(dictOrd),
    Semigroup0: function() {
      return semigroupTrie1;
    }
  };
};
var prune = function(dictOrd) {
  var delete1 = $$delete2(dictOrd);
  var mempty33 = mempty(monoidTrie(dictOrd));
  return function(ctxs) {
    if (ctxs instanceof Cons && ctxs.value0 instanceof BranchCtx) {
      var newChildren = delete1(ctxs.value0.value1)(ctxs.value0.value2);
      var $333 = isJust(ctxs.value0.value0) || !isEmpty(newChildren);
      if ($333) {
        return new Zipper(new Branch(ctxs.value0.value0, newChildren), ctxs.value1);
      }
      ;
      return prune(dictOrd)(ctxs.value1);
    }
    ;
    if (ctxs instanceof Cons && ctxs.value0 instanceof ArcCtx) {
      return prune(dictOrd)(ctxs.value1);
    }
    ;
    if (ctxs instanceof Nil) {
      return mkZipper(mempty33);
    }
    ;
    throw new Error("Failed pattern match at Data.Search.Trie.Internal (line 187, column 3 - line 195, column 27): " + [ctxs.constructor.name]);
  };
};
var alter$prime = function(dictOrd) {
  var descend1 = descend(dictOrd);
  var prune1 = prune(dictOrd);
  return function(path14) {
    return function(f) {
      return function(zipper) {
        var v = descend1(path14)(zipper);
        var updatedValue = f(v.mbValue);
        var wasDeleted = isJust(v.mbValue) && (isNothing(updatedValue) && isEmpty(v.children));
        if (wasDeleted) {
          return prune1(v.ctxs);
        }
        ;
        return new Zipper(new Branch(updatedValue, v.children), v.ctxs);
      };
    };
  };
};
var alter5 = function(dictOrd) {
  var withZipper1 = withZipper(dictOrd);
  var alter$prime1 = alter$prime(dictOrd);
  return function(path14) {
    var $371 = alter$prime1(path14);
    return function($372) {
      return withZipper1($371($372));
    };
  };
};

// output/Docs.Search.Score/index.js
var insertWith2 = /* @__PURE__ */ insertWith(ordPackageName2);
var add2 = /* @__PURE__ */ add(semiringPackageScore);
var coerce14 = /* @__PURE__ */ coerce();
var one2 = /* @__PURE__ */ one(semiringPackageScore);
var zero2 = /* @__PURE__ */ zero(semiringPackageScore);
var lookup16 = /* @__PURE__ */ lookup3(ordPackageName2);
var mkScores = /* @__PURE__ */ function() {
  var updateScoresFor = function(deps) {
    return function(scores) {
      return foldr2(function(v) {
        return insertWith2(add2)(coerce14(v.value0))(one2);
      })(scores)(deps);
    };
  };
  return foldr2(function(v) {
    var $16 = updateScoresFor(v.devDependencies);
    var $17 = updateScoresFor(v.dependencies);
    return function($18) {
      return $16($17($18));
    };
  })(empty4);
}();
var getPackageScoreForPackageName = function(scores) {
  return function(p) {
    return fromMaybe(zero2)(lookup16(p)(scores));
  };
};
var getPackageScore = function(scores) {
  return function(v) {
    if (v instanceof Package) {
      return getPackageScoreForPackageName(scores)(v.value0);
    }
    ;
    if (v instanceof Builtin) {
      return 1e5;
    }
    ;
    if (v instanceof LocalPackage2) {
      return 2e5;
    }
    ;
    if (v instanceof UnknownPackage) {
      return zero2;
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.Score (line 38, column 26 - line 42, column 25): " + [v.constructor.name]);
  };
};

// output/Docs.Search.DocsJson/index.js
var wrapIso4 = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity)))();
var object8 = /* @__PURE__ */ object2();
var rowListCodecCons7 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var sourcePosCodec = /* @__PURE__ */ wrapIso4(SourcePos)(/* @__PURE__ */ named("SourcePos")(/* @__PURE__ */ object8(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons7({
  reflectSymbol: function() {
    return "line";
  }
}))()()({
  reflectSymbol: function() {
    return "column";
  }
}))({
  line: $$int,
  column: $$int
})));
var sourceSpanCodec = /* @__PURE__ */ wrapIso4(SourceSpan)(/* @__PURE__ */ named("SourceSpan")(/* @__PURE__ */ object8(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons7({
  reflectSymbol: function() {
    return "start";
  }
}))()()({
  reflectSymbol: function() {
    return "name";
  }
}))()()({
  reflectSymbol: function() {
    return "end";
  }
}))({
  start: sourcePosCodec,
  end: sourcePosCodec,
  name: string
})));

// output/Language.PureScript.AST.Declarations/index.js
var pure70 = /* @__PURE__ */ pure(applicativeEither);
var DataSig = /* @__PURE__ */ function() {
  function DataSig2() {
  }
  ;
  DataSig2.value = new DataSig2();
  return DataSig2;
}();
var NewtypeSig = /* @__PURE__ */ function() {
  function NewtypeSig2() {
  }
  ;
  NewtypeSig2.value = new NewtypeSig2();
  return NewtypeSig2;
}();
var TypeSynonymSig = /* @__PURE__ */ function() {
  function TypeSynonymSig2() {
  }
  ;
  TypeSynonymSig2.value = new TypeSynonymSig2();
  return TypeSynonymSig2;
}();
var ClassSig = /* @__PURE__ */ function() {
  function ClassSig2() {
  }
  ;
  ClassSig2.value = new ClassSig2();
  return ClassSig2;
}();
var toKindSignatureFor = /* @__PURE__ */ composeKleisli(bindEither)(toString8)(function(v) {
  if (v === "data") {
    return pure70(DataSig.value);
  }
  ;
  if (v === "newtype") {
    return pure70(NewtypeSig.value);
  }
  ;
  if (v === "class") {
    return pure70(ClassSig.value);
  }
  ;
  if (v === "type") {
    return pure70(TypeSynonymSig.value);
  }
  ;
  return new Left(new DecodeError2("Expected 'data', 'newtype', 'class', or 'type' but got '" + (v + "'")));
});

// output/Language.PureScript.AST.Operators/index.js
var associativityIsSymbol = {
  reflectSymbol: function() {
    return "associativity";
  }
};
var precedenceIsSymbol = {
  reflectSymbol: function() {
    return "precedence";
  }
};
var pure71 = /* @__PURE__ */ pure(applicativeEither);
var Infixl = /* @__PURE__ */ function() {
  function Infixl3() {
  }
  ;
  Infixl3.value = new Infixl3();
  return Infixl3;
}();
var Infixr = /* @__PURE__ */ function() {
  function Infixr3() {
  }
  ;
  Infixr3.value = new Infixr3();
  return Infixr3;
}();
var Infix = /* @__PURE__ */ function() {
  function Infix3() {
  }
  ;
  Infix3.value = new Infix3();
  return Infix3;
}();
var Fixity = function(x) {
  return x;
};
var toAssociativity = /* @__PURE__ */ composeKleisli(bindEither)(toString8)(function(v) {
  if (v === "infixl") {
    return pure71(Infixl.value);
  }
  ;
  if (v === "infixr") {
    return pure71(Infixr.value);
  }
  ;
  if (v === "infix") {
    return pure71(Infix.value);
  }
  ;
  return new Left(new DecodeError2("Expected 'infixl', 'infixr', or 'infix' but got '" + (v + "'")));
});
var toFixity = /* @__PURE__ */ toRecordN()(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(toRecordObjNil)(precedenceIsSymbol)()()())(associativityIsSymbol)()()())()(Fixity)({
  associativity: /* @__PURE__ */ toRequired(toAssociativity),
  precedence: /* @__PURE__ */ toRequired(toInt)
});

// output/Language.PureScript.Docs.RenderedCode.Types/index.js
var toFixityAlias = /* @__PURE__ */ toQualified(/* @__PURE__ */ toEitherSingle(toProperName)(/* @__PURE__ */ toEitherSingle(toIdent)(toProperName)));

// output/Language.PureScript.Constants.Prim/index.js
var m_Prim = "Prim";
var tyFunction = /* @__PURE__ */ function() {
  return new Qualified(new ByModuleName(m_Prim), "Function");
}();
var tyRow = /* @__PURE__ */ function() {
  return new Qualified(new ByModuleName(m_Prim), "Row");
}();
var tyType = /* @__PURE__ */ function() {
  return new Qualified(new ByModuleName(m_Prim), "Type");
}();

// output/Language.PureScript.PSString/foreign.js
var decodeUtf16BEImpl = (arrayOfUt16CodeUnits) => {
  const arrayBuf = new ArrayBuffer(2 * arrayOfUt16CodeUnits.length);
  const dataBuf = new DataView(arrayBuf);
  for (let i = 0; i < arrayOfUt16CodeUnits.length; i++) {
    dataBuf.setUint16(2 * i, arrayOfUt16CodeUnits[i], false);
  }
  const decoder = new TextDecoder("utf-16be", { fatal: true, ignoreBOM: false });
  try {
    return decoder.decode(dataBuf);
  } catch {
    return null;
  }
};

// output/Data.CodeUnit/index.js
var $runtime_lazy13 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var compare18 = /* @__PURE__ */ compare(ordInt);
var between3 = /* @__PURE__ */ between(ordInt);
var fromJust11 = /* @__PURE__ */ fromJust();
var div4 = /* @__PURE__ */ div(euclideanRingInt);
var mod7 = /* @__PURE__ */ mod(euclideanRingInt);
var fromEnum14 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var map88 = /* @__PURE__ */ map(functorST);
var notEq9 = /* @__PURE__ */ notEq(eqInt);
var unsafeIndex5 = /* @__PURE__ */ unsafeIndex();
var toEnum12 = /* @__PURE__ */ toEnum(boundedEnumCodePoint);
var eqCodeUnit = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordCodeUnit = {
  compare: function(x) {
    return function(y) {
      return compare18(x)(y);
    };
  },
  Eq0: function() {
    return eqCodeUnit;
  }
};
var boundedCodeUnit = {
  bottom: 0,
  top: 65535,
  Ord0: function() {
    return ordCodeUnit;
  }
};
var boundedEnumCodeUnit = {
  cardinality: 65535,
  toEnum: function(c) {
    if (between3(0)(65535)(c)) {
      return new Just(c);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.CodeUnit (line 40, column 1 - line 45, column 28): " + [c.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedCodeUnit;
  },
  Enum1: function() {
    return $lazy_enumCodeUnit(0);
  }
};
var $lazy_enumCodeUnit = /* @__PURE__ */ $runtime_lazy13("enumCodeUnit", "Data.CodeUnit", function() {
  return {
    succ: defaultSucc(toEnum(boundedEnumCodeUnit))(fromEnum(boundedEnumCodeUnit)),
    pred: defaultPred(toEnum(boundedEnumCodeUnit))(fromEnum(boundedEnumCodeUnit)),
    Ord0: function() {
      return ordCodeUnit;
    }
  };
});
var toEnum24 = /* @__PURE__ */ toEnum(boundedEnumCodeUnit);
var fromEnum15 = /* @__PURE__ */ fromEnum(boundedEnumCodeUnit);
var toCodeUnit = /* @__PURE__ */ composeKleisli(bindEither)(toInt)(/* @__PURE__ */ function() {
  var $83 = note(new DecodeError2("Value out of bounds for CodeUnit (0 <= x <= 65535)"));
  return function($84) {
    return $83(toEnum24($84));
  };
}());
var lowByte = function(v) {
  return v & 255;
};
var isTrail2 = function(l) {
  return l >= 56320 && l <= 57343;
};
var isLead2 = function(h) {
  return h >= 55296 && h <= 56319;
};
var isSurrogate = function(c) {
  return isLead2(c) || isTrail2(c);
};
var highByte = function(v) {
  return v >> 8 & 255;
};
var unpairBE = function(c) {
  return [highByte(c), lowByte(c)];
};
var fromCodeUnit = function($87) {
  return fromInt2(fromEnum15($87));
};
var divMod = function(l) {
  return function(r) {
    return new Tuple(div4(l)(r), mod7(l)(r));
  };
};
var encodeUtf16BE = function(cp) {
  var surrogatesBE = function(cpAsInt2) {
    var v2 = divMod(cpAsInt2 - 65536 | 0)(1024);
    return new Tuple(v2.value0 + 55296 | 0, v2.value1 + 56320 | 0);
  };
  var cpAsInt = fromEnum14(cp);
  var $67 = cpAsInt >= 65535;
  if ($67) {
    var v = surrogatesBE(cpAsInt);
    return [v.value0, v.value1];
  }
  ;
  return [cpAsInt];
};
var decodeUtf16BEStr = function(codeUnitToStr) {
  return function(cus) {
    return function() {
      var len = length(cus);
      var lastIdx = len - 1 | 0;
      return function __do3() {
        var str2 = {
          value: ""
        };
        var currentIdx = {
          value: 0
        };
        (function() {
          while (map88(notEq9(len))(read2(currentIdx))()) {
            (function __do4() {
              var idx = currentIdx.value;
              var v = unsafeIndex5(cus)(idx);
              var $72 = (idx + 1 | 0) <= lastIdx;
              if ($72) {
                var v1 = unsafeIndex5(cus)(idx + 1 | 0);
                var $74 = isLead2(v) && isTrail2(v1);
                if ($74) {
                  str2.value = function(s) {
                    return s + singleton7(fromJust11(toEnum12((((v - 55296 | 0) * 1024 | 0) + (v1 - 56320 | 0) | 0) + 65536 | 0)));
                  }(str2.value);
                  return currentIdx.value = idx + 2 | 0;
                }
                ;
                str2.value = function(s) {
                  return s + function() {
                    var $75 = isSurrogate(v);
                    if ($75) {
                      return codeUnitToStr(fromJust11(toEnum24(v)));
                    }
                    ;
                    return singleton7(fromJust11(toEnum12(v)));
                  }();
                }(str2.value);
                return currentIdx.value = idx + 1 | 0;
              }
              ;
              str2.value = function(s) {
                return s + function() {
                  var $76 = isSurrogate(v);
                  if ($76) {
                    return codeUnitToStr(fromJust11(toEnum24(v)));
                  }
                  ;
                  return singleton7(fromJust11(toEnum12(v)));
                }();
              }(str2.value);
              return currentIdx.value = idx + 1 | 0;
            })();
          }
          ;
          return {};
        })();
        return str2.value;
      };
    }()();
  };
};

// output/Language.PureScript.PSString/index.js
var map89 = /* @__PURE__ */ map(functorEither);
var alt28 = /* @__PURE__ */ alt(altEither);
var PSString = function(x) {
  return x;
};
var toUTF16CodeUnits = function(v) {
  return v;
};
var mkPSString = /* @__PURE__ */ function() {
  var $34 = concatMap(encodeUtf16BE);
  return function($35) {
    return PSString($34(toCodePointArray($35)));
  };
}();
var toPSString = function(j) {
  var asString = map89(mkPSString)(toString8(j));
  var asCodeUnitArray = map89(PSString)(toArray5(toCodeUnit)(j));
  return alt28(asString)(asCodeUnitArray);
};
var decodeStringWithReplacement = /* @__PURE__ */ function() {
  var $36 = decodeUtf16BEStr($$const("\uFFFD"));
  return function($37) {
    return $36(toUTF16CodeUnits($37));
  };
}();
var decodeString = /* @__PURE__ */ function() {
  var $39 = concatMap(unpairBE);
  return function($40) {
    return toMaybe(decodeUtf16BEImpl($39(toUTF16CodeUnits($40))));
  };
}();
var fromPsString = function(psStr) {
  var v = decodeString(psStr);
  if (v instanceof Just) {
    return fromString8(v.value0);
  }
  ;
  if (v instanceof Nothing) {
    return fromArray5(fromCodeUnit)(toUTF16CodeUnits(psStr));
  }
  ;
  throw new Error("Failed pattern match at Language.PureScript.PSString (line 48, column 22 - line 50, column 66): " + [v.constructor.name]);
};

// output/Language.PureScript.Label/index.js
var toLabel = /* @__PURE__ */ function() {
  var $29 = coerce();
  return function($30) {
    return $29(toPSString($30));
  };
}();
var fromLabel = /* @__PURE__ */ function() {
  var $31 = unwrap();
  return function($32) {
    return fromPsString($31($32));
  };
}();

// output/Language.PureScript.Types/index.js
var annIsSymbol = {
  reflectSymbol: function() {
    return "ann";
  }
};
var argsIsSymbol = {
  reflectSymbol: function() {
    return "args";
  }
};
var classIsSymbol = {
  reflectSymbol: function() {
    return "class";
  }
};
var dataIsSymbol = {
  reflectSymbol: function() {
    return "data";
  }
};
var kindArgsIsSymbol = {
  reflectSymbol: function() {
    return "kindArgs";
  }
};
var map90 = /* @__PURE__ */ map(functorMaybe);
var map137 = /* @__PURE__ */ map(functorArray);
var voidRight8 = /* @__PURE__ */ voidRight(functorEither);
var map226 = /* @__PURE__ */ map(functorEither);
var alt29 = /* @__PURE__ */ alt(altEither);
var pure72 = /* @__PURE__ */ pure(applicativeEither);
var toRecord3 = /* @__PURE__ */ toRecord2();
var toRecordObjCons3 = /* @__PURE__ */ toRecordObjCons(toRecordObjNil);
var bind58 = /* @__PURE__ */ bind(bindEither);
var toRecord12 = /* @__PURE__ */ toRecord3(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons3({
  reflectSymbol: function() {
    return "v";
  }
})()()())({
  reflectSymbol: function() {
    return "t";
  }
})()()())({
  reflectSymbol: function() {
    return "s";
  }
})()()())({
  reflectSymbol: function() {
    return "k";
  }
})()()())({
  reflectSymbol: function() {
    return "i";
  }
})()()());
var toRecordN3 = /* @__PURE__ */ toRecordN()(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons3(kindArgsIsSymbol)()()())(dataIsSymbol)()()())(classIsSymbol)()()())(argsIsSymbol)()()())(annIsSymbol)()()())();
var fromRecordN3 = /* @__PURE__ */ fromRecordN()(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(/* @__PURE__ */ fromRecordPropArrayCons(fromRecordPropArrayNil)(kindArgsIsSymbol)()())(dataIsSymbol)()())(classIsSymbol)()())(argsIsSymbol)()())(annIsSymbol)()())();
var HoleWildcard = /* @__PURE__ */ function() {
  function HoleWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  HoleWildcard2.create = function(value0) {
    return new HoleWildcard2(value0);
  };
  return HoleWildcard2;
}();
var UnnamedWildcard = /* @__PURE__ */ function() {
  function UnnamedWildcard2() {
  }
  ;
  UnnamedWildcard2.value = new UnnamedWildcard2();
  return UnnamedWildcard2;
}();
var IgnoredWildcard = /* @__PURE__ */ function() {
  function IgnoredWildcard2() {
  }
  ;
  IgnoredWildcard2.value = new IgnoredWildcard2();
  return IgnoredWildcard2;
}();
var TypeVarVisible = /* @__PURE__ */ function() {
  function TypeVarVisible2() {
  }
  ;
  TypeVarVisible2.value = new TypeVarVisible2();
  return TypeVarVisible2;
}();
var TypeVarInvisible = /* @__PURE__ */ function() {
  function TypeVarInvisible2() {
  }
  ;
  TypeVarInvisible2.value = new TypeVarInvisible2();
  return TypeVarInvisible2;
}();
var PartialConstraintData = /* @__PURE__ */ function() {
  function PartialConstraintData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  PartialConstraintData2.create = function(value0) {
    return function(value12) {
      return new PartialConstraintData2(value0, value12);
    };
  };
  return PartialConstraintData2;
}();
var Constraint = function(x) {
  return x;
};
var TUnknown = /* @__PURE__ */ function() {
  function TUnknown2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TUnknown2.create = function(value0) {
    return function(value12) {
      return new TUnknown2(value0, value12);
    };
  };
  return TUnknown2;
}();
var TypeVar = /* @__PURE__ */ function() {
  function TypeVar3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeVar3.create = function(value0) {
    return function(value12) {
      return new TypeVar3(value0, value12);
    };
  };
  return TypeVar3;
}();
var TypeLevelString = /* @__PURE__ */ function() {
  function TypeLevelString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeLevelString2.create = function(value0) {
    return function(value12) {
      return new TypeLevelString2(value0, value12);
    };
  };
  return TypeLevelString2;
}();
var TypeLevelInt = /* @__PURE__ */ function() {
  function TypeLevelInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeLevelInt2.create = function(value0) {
    return function(value12) {
      return new TypeLevelInt2(value0, value12);
    };
  };
  return TypeLevelInt2;
}();
var TypeWildcard = /* @__PURE__ */ function() {
  function TypeWildcard3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeWildcard3.create = function(value0) {
    return function(value12) {
      return new TypeWildcard3(value0, value12);
    };
  };
  return TypeWildcard3;
}();
var TypeConstructor = /* @__PURE__ */ function() {
  function TypeConstructor3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeConstructor3.create = function(value0) {
    return function(value12) {
      return new TypeConstructor3(value0, value12);
    };
  };
  return TypeConstructor3;
}();
var TypeOp = /* @__PURE__ */ function() {
  function TypeOp3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeOp3.create = function(value0) {
    return function(value12) {
      return new TypeOp3(value0, value12);
    };
  };
  return TypeOp3;
}();
var TypeApp = /* @__PURE__ */ function() {
  function TypeApp3(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeApp3.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeApp3(value0, value12, value22);
      };
    };
  };
  return TypeApp3;
}();
var KindApp = /* @__PURE__ */ function() {
  function KindApp2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  KindApp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new KindApp2(value0, value12, value22);
      };
    };
  };
  return KindApp2;
}();
var ForAll = /* @__PURE__ */ function() {
  function ForAll2(value0, value12, value22, value32, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  ForAll2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return new ForAll2(value0, value12, value22, value32, value4, value5);
            };
          };
        };
      };
    };
  };
  return ForAll2;
}();
var ConstrainedType = /* @__PURE__ */ function() {
  function ConstrainedType2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ConstrainedType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ConstrainedType2(value0, value12, value22);
      };
    };
  };
  return ConstrainedType2;
}();
var Skolem = /* @__PURE__ */ function() {
  function Skolem2(value0, value12, value22, value32, value4) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
  }
  ;
  Skolem2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return new Skolem2(value0, value12, value22, value32, value4);
          };
        };
      };
    };
  };
  return Skolem2;
}();
var REmpty = /* @__PURE__ */ function() {
  function REmpty2(value0) {
    this.value0 = value0;
  }
  ;
  REmpty2.create = function(value0) {
    return new REmpty2(value0);
  };
  return REmpty2;
}();
var RCons = /* @__PURE__ */ function() {
  function RCons2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  RCons2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new RCons2(value0, value12, value22, value32);
        };
      };
    };
  };
  return RCons2;
}();
var KindedType = /* @__PURE__ */ function() {
  function KindedType2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  KindedType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new KindedType2(value0, value12, value22);
      };
    };
  };
  return KindedType2;
}();
var BinaryNoParensType = /* @__PURE__ */ function() {
  function BinaryNoParensType2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  BinaryNoParensType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new BinaryNoParensType2(value0, value12, value22, value32);
        };
      };
    };
  };
  return BinaryNoParensType2;
}();
var ParensInType = /* @__PURE__ */ function() {
  function ParensInType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParensInType2.create = function(value0) {
    return function(value12) {
      return new ParensInType2(value0, value12);
    };
  };
  return ParensInType2;
}();
var functorType = {
  map: function(f) {
    return function(m) {
      if (m instanceof TUnknown) {
        return new TUnknown(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeVar) {
        return new TypeVar(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeLevelString) {
        return new TypeLevelString(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeLevelInt) {
        return new TypeLevelInt(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeWildcard) {
        return new TypeWildcard(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeConstructor) {
        return new TypeConstructor(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeOp) {
        return new TypeOp(f(m.value0), m.value1);
      }
      ;
      if (m instanceof TypeApp) {
        return new TypeApp(f(m.value0), map(functorType)(f)(m.value1), map(functorType)(f)(m.value2));
      }
      ;
      if (m instanceof KindApp) {
        return new KindApp(f(m.value0), map(functorType)(f)(m.value1), map(functorType)(f)(m.value2));
      }
      ;
      if (m instanceof ForAll) {
        return new ForAll(f(m.value0), m.value1, m.value2, map90(map(functorType)(f))(m.value3), map(functorType)(f)(m.value4), m.value5);
      }
      ;
      if (m instanceof ConstrainedType) {
        return new ConstrainedType(f(m.value0), map(functorConstraint)(f)(m.value1), map(functorType)(f)(m.value2));
      }
      ;
      if (m instanceof Skolem) {
        return new Skolem(f(m.value0), m.value1, map90(map(functorType)(f))(m.value2), m.value3, m.value4);
      }
      ;
      if (m instanceof REmpty) {
        return new REmpty(f(m.value0));
      }
      ;
      if (m instanceof RCons) {
        return new RCons(f(m.value0), m.value1, map(functorType)(f)(m.value2), map(functorType)(f)(m.value3));
      }
      ;
      if (m instanceof KindedType) {
        return new KindedType(f(m.value0), map(functorType)(f)(m.value1), map(functorType)(f)(m.value2));
      }
      ;
      if (m instanceof BinaryNoParensType) {
        return new BinaryNoParensType(f(m.value0), map(functorType)(f)(m.value1), map(functorType)(f)(m.value2), map(functorType)(f)(m.value3));
      }
      ;
      if (m instanceof ParensInType) {
        return new ParensInType(f(m.value0), map(functorType)(f)(m.value1));
      }
      ;
      throw new Error("Failed pattern match at Language.PureScript.Types (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var functorConstraint = {
  map: function(f) {
    return function(m) {
      return {
        "class": m["class"],
        data: m.data,
        ann: f(m.ann),
        args: map137(map(functorType)(f))(m.args),
        kindArgs: map137(map(functorType)(f))(m.kindArgs)
      };
    };
  }
};
var toWildcardData = function(j) {
  var unnamedWildcard = voidRight8(UnnamedWildcard.value)(toJNull(j));
  var ignoredWildcard = voidRight8(IgnoredWildcard.value)(toJObject2(j));
  var holeWildcard = map226(HoleWildcard.create)(toString8(j));
  return alt29(holeWildcard)(alt29(unnamedWildcard)(ignoredWildcard));
};
var toTypeVarVisibility = /* @__PURE__ */ composeKleisli(bindEither)(toString8)(function(v) {
  if (v === "TypeVarVisible") {
    return pure72(TypeVarVisible.value);
  }
  ;
  if (v === "TypeVarInvisible") {
    return pure72(TypeVarInvisible.value);
  }
  ;
  return new Left(new DecodeError2("Expected 'TypeVarVisible' or 'TypeVarInvisible' but got '" + (v + "'.")));
});
var toSkolemScope = /* @__PURE__ */ coerce()(toInt);
var toConstraintData = /* @__PURE__ */ function() {
  var $1730 = map226(function(v) {
    return v.contents;
  });
  var $1731 = toRecord3(toRecordObjCons3({
    reflectSymbol: function() {
      return "contents";
    }
  })()()())({
    contents: toRequired(toArray22(toArray5(toArray5(toString8)))(toBoolean2)(PartialConstraintData.create))
  });
  return function($1732) {
    return $1730($1731($1732));
  };
}();
var toType$prime = function(defaultAnn) {
  return function(toAnn) {
    return function(j) {
      var go = toType$prime(defaultAnn)(toAnn);
      return bind58(toJObject2(j))(function(o) {
        return bind58(underKey("tag")(toString8)(o))(function(tag) {
          return bind58(alt29(underKey("annotation")(toAnn)(o))(defaultAnn))(function(a) {
            var contents = function(f) {
              return underKey("contents")(f)(o);
            };
            if (tag === "TUnknown") {
              return map226(TUnknown.create(a))(contents(toInt));
            }
            ;
            if (tag === "TypeVar") {
              return map226(TypeVar.create(a))(contents(toString8));
            }
            ;
            if (tag === "TypeLevelString") {
              return map226(TypeLevelString.create(a))(contents(toPSString));
            }
            ;
            if (tag === "TypeLevelInt") {
              return map226(TypeLevelInt.create(a))(contents(toInt));
            }
            ;
            if (tag === "TypeWildcard") {
              return map226(TypeWildcard.create(a))(alt29(contents(toWildcardData))(pure72(UnnamedWildcard.value)));
            }
            ;
            if (tag === "TypeConstructor") {
              return map226(TypeConstructor.create(a))(contents(toQualified(toProperName)));
            }
            ;
            if (tag === "TypeOp") {
              return map226(TypeOp.create(a))(contents(toQualified(toOpName)));
            }
            ;
            if (tag === "TypeApp") {
              return contents(toArray22(go)(go)(TypeApp.create(a)));
            }
            ;
            if (tag === "KindApp") {
              return contents(toArray22(go)(go)(KindApp.create(a)));
            }
            ;
            if (tag === "ForAll") {
              var withoutMbKind = function(fromContents) {
                return toArray32(toString8)(go)(toNullNothingOrJust(toSkolemScope))(function(i) {
                  return function(t) {
                    return function(s) {
                      return new ForAll(a, TypeVarInvisible.value, i, Nothing.value, t, s);
                    };
                  };
                })(fromContents);
              };
              var withMbKind = function(fromContents) {
                return toArray42(toString8)(toNullNothingOrJust(go))(go)(toNullNothingOrJust(toSkolemScope))(function(i) {
                  return function(k) {
                    return function(t) {
                      return function(s) {
                        return new ForAll(a, TypeVarInvisible.value, i, k, t, s);
                      };
                    };
                  };
                })(fromContents);
              };
              var asObject = function(fromContents) {
                return bind58(toRecord12({
                  v: toRequiredRename("visibility")(toTypeVarVisibility),
                  i: toRequiredRename("identifier")(toString8),
                  k: toOptionDefaultRename("kind")(Nothing.value)(toNullNothingOrJust(go)),
                  t: toRequiredRename("type")(go),
                  s: toRequiredRename("skolem")(toNullNothingOrJust(toSkolemScope))
                })(fromContents))(function(v) {
                  return pure72(new ForAll(a, v.v, v.i, v.k, v.t, v.s));
                });
              };
              return contents(altAccumulate(altAccumulate(asObject)(withMbKind))(withoutMbKind));
            }
            ;
            if (tag === "ConstrainedType") {
              return contents(toArray22(toConstraint$prime(defaultAnn)(toAnn))(go)(ConstrainedType.create(a)));
            }
            ;
            if (tag === "Skolem") {
              return contents(toArray42(toString8)(toNullNothingOrJust(go))(toInt)(toSkolemScope)(Skolem.create(a)));
            }
            ;
            if (tag === "REmpty") {
              return pure72(new REmpty(a));
            }
            ;
            if (tag === "RCons") {
              return contents(toArray32(toLabel)(go)(go)(RCons.create(a)));
            }
            ;
            if (tag === "KindedType") {
              return contents(toArray22(go)(go)(KindedType.create(a)));
            }
            ;
            if (tag === "BinaryNoParensType") {
              return contents(toArray32(go)(go)(go)(BinaryNoParensType.create(a)));
            }
            ;
            if (tag === "ParensInType") {
              return map226(ParensInType.create(a))(contents(go));
            }
            ;
            if (tag === "KUnknown") {
              return map226(TUnknown.create(a))(contents(toInt));
            }
            ;
            if (tag === "Row") {
              return map226(TypeApp.create(a)(new TypeConstructor(a, tyRow)))(contents(go));
            }
            ;
            if (tag === "FunKind") {
              return contents(toArray22(go)(go)(function(b) {
                return function(c) {
                  return new TypeApp(a, new TypeApp(a, new TypeConstructor(a, tyFunction), b), c);
                };
              }));
            }
            ;
            if (tag === "NamedKind") {
              return map226(TypeConstructor.create(a))(contents(toQualified(toProperName)));
            }
            ;
            return new Left(new DecodeError2("Unexpected value for `declType`: " + tag));
          });
        });
      });
    };
  };
};
var toConstraint$prime = function(defaultAnn) {
  return function(toAnn) {
    return toRecordN3(Constraint)({
      ann: function(lookup21, v) {
        return alt29(maybe(defaultAnn)(toAnn)(lookup21("constraintAnn")))(defaultAnn);
      },
      "class": toRequiredRename("constraintClass")(toQualified(toProperName)),
      kindArgs: toOptionDefaultRename("constraintKindArgs")([])(toArray5(toType$prime(defaultAnn)(toAnn))),
      args: toRequiredRename("constraintArgs")(toArray5(toType$prime(defaultAnn)(toAnn))),
      data: toRequiredRename("constraintData")(toNullNothingOrJust(toConstraintData))
    });
  };
};
var toConstraintUnit = function(toAnn) {
  return toConstraint$prime(pure72(unit))(toAnn);
};
var toTypeUnit = /* @__PURE__ */ toType$prime(/* @__PURE__ */ pure72(unit))(toJNull);
var srcTypeConstructor = /* @__PURE__ */ function() {
  return TypeConstructor.create(nullSourceAnn);
}();
var fromWildcardData = function(v) {
  if (v instanceof HoleWildcard) {
    return fromString8(v.value0);
  }
  ;
  if (v instanceof UnnamedWildcard) {
    return fromJNull;
  }
  ;
  if (v instanceof IgnoredWildcard) {
    return fromObjSingleton("ignored")(fromBoolean2(true));
  }
  ;
  throw new Error("Failed pattern match at Language.PureScript.Types (line 55, column 20 - line 58, column 77): " + [v.constructor.name]);
};
var fromTypeVarVisibility = function($1733) {
  return fromString8(function(v) {
    if (v instanceof TypeVarVisible) {
      return "TypeVarVisible";
    }
    ;
    if (v instanceof TypeVarInvisible) {
      return "TypeVarInvisible";
    }
    ;
    throw new Error("Failed pattern match at Language.PureScript.Types (line 78, column 45 - line 80, column 41): " + [v.constructor.name]);
  }($1733));
};
var fromSkolemScope = /* @__PURE__ */ function() {
  var $1734 = unwrap();
  return function($1735) {
    return fromInt2($1734($1735));
  };
}();
var fromConstraintData = function(v) {
  return fromObjSingleton("contents")(fromArray22(fromArray5(fromArray5(fromString8))(v.value0))(fromBoolean2(v.value1)));
};
var fromType = function(fromAnn) {
  return function(ty) {
    var variant2 = function(tag) {
      return function(ann) {
        return function(contents) {
          return fromPropArray([new Tuple("tag", fromString8(tag)), new Tuple("annotation", fromAnn(ann)), new Tuple("contents", contents)]);
        };
      };
    };
    var nullary = function(tag) {
      return function(ann) {
        return fromPropArray([new Tuple("tag", fromString8(tag)), new Tuple("annotation", fromAnn(ann))]);
      };
    };
    var go = fromType(fromAnn);
    if (ty instanceof TUnknown) {
      return variant2("TUnknown")(ty.value0)(fromInt2(ty.value1));
    }
    ;
    if (ty instanceof TypeVar) {
      return variant2("TypeVar")(ty.value0)(fromString8(ty.value1));
    }
    ;
    if (ty instanceof TypeLevelString) {
      return variant2("TypeLevelString")(ty.value0)(fromPsString(ty.value1));
    }
    ;
    if (ty instanceof TypeLevelInt) {
      return variant2("TypeLevelInt")(ty.value0)(fromInt2(ty.value1));
    }
    ;
    if (ty instanceof TypeWildcard) {
      return variant2("TypeWildcard")(ty.value0)(fromWildcardData(ty.value1));
    }
    ;
    if (ty instanceof TypeConstructor) {
      return variant2("TypeConstructor")(ty.value0)(fromQualified(fromProperName)(ty.value1));
    }
    ;
    if (ty instanceof TypeOp) {
      return variant2("TypeOp")(ty.value0)(fromQualified(fromOpName)(ty.value1));
    }
    ;
    if (ty instanceof TypeApp) {
      return variant2("TypeApp")(ty.value0)(fromArray22(go(ty.value1))(go(ty.value2)));
    }
    ;
    if (ty instanceof KindApp) {
      return variant2("KindApp")(ty.value0)(fromArray22(go(ty.value1))(go(ty.value2)));
    }
    ;
    if (ty instanceof ForAll) {
      return variant2("ForAll")(ty.value0)(fromPropArray([new Tuple("visibility", fromTypeVarVisibility(ty.value1)), new Tuple("identifier", fromString8(ty.value2)), new Tuple("kind", fromNullNothingOrJust(go)(ty.value3)), new Tuple("type", go(ty.value4)), new Tuple("skolem", fromNullNothingOrJust(fromSkolemScope)(ty.value5))]));
    }
    ;
    if (ty instanceof ConstrainedType) {
      return variant2("ConstrainedType")(ty.value0)(fromArray22(fromConstraint(fromAnn)(ty.value1))(go(ty.value2)));
    }
    ;
    if (ty instanceof Skolem) {
      return variant2("Skolem")(ty.value0)(fromArray42(fromString8(ty.value1))(fromNullNothingOrJust(go)(ty.value2))(fromInt2(ty.value3))(fromSkolemScope(ty.value4)));
    }
    ;
    if (ty instanceof REmpty) {
      return nullary("REmpty")(ty.value0);
    }
    ;
    if (ty instanceof RCons) {
      return variant2("RCons")(ty.value0)(fromArray32(fromLabel(ty.value1))(go(ty.value2))(go(ty.value3)));
    }
    ;
    if (ty instanceof KindedType) {
      return variant2("KindedType")(ty.value0)(fromArray22(go(ty.value1))(go(ty.value2)));
    }
    ;
    if (ty instanceof BinaryNoParensType) {
      return variant2("BinaryNoParensType")(ty.value0)(fromArray32(go(ty.value1))(go(ty.value2))(go(ty.value3)));
    }
    ;
    if (ty instanceof ParensInType) {
      return variant2("ParensInType")(ty.value0)(go(ty.value1));
    }
    ;
    throw new Error("Failed pattern match at Language.PureScript.Types (line 121, column 3 - line 161, column 38): " + [ty.constructor.name]);
  };
};
var fromConstraint = function(fromAnn) {
  return fromRecordN3(Constraint)({
    ann: fromRequiredRename("constraintAnn")(fromAnn),
    "class": fromRequiredRename("constraintClass")(fromQualified(fromProperName)),
    kindArgs: fromRequiredRename("constraintKindArgs")(fromArray5(fromType(fromAnn))),
    args: fromRequiredRename("constraintArgs")(fromArray5(fromType(fromAnn))),
    data: fromRequiredRename("constraintData")(fromNullNothingOrJust(fromConstraintData))
  });
};

// output/Language.PureScript.Environment/index.js
var pure73 = /* @__PURE__ */ pure(applicativeEither);
var Data = /* @__PURE__ */ function() {
  function Data2() {
  }
  ;
  Data2.value = new Data2();
  return Data2;
}();
var Newtype = /* @__PURE__ */ function() {
  function Newtype2() {
  }
  ;
  Newtype2.value = new Newtype2();
  return Newtype2;
}();
var toDataDeclType = /* @__PURE__ */ composeKleisli(bindEither)(toString8)(function(v) {
  if (v === "data") {
    return pure73(Data.value);
  }
  ;
  if (v === "newtype") {
    return pure73(Newtype.value);
  }
  ;
  return new Left(new DecodeError2("Expected 'data' or 'newtype' but got '" + (v + "'.")));
});
var showDataDeclType = function(v) {
  if (v instanceof Data) {
    return "data";
  }
  ;
  if (v instanceof Newtype) {
    return "newtype";
  }
  ;
  throw new Error("Failed pattern match at Language.PureScript.Environment (line 22, column 1 - line 22, column 43): " + [v.constructor.name]);
};
var kindType = /* @__PURE__ */ srcTypeConstructor(tyType);
var fromDataDeclType = function($25) {
  return fromString8(showDataDeclType($25));
};

// output/Language.PureScript.Role/index.js
var pure74 = /* @__PURE__ */ pure(applicativeEither);
var Nominal = /* @__PURE__ */ function() {
  function Nominal3() {
  }
  ;
  Nominal3.value = new Nominal3();
  return Nominal3;
}();
var Representational = /* @__PURE__ */ function() {
  function Representational3() {
  }
  ;
  Representational3.value = new Representational3();
  return Representational3;
}();
var Phantom = /* @__PURE__ */ function() {
  function Phantom3() {
  }
  ;
  Phantom3.value = new Phantom3();
  return Phantom3;
}();
var toRole = /* @__PURE__ */ composeKleisli(bindEither)(toString8)(function(v) {
  if (v === "Representational") {
    return pure74(Representational.value);
  }
  ;
  if (v === "Nominal") {
    return pure74(Nominal.value);
  }
  ;
  if (v === "Phantom") {
    return pure74(Phantom.value);
  }
  ;
  return new Left(new DecodeError2("Expected 'Representational', 'Nominal', or 'Phantom', but got '" + (v + "'.")));
});

// output/Language.PureScript.Docs.Types/index.js
var keywordIsSymbol = {
  reflectSymbol: function() {
    return "keyword";
  }
};
var kindIsSymbol = {
  reflectSymbol: function() {
    return "kind";
  }
};
var titleIsSymbol = {
  reflectSymbol: function() {
    return "title";
  }
};
var commentsIsSymbol = {
  reflectSymbol: function() {
    return "comments";
  }
};
var infoIsSymbol = {
  reflectSymbol: function() {
    return "info";
  }
};
var sourceSpanIsSymbol = {
  reflectSymbol: function() {
    return "sourceSpan";
  }
};
var childrenIsSymbol = {
  reflectSymbol: function() {
    return "children";
  }
};
var declarationsIsSymbol = {
  reflectSymbol: function() {
    return "declarations";
  }
};
var nameIsSymbol3 = {
  reflectSymbol: function() {
    return "name";
  }
};
var reExportsIsSymbol = {
  reflectSymbol: function() {
    return "reExports";
  }
};
var toRecordN4 = /* @__PURE__ */ toRecordN();
var toRecordObjCons4 = /* @__PURE__ */ toRecordObjCons(toRecordObjNil);
var toRecord4 = /* @__PURE__ */ toRecord2();
var toRecord13 = /* @__PURE__ */ toRecord4(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons4({
  reflectSymbol: function() {
    return "package";
  }
})()()())({
  reflectSymbol: function() {
    return "item";
  }
})()()());
var map91 = /* @__PURE__ */ map(functorEither);
var coerce15 = /* @__PURE__ */ coerce();
var bind59 = /* @__PURE__ */ bind(bindEither);
var apply23 = /* @__PURE__ */ apply2(applyEither);
var toRecordObjCons1 = /* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons4(titleIsSymbol)()()())(sourceSpanIsSymbol)()()());
var alt30 = /* @__PURE__ */ alt(altEither);
var pure75 = /* @__PURE__ */ pure(applicativeEither);
var $$void18 = /* @__PURE__ */ $$void(functorType);
var map138 = /* @__PURE__ */ map(functorFn);
var KindInfo = function(x) {
  return x;
};
var Local2 = /* @__PURE__ */ function() {
  function Local3(value0) {
    this.value0 = value0;
  }
  ;
  Local3.create = function(value0) {
    return new Local3(value0);
  };
  return Local3;
}();
var FromDep = /* @__PURE__ */ function() {
  function FromDep2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FromDep2.create = function(value0) {
    return function(value12) {
      return new FromDep2(value0, value12);
    };
  };
  return FromDep2;
}();
var ValueDeclaration = /* @__PURE__ */ function() {
  function ValueDeclaration2(value0) {
    this.value0 = value0;
  }
  ;
  ValueDeclaration2.create = function(value0) {
    return new ValueDeclaration2(value0);
  };
  return ValueDeclaration2;
}();
var DataDeclaration = /* @__PURE__ */ function() {
  function DataDeclaration2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DataDeclaration2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DataDeclaration2(value0, value12, value22);
      };
    };
  };
  return DataDeclaration2;
}();
var ExternDataDeclaration = /* @__PURE__ */ function() {
  function ExternDataDeclaration2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExternDataDeclaration2.create = function(value0) {
    return function(value12) {
      return new ExternDataDeclaration2(value0, value12);
    };
  };
  return ExternDataDeclaration2;
}();
var TypeSynonymDeclaration = /* @__PURE__ */ function() {
  function TypeSynonymDeclaration2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeSynonymDeclaration2.create = function(value0) {
    return function(value12) {
      return new TypeSynonymDeclaration2(value0, value12);
    };
  };
  return TypeSynonymDeclaration2;
}();
var TypeClassDeclaration = /* @__PURE__ */ function() {
  function TypeClassDeclaration2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeClassDeclaration2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeClassDeclaration2(value0, value12, value22);
      };
    };
  };
  return TypeClassDeclaration2;
}();
var AliasDeclaration = /* @__PURE__ */ function() {
  function AliasDeclaration2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AliasDeclaration2.create = function(value0) {
    return function(value12) {
      return new AliasDeclaration2(value0, value12);
    };
  };
  return AliasDeclaration2;
}();
var ChildInstance = /* @__PURE__ */ function() {
  function ChildInstance2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ChildInstance2.create = function(value0) {
    return function(value12) {
      return new ChildInstance2(value0, value12);
    };
  };
  return ChildInstance2;
}();
var ChildDataConstructor = /* @__PURE__ */ function() {
  function ChildDataConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  ChildDataConstructor2.create = function(value0) {
    return new ChildDataConstructor2(value0);
  };
  return ChildDataConstructor2;
}();
var ChildTypeClassMember = /* @__PURE__ */ function() {
  function ChildTypeClassMember2(value0) {
    this.value0 = value0;
  }
  ;
  ChildTypeClassMember2.create = function(value0) {
    return new ChildTypeClassMember2(value0);
  };
  return ChildTypeClassMember2;
}();
var ChildDeclaration = function(x) {
  return x;
};
var Declaration = function(x) {
  return x;
};
var DocModule = function(x) {
  return x;
};
var toTypeArguments = /* @__PURE__ */ toArray5(/* @__PURE__ */ toTuple(toString8)(/* @__PURE__ */ toNullNothingOrJust(toTypeUnit)));
var toKindInfo = /* @__PURE__ */ toRecordN4(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons4(kindIsSymbol)()()())(keywordIsSymbol)()()())()(KindInfo)({
  keyword: /* @__PURE__ */ toRequired(toKindSignatureFor),
  kind: /* @__PURE__ */ toRequired(toTypeUnit)
});
var toInPackage = function(toInner) {
  var $1817 = map91(function(v) {
    return maybe(new Local2(v.item))(flip(FromDep.create)(v.item))(v["package"]);
  });
  var $1818 = toRecord13({
    "package": toOptionDefault(Nothing.value)(toNullNothingOrJust(toPackageName)),
    item: toRequired(toInner)
  });
  return function($1819) {
    return $1817($1818($1819));
  };
};
var toFunDeps = /* @__PURE__ */ toArray5(/* @__PURE__ */ toTuple(/* @__PURE__ */ toArray5(toString8))(/* @__PURE__ */ toArray5(toString8)));
var toAsConstrantUnit = /* @__PURE__ */ function() {
  return toRecordN4(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons4({
    reflectSymbol: function() {
      return "kindArgs";
    }
  })()()())({
    reflectSymbol: function() {
      return "data";
    }
  })()()())({
    reflectSymbol: function() {
      return "class";
    }
  })()()())({
    reflectSymbol: function() {
      return "args";
    }
  })()()())({
    reflectSymbol: function() {
      return "ann";
    }
  })()()())()(Constraint)({
    ann: toStatic(unit),
    "class": toRequiredRename("constraintClass")(toQualified(toProperName)),
    kindArgs: toOptionDefaultRename("constraintKindArgs")([])(toArray5(toTypeUnit)),
    args: toRequiredRename("constraintArgs")(toArray5(toTypeUnit)),
    data: toStatic(Nothing.value)
  });
}();
var toChildDeclarationInfo = function(j) {
  return bind59(toJObject2(j))(function(jo) {
    return bind59(underKey("declType")(toString8)(jo))(function(declType) {
      if (declType === "instance") {
        return apply23(map91(ChildInstance.create)(underKey("dependencies")(toArray5(toAsConstrantUnit))(jo)))(underKey("type")(toTypeUnit)(jo));
      }
      ;
      if (declType === "dataConstructor") {
        return map91(ChildDataConstructor.create)(underKey("arguments")(toArray5(toTypeUnit))(jo));
      }
      ;
      if (declType === "typeClassMember") {
        return map91(ChildTypeClassMember.create)(underKey("type")(toTypeUnit)(jo));
      }
      ;
      return new Left(new DecodeError2("Expected 'instance', 'dataConstructor', or 'typeClassMember' but got '" + (declType + "'.")));
    });
  });
};
var toChildDeclaration = /* @__PURE__ */ toRecordN4(/* @__PURE__ */ toRecordObjCons(/* @__PURE__ */ toRecordObjCons1(infoIsSymbol)()()())(commentsIsSymbol)()()())()(ChildDeclaration)({
  title: /* @__PURE__ */ toRequired(toString8),
  comments: /* @__PURE__ */ toRequired(/* @__PURE__ */ toNullNothingOrJust(toString8)),
  sourceSpan: /* @__PURE__ */ toRequired(/* @__PURE__ */ toNullNothingOrJust(toSourceSpan)),
  info: /* @__PURE__ */ toRequired(toChildDeclarationInfo)
});
var toDeclarationInfo = function(j) {
  return bind59(toJObject2(j))(function(jo) {
    return bind59(underKey("declType")(toString8)(jo))(function(declType) {
      if (declType === "value") {
        return map91(ValueDeclaration.create)(underKey("type")(toTypeUnit)(jo));
      }
      ;
      if (declType === "data") {
        return apply23(apply23(map91(DataDeclaration.create)(underKey("dataDeclType")(toDataDeclType)(jo)))(underKey("typeArguments")(toTypeArguments)(jo)))(alt30(underKey("roles")(toArray5(toRole))(jo))(pure75([])));
      }
      ;
      if (declType === "externData") {
        return apply23(map91(ExternDataDeclaration.create)(underKey("kind")(toTypeUnit)(jo)))(alt30(underKey("roles")(toArray5(toRole))(jo))(pure75([])));
      }
      ;
      if (declType === "typeSynonym") {
        return apply23(map91(TypeSynonymDeclaration.create)(underKey("arguments")(toTypeArguments)(jo)))(underKey("type")(toTypeUnit)(jo));
      }
      ;
      if (declType === "typeClass") {
        return apply23(apply23(map91(TypeClassDeclaration.create)(underKey("arguments")(toTypeArguments)(jo)))(underKey("superclasses")(toArray5(toAsConstrantUnit))(jo)))(alt30(underKey("fundeps")(toFunDeps)(jo))(pure75([])));
      }
      ;
      if (declType === "alias") {
        return apply23(map91(AliasDeclaration.create)(underKey("fixity")(toFixity)(jo)))(underKey("alias")(toFixityAlias)(jo));
      }
      ;
      if (declType === "kind") {
        return pure75(new ExternDataDeclaration($$void18(kindType), []));
      }
      ;
      return new Left(new DecodeError2("Expected 'instance', 'dataConstructor', or 'typeClassMember' but got '" + (declType + "'.")));
    });
  });
};
var toDeclaration = /* @__PURE__ */ function() {
  return toRecordN4(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons1(kindIsSymbol)()()())(infoIsSymbol)()()())(commentsIsSymbol)()()())(childrenIsSymbol)()()())()(Declaration)({
    title: toRequired(toString8),
    comments: toRequired(toNullNothingOrJust(toString8)),
    sourceSpan: toRequired(toNullNothingOrJust(toSourceSpan)),
    children: toRequired(toArray5(toChildDeclaration)),
    info: toRequired(toDeclarationInfo),
    kind: toOptionDefault(Nothing.value)(toNullNothingOrJust(toKindInfo))
  });
}();
var toDocModule = /* @__PURE__ */ function() {
  var toAsRexportModuleName = altAccumulate(toInPackage(toModuleName))(map138(map91(Local2.create))(toModuleName));
  var toAsReExport = function() {
    var $1822 = map91(function(v) {
      return new Tuple(v.moduleName, v.declarations);
    });
    var $1823 = toRecord4(toRecordObjCons(toRecordObjCons4({
      reflectSymbol: function() {
        return "moduleName";
      }
    })()()())(declarationsIsSymbol)()()())({
      moduleName: toRequired(toAsRexportModuleName),
      declarations: toRequired(toArray5(toDeclaration))
    });
    return function($1824) {
      return $1822($1823($1824));
    };
  }();
  return toRecordN4(toRecordObjCons(toRecordObjCons(toRecordObjCons(toRecordObjCons4(reExportsIsSymbol)()()())(nameIsSymbol3)()()())(declarationsIsSymbol)()()())(commentsIsSymbol)()()())()(DocModule)({
    name: toRequired(function($1825) {
      return coerce15(toString8($1825));
    }),
    comments: toRequired(toNullNothingOrJust(toString8)),
    declarations: toRequired(toArray5(toDeclaration)),
    reExports: toRequired(toArray5(toAsReExport))
  });
}();

// output/Docs.Search.TypeDecoder/index.js
var toArgonaut = unsafeCoerce2;
var funDepsCodec = /* @__PURE__ */ function() {
  var typeVarsCodec = array(string);
  return array(tuple(typeVarsCodec)(typeVarsCodec));
}();
var fromArgonaut = unsafeCoerce2;
var qualifiedNameCodec = /* @__PURE__ */ codec$prime(/* @__PURE__ */ fromUni(/* @__PURE__ */ toQualified(toProperName)))(/* @__PURE__ */ function() {
  var $15 = fromQualified(fromProperName);
  return function($16) {
    return fromArgonaut($15($16));
  };
}());
var typeCodec = /* @__PURE__ */ codec$prime(/* @__PURE__ */ fromUni(toTypeUnit))(/* @__PURE__ */ function() {
  var $17 = fromType(function(v) {
    return toArgonaut($$null3);
  });
  return function($18) {
    return fromArgonaut($17($18));
  };
}());
var typeArgumentCodec = /* @__PURE__ */ named("TypeArgument")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "name";
  }
}))()()({
  reflectSymbol: function() {
    return "kind";
  }
}))({
  name: string,
  kind: /* @__PURE__ */ optional4(typeCodec)
}));
var dataDeclTypeCodec = /* @__PURE__ */ codec$prime(/* @__PURE__ */ fromUni(toDataDeclType))(function($19) {
  return fromArgonaut(fromDataDeclType($19));
});
var constraintCodec = /* @__PURE__ */ codec$prime(/* @__PURE__ */ fromUni(/* @__PURE__ */ toConstraintUnit(toJNull)))(/* @__PURE__ */ function() {
  var $20 = fromConstraint(function(v) {
    return toArgonaut($$null3);
  });
  return function($21) {
    return fromArgonaut($20($21));
  };
}());

// output/Docs.Search.SearchResult/index.js
var inject5 = /* @__PURE__ */ inject();
var dataIsSymbol2 = {
  reflectSymbol: function() {
    return "data";
  }
};
var inject12 = /* @__PURE__ */ inject5(dataIsSymbol2);
var externDataIsSymbol = {
  reflectSymbol: function() {
    return "externData";
  }
};
var inject23 = /* @__PURE__ */ inject5(externDataIsSymbol);
var typeSynonymIsSymbol = {
  reflectSymbol: function() {
    return "typeSynonym";
  }
};
var inject32 = /* @__PURE__ */ inject5(typeSynonymIsSymbol);
var dataConstructorIsSymbol = {
  reflectSymbol: function() {
    return "dataConstructor";
  }
};
var inject42 = /* @__PURE__ */ inject5(dataConstructorIsSymbol);
var typeClassMemberIsSymbol = {
  reflectSymbol: function() {
    return "typeClassMember";
  }
};
var inject52 = /* @__PURE__ */ inject5(typeClassMemberIsSymbol);
var typeClassIsSymbol = {
  reflectSymbol: function() {
    return "typeClass";
  }
};
var inject6 = /* @__PURE__ */ inject5(typeClassIsSymbol);
var valueIsSymbol = {
  reflectSymbol: function() {
    return "value";
  }
};
var inject7 = /* @__PURE__ */ inject5(valueIsSymbol);
var valueAliasIsSymbol = {
  reflectSymbol: function() {
    return "valueAlias";
  }
};
var inject8 = /* @__PURE__ */ inject5(valueAliasIsSymbol);
var typeAliasIsSymbol = {
  reflectSymbol: function() {
    return "typeAlias";
  }
};
var inject9 = /* @__PURE__ */ inject5(typeAliasIsSymbol);
var externKindIsSymbol = {
  reflectSymbol: function() {
    return "externKind";
  }
};
var inject10 = /* @__PURE__ */ inject5(externKindIsSymbol);
var profunctorCodec4 = /* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity));
var object9 = /* @__PURE__ */ object2();
var rowListCodecCons8 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var dataDeclTypeIsSymbol = {
  reflectSymbol: function() {
    return "dataDeclType";
  }
};
var typeIsSymbol3 = {
  reflectSymbol: function() {
    return "type";
  }
};
var rowListCodecCons1 = /* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons8(typeIsSymbol3))()();
var argumentsIsSymbol = {
  reflectSymbol: function() {
    return "arguments";
  }
};
var wrapIso5 = /* @__PURE__ */ wrapIso(profunctorCodec4)();
var DataResult = /* @__PURE__ */ function() {
  function DataResult2(value0) {
    this.value0 = value0;
  }
  ;
  DataResult2.create = function(value0) {
    return new DataResult2(value0);
  };
  return DataResult2;
}();
var ExternDataResult = /* @__PURE__ */ function() {
  function ExternDataResult2(value0) {
    this.value0 = value0;
  }
  ;
  ExternDataResult2.create = function(value0) {
    return new ExternDataResult2(value0);
  };
  return ExternDataResult2;
}();
var TypeSynonymResult = /* @__PURE__ */ function() {
  function TypeSynonymResult2(value0) {
    this.value0 = value0;
  }
  ;
  TypeSynonymResult2.create = function(value0) {
    return new TypeSynonymResult2(value0);
  };
  return TypeSynonymResult2;
}();
var DataConstructorResult = /* @__PURE__ */ function() {
  function DataConstructorResult2(value0) {
    this.value0 = value0;
  }
  ;
  DataConstructorResult2.create = function(value0) {
    return new DataConstructorResult2(value0);
  };
  return DataConstructorResult2;
}();
var TypeClassMemberResult = /* @__PURE__ */ function() {
  function TypeClassMemberResult2(value0) {
    this.value0 = value0;
  }
  ;
  TypeClassMemberResult2.create = function(value0) {
    return new TypeClassMemberResult2(value0);
  };
  return TypeClassMemberResult2;
}();
var TypeClassResult = /* @__PURE__ */ function() {
  function TypeClassResult2(value0) {
    this.value0 = value0;
  }
  ;
  TypeClassResult2.create = function(value0) {
    return new TypeClassResult2(value0);
  };
  return TypeClassResult2;
}();
var ValueResult = /* @__PURE__ */ function() {
  function ValueResult2(value0) {
    this.value0 = value0;
  }
  ;
  ValueResult2.create = function(value0) {
    return new ValueResult2(value0);
  };
  return ValueResult2;
}();
var ValueAliasResult = /* @__PURE__ */ function() {
  function ValueAliasResult2() {
  }
  ;
  ValueAliasResult2.value = new ValueAliasResult2();
  return ValueAliasResult2;
}();
var TypeAliasResult = /* @__PURE__ */ function() {
  function TypeAliasResult2() {
  }
  ;
  TypeAliasResult2.value = new TypeAliasResult2();
  return TypeAliasResult2;
}();
var ExternKindResult = /* @__PURE__ */ function() {
  function ExternKindResult2() {
  }
  ;
  ExternKindResult2.value = new ExternKindResult2();
  return ExternKindResult2;
}();
var SearchResult = function(x) {
  return x;
};
var resultInfoCodec = /* @__PURE__ */ function() {
  var toVariant = function(v) {
    if (v instanceof DataResult) {
      return inject12(v.value0);
    }
    ;
    if (v instanceof ExternDataResult) {
      return inject23(v.value0.kind);
    }
    ;
    if (v instanceof TypeSynonymResult) {
      return inject32(v.value0);
    }
    ;
    if (v instanceof DataConstructorResult) {
      return inject42(v.value0);
    }
    ;
    if (v instanceof TypeClassMemberResult) {
      return inject52(v.value0);
    }
    ;
    if (v instanceof TypeClassResult) {
      return inject6(v.value0);
    }
    ;
    if (v instanceof ValueResult) {
      return inject7(v.value0.type);
    }
    ;
    if (v instanceof ValueAliasResult) {
      return inject8(unit);
    }
    ;
    if (v instanceof TypeAliasResult) {
      return inject9(unit);
    }
    ;
    if (v instanceof ExternKindResult) {
      return inject10(unit);
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.SearchResult (line 88, column 15 - line 98, column 50): " + [v.constructor.name]);
  };
  var fromVariant = match2()()()({
    data: DataResult.create,
    externData: function(arg) {
      return new ExternDataResult({
        kind: arg
      });
    },
    typeSynonym: TypeSynonymResult.create,
    dataConstructor: DataConstructorResult.create,
    typeClassMember: TypeClassMemberResult.create,
    typeClass: TypeClassResult.create,
    value: function(arg) {
      return new ValueResult({
        type: arg
      });
    },
    valueAlias: $$const(ValueAliasResult.value),
    typeAlias: $$const(TypeAliasResult.value),
    externKind: $$const(ExternKindResult.value)
  });
  return dimap(profunctorCodec4)(toVariant)(fromVariant)(variantMatch()(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecCons(variantCodecNil)()()(valueAliasIsSymbol)(refl))()()(valueIsSymbol)(refl))()()(typeSynonymIsSymbol)(refl))()()(typeClassMemberIsSymbol)(refl))()()(typeClassIsSymbol)(refl))()()(typeAliasIsSymbol)(refl))()()(externKindIsSymbol)(refl))()()(externDataIsSymbol)(refl))()()(dataConstructorIsSymbol)(refl))()()(dataIsSymbol2)(refl))({
    data: new Right(named("DataResult")(object9(rowListCodecCons(rowListCodecCons8({
      reflectSymbol: function() {
        return "typeArguments";
      }
    }))()()(dataDeclTypeIsSymbol))({
      typeArguments: array(typeArgumentCodec),
      dataDeclType: dataDeclTypeCodec
    }))),
    externData: new Right(typeCodec),
    typeSynonym: new Right(named("TypeSynonymResult")(object9(rowListCodecCons1(argumentsIsSymbol))({
      "arguments": array(typeArgumentCodec),
      type: typeCodec
    }))),
    dataConstructor: new Right(named("DataConstructorResult")(object9(rowListCodecCons1(dataDeclTypeIsSymbol))({
      dataDeclType: dataDeclTypeCodec,
      type: typeCodec
    }))),
    typeClassMember: new Right(named("TypeClassMemberResult")(object9(rowListCodecCons(rowListCodecCons(rowListCodecCons8({
      reflectSymbol: function() {
        return "typeClassArguments";
      }
    }))()()(typeClassIsSymbol))()()(typeIsSymbol3))({
      type: typeCodec,
      typeClass: qualifiedNameCodec,
      typeClassArguments: array(typeArgumentCodec)
    }))),
    typeClass: new Right(named("TypeClassResult")(object9(rowListCodecCons(rowListCodecCons(rowListCodecCons8({
      reflectSymbol: function() {
        return "superclasses";
      }
    }))()()({
      reflectSymbol: function() {
        return "fundeps";
      }
    }))()()(argumentsIsSymbol))({
      fundeps: funDepsCodec,
      "arguments": array(typeArgumentCodec),
      superclasses: array(constraintCodec)
    }))),
    value: new Right(typeCodec),
    valueAlias: new Left(unit),
    typeAlias: new Left(unit),
    externKind: new Left(unit)
  }));
}();
var searchResultCodec = /* @__PURE__ */ wrapIso5(SearchResult)(/* @__PURE__ */ named("SearchResult")(/* @__PURE__ */ object9(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "sourceSpan";
  }
}))()()({
  reflectSymbol: function() {
    return "score";
  }
}))()()({
  reflectSymbol: function() {
    return "packageInfo";
  }
}))()()({
  reflectSymbol: function() {
    return "name";
  }
}))()()({
  reflectSymbol: function() {
    return "moduleName";
  }
}))()()({
  reflectSymbol: function() {
    return "info";
  }
}))()()({
  reflectSymbol: function() {
    return "hashAnchor";
  }
}))()()({
  reflectSymbol: function() {
    return "comments";
  }
}))({
  name: /* @__PURE__ */ wrapIso5(Identifier)(string),
  comments: /* @__PURE__ */ optional4(string),
  hashAnchor: string,
  moduleName: moduleNameCodec,
  packageInfo: packageInfoCodec,
  score: packageScoreCodec,
  sourceSpan: /* @__PURE__ */ optional4(sourceSpanCodec),
  info: resultInfoCodec
})));

// output/Docs.Search.Extra/index.js
var foldMapFlipped = function(dictFoldable) {
  var foldMap32 = foldMap(dictFoldable);
  return function(dictMonoid) {
    return flip(foldMap32(dictMonoid));
  };
};

// output/StringParser.Parser/index.js
var map93 = /* @__PURE__ */ map(functorEither);
var bind60 = /* @__PURE__ */ bind(bindEither);
var pure76 = /* @__PURE__ */ pure(applicativeEither);
var tailRecM6 = /* @__PURE__ */ tailRecM(monadRecEither);
var unParser = function(v) {
  return v;
};
var runParser3 = function(v) {
  return function(s) {
    return map93(function(v1) {
      return v1.result;
    })(v({
      substring: s,
      position: 0
    }));
  };
};
var functorParser = {
  map: function(f) {
    return function(v) {
      var $69 = map93(function(v1) {
        return {
          result: f(v1.result),
          suffix: v1.suffix
        };
      });
      return function($70) {
        return $69(v($70));
      };
    };
  }
};
var fail5 = function(error5) {
  return function(v) {
    return new Left({
      pos: v.position,
      error: error5
    });
  };
};
var applyParser = {
  apply: function(v) {
    return function(v1) {
      return function(s) {
        return bind60(v(s))(function(v2) {
          return bind60(v1(v2.suffix))(function(v3) {
            return pure76({
              result: v2.result(v3.result),
              suffix: v3.suffix
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var bindParser = {
  bind: function(v) {
    return function(f) {
      return function(s) {
        return bind60(v(s))(function(v1) {
          return unParser(f(v1.result))(v1.suffix);
        });
      };
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var applicativeParser = {
  pure: function(a) {
    return function(s) {
      return new Right({
        result: a,
        suffix: s
      });
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var monadParser = {
  Applicative0: function() {
    return applicativeParser;
  },
  Bind1: function() {
    return bindParser;
  }
};
var monadRecParser = {
  tailRecM: function(f) {
    return function(a) {
      var split3 = function(v) {
        if (v.result instanceof Loop) {
          return new Loop({
            state: v.result.value0,
            str: v.suffix
          });
        }
        ;
        if (v.result instanceof Done) {
          return new Done({
            result: v.result.value0,
            suffix: v.suffix
          });
        }
        ;
        throw new Error("Failed pattern match at StringParser.Parser (line 87, column 5 - line 87, column 68): " + [v.constructor.name]);
      };
      return function(str2) {
        return tailRecM6(function(st) {
          return map93(split3)(unParser(f(st.state))(st.str));
        })({
          state: a,
          str: str2
        });
      };
    };
  },
  Monad0: function() {
    return monadParser;
  }
};
var altParser = {
  alt: function(v) {
    return function(v1) {
      return function(s) {
        var v2 = v(s);
        if (v2 instanceof Left) {
          if (s.position === v2.value0.pos) {
            return v1(s);
          }
          ;
          if (otherwise) {
            return new Left({
              error: v2.value0.error,
              pos: v2.value0.pos
            });
          }
          ;
        }
        ;
        return v2;
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var plusParser = {
  empty: /* @__PURE__ */ fail5("No alternative"),
  Alt0: function() {
    return altParser;
  }
};
var alternativeParser = {
  Applicative0: function() {
    return applicativeParser;
  },
  Plus1: function() {
    return plusParser;
  }
};

// output/StringParser.Combinators/index.js
var alt31 = /* @__PURE__ */ alt(altParser);
var bind61 = /* @__PURE__ */ bind(bindParser);
var pure77 = /* @__PURE__ */ pure(applicativeParser);
var map94 = /* @__PURE__ */ map(functorParser);
var applySecond7 = /* @__PURE__ */ applySecond(applyParser);
var tailRecM7 = /* @__PURE__ */ tailRecM(monadRecParser);
var pure125 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var withError = function(p) {
  return function(msg) {
    return alt31(p)(fail5(msg));
  };
};
var $$try9 = function(v) {
  return function(s) {
    var v1 = v(s);
    if (v1 instanceof Left) {
      return new Left({
        pos: s.position,
        error: v1.value0.error
      });
    }
    ;
    return v1;
  };
};
var cons$prime3 = function(h) {
  return function(t) {
    return new NonEmpty(h, t);
  };
};
var choice3 = function(dictFoldable) {
  return foldl(dictFoldable)(alt31)(fail5("Nothing to parse"));
};
var assertConsume = function(v) {
  return function(s) {
    var v1 = v(s);
    if (v1 instanceof Right) {
      var $34 = s.position < v1.value0.suffix.position;
      if ($34) {
        return new Right(v1.value0);
      }
      ;
      return new Left({
        pos: s.position,
        error: "Consumed no input."
      });
    }
    ;
    return v1;
  };
};
var many5 = /* @__PURE__ */ function() {
  var $37 = manyRec(monadRecParser)(alternativeParser);
  return function($38) {
    return $37(assertConsume($38));
  };
}();
var sepBy12 = function(p) {
  return function(sep3) {
    return bind61(p)(function(a) {
      return bind61(many5(applySecond7(sep3)(p)))(function(as3) {
        return pure77(cons$prime3(a)(as3));
      });
    });
  };
};
var many1Till = function(p) {
  return function(end4) {
    var ending = function(acc) {
      return bind61(end4)(function() {
        return pure77(new Done(reverse3(acc)));
      });
    };
    var $$continue = function(acc) {
      return bind61(assertConsume(p))(function(c) {
        return pure77(new Loop(cons3(c)(acc)));
      });
    };
    var inner = function(acc) {
      return alt31(ending(acc))($$continue(acc));
    };
    return bind61(p)(function(x) {
      return tailRecM7(inner)(pure125(x));
    });
  };
};
var manyTill = function(p) {
  return function(end4) {
    return alt31(applySecond7(end4)(pure77(Nil.value)))(map94(toList2)(many1Till(p)(end4)));
  };
};

// output/StringParser.CodePoints/index.js
var bind63 = /* @__PURE__ */ bind(bindParser);
var pure78 = /* @__PURE__ */ pure(applicativeParser);
var show45 = /* @__PURE__ */ show(showChar);
var map95 = /* @__PURE__ */ map(functorMaybe);
var show214 = /* @__PURE__ */ show(showInt);
var foldMap24 = /* @__PURE__ */ foldMap(foldableList)(monoidString);
var string5 = function(pattern) {
  return function(v) {
    var length9 = length5(pattern);
    var v1 = splitAt3(length9)(v.substring);
    var $45 = v1.before === pattern;
    if ($45) {
      return new Right({
        result: pattern,
        suffix: {
          substring: v1.after,
          position: v.position + length9 | 0
        }
      });
    }
    ;
    return new Left({
      pos: v.position,
      error: "Expected '" + (pattern + "'.")
    });
  };
};
var regex3 = function(pat) {
  var pattern = "^(" + (pat + ")");
  var matchRegex = function(r) {
    return function(v2) {
      var v1 = map95(head2)(match(r)(v2.substring));
      if (v1 instanceof Just && v1.value0 instanceof Just) {
        return new Right({
          result: v1.value0.value0,
          suffix: {
            substring: drop3(length5(v1.value0.value0))(v2.substring),
            position: v2.position + length5(v1.value0.value0) | 0
          }
        });
      }
      ;
      return new Left({
        pos: v2.position,
        error: "no match"
      });
    };
  };
  var v = regex(pattern)(noFlags);
  if (v instanceof Left) {
    return fail5("StringParser.String.regex': illegal regex " + pat);
  }
  ;
  if (v instanceof Right) {
    return matchRegex(v.value0);
  }
  ;
  throw new Error("Failed pattern match at StringParser.CodePoints (line 158, column 3 - line 162, column 19): " + [v.constructor.name]);
};
var anyCodePoint = function(v) {
  var v1 = uncons3(v.substring);
  if (v1 instanceof Nothing) {
    return new Left({
      pos: v.position,
      error: "Unexpected EOF"
    });
  }
  ;
  if (v1 instanceof Just) {
    return new Right({
      result: v1.value0.head,
      suffix: {
        substring: v1.value0.tail,
        position: v.position + 1 | 0
      }
    });
  }
  ;
  throw new Error("Failed pattern match at StringParser.CodePoints (line 72, column 3 - line 74, column 103): " + [v1.constructor.name]);
};
var anyChar3 = /* @__PURE__ */ function() {
  var notAChar = function(cc) {
    return fail5("Code point " + (show214(cc) + " is not a character"));
  };
  return bind63(mapFlipped(functorParser)(anyCodePoint)(fromEnum(boundedEnumCodePoint)))(function(cc) {
    var v = fromCharCode3(cc);
    if (v instanceof Just) {
      var $73 = cc > 65535;
      if ($73) {
        return notAChar(cc);
      }
      ;
      return pure78(v.value0);
    }
    ;
    if (v instanceof Nothing) {
      return notAChar(cc);
    }
    ;
    throw new Error("Failed pattern match at StringParser.CodePoints (line 57, column 3 - line 65, column 27): " + [v.constructor.name]);
  });
}();
var satisfy2 = function(f) {
  return $$try9(bind63(anyChar3)(function(c) {
    var $75 = f(c);
    if ($75) {
      return pure78(c);
    }
    ;
    return fail5("Character " + (show45(c) + " did not satisfy predicate"));
  }));
};
var $$char4 = function(c) {
  return withError(satisfy2(function(v) {
    return v === c;
  }))("Could not match character " + show45(c));
};
var noneOf2 = function(dictFoldable) {
  var $76 = flip(notElem(dictFoldable)(eqChar));
  return function($77) {
    return satisfy2($76($77));
  };
};
var whiteSpace = /* @__PURE__ */ bind63(/* @__PURE__ */ many5(/* @__PURE__ */ satisfy2(function(c) {
  return c === "\n" || (c === "\r" || (c === " " || c === "	"));
})))(function(cs) {
  return pure78(foldMap24(singleton6)(cs));
});

// output/Docs.Search.TypeQuery/index.js
var coerce16 = /* @__PURE__ */ coerce();
var labelToIdentifier = /* @__PURE__ */ coerce16(decodeStringWithReplacement);
var joinRows = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof RCons) {
          $tco_var_v = new Cons({
            row: labelToIdentifier(v1.value1),
            ty: v1.value2
          }, v);
          $copy_v1 = v1.value3;
          return;
        }
        ;
        $tco_done = true;
        return {
          rows: reverse2(v),
          ty: function() {
            if (v1 instanceof REmpty) {
              return Nothing.value;
            }
            ;
            return new Just(v1);
          }()
        };
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
}();
var joinForAlls = function(ty) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof ForAll) {
          $tco_var_v = new Cons({
            name: v1.value2,
            kind: v1.value3
          }, v);
          $copy_v1 = v1.value4;
          return;
        }
        ;
        $tco_done = true;
        return {
          binders: v,
          ty: v1
        };
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value)(ty);
};

// output/Docs.Search.Declarations/index.js
var monoidTrie2 = /* @__PURE__ */ monoidTrie(ordChar);
var mapFlipped18 = /* @__PURE__ */ mapFlipped(functorArray);
var coerce17 = /* @__PURE__ */ coerce();
var append39 = /* @__PURE__ */ append(semigroupArray);
var toUnfoldable28 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var foldr16 = /* @__PURE__ */ foldr(foldableArray);
var compose2 = /* @__PURE__ */ compose(semigroupoidFn);
var identity32 = /* @__PURE__ */ identity(categoryFn);
var foldl16 = /* @__PURE__ */ foldl(foldableArray);
var mempty27 = /* @__PURE__ */ mempty(monoidList);
var fromFoldable40 = /* @__PURE__ */ fromFoldable6(foldableArray);
var alter6 = /* @__PURE__ */ alter5(ordChar);
var alt32 = /* @__PURE__ */ alt(altMaybe);
var map96 = /* @__PURE__ */ map(functorMaybe);
var composeKleisli4 = /* @__PURE__ */ composeKleisli(bindMaybe);
var eq38 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var bind64 = /* @__PURE__ */ bind(bindMaybe);
var zero3 = /* @__PURE__ */ zero(semiringPackageScore);
var append121 = /* @__PURE__ */ append(semigroupList);
var bind123 = /* @__PURE__ */ bind(bindList);
var foldr17 = /* @__PURE__ */ foldr(foldableList);
var mempty112 = /* @__PURE__ */ mempty(monoidTrie2);
var Declarations = function(x) {
  return x;
};
var ValueLevel = /* @__PURE__ */ function() {
  function ValueLevel2() {
  }
  ;
  ValueLevel2.value = new ValueLevel2();
  return ValueLevel2;
}();
var TypeLevel = /* @__PURE__ */ function() {
  function TypeLevel2() {
  }
  ;
  TypeLevel2.value = new TypeLevel2();
  return TypeLevel2;
}();
var toTypeVars = /* @__PURE__ */ map(functorArray)(function(v) {
  return new TypeVar(unit, v.name);
});
var mkInfo = function(declLevel) {
  return function(v) {
    var toTypeArgument = function(v1) {
      return {
        name: v1.value0,
        kind: v1.value1
      };
    };
    if (v.info instanceof ValueDeclaration) {
      return new Just(new ValueResult({
        type: v.info.value0
      }));
    }
    ;
    if (v.info instanceof DataDeclaration) {
      return new Just(new DataResult({
        dataDeclType: v.info.value0,
        typeArguments: mapFlipped18(v.info.value1)(toTypeArgument)
      }));
    }
    ;
    if (v.info instanceof ExternDataDeclaration) {
      return new Just(new ExternDataResult({
        kind: v.info.value0
      }));
    }
    ;
    if (v.info instanceof TypeSynonymDeclaration) {
      return new Just(new TypeSynonymResult({
        type: v.info.value1,
        "arguments": mapFlipped18(v.info.value0)(toTypeArgument)
      }));
    }
    ;
    if (v.info instanceof TypeClassDeclaration) {
      return new Just(new TypeClassResult({
        fundeps: v.info.value2,
        "arguments": mapFlipped18(v.info.value0)(toTypeArgument),
        superclasses: v.info.value1
      }));
    }
    ;
    if (v.info instanceof AliasDeclaration) {
      if (declLevel instanceof TypeLevel) {
        return new Just(TypeAliasResult.value);
      }
      ;
      if (declLevel instanceof ValueLevel) {
        return new Just(ValueAliasResult.value);
      }
      ;
      throw new Error("Failed pattern match at Docs.Search.Declarations (line 151, column 7 - line 153, column 44): " + [declLevel.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.Declarations (line 124, column 3 - line 153, column 44): " + [v.info.constructor.name]);
  };
};
var mkChildInfo = function(v) {
  return function(v1) {
    var v2 = function(v3) {
      var v4 = function(v52) {
        if (otherwise) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Docs.Search.Declarations (line 251, column 1 - line 254, column 22): " + [v.constructor.name, v1.constructor.name]);
      };
      if (v1.info instanceof ChildTypeClassMember) {
        if (v.info instanceof TypeClassResult) {
          var v5 = joinForAlls(v1.info.value0);
          var constraintClass = new Qualified(new ByModuleName(v.moduleName), coerce17(v.name));
          var allArguments = append39(v["info"]["value0"]["arguments"])(toUnfoldable28(v5.binders));
          var restoreType = foldr16(function(v6) {
            return compose2(function(ty1) {
              return new ForAll(unit, TypeVarInvisible.value, v6.name, v6.kind, ty1, Nothing.value);
            });
          })(identity32)(allArguments);
          var restoredType = restoreType(new ConstrainedType(unit, {
            ann: unit,
            args: toTypeVars(v["info"]["value0"]["arguments"]),
            "class": constraintClass,
            data: Nothing.value,
            kindArgs: []
          }, v5.ty));
          return new Just(new TypeClassMemberResult({
            type: restoredType,
            typeClass: constraintClass,
            typeClassArguments: v["info"]["value0"]["arguments"]
          }));
        }
        ;
        return v4(true);
      }
      ;
      return v4(true);
    };
    if (v1.info instanceof ChildDataConstructor) {
      if (v.info instanceof DataResult) {
        var typeArrow = TypeApp.create(unit)(new TypeConstructor(unit, new Qualified(new ByModuleName("Prim"), "Function")));
        var parentTypeCtor = new TypeConstructor(unit, new Qualified(new ByModuleName(v.moduleName), coerce17(v.name)));
        var parentTypeArgs = mapFlipped18(v.info.value0.typeArguments)(function(v3) {
          return new TypeVar(unit, v3.name);
        });
        var parentType = foldl16(TypeApp.create(unit))(parentTypeCtor)(parentTypeArgs);
        var makeType = foldr16(function(a) {
          return function(b) {
            return new TypeApp(unit, typeArrow(a), b);
          };
        })(parentType);
        return new Just(new DataConstructorResult({
          dataDeclType: v.info.value0.dataDeclType,
          type: makeType(v1.info.value0)
        }));
      }
      ;
      return v2(true);
    }
    ;
    return v2(true);
  };
};
var resultsForChildDeclaration = function(scores) {
  return function(packageInfo) {
    return function(moduleName3) {
      return function(parentResult) {
        return function(v) {
          var v1 = function(v2) {
            if (otherwise) {
              return mempty27;
            }
            ;
            throw new Error("Failed pattern match at Docs.Search.Declarations (line 219, column 1 - line 225, column 53): " + [scores.constructor.name, packageInfo.constructor.name, moduleName3.constructor.name, parentResult.constructor.name, v.constructor.name]);
          };
          var $130 = mkChildInfo(parentResult)(v);
          if ($130 instanceof Just) {
            return singleton8({
              path: v.title,
              result: {
                name: v.title,
                comments: v.comments,
                hashAnchor: "v",
                moduleName: moduleName3,
                sourceSpan: v.sourceSpan,
                packageInfo,
                score: getPackageScore(scores)(packageInfo),
                info: $130.value0
              }
            });
          }
          ;
          return v1(true);
        };
      };
    };
  };
};
var insertSearchResult = function(v) {
  return function(trie) {
    var updateResults = function(mbOldResults) {
      var v1 = function(v2) {
        if (otherwise) {
          return singleton8(v.result);
        }
        ;
        throw new Error("Failed pattern match at Docs.Search.Declarations (line 60, column 1 - line 65, column 35): " + [mbOldResults.constructor.name]);
      };
      if (mbOldResults instanceof Just) {
        return new Cons(v.result, mbOldResults.value0);
      }
      ;
      return v1(true);
    };
    var path$prime = fromFoldable40(toCharArray(toLower(v.path)));
    return alter6(path$prime)(function($192) {
      return Just.create(updateResults($192));
    })(trie);
  };
};
var getLevelAndName = function(v) {
  if (v.info instanceof ValueDeclaration) {
    return {
      name: v.title,
      declLevel: ValueLevel.value
    };
  }
  ;
  if (v.info instanceof DataDeclaration) {
    return {
      name: v.title,
      declLevel: TypeLevel.value
    };
  }
  ;
  if (v.info instanceof TypeSynonymDeclaration) {
    return {
      name: v.title,
      declLevel: TypeLevel.value
    };
  }
  ;
  if (v.info instanceof TypeClassDeclaration) {
    return {
      name: v.title,
      declLevel: TypeLevel.value
    };
  }
  ;
  if (v.info instanceof AliasDeclaration) {
    var withAnchor = function(declLevel) {
      return function(name5) {
        return {
          declLevel,
          name: name5
        };
      };
    };
    return fromMaybe(withAnchor(ValueLevel.value)(v.title))(alt32(map96(withAnchor(ValueLevel.value))(composeKleisli4(stripPrefix2("("))(stripSuffix(")"))(v.title)))(map96(withAnchor(TypeLevel.value))(composeKleisli4(stripPrefix2("type ("))(stripSuffix(")"))(v.title))));
  }
  ;
  if (v.info instanceof ExternDataDeclaration) {
    return {
      name: v.title,
      declLevel: TypeLevel.value
    };
  }
  ;
  throw new Error("Failed pattern match at Docs.Search.Declarations (line 174, column 3 - line 199, column 44): " + [v.info.constructor.name]);
};
var extractPackageName = function(v) {
  return function(v1) {
    if (eq38(index(split(".")(v))(0))(new Just("Prim"))) {
      return Builtin.value;
    }
    ;
    if (v1 instanceof Nothing) {
      return UnknownPackage.value;
    }
    ;
    if (v1 instanceof Just) {
      var dirs = split("/")(v1.value0.name);
      return fromMaybe(LocalPackage2.value)(bind64(index(dirs)(0))(function(topLevelDir) {
        var $163 = topLevelDir === ".spago";
        if ($163) {
          return map96(function($193) {
            return Package.create(PackageName($193));
          })(index(dirs)(2));
        }
        ;
        return bind64(findIndex(function(v2) {
          return v2 === "bower_components";
        })(dirs))(function(bowerDirIx) {
          return map96(function($194) {
            return Package.create(PackageName($194));
          })(index(dirs)(bowerDirIx + 1 | 0));
        });
      }));
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.Declarations (line 204, column 1 - line 204, column 68): " + [v.constructor.name, v1.constructor.name]);
  };
};
var declLevelToHashAnchor = function(v) {
  if (v instanceof ValueLevel) {
    return "v";
  }
  ;
  if (v instanceof TypeLevel) {
    return "t";
  }
  ;
  throw new Error("Failed pattern match at Docs.Search.Declarations (line 164, column 25 - line 166, column 19): " + [v.constructor.name]);
};
var resultsForDeclaration = function(scores) {
  return function(moduleName3) {
    return function(v) {
      var v1 = getLevelAndName(v);
      var packageInfo = extractPackageName(moduleName3)(v.sourceSpan);
      var mbPackageName = function() {
        if (packageInfo instanceof Package) {
          return new Just(packageInfo.value0);
        }
        ;
        return Nothing.value;
      }();
      var v2 = mkInfo(v1.declLevel)(v);
      if (v2 instanceof Nothing) {
        return mempty27;
      }
      ;
      if (v2 instanceof Just) {
        var result = {
          name: v.title,
          comments: v.comments,
          hashAnchor: declLevelToHashAnchor(v1.declLevel),
          moduleName: moduleName3,
          sourceSpan: v.sourceSpan,
          packageInfo,
          score: fromMaybe(zero3)(map96(getPackageScoreForPackageName(scores))(mbPackageName)),
          info: v2.value0
        };
        return append121(singleton8({
          path: v1.name,
          result
        }))(bind123(fromFoldable40(v.children))(resultsForChildDeclaration(scores)(packageInfo)(moduleName3)(result)));
      }
      ;
      throw new Error("Failed pattern match at Docs.Search.Declarations (line 89, column 3 - line 112, column 12): " + [v2.constructor.name]);
    };
  };
};
var insertDeclaration = function(scores) {
  return function(moduleName3) {
    return function(v) {
      return function(trie) {
        return foldr17(insertSearchResult)(trie)(resultsForDeclaration(scores)(moduleName3)(v));
      };
    };
  };
};
var mkDeclarations = function(scores) {
  var insertDocModule = function(_scores) {
    return function(v) {
      return function(trie) {
        return foldr16(insertDeclaration(scores)(v.name))(trie)(v.declarations);
      };
    };
  };
  var $195 = foldr16(insertDocModule(scores))(mempty112);
  return function($196) {
    return Declarations($195($196));
  };
};

// output/Docs.Search.Meta/index.js
var metaCodec = /* @__PURE__ */ named("Meta")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "localPackageName";
  }
}))({
  localPackageName: packageNameCodec
}));

// output/Docs.Search.ModuleIndex/index.js
var foldr18 = /* @__PURE__ */ foldr(foldableList);
var unionWith4 = /* @__PURE__ */ unionWith(ordPackageInfo);
var union10 = /* @__PURE__ */ union3(ordModuleName);
var map97 = /* @__PURE__ */ map(functorList);
var alter7 = /* @__PURE__ */ alter(ordPackageInfo);
var append40 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSet(ordModuleName));
var fromFoldable115 = /* @__PURE__ */ fromFoldable8(foldableArray)(ordModuleName);
var packedModuleIndexCodec = /* @__PURE__ */ map20(ordPackageInfo)(packageInfoCodec)(/* @__PURE__ */ set(ordModuleName)(moduleNameCodec));
var mkPackedModuleIndex = function(v) {
  return function(moduleNames) {
    var extract4 = function() {
      var mkEntry = function(v1) {
        return singleton10(v1.packageInfo)(singleton11(v1.moduleName));
      };
      var $68 = foldr18(unionWith4(union10))(empty4);
      var $69 = map97(mkEntry);
      return function($70) {
        return $68($69($70));
      };
    }();
    var addLocalPackageModuleNames = flip(alter7)(LocalPackage2.value)(function() {
      var $71 = append40(fromFoldable115(moduleNames));
      var $72 = fromMaybe(empty5);
      return function($73) {
        return Just.create($71($72($73)));
      };
    }());
    return addLocalPackageModuleNames(foldr18(unionWith4(union10))(empty4)(map97(extract4)(values3(v))));
  };
};

// output/Docs.Search.ModuleParser/index.js
var discard35 = /* @__PURE__ */ discard(discardUnit)(bindParser);
var $$void19 = /* @__PURE__ */ $$void(functorParser);
var noneOf3 = /* @__PURE__ */ noneOf2(foldableArray);
var bind65 = /* @__PURE__ */ bind(bindParser);
var pure79 = /* @__PURE__ */ pure(applicativeParser);
var singleLineComment = /* @__PURE__ */ discard35(/* @__PURE__ */ $$void19(/* @__PURE__ */ string5("--")))(function() {
  return $$void19(manyTill($$void19(noneOf3(["\n"])))($$char4("\n")));
});
var multiLineComment = /* @__PURE__ */ discard35(/* @__PURE__ */ $$void19(/* @__PURE__ */ string5("{-")))(function() {
  return $$void19(manyTill($$void19(noneOf3([])))(string5("-}")));
});
var whiteSpaceOrComment = /* @__PURE__ */ choice3(foldableArray)([/* @__PURE__ */ $$try9(multiLineComment), /* @__PURE__ */ $$try9(singleLineComment), /* @__PURE__ */ $$try9(/* @__PURE__ */ $$void19(whiteSpace))]);
var moduleNameWord = /* @__PURE__ */ bind65(/* @__PURE__ */ regex3("[A-Z]"))(function(first2) {
  return bind65(regex3("[A-Za-z0-9]*"))(function(rest2) {
    return pure79(first2 + rest2);
  });
});
var moduleName2 = /* @__PURE__ */ mapFlipped(functorParser)(/* @__PURE__ */ sepBy12(moduleNameWord)(/* @__PURE__ */ string5(".")))(/* @__PURE__ */ intercalate(foldableNonEmptyList)(monoidString)("."));
var moduleHeader = /* @__PURE__ */ discard35(/* @__PURE__ */ $$void19(/* @__PURE__ */ string5("module")))(function() {
  return discard35($$void19(many5(whiteSpaceOrComment)))(function() {
    return moduleName2;
  });
});
var parseModuleName = /* @__PURE__ */ function() {
  var $14 = map(functorMaybe)(wrap());
  var $15 = runParser3(discard35($$void19(many5(whiteSpaceOrComment)))(function() {
    return moduleHeader;
  }));
  return function($16) {
    return $14(hush($15($16)));
  };
}();

// output/Docs.Search.PackageIndex/index.js
var fromFoldable41 = /* @__PURE__ */ fromFoldable(foldableList);
var insert18 = /* @__PURE__ */ insert2(ordPackageName2);
var mapFlipped19 = /* @__PURE__ */ mapFlipped(functorArray);
var mapFlipped110 = /* @__PURE__ */ mapFlipped(functorMaybe);
var unwrap19 = /* @__PURE__ */ unwrap();
var packageResultCodec = /* @__PURE__ */ named("PackageResult")(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "score";
  }
}))()()({
  reflectSymbol: function() {
    return "repository";
  }
}))()()({
  reflectSymbol: function() {
    return "name";
  }
}))()()({
  reflectSymbol: function() {
    return "description";
  }
}))()()({
  reflectSymbol: function() {
    return "dependencies";
  }
}))({
  name: packageNameCodec,
  description: /* @__PURE__ */ optional4(string),
  score: packageScoreCodec,
  dependencies: /* @__PURE__ */ array(packageNameCodec),
  repository: /* @__PURE__ */ optional4(string)
}));
var packageMetaCodec = /* @__PURE__ */ function() {
  var encode6 = function($52) {
    return fromPackageMeta($52);
  };
  var decode4 = fromUni(toPackageMeta);
  return codec$prime(decode4)(encode6);
}();
var mkPackageInfo = function(packageScores) {
  return function(pms) {
    var insert22 = function(v) {
      return insert18(v.name)({
        name: v.name,
        description: v.description,
        score: getPackageScoreForPackageName(packageScores)(v.name),
        dependencies: mapFlipped19(v.dependencies)(fst),
        repository: mapFlipped110(v.repository)(function($55) {
          return function(v1) {
            return v1.url;
          }(unwrap19($55));
        })
      });
    };
    return fromFoldable41(values(foldr2(insert22)(empty4)(pms)));
  };
};

// output/Docs.Search.TypeShape/foreign.js
function hash(string8) {
  var hash4 = Math.floor(Number.MAX_SAFE_INTEGER / 2);
  if (string8.length == 0) {
    return hash4;
  }
  for (var i = 0; i < string8.length; i++) {
    var char2 = string8.charCodeAt(i);
    hash4 = (hash4 << 5) - hash4 + char2;
    hash4 = hash4 & hash4;
  }
  return hash4;
}

// output/Docs.Search.TypeShape/index.js
var show46 = /* @__PURE__ */ show(showInt);
var foldMap25 = /* @__PURE__ */ foldMap(foldableList)(monoidString);
var abs4 = /* @__PURE__ */ abs(ordInt)(ringInt);
var compare19 = /* @__PURE__ */ compare(ordIdentifier);
var append122 = /* @__PURE__ */ append(semigroupList);
var pure80 = /* @__PURE__ */ pure(applicativeList);
var mapFlipped20 = /* @__PURE__ */ mapFlipped(functorList);
var PVar = /* @__PURE__ */ function() {
  function PVar2() {
  }
  ;
  PVar2.value = new PVar2();
  return PVar2;
}();
var PFun = /* @__PURE__ */ function() {
  function PFun2() {
  }
  ;
  PFun2.value = new PFun2();
  return PFun2;
}();
var PApp = /* @__PURE__ */ function() {
  function PApp2() {
  }
  ;
  PApp2.value = new PApp2();
  return PApp2;
}();
var PForAll = /* @__PURE__ */ function() {
  function PForAll2(value0) {
    this.value0 = value0;
  }
  ;
  PForAll2.create = function(value0) {
    return new PForAll2(value0);
  };
  return PForAll2;
}();
var PRow = /* @__PURE__ */ function() {
  function PRow2(value0) {
    this.value0 = value0;
  }
  ;
  PRow2.create = function(value0) {
    return new PRow2(value0);
  };
  return PRow2;
}();
var stringifyShape = function(shape) {
  var stringifyChunk = function(v) {
    if (v instanceof PVar) {
      return "v";
    }
    ;
    if (v instanceof PFun) {
      return "f";
    }
    ;
    if (v instanceof PApp) {
      return "a";
    }
    ;
    if (v instanceof PForAll) {
      return "b" + show46(v.value0);
    }
    ;
    if (v instanceof PRow) {
      return "r" + show46(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.TypeShape (line 48, column 5 - line 53, column 30): " + [v.constructor.name]);
  };
  var res = foldMap25(stringifyChunk)(shape);
  return show46(abs4(hash(function() {
    var $65 = res === "";
    if ($65) {
      return "0";
    }
    ;
    return res;
  }())));
};
var shapeOfType = function(ty) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v instanceof Nil) {
          $tco_done = true;
          return v1;
        }
        ;
        if (v instanceof Cons) {
          if (v.value0 instanceof TypeVar) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeLevelString) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeWildcard) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeApp && (v.value0.value1 instanceof TypeApp && (v.value0.value1.value1 instanceof TypeConstructor && (v.value0.value1.value1.value1.value0 instanceof ByModuleName && (v.value0.value1.value1.value1.value0.value0 === "Prim" && v.value0.value1.value1.value1.value1 === "Function"))))) {
            $tco_var_v = new Cons(v.value0.value1.value2, new Cons(v.value0.value2, v.value1));
            $copy_v1 = new Cons(PFun.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeConstructor) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeOp) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof TypeApp) {
            $tco_var_v = new Cons(v.value0.value1, new Cons(v.value0.value2, v.value1));
            $copy_v1 = new Cons(PApp.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof KindApp) {
            $tco_var_v = new Cons(v.value0.value1, new Cons(v.value0.value2, v.value1));
            $copy_v1 = new Cons(PApp.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof ForAll) {
            var foralls = joinForAlls(v.value0);
            $tco_var_v = new Cons(foralls.ty, v.value1);
            $copy_v1 = new Cons(new PForAll(length6(foralls.binders)), v1);
            return;
          }
          ;
          if (v.value0 instanceof ParensInType) {
            $tco_var_v = new Cons(v.value0.value1, v.value1);
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof ConstrainedType) {
            $tco_var_v = new Cons(v.value0.value2, v.value1);
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof REmpty) {
            $tco_var_v = v.value1;
            $copy_v1 = new Cons(PVar.value, v1);
            return;
          }
          ;
          if (v.value0 instanceof RCons) {
            var joined = joinRows(v.value0);
            var sorted = sortBy2(function(x) {
              return function(y) {
                return compare19(x.row)(y.row);
              };
            })(joined.rows);
            var typesInRow = mapFlipped20(sorted)(function(v2) {
              return v2.ty;
            });
            $tco_var_v = append122(typesInRow)(v.value1);
            $copy_v1 = new Cons(new PRow(length6(joined.rows)), v1);
            return;
          }
          ;
          if (v.value0 instanceof KindedType) {
            $tco_var_v = new Cons(v.value0.value1, v.value1);
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof BinaryNoParensType) {
            $tco_var_v = new Cons(new TypeApp(unit, new TypeApp(unit, v.value0.value1, v.value0.value2), v.value0.value3), v.value1);
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof Skolem) {
            $tco_var_v = v.value1;
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof TypeLevelInt) {
            $tco_var_v = v.value1;
            $copy_v1 = v1;
            return;
          }
          ;
          if (v.value0 instanceof TUnknown) {
            $tco_var_v = v.value1;
            $copy_v1 = v1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Docs.Search.TypeShape (line 94, column 5 - line 164, column 20): " + [v.value0.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Docs.Search.TypeShape (line 92, column 3 - line 92, column 19): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return reverse2(go(pure80(ty))(Nil.value));
};

// output/Docs.Search.TypeIndex/index.js
var bind216 = /* @__PURE__ */ bind(bindArray);
var map98 = /* @__PURE__ */ map(functorList);
var fromFoldable45 = /* @__PURE__ */ fromFoldable(foldableList);
var insertWith3 = /* @__PURE__ */ insertWith(ordString);
var append41 = /* @__PURE__ */ append(semigroupArray);
var pure215 = /* @__PURE__ */ pure(applicativeArray);
var identity33 = /* @__PURE__ */ identity(categoryFn);
var map139 = /* @__PURE__ */ map(functorMap);
var foldr19 = /* @__PURE__ */ foldr(foldableArray);
var getType2 = function(v) {
  if (v.info instanceof ValueResult) {
    return new Just(v.info.value0.type);
  }
  ;
  if (v.info instanceof TypeClassMemberResult) {
    return new Just(v.info.value0.type);
  }
  ;
  if (v.info instanceof TypeSynonymResult) {
    return new Just(v.info.value0.type);
  }
  ;
  return Nothing.value;
};
var allResults = function(scores) {
  return function(v) {
    return bind216(v.declarations)(function() {
      var $46 = map98(function(v1) {
        return v1.result;
      });
      var $47 = resultsForDeclaration(scores)(v.name);
      return function($48) {
        return fromFoldable45($46($47($48)));
      };
    }());
  };
};
var mkTypeIndex = function(scores) {
  return function(docsJsons) {
    var insert111 = function(docsJson) {
      return function(mp) {
        return foldr2(function(result) {
          var v = getType2(result);
          if (v instanceof Just) {
            return insertWith3(append41)(stringifyShape(shapeOfType(v.value0)))(pure215(result));
          }
          ;
          if (v instanceof Nothing) {
            return identity33;
          }
          ;
          throw new Error("Failed pattern match at Docs.Search.TypeIndex (line 40, column 11 - line 43, column 32): " + [v.constructor.name]);
        })(mp)(allResults(scores)(docsJson));
      };
    };
    return map139(Just.create)(foldr19(insert111)(empty4)(docsJsons));
  };
};

// output/Docs.Search.IndexBuilder/index.js
var toUnfoldableUnordered3 = /* @__PURE__ */ toUnfoldableUnordered(unfoldableArray);
var unwrap20 = /* @__PURE__ */ unwrap();
var for_9 = /* @__PURE__ */ for_(applicativeAff);
var for_12 = /* @__PURE__ */ for_9(foldableArray);
var fold23 = /* @__PURE__ */ fold(foldableArray)(monoidString);
var discard36 = /* @__PURE__ */ discard(discardUnit);
var liftEffect12 = /* @__PURE__ */ liftEffect(monadEffectAff);
var map99 = /* @__PURE__ */ map(functorEffect);
var $$for10 = /* @__PURE__ */ $$for(applicativeEffect)(traversableArray);
var bind66 = /* @__PURE__ */ bind(bindAff);
var map140 = /* @__PURE__ */ map(functorAff);
var for12 = /* @__PURE__ */ $$for(applicativeAff)(traversableArray);
var discard212 = /* @__PURE__ */ discard36(bindAff);
var pure81 = /* @__PURE__ */ pure(applicativeAff);
var foldMapFlipped2 = /* @__PURE__ */ foldMapFlipped(foldableList)(monoidString);
var fromFoldable46 = /* @__PURE__ */ fromFoldable(foldableList);
var toUnfoldable29 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var foldr20 = /* @__PURE__ */ foldr(foldableList);
var ordList3 = /* @__PURE__ */ ordList(ordChar);
var insert19 = /* @__PURE__ */ insert3(ordList3);
var mempty28 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidSet(ordList3));
var map227 = /* @__PURE__ */ map(functorList);
var mapFlipped21 = /* @__PURE__ */ mapFlipped(functorArray);
var query2 = /* @__PURE__ */ query(ordChar);
var insertWith4 = /* @__PURE__ */ insertWith(ordPartId);
var append123 = /* @__PURE__ */ append(semigroupArray);
var show47 = /* @__PURE__ */ show(showPartId);
var whenM4 = /* @__PURE__ */ whenM(monadAff);
var for_22 = /* @__PURE__ */ for_9(foldableMaybe);
var when16 = /* @__PURE__ */ when(applicativeAff);
var bind124 = /* @__PURE__ */ bind(bindEither);
var left2 = /* @__PURE__ */ left(choiceFn);
var compare20 = /* @__PURE__ */ compare(ordPackageName2);
var map313 = /* @__PURE__ */ map(functorFn);
var join10 = /* @__PURE__ */ join(bindMaybe);
var not3 = /* @__PURE__ */ not(heytingAlgebraBoolean);
var sequential4 = /* @__PURE__ */ sequential(parallelAff);
var apply24 = /* @__PURE__ */ apply2(applyParAff);
var map415 = /* @__PURE__ */ map(functorParAff);
var parallel5 = /* @__PURE__ */ parallel(parallelAff);
var show118 = /* @__PURE__ */ show(showInt);
var $$void20 = /* @__PURE__ */ $$void(functorAff);
var sum2 = /* @__PURE__ */ sum(foldableList)(semiringInt);
var map511 = /* @__PURE__ */ map(functorMaybe);
var writeTypeIndex = function(typeIndex) {
  var mkHeader = function(typeShape) {
    return "// This file was generated by docs-search\n" + ('window.DocsSearchTypeIndex["' + (typeShape + '"] = '));
  };
  var entries3 = toUnfoldableUnordered3(unwrap20(typeIndex));
  var codec12 = maybe2(array(searchResultCodec));
  return for_12(entries3)(function(v) {
    return writeTextFile2(UTF8.value)(unwrap20(typeIndexDirectory) + ("/" + (v.value0 + ".js")))(mkHeader(v.value0) + print(encode2(codec12)(v.value1)));
  });
};
var writePackageInfo = function(packageInfo) {
  return writeTextFile2(UTF8.value)(unwrap20(packageInfoPath))("window.DocsSearchPackageIndex = " + print(encode2(array(packageResultCodec))(packageInfo)));
};
var writeModuleIndex = function(moduleIndex) {
  return writeTextFile2(UTF8.value)(unwrap20(moduleIndexPath))("window.DocsSearchModuleIndex = " + print(encode2(packedModuleIndexCodec)(moduleIndex)));
};
var writeMeta = function(meta) {
  var header = "window." + (unwrap20(metaItem) + " = ");
  return writeTextFile2(UTF8.value)(unwrap20(metaPath))(header + print(encode2(metaCodec)(meta)));
};
var showGlobs = /* @__PURE__ */ intercalate2(monoidString)(", ");
var patchHtml = function(html) {
  var patch3 = fold23(["<!-- Docs search index. -->", '<script type="text/javascript" src="./docs-search-app.js"></script>', '<script type="text/javascript">', "window.DocsSearchTypeIndex = {};", "window.DocsSearchIndex = {};", "</script>", "</body>"]);
  var $80 = contains(patch3)(html);
  if ($80) {
    return Nothing.value;
  }
  ;
  return new Just(replace("</body>")(patch3)(html));
};
var logAndExit = function(message3) {
  return function __do3() {
    log2(message3)();
    return exit$prime(1)();
  };
};
var getPathsByGlobs = function(globs) {
  return liftEffect12(map99(concat)($$for10(globs)(glob2)));
};
var parseModuleHeaders = function(globs) {
  return bind66(getPathsByGlobs(globs))(function(files) {
    return map140(concat)(for12(files)(function(filePath) {
      return bind66(readTextFile2(UTF8.value)(filePath))(function(fileContents) {
        var v = parseModuleName(fileContents);
        if (v instanceof Nothing) {
          return discard212(liftEffect12(log2("Module header decoding failed for " + (filePath + ", unable to extract module name"))))(function() {
            return pure81([]);
          });
        }
        ;
        if (v instanceof Just) {
          return pure81([v.value0]);
        }
        ;
        throw new Error("Failed pattern match at Docs.Search.IndexBuilder (line 215, column 5 - line 221, column 31): " + [v.constructor.name]);
      });
    }));
  });
};
var getIndex = function(v) {
  var toTuple2 = function(v1) {
    return new Tuple(foldMapFlipped2(v1.value0)(singleton6), fromFoldable46(v1.value1));
  };
  var prefixes = toUnfoldable29(foldr20(function(path14) {
    return insert19(take4(2)(path14));
  })(mempty28)(map227(fst)(entriesUnordered(v))));
  var parts = mapFlipped21(prefixes)(function(prefix4) {
    var results = fromFoldable46(map227(toTuple2)(function() {
      var $87 = length6(prefix4) === 2;
      if ($87) {
        return query2(prefix4)(v);
      }
      ;
      return filter3(function(v1) {
        return length6(v1.value0) === 1;
      })(query2(prefix4)(v));
    }()));
    return {
      prefix: prefix4,
      results
    };
  });
  var insert111 = function(part) {
    return insertWith4(append123)(getPartId(part.prefix))(part.results);
  };
  return foldr2(insert111)(empty4)(parts);
};
var writeIndex = function(v) {
  var codec12 = array(tuple(string)(array(searchResultCodec)));
  return function($120) {
    return function(resultsMap) {
      return for_12(toUnfoldableUnordered3(resultsMap))(function(v1) {
        var header = "// This file was generated by docs-search.\n" + ('window.DocsSearchIndex["' + (show47(v1.value0) + '"] = '));
        return writeTextFile2(UTF8.value)(v.generatedDocs + mkIndexPartPath(v1.value0))(header + print(encode2(codec12)(v1.value1)));
      });
    }(getIndex($120));
  };
};
var fileExists = function(path14) {
  return bind66(liftEffect12(exists(path14)))(function(doesExist) {
    if (!doesExist) {
      return pure81(false);
    }
    ;
    if (doesExist) {
      return map140(isFile)(stat3(path14));
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.IndexBuilder (line 432, column 3 - line 434, column 33): " + [doesExist.constructor.name]);
  });
};
var patchDocs = function(cfg) {
  return bind66(readdir3(concat3([cfg.generatedDocs, "html"])))(function(files) {
    return for_12(files)(function(file) {
      var path14 = concat3([cfg.generatedDocs, "html", file]);
      return whenM4(fileExists(path14))(bind66(readTextFile2(UTF8.value)(path14))(function(contents) {
        var html = patchHtml(contents);
        return for_22(html)(writeTextFile2(UTF8.value)(path14));
      }));
    });
  });
};
var withExisting = function(file) {
  return function(f) {
    return bind66(fileExists(file))(function(doesExist) {
      if (doesExist) {
        return bind66(readTextFile2(UTF8.value)(file))(function(contents) {
          return bind66(f(contents))(function(res) {
            return pure81(new Just(res));
          });
        });
      }
      ;
      return discard212(liftEffect12(log2("File does not exist: " + file)))(function() {
        return pure81(Nothing.value);
      });
    });
  };
};
var directoryExists = function(path14) {
  return bind66(liftEffect12(exists(path14)))(function(doesExist) {
    if (!doesExist) {
      return pure81(false);
    }
    ;
    if (doesExist) {
      return map140(isDirectory)(stat3(path14));
    }
    ;
    throw new Error("Failed pattern match at Docs.Search.IndexBuilder (line 425, column 3 - line 427, column 38): " + [doesExist.constructor.name]);
  });
};
var decodeDocsJsons = function(v) {
  return bind66(getPathsByGlobs(v.docsFiles))(function(paths2) {
    return discard212(when16($$null(paths2))(liftEffect12(logAndExit("The following globs do not match any files: " + (showGlobs(v.docsFiles) + ".\nBuild the documentation first!")))))(function() {
      return bind66(map140(catMaybes)(for12(paths2)(function(jsonFile) {
        return bind66(fileExists(jsonFile))(function(doesExist) {
          if (doesExist) {
            return bind66(readTextFile2(UTF8.value)(jsonFile))(function(contents) {
              var eiResult = bind124(parse(contents))(function() {
                var $121 = left2(printDecodeError);
                return function($122) {
                  return $121(toDocModule($122));
                };
              }());
              if (eiResult instanceof Left) {
                return discard212(liftEffect12(log2('"docs.json" decoding failed failed for ' + (jsonFile + (": " + eiResult.value0)))))(function() {
                  return pure81(Nothing.value);
                });
              }
              ;
              if (eiResult instanceof Right) {
                return pure81(new Just(eiResult.value0));
              }
              ;
              throw new Error("Failed pattern match at Docs.Search.IndexBuilder (line 181, column 7 - line 186, column 43): " + [eiResult.constructor.name]);
            });
          }
          ;
          return discard212(liftEffect12(log2("File does not exist: " + jsonFile)))(function() {
            return pure81(Nothing.value);
          });
        });
      })))(function(docsJsons) {
        return discard212(when16($$null(docsJsons))(liftEffect12(logAndExit("Couldn't decode any of the files matched by the following globs: " + showGlobs(v.docsFiles)))))(function() {
          return pure81(docsJsons);
        });
      });
    });
  });
};
var decodeBowerJsons = function(v) {
  var logError4 = function(fileName) {
    return function(error5) {
      return discard212(liftEffect12(log2('"bower.json" decoding failed for ' + (fileName + (": " + error5)))))(function() {
        return pure81(Nothing.value);
      });
    };
  };
  var compareNames = function(v1) {
    return function(v2) {
      return compare20(v1.name)(v2.name);
    };
  };
  return bind66(getPathsByGlobs(v.bowerFiles))(function(paths2) {
    return discard212(when16($$null(paths2))(liftEffect12(logAndExit("The following globs do not match any files: " + (showGlobs(v.bowerFiles) + ".\nAre you in a project directory?")))))(function() {
      return map140(map313(nubBy(compareNames))(catMaybes))(for12(paths2)(function(jsonFileName) {
        return map140(join10)(withExisting(jsonFileName)(function(contents) {
          return either(logError4(jsonFileName))(function($123) {
            return pure81(Just.create($123));
          })(bind124(parse(contents))(function() {
            var $124 = left2(print3);
            var $125 = decode2(packageMetaCodec);
            return function($126) {
              return $124($125($126));
            };
          }()));
        }));
      }));
    });
  });
};
var createDirectories = function(v) {
  var typeIndexDir = concat3([v.generatedDocs, "html", "index", "types"]);
  var indexDir = concat3([v.generatedDocs, "html", "index"]);
  var htmlDocs = concat3([v.generatedDocs, "html"]);
  var declIndexDir = concat3([v.generatedDocs, "html", "index", "declarations"]);
  return discard212(whenM4(map140(not3)(directoryExists(v.generatedDocs)))(liftEffect12(logAndExit("Generate the documentation first!"))))(function() {
    return discard212(whenM4(map140(not3)(directoryExists(htmlDocs)))(liftEffect12(logAndExit("Generate the documentation first!"))))(function() {
      return discard212(whenM4(map140(not3)(directoryExists(indexDir)))(mkdir3(indexDir)))(function() {
        return discard212(whenM4(map140(not3)(directoryExists(declIndexDir)))(mkdir3(declIndexDir)))(function() {
          return whenM4(map140(not3)(directoryExists(typeIndexDir)))(mkdir3(typeIndexDir));
        });
      });
    });
  });
};
var copyAppFile = function(v) {
  return bind66(liftEffect12(getDocsSearchAppPath))(function(appFile) {
    return discard212(whenM4(map140(not3)(fileExists(appFile)))(liftEffect12(logAndExit("Client-side app was not found at " + (appFile + ".\nCheck your installation.")))))(function() {
      return bind66(readFile3(appFile))(function(buffer) {
        return writeFile3(concat3([v.generatedDocs, "html", "docs-search-app.js"]))(buffer);
      });
    });
  });
};
var checkDirectories = function(cfg) {
  var dirs = [cfg.generatedDocs, concat3([cfg.generatedDocs, "html"])];
  return for_12(dirs)(function(dir) {
    return whenM4(map140(not3)(directoryExists(dir)))(liftEffect12(logAndExit("Build the documentation first!")));
  });
};
var run$prime = function(cfg) {
  var ignore2 = function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return function(v4) {
            return function(v5) {
              return function(v6) {
                return unit;
              };
            };
          };
        };
      };
    };
  };
  return discard212(checkDirectories(cfg))(function() {
    return discard212(liftEffect12(log2("Building the search index...")))(function() {
      return bind66(sequential4(apply24(apply24(map415(function(d) {
        return function(h) {
          return function(m) {
            return new Tuple(d, new Tuple(h, m));
          };
        };
      })(parallel5(decodeDocsJsons(cfg))))(parallel5(parseModuleHeaders(cfg.sourceFiles))))(parallel5(decodeBowerJsons(cfg)))))(function(v) {
        var countOfPackages = length(v.value1.value1);
        var countOfModules = length(v.value0);
        return discard212(liftEffect12(log2("Indexing " + (show118(countOfModules) + (" modules from " + (show118(countOfPackages) + " packages..."))))))(function() {
          var scores = mkScores(v.value1.value1);
          var typeIndex = mkTypeIndex(scores)(v.value0);
          var packageInfo = mkPackageInfo(scores)(v.value1.value1);
          var meta = {
            localPackageName: cfg.packageName
          };
          var index5 = mkDeclarations(scores)(v.value0);
          var moduleIndex = mkPackedModuleIndex(index5)(v.value1.value0);
          return discard212(createDirectories(cfg))(function() {
            return discard212($$void20(sequential4(apply24(apply24(apply24(apply24(apply24(apply24(map415(ignore2)(parallel5(writeIndex(cfg)(index5))))(parallel5(writeTypeIndex(typeIndex))))(parallel5(writePackageInfo(packageInfo))))(parallel5(writeModuleIndex(moduleIndex))))(parallel5(writeMeta(meta))))(parallel5(patchDocs(cfg))))(parallel5(copyAppFile(cfg))))))(function() {
              var countOfTypeDefinitions = sum2(map227(map313(fromMaybe(0))(map511(length)))(values(unwrap20(typeIndex))));
              var countOfDefinitions = size7(unwrap20(index5));
              return liftEffect12(log2("Added " + (show118(countOfDefinitions) + (" definitions and " + (show118(countOfTypeDefinitions) + (" type definitions from " + (show118(countOfPackages) + " packages to the search index.")))))));
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Docs/index.js
var discard37 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo8 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var bind67 = /* @__PURE__ */ bind(bindSpago);
var ask11 = /* @__PURE__ */ ask(monadAskSpago);
var die10 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var pure82 = /* @__PURE__ */ pure(applicativeSpago);
var when17 = /* @__PURE__ */ when(applicativeSpago);
var eq39 = /* @__PURE__ */ eq(eqDocsFormat);
var liftAff8 = /* @__PURE__ */ liftAff(monadAffSpago);
var liftEffect13 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var openFile = function(dictMonadAff) {
  var $32 = liftAff(dictMonadAff);
  var $33 = runEffectFn1(openImpl);
  return function($34) {
    return $32(toAffE($33($34)));
  };
};
var openFile1 = /* @__PURE__ */ openFile(monadAffSpago);
var run6 = /* @__PURE__ */ discard37(/* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString)("Running `spago docs`"))(function() {
  return discard37(logInfo8("Generating documentation for the project. This might take a while..."))(function() {
    return bind67(ask11)(function(v) {
      var globs = getBuildGlobs({
        withTests: true,
        selected: getWorkspacePackages(v.workspace.packageSet),
        dependencies: toAllDependencies(v.dependencies),
        depsOnly: v.depsOnly
      });
      return bind67(docs(globs)(v.docsFormat))(function(result) {
        return discard37(function() {
          if (result instanceof Left) {
            return die10(result.value0.message);
          }
          ;
          return pure82(unit);
        }())(function() {
          return when17(eq39(v.docsFormat)(Html.value))(discard37(liftAff8(run$prime({
            docsFiles: defaultDocsFiles,
            bowerFiles: defaultBowerFiles,
            generatedDocs: "./generated-docs/",
            packageName: defaultPackageName,
            sourceFiles: defaultSourceFiles
          })))(function() {
            return bind67(liftEffect13(cwd))(function(currentDir) {
              var link4 = "file://" + (currentDir + "/generated-docs/html/index.html");
              return discard37(logInfo8("Link: " + link4))(function() {
                return when17(v.open)(openFile1(link4));
              });
            });
          }));
        });
      });
    });
  });
});

// output/Spago.Command.Graph/index.js
var map100 = /* @__PURE__ */ map(functorArray);
var show48 = /* @__PURE__ */ show(showString);
var fromFoldable47 = /* @__PURE__ */ fromFoldable(foldableSet);
var append124 = /* @__PURE__ */ append(semigroupArray);
var foldMap26 = /* @__PURE__ */ foldMap2(monoidArray);
var toUnfoldable30 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var fromFoldable116 = /* @__PURE__ */ fromFoldable(foldableArray);
var eq40 = /* @__PURE__ */ eq(eqPackageName);
var filter10 = /* @__PURE__ */ filter4(ordString);
var bind68 = /* @__PURE__ */ bind(bindSpago);
var ask12 = /* @__PURE__ */ ask(monadAskSpago);
var die11 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var pure83 = /* @__PURE__ */ pure(applicativeSpago);
var runSpago6 = /* @__PURE__ */ runSpago(monadAffSpago);
var union11 = /* @__PURE__ */ union5();
var output3 = /* @__PURE__ */ output(monadEffectSpago);
var topologicalSort2 = /* @__PURE__ */ topologicalSort(ordPackageName);
var map141 = /* @__PURE__ */ map(functorMap);
var fromFoldable212 = /* @__PURE__ */ fromFoldable6(foldableSet);
var fromFoldable310 = /* @__PURE__ */ fromFoldable(foldableList);
var topologicalSort1 = /* @__PURE__ */ topologicalSort(ordString);
var fromFoldable48 = /* @__PURE__ */ fromFoldable6(foldableArray);
var packagesToDot = function(selected) {
  return function(graph2) {
    var workspacePackages = map100(function(v) {
      return show48(print5(v["package"].name)) + " [style=dashed];";
    })(toArray(selected));
    var packageToDot = function(v) {
      return map100(function(dep) {
        return show48(print5(v.value0)) + (" -> " + (show48(print5(dep)) + ";"));
      })(fromFoldable47(v.value1.depends));
    };
    return append124(["strict digraph deps {", "node[shape=rect]", "splines=ortho"])(append124(workspacePackages)(append124(foldMap26(packageToDot)(toUnfoldable30(graph2)))(["}"])));
  };
};
var modulesToDot = function(selected) {
  return function(graph2) {
    var moduleToDot = function(v) {
      return map100(function(dep) {
        return show48(v.value0) + (" -> " + (show48(dep) + ";"));
      })(fromFoldable116(v.value1.depends));
    };
    var isInWorskpace = function(node) {
      return any3(function(v) {
        return eq40(v["package"].name)(node["package"]);
      })(selected);
    };
    var workspaceModules = map100(function(v) {
      return show48(v.value0) + " [style=dashed];";
    })(toUnfoldable30(filter10(isInWorskpace)(graph2)));
    return append124(["strict digraph modules {", "node[shape=rect]", "splines=ortho"])(append124(workspaceModules)(append124(foldMap26(moduleToDot)(toUnfoldable30(graph2)))(["}"])));
  };
};
var graphPackages = function(v) {
  return bind68(ask12)(function(v1) {
    var allDependencies = toAllDependencies(v1.dependencies);
    var selected = getWorkspacePackages(v1.workspace.packageSet);
    var globs = getBuildGlobs({
      selected,
      withTests: false,
      dependencies: allDependencies,
      depsOnly: false
    });
    return bind68(runGraph(globs)([]))(function(eitherGraph) {
      return bind68(either(die11)(pure83)(eitherGraph))(function(graph2) {
        return bind68(runSpago6(union11({
          selected
        })(v1))(getPackageGraph(graph2)))(function(packageGraph) {
          if (!v.topo) {
            return output3(function() {
              if (v.dot) {
                return new OutputLines(packagesToDot(selected)(packageGraph));
              }
              ;
              if (v.json) {
                return new OutputJson(packageGraphCodec, packageGraph);
              }
              ;
              return new OutputYaml(packageGraphCodec, packageGraph);
            }());
          }
          ;
          if (v.topo) {
            var list3 = reverse2(topologicalSort2(fromMap2(map141(function(v2) {
              return new Tuple(unit, fromFoldable212(v2.depends));
            })(packageGraph))));
            return output3(function() {
              if (v.json) {
                return new OutputJson(list(codec2), list3);
              }
              ;
              if (!v.json) {
                return new OutputLines(map100(print5)(fromFoldable310(list3)));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Graph (line 90, column 16 - line 92, column 81): " + [v.json.constructor.name]);
            }());
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Graph (line 78, column 3 - line 92, column 81): " + [v.topo.constructor.name]);
        });
      });
    });
  });
};
var graphModules = function(v) {
  return bind68(ask12)(function(v1) {
    var allDependencies = toAllDependencies(v1.dependencies);
    var selected = getWorkspacePackages(v1.workspace.packageSet);
    var globs = getBuildGlobs({
      selected,
      withTests: false,
      dependencies: allDependencies,
      depsOnly: false
    });
    return bind68(runGraph(globs)([]))(function(eitherGraph) {
      return bind68(either(die11)(pure83)(eitherGraph))(function(graph2) {
        return bind68(runSpago6(union11({
          selected
        })(v1))(getModuleGraphWithPackage(graph2)))(function(moduleGraph) {
          if (!v.topo) {
            return output3(function() {
              if (v.dot) {
                return new OutputLines(modulesToDot(selected)(moduleGraph));
              }
              ;
              if (v.json) {
                return new OutputJson(moduleGraphCodec2, moduleGraph);
              }
              ;
              return new OutputYaml(moduleGraphCodec2, moduleGraph);
            }());
          }
          ;
          if (v.topo) {
            var list3 = reverse2(topologicalSort1(fromMap2(map141(function(v2) {
              return new Tuple(unit, fromFoldable48(v2.depends));
            })(moduleGraph))));
            return output3(function() {
              if (v.json) {
                return new OutputJson(list(string), list3);
              }
              ;
              if (!v.json) {
                return new OutputLines(fromFoldable310(list3));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Graph (line 64, column 16 - line 66, column 57): " + [v.json.constructor.name]);
            }());
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Graph (line 52, column 3 - line 66, column 57): " + [v.topo.constructor.name]);
        });
      });
    });
  });
};

// output/Spago.Command.Init/index.js
var show49 = /* @__PURE__ */ show(showString);
var mapFlipped23 = /* @__PURE__ */ mapFlipped(functorMaybe);
var fromFoldable49 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var map101 = /* @__PURE__ */ map(functorArray);
var map142 = /* @__PURE__ */ map(functorMaybe);
var bind69 = /* @__PURE__ */ bind(bindSpago);
var exists9 = /* @__PURE__ */ exists2(monadEffectSpago);
var logInfo9 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var applySecond8 = /* @__PURE__ */ applySecond(applySpago);
var mkdirp4 = /* @__PURE__ */ mkdirp(monadAffSpago);
var writeTextFile5 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var discard38 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var ask13 = /* @__PURE__ */ ask(monadAskSpago);
var liftAff9 = /* @__PURE__ */ liftAff(monadAffSpago);
var pure84 = /* @__PURE__ */ pure(applicativeSpago);
var PackageOnly = /* @__PURE__ */ function() {
  function PackageOnly2(value0) {
    this.value0 = value0;
  }
  ;
  PackageOnly2.create = function(value0) {
    return new PackageOnly2(value0);
  };
  return PackageOnly2;
}();
var WorkspaceOnly = /* @__PURE__ */ function() {
  function WorkspaceOnly2(value0) {
    this.value0 = value0;
  }
  ;
  WorkspaceOnly2.create = function(value0) {
    return new WorkspaceOnly2(value0);
  };
  return WorkspaceOnly2;
}();
var PackageAndWorkspace = /* @__PURE__ */ function() {
  function PackageAndWorkspace2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  PackageAndWorkspace2.create = function(value0) {
    return function(value12) {
      return new PackageAndWorkspace2(value0, value12);
    };
  };
  return PackageAndWorkspace2;
}();
var testMainTemplate = function(moduleName3) {
  return "module " + (moduleName3 + ' where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Class.Console (log)\n\nmain :: Effect Unit\nmain = do\n  log "\u{1F355}"\n  log "You should add some tests."\n\n');
};
var srcMainTemplate = function(moduleName3) {
  return "module " + (moduleName3 + ' where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Console (log)\n\nmain :: Effect Unit\nmain = do\n  log "\u{1F35D}"\n\n');
};
var pursReplFile = {
  name: ".purs-repl",
  content: "import Prelude\n"
};
var gitignoreTemplate = "\nbower_components/\nnode_modules/\n.pulp-cache/\noutput/\noutput-es/\ngenerated-docs/\n.psc-package/\n.psc*\n.purs*\n.psa*\n.spago\n";
var getDefaultConfigWorkspaceOptions = function(v) {
  if (v instanceof PackageAndWorkspace) {
    return new Just(v.value1);
  }
  ;
  if (v instanceof WorkspaceOnly) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof PackageOnly) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Spago.Command.Init (line 146, column 36 - line 149, column 27): " + [v.constructor.name]);
};
var getDefaultConfigPackageOptions = function(v) {
  if (v instanceof PackageOnly) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof PackageAndWorkspace) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof WorkspaceOnly) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Spago.Command.Init (line 140, column 34 - line 143, column 29): " + [v.constructor.name]);
};
var foundExistingProject = function(path14) {
  return "Found a " + (show49(path14) + " file, skipping copy.");
};
var foundExistingFile = function(file) {
  return "Found existing file " + (show49(file) + ", not overwriting it");
};
var foundExistingDirectory = function(dir) {
  return "Found existing directory " + (show49(dir) + ", skipping copy of sample sources");
};
var defaultConfig$prime = function(opts) {
  var mkDep = function(p) {
    return new Tuple(unsafeFromRight(parse3(p)), Nothing.value);
  };
  return {
    "package": mapFlipped23(getDefaultConfigPackageOptions(opts))(function(v) {
      return {
        name: v.name,
        dependencies: fromFoldable49(map101(mkDep)(v.dependencies)),
        description: Nothing.value,
        build: mapFlipped23(v.build)(function(v1) {
          return {
            censorProjectWarnings: v1.censorProjectWarnings,
            strict: v1.strict,
            pedanticPackages: v1.pedanticPackages
          };
        }),
        run: Nothing.value,
        test: mapFlipped23(v.test)(function(v1) {
          return {
            dependencies: fromMaybe(empty4)(v1.dependencies),
            execArgs: Nothing.value,
            main: v1.moduleMain,
            censorTestWarnings: v1.censorTestWarnings,
            strict: v1.strict,
            pedanticPackages: v1.pedanticPackages
          };
        }),
        publish: Nothing.value,
        bundle: Nothing.value
      };
    }),
    workspace: mapFlipped23(getDefaultConfigWorkspaceOptions(opts))(function(v) {
      return {
        extraPackages: new Just(empty4),
        packageSet: map142(function(set4) {
          return new SetFromRegistry({
            registry: set4
          });
        })(v.setVersion),
        buildOpts: Nothing.value,
        backend: Nothing.value
      };
    })
  };
};
var defaultConfig = function(v) {
  var pkg = {
    name: v.name,
    dependencies: ["effect", "console", "prelude"],
    test: new Just({
      moduleMain: v.testModuleName,
      strict: Nothing.value,
      censorTestWarnings: Nothing.value,
      pedanticPackages: Nothing.value,
      dependencies: Nothing.value
    }),
    build: Nothing.value
  };
  return defaultConfig$prime(function() {
    if (v.withWorkspace instanceof Nothing) {
      return new PackageOnly(pkg);
    }
    ;
    if (v.withWorkspace instanceof Just) {
      return new PackageAndWorkspace(pkg, v.withWorkspace.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Init (line 107, column 18 - line 109, column 40): " + [v.withWorkspace.constructor.name]);
  }());
};
var run7 = function(opts) {
  var whenDirNotExists = function(dirPath) {
    return function(action) {
      return bind69(exists9(dirPath))(function(v) {
        if (v) {
          return logInfo9(foundExistingDirectory(dirPath));
        }
        ;
        if (!v) {
          return applySecond8(mkdirp4(dirPath))(action);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Init (line 81, column 29 - line 83, column 43): " + [v.constructor.name]);
      });
    };
  };
  var copyIfNotExists = function(dest) {
    return function(srcTemplate) {
      return bind69(exists9(dest))(function(v) {
        if (v) {
          return logInfo9(foundExistingFile(dest));
        }
        ;
        if (!v) {
          return writeTextFile5(dest)(srcTemplate);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Init (line 86, column 26 - line 88, column 49): " + [v.constructor.name]);
      });
    };
  };
  return discard38(logInfo9("Initializing a new project..."))(function() {
    return bind69(findPackageSet(opts.setVersion))(function(packageSetVersion) {
      return bind69(ask13)(function(v) {
        return discard38(logInfo9("Found PureScript " + (print6(v.purs.version) + (", will use package set " + print6(packageSetVersion)))))(function() {
          var config2 = defaultConfig({
            name: opts.packageName,
            withWorkspace: new Just({
              setVersion: function() {
                if (opts.useSolver) {
                  return Nothing.value;
                }
                ;
                if (!opts.useSolver) {
                  return new Just(packageSetVersion);
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Init (line 51, column 25 - line 53, column 46): " + [opts.useSolver.constructor.name]);
              }()
            }),
            testModuleName: "Test.Main"
          });
          return discard38(bind69(exists9("spago.yaml"))(function(v1) {
            if (v1) {
              return logInfo9(foundExistingProject("spago.yaml"));
            }
            ;
            if (!v1) {
              return liftAff9(writeYamlFile(configCodec)("spago.yaml")(config2));
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Init (line 58, column 30 - line 60, column 77): " + [v1.constructor.name]);
          }))(function() {
            return discard38(whenDirNotExists("src")(copyIfNotExists("src" + (sep + "Main.purs"))(srcMainTemplate("Main"))))(function() {
              return discard38(whenDirNotExists("test")(discard38(mkdirp4(concat3(["test", "Test"])))(function() {
                return copyIfNotExists(concat3(["test", "Test", "Main.purs"]))(testMainTemplate("Test.Main"));
              })))(function() {
                return discard38(copyIfNotExists(".gitignore")(gitignoreTemplate))(function() {
                  return discard38(copyIfNotExists(pursReplFile.name)(pursReplFile.content))(function() {
                    return pure84(config2);
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Ls/index.js
var discard39 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug16 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var output4 = /* @__PURE__ */ output(monadEffectSpago);
var map102 = /* @__PURE__ */ map20(ordString);
var fromFoldable50 = /* @__PURE__ */ fromFoldable7(ordString)(foldableArray);
var map143 = /* @__PURE__ */ map(functorArray);
var object10 = /* @__PURE__ */ object2();
var rowListCodecCons9 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var object12 = /* @__PURE__ */ object10(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons9({
  reflectSymbol: function() {
    return "path";
  }
}))()()({
  reflectSymbol: function() {
    return "package";
  }
}))()()({
  reflectSymbol: function() {
    return "hasTests";
  }
}));
var $$delete9 = /* @__PURE__ */ $$delete5({
  reflectSymbol: function() {
    return "doc";
  }
})()();
var except9 = /* @__PURE__ */ except(applicativeIdentity);
var object22 = /* @__PURE__ */ object10(/* @__PURE__ */ rowListCodecCons9({
  reflectSymbol: function() {
    return "version";
  }
}));
var alt33 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupDecodeError)(monadIdentity));
var map228 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var object32 = /* @__PURE__ */ object10(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons9({
  reflectSymbol: function() {
    return "value";
  }
}))()()({
  reflectSymbol: function() {
    return "type";
  }
}));
var map314 = /* @__PURE__ */ map(functorMap);
var fromFoldable117 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var bind70 = /* @__PURE__ */ bind(bindSpago);
var ask14 = /* @__PURE__ */ ask(monadAskSpago);
var die15 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var toUnfoldable31 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var unwrap21 = /* @__PURE__ */ unwrap();
var filterKeys5 = /* @__PURE__ */ filterKeys(ordPackageName);
var elem6 = /* @__PURE__ */ elem(foldableSet)(eqPackageName);
var logWarn7 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var listPaths = function(v) {
  var keyValuePairs = [new Tuple("Global cache path", globalCachePath), new Tuple("Global registry path", registryPath), new Tuple("Global registry index path", registryIndexPath), new Tuple("Global package sets path", packageSetsPath), new Tuple("Global database path", databasePath), new Tuple("Local cache path", localCachePath), new Tuple("Local cache packages path", localCachePackagesPath)];
  return discard39(logDebug16("Running `listPaths`"))(function() {
    if (v.json) {
      return output4(new OutputJson(map102(string)(string), fromFoldable50(keyValuePairs)));
    }
    ;
    if (!v.json) {
      return output4(new OutputTable({
        titles: ["Name", "Path"],
        rows: map143(function(v1) {
          return [v1.value0, v1.value1];
        })(keyValuePairs)
      }));
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Ls (line 69, column 3 - line 76, column 10): " + [v.json.constructor.name]);
  });
};
var formatPackagesTable = function(dictMonadEffect) {
  var output1 = output(dictMonadEffect);
  return function(pkgs) {
    var showVersion2 = function(v) {
      if (v instanceof RegistryVersion) {
        return print6(v.value0);
      }
      ;
      if (v instanceof GitPackage) {
        return v.value0.ref;
      }
      ;
      if (v instanceof LocalPackage) {
        return "local";
      }
      ;
      if (v instanceof WorkspacePackage) {
        return "workspace";
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 182, column 17 - line 186, column 38): " + [v.constructor.name]);
    };
    var showLocation = function(v) {
      if (v instanceof RegistryVersion) {
        return "-";
      }
      ;
      if (v instanceof GitPackage) {
        return v.value0.git;
      }
      ;
      if (v instanceof LocalPackage) {
        return v.value0.path;
      }
      ;
      if (v instanceof WorkspacePackage) {
        return v.value0.path;
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 175, column 18 - line 179, column 38): " + [v.constructor.name]);
    };
    var toRow = function(v) {
      return [print5(v.value0), showVersion2(v.value1), showLocation(v.value1)];
    };
    return output1(new OutputTable({
      titles: ["Package", "Version", "Location"],
      rows: map143(toRow)(pkgs)
    }));
  };
};
var formatPackagesTable1 = /* @__PURE__ */ formatPackagesTable(monadEffectSpago);
var formatPackagesJson = function(dictMonadEffect) {
  var output1 = output(dictMonadEffect);
  return function(packages3) {
    var wrapPackage = function(value4) {
      return {
        value: value4,
        type: function() {
          if (value4 instanceof RegistryVersion) {
            return "registry";
          }
          ;
          if (value4 instanceof GitPackage) {
            return "git";
          }
          ;
          if (value4 instanceof LocalPackage) {
            return "local";
          }
          ;
          if (value4 instanceof WorkspacePackage) {
            return "workspace";
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Ls (line 123, column 13 - line 127, column 42): " + [value4.constructor.name]);
        }()
      };
    };
    var workspacePackageCodec = function() {
      var encode6 = function() {
        var $136 = encode2(named("WorkspacePackage")(object12({
          path: string,
          "package": packageConfigCodec,
          hasTests: $$boolean
        })));
        var $137 = $$delete9($$Proxy.value);
        return function($138) {
          return $136($137($138));
        };
      }();
      var decode4 = function(_json) {
        return except9(new Left(basic("Decoding workspace packages is not supported.")));
      };
      return codec$prime(decode4)(encode6);
    }();
    var packageCodec = function() {
      var registryVersionCodec = named("RegistryVersion")(object22({
        version: codec3
      }));
      var encode6 = function(v) {
        if (v instanceof RegistryVersion) {
          return encode2(registryVersionCodec)({
            version: v.value0
          });
        }
        ;
        if (v instanceof GitPackage) {
          return encode2(gitPackageCodec)(v.value0);
        }
        ;
        if (v instanceof LocalPackage) {
          return encode2(localPackageCodec)(v.value0);
        }
        ;
        if (v instanceof WorkspacePackage) {
          return encode2(workspacePackageCodec)(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Ls (line 137, column 14 - line 141, column 62): " + [v.constructor.name]);
      };
      var decode4 = function(json4) {
        return alt33(map228(function($139) {
          return RegistryVersion.create(function(v) {
            return v.version;
          }($139));
        })(decode(registryVersionCodec)(json4)))(alt33(map228(GitPackage.create)(decode(gitPackageCodec)(json4)))(alt33(map228(LocalPackage.create)(decode(localPackageCodec)(json4)))(map228(WorkspacePackage.create)(decode(workspacePackageCodec)(json4)))));
      };
      var innerCodec = codec$prime(decode4)(encode6);
      return named("Package")(object32({
        type: string,
        value: innerCodec
      }));
    }();
    return output1(new OutputJson(packageMap(packageCodec), map314(wrapPackage)(fromFoldable117(packages3))));
  };
};
var formatPackagesJson1 = /* @__PURE__ */ formatPackagesJson(monadEffectSpago);
var listPackageSet = function(v) {
  return discard39(logDebug16("Running `listPackageSet`"))(function() {
    return bind70(ask14)(function(v1) {
      if (v1.workspace.packageSet.buildType instanceof RegistrySolverBuild) {
        return die15("Cannot list the packages in the package set, as none is configured for the project.");
      }
      ;
      if (v1.workspace.packageSet.buildType instanceof PackageSetBuild) {
        var packages3 = toUnfoldable31(v1.workspace.packageSet.buildType.value1);
        if (v.json) {
          return formatPackagesJson1(packages3);
        }
        ;
        if (!v.json) {
          return formatPackagesTable1(packages3);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Ls (line 98, column 7 - line 100, column 46): " + [v.json.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 94, column 3 - line 100, column 46): " + [v1.workspace.packageSet.buildType.constructor.name]);
    });
  });
};
var listPackages = function(v) {
  return discard39(logDebug16("Running `listPackages`"))(function() {
    return bind70(ask14)(function(v1) {
      var direct = keys3(unwrap21(function(v2) {
        return v2.dependencies;
      }(function(v2) {
        return v2["package"];
      }(v1.selected))));
      var allDependencies = toAllDependencies(v1.dependencies);
      var directDependencies = filterKeys5(function(v2) {
        return elem6(v2)(direct);
      })(allDependencies);
      var packages3 = toUnfoldable31(function() {
        if (v.transitive) {
          return allDependencies;
        }
        ;
        return directDependencies;
      }());
      if (packages3.length === 0) {
        return logWarn7("There are no dependencies listed in your configuration");
      }
      ;
      if (v.json) {
        return formatPackagesJson1(packages3);
      }
      ;
      if (!v.json) {
        return formatPackagesTable1(packages3);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 114, column 10 - line 116, column 44): " + [v.json.constructor.name]);
    });
  });
};

// output/Data.Lens.Iso/index.js
var coerce18 = /* @__PURE__ */ coerce();
var iso = function(f) {
  return function(g) {
    return function(dictProfunctor) {
      var dimap6 = dimap(dictProfunctor);
      return function(pab) {
        return dimap6(f)(g)(pab);
      };
    };
  };
};
var coerced = function() {
  return function() {
    return function(dictProfunctor) {
      return iso(coerce18)(coerce18)(dictProfunctor);
    };
  };
};

// output/Data.Lens.Iso.Newtype/index.js
var coerced2 = /* @__PURE__ */ coerced()();
var _Newtype = function() {
  return function() {
    return function(dictProfunctor) {
      return coerced2(dictProfunctor);
    };
  };
};

// output/Routing.Duplex.Types/index.js
var emptyRouteState = {
  segments: [],
  params: [],
  hash: ""
};

// output/Routing.Duplex.Parser/index.js
var $runtime_lazy14 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var lookup17 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var map103 = /* @__PURE__ */ map(functorNonEmptyArray);
var map144 = /* @__PURE__ */ map(functorFn);
var foldl17 = /* @__PURE__ */ foldl(foldableNonEmptyArray);
var append43 = /* @__PURE__ */ append(semigroupNonEmptyArray);
var Expected = /* @__PURE__ */ function() {
  function Expected2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Expected2.create = function(value0) {
    return function(value12) {
      return new Expected2(value0, value12);
    };
  };
  return Expected2;
}();
var ExpectedEndOfPath = /* @__PURE__ */ function() {
  function ExpectedEndOfPath2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectedEndOfPath2.create = function(value0) {
    return new ExpectedEndOfPath2(value0);
  };
  return ExpectedEndOfPath2;
}();
var MissingParam = /* @__PURE__ */ function() {
  function MissingParam2(value0) {
    this.value0 = value0;
  }
  ;
  MissingParam2.create = function(value0) {
    return new MissingParam2(value0);
  };
  return MissingParam2;
}();
var EndOfPath = /* @__PURE__ */ function() {
  function EndOfPath2() {
  }
  ;
  EndOfPath2.value = new EndOfPath2();
  return EndOfPath2;
}();
var Fail2 = /* @__PURE__ */ function() {
  function Fail3(value0) {
    this.value0 = value0;
  }
  ;
  Fail3.create = function(value0) {
    return new Fail3(value0);
  };
  return Fail3;
}();
var Success3 = /* @__PURE__ */ function() {
  function Success4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Success4.create = function(value0) {
    return function(value12) {
      return new Success4(value0, value12);
    };
  };
  return Success4;
}();
var Alt = /* @__PURE__ */ function() {
  function Alt2(value0) {
    this.value0 = value0;
  }
  ;
  Alt2.create = function(value0) {
    return new Alt2(value0);
  };
  return Alt2;
}();
var Chomp = /* @__PURE__ */ function() {
  function Chomp2(value0) {
    this.value0 = value0;
  }
  ;
  Chomp2.create = function(value0) {
    return new Chomp2(value0);
  };
  return Chomp2;
}();
var Prefix = /* @__PURE__ */ function() {
  function Prefix2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Prefix2.create = function(value0) {
    return function(value12) {
      return new Prefix2(value0, value12);
    };
  };
  return Prefix2;
}();
var take7 = /* @__PURE__ */ function() {
  return new Chomp(function(state2) {
    var v = uncons(state2.segments);
    if (v instanceof Just) {
      return new Success3({
        params: state2.params,
        hash: state2.hash,
        segments: v.value0.tail
      }, v.value0.head);
    }
    ;
    return new Fail2(EndOfPath.value);
  });
}();
var prefix2 = /* @__PURE__ */ function() {
  return Prefix.create;
}();
var param = function(key) {
  return new Chomp(function(state2) {
    var v = lookup17(key)(state2.params);
    if (v instanceof Just) {
      return new Success3(state2, v.value0);
    }
    ;
    return new Fail2(new MissingParam(key));
  });
};
var functorRouteResult = {
  map: function(f) {
    return function(m) {
      if (m instanceof Fail2) {
        return new Fail2(m.value0);
      }
      ;
      if (m instanceof Success3) {
        return new Success3(m.value0, f(m.value1));
      }
      ;
      throw new Error("Failed pattern match at Routing.Duplex.Parser (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map229 = /* @__PURE__ */ map(functorRouteResult);
var functorRouteParser = {
  map: function(f) {
    return function(m) {
      if (m instanceof Alt) {
        return new Alt(map103(map(functorRouteParser)(f))(m.value0));
      }
      ;
      if (m instanceof Chomp) {
        return new Chomp(map144(map229(f))(m.value0));
      }
      ;
      if (m instanceof Prefix) {
        return new Prefix(m.value0, map(functorRouteParser)(f)(m.value1));
      }
      ;
      throw new Error("Failed pattern match at Routing.Duplex.Parser (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map315 = /* @__PURE__ */ map(functorRouteParser);
var end2 = /* @__PURE__ */ function() {
  return new Chomp(function(state2) {
    var v = head(state2.segments);
    if (v instanceof Nothing) {
      return new Success3(state2, unit);
    }
    ;
    if (v instanceof Just) {
      return new Fail2(new ExpectedEndOfPath(v.value0));
    }
    ;
    throw new Error("Failed pattern match at Routing.Duplex.Parser (line 266, column 3 - line 268, column 45): " + [v.constructor.name]);
  });
}();
var chompPrefix = function(pre) {
  return function(state2) {
    var v = head(state2.segments);
    if (v instanceof Just && pre === v.value0) {
      return new Success3({
        params: state2.params,
        hash: state2.hash,
        segments: drop(1)(state2.segments)
      }, unit);
    }
    ;
    if (v instanceof Just) {
      return new Fail2(new Expected(pre, v.value0));
    }
    ;
    return new Fail2(EndOfPath.value);
  };
};
var $lazy_runRouteParser = /* @__PURE__ */ $runtime_lazy14("runRouteParser", "Routing.Duplex.Parser", function() {
  var goAlt = function(v) {
    return function(v1) {
      return function(v2) {
        if (v1 instanceof Fail2) {
          return $lazy_runRouteParser(161)(v)(v2);
        }
        ;
        return v1;
      };
    };
  };
  var go = function($copy_state) {
    return function($copy_v) {
      var $tco_var_state = $copy_state;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(state2, v) {
        if (v instanceof Alt) {
          $tco_done = true;
          return foldl17(goAlt(state2))(new Fail2(EndOfPath.value))(v.value0);
        }
        ;
        if (v instanceof Chomp) {
          $tco_done = true;
          return v.value0(state2);
        }
        ;
        if (v instanceof Prefix) {
          var v1 = chompPrefix(v.value0)(state2);
          if (v1 instanceof Fail2) {
            $tco_done = true;
            return new Fail2(v1.value0);
          }
          ;
          if (v1 instanceof Success3) {
            $tco_var_state = v1.value0;
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Routing.Duplex.Parser (line 157, column 7 - line 159, column 40): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 153, column 14 - line 159, column 40): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_state, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
});
var runRouteParser = /* @__PURE__ */ $lazy_runRouteParser(150);
var as = function(print12) {
  return function(decode4) {
    return function(p) {
      return new Chomp(function(state2) {
        var v = runRouteParser(state2)(p);
        if (v instanceof Fail2) {
          return new Fail2(v.value0);
        }
        ;
        if (v instanceof Success3) {
          var v1 = decode4(v.value1);
          if (v1 instanceof Left) {
            return new Fail2(new Expected(v1.value0, print12(v.value1)));
          }
          ;
          if (v1 instanceof Right) {
            return new Success3(v.value0, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Routing.Duplex.Parser (line 254, column 7 - line 256, column 36): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 251, column 3 - line 256, column 36): " + [v.constructor.name]);
      });
    };
  };
};
var applyRouteParser = {
  apply: function(fx) {
    return function(x) {
      return new Chomp(function(state2) {
        var v = runRouteParser(state2)(fx);
        if (v instanceof Fail2) {
          return new Fail2(v.value0);
        }
        ;
        if (v instanceof Success3) {
          return map229(v.value1)(runRouteParser(v.value0)(x));
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 81, column 5 - line 83, column 56): " + [v.constructor.name]);
      });
    };
  },
  Functor0: function() {
    return functorRouteParser;
  }
};
var applicativeRouteParser = {
  pure: /* @__PURE__ */ function() {
    var $368 = flip(Success3.create);
    return function($369) {
      return Chomp.create($368($369));
    };
  }(),
  Apply0: function() {
    return applyRouteParser;
  }
};
var pure85 = /* @__PURE__ */ pure(applicativeRouteParser);
var altSnoc = function(v) {
  return function(v1) {
    var v2 = function(v3) {
      return snoc2(v)(v1);
    };
    if (v1 instanceof Prefix) {
      var $310 = last2(v);
      if ($310 instanceof Prefix) {
        var $311 = v1.value0 === $310.value0;
        if ($311) {
          return snoc$prime(init2(v))(new Prefix(v1.value0, alt(altRouteParser)($310.value1)(v1.value1)));
        }
        ;
        return v2(true);
      }
      ;
      return v2(true);
    }
    ;
    return v2(true);
  };
};
var altRouteParser = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Alt && v1 instanceof Alt) {
        return new Alt(altAppend(v.value0)(v1.value0));
      }
      ;
      if (v instanceof Alt) {
        return new Alt(altSnoc(v.value0)(v1));
      }
      ;
      if (v1 instanceof Alt) {
        return new Alt(altCons(v)(v1.value0));
      }
      ;
      if (v instanceof Prefix && (v1 instanceof Prefix && v.value0 === v1.value0)) {
        return new Prefix(v.value0, alt(altRouteParser)(v.value1)(v1.value1));
      }
      ;
      return new Alt(cons2(v)(singleton4(v1)));
    };
  },
  Functor0: function() {
    return functorRouteParser;
  }
};
var altCons = function(v) {
  return function(v1) {
    var v2 = function(v3) {
      return cons2(v)(v1);
    };
    if (v instanceof Prefix) {
      var $330 = head2(v1);
      if ($330 instanceof Prefix) {
        var $331 = v.value0 === $330.value0;
        if ($331) {
          return cons$prime(new Prefix(v.value0, alt(altRouteParser)(v.value1)($330.value1)))(tail2(v1));
        }
        ;
        return v2(true);
      }
      ;
      return v2(true);
    }
    ;
    return v2(true);
  };
};
var altAppend = function($copy_ls) {
  return function($copy_rs) {
    var $tco_var_ls = $copy_ls;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(ls3, rs) {
      var v = function(v12) {
        if (otherwise) {
          return append43(ls3)(rs);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 103, column 1 - line 107, column 35): " + [ls3.constructor.name, rs.constructor.name]);
      };
      var $340 = last2(ls3);
      if ($340 instanceof Prefix) {
        var $341 = head2(rs);
        if ($341 instanceof Prefix) {
          var $342 = $340.value0 === $341.value0;
          if ($342) {
            var rs$prime = cons$prime(new Prefix($340.value0, alt(altRouteParser)($340.value1)($341.value1)))(tail2(rs));
            var v1 = fromArray(init2(ls3));
            if (v1 instanceof Just) {
              $tco_var_ls = v1.value0;
              $copy_rs = rs$prime;
              return;
            }
            ;
            if (v1 instanceof Nothing) {
              $tco_done = true;
              return rs$prime;
            }
            ;
            throw new Error("Failed pattern match at Routing.Duplex.Parser (line 116, column 9 - line 118, column 25): " + [v1.constructor.name]);
          }
          ;
          $tco_done = true;
          return v(true);
        }
        ;
        $tco_done = true;
        return v(true);
      }
      ;
      $tco_done = true;
      return v(true);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_ls, $copy_rs);
    }
    ;
    return $tco_result;
  };
};
var alt34 = /* @__PURE__ */ alt(altRouteParser);
var $$default = /* @__PURE__ */ function() {
  var $370 = flip(alt34);
  return function($371) {
    return $370(pure85($371));
  };
}();
var optional6 = /* @__PURE__ */ function() {
  var $375 = $$default(Nothing.value);
  var $376 = map315(Just.create);
  return function($377) {
    return $375($376($377));
  };
}();

// output/Routing.Duplex.Printer/index.js
var append44 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupMaybe(semigroupString));
var semigroupRoutePrinter = {
  append: function(v) {
    return function(v1) {
      return function($33) {
        return v1(v($33));
      };
    };
  }
};
var put6 = function(str2) {
  return function(state2) {
    return {
      params: state2.params,
      hash: state2.hash,
      segments: snoc(state2.segments)(str2)
    };
  };
};
var printPath = function(v) {
  var printSegments = function(v1) {
    if (v1.length === 1 && v1[0] === "") {
      return "/";
    }
    ;
    return joinWith("/")(mapMaybe($$encodeURIComponent)(v1));
  };
  var printParam = function(v1) {
    return function(v2) {
      if (v2 === "") {
        return $$encodeURIComponent(v1);
      }
      ;
      return append44($$encodeURIComponent(v1))(append44(new Just("="))($$encodeURIComponent(v2)));
    };
  };
  var printParams = function(v1) {
    if (v1.length === 0) {
      return "";
    }
    ;
    return "?" + joinWith("&")(mapMaybe(uncurry(printParam))(v1));
  };
  var printHash = function(v1) {
    if (v1 === "") {
      return "";
    }
    ;
    return "#" + v1;
  };
  return printSegments(v.segments) + (printParams(v.params) + printHash(v.hash));
};
var param2 = function(key) {
  return function(val) {
    return function(state2) {
      return {
        segments: state2.segments,
        hash: state2.hash,
        params: cons(new Tuple(key, val))(state2.params)
      };
    };
  };
};
var run8 = /* @__PURE__ */ function() {
  var $34 = applyFlipped(emptyRouteState);
  var $35 = unwrap();
  return function($36) {
    return printPath($34($35($36)));
  };
}();
var monoidRoutePRinter = {
  mempty: /* @__PURE__ */ identity(categoryFn),
  Semigroup0: function() {
    return semigroupRoutePrinter;
  }
};

// output/Routing.Duplex/index.js
var append45 = /* @__PURE__ */ append(semigroupRoutePrinter);
var applyFirst3 = /* @__PURE__ */ applyFirst(applyRouteParser);
var pure86 = /* @__PURE__ */ pure(applicativeRouteParser);
var identity34 = /* @__PURE__ */ identity(categoryFn);
var apply25 = /* @__PURE__ */ apply2(applyRouteParser);
var map104 = /* @__PURE__ */ map(functorRouteParser);
var foldMap27 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidRoutePRinter);
var mempty29 = /* @__PURE__ */ mempty(monoidRoutePRinter);
var apply110 = /* @__PURE__ */ apply2(applyFn);
var map145 = /* @__PURE__ */ map(functorFn);
var RouteDuplex = /* @__PURE__ */ function() {
  function RouteDuplex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RouteDuplex2.create = function(value0) {
    return function(value12) {
      return new RouteDuplex2(value0, value12);
    };
  };
  return RouteDuplex2;
}();
var string6 = identity34;
var segment = /* @__PURE__ */ function() {
  return new RouteDuplex(put6, take7);
}();
var record3 = /* @__PURE__ */ function() {
  return new RouteDuplex(mempty(monoidFn(monoidRoutePRinter)), pure86({}));
}();
var prop3 = function(dictIsSymbol) {
  var get6 = get3(dictIsSymbol)();
  var insert22 = insert5(dictIsSymbol)()();
  return function() {
    return function() {
      return function() {
        return function(sym) {
          return function(v) {
            return function(v1) {
              return new RouteDuplex(function(r) {
                return append45(v1.value0(r))(v.value0(get6(sym)(r)));
              }, apply25(map104(flip(insert22(sym)))(v1.value1))(v.value1));
            };
          };
        };
      };
    };
  };
};
var profunctorRouteDuplex = {
  dimap: function(f) {
    return function(g) {
      return function(v) {
        return new RouteDuplex(function($137) {
          return v.value0(f($137));
        }, map104(g)(v.value1));
      };
    };
  }
};
var print11 = function(v) {
  return function($138) {
    return run8(v.value0($138));
  };
};
var prefix3 = function(s) {
  return function(v) {
    return new RouteDuplex(function(a) {
      return append45(put6(s))(v.value0(a));
    }, prefix2(s)(v.value1));
  };
};
var path13 = /* @__PURE__ */ function() {
  var $139 = flip(foldr(foldableArray)(prefix3));
  var $140 = split("/");
  return function($141) {
    return $139($140($141));
  };
}();
var root = /* @__PURE__ */ path13("");
var params = function(dict) {
  return dict.params;
};
var param3 = function(p) {
  return new RouteDuplex(param2(p), param(p));
};
var optional7 = function(v) {
  return new RouteDuplex(foldMap27(v.value0), optional6(v.value1));
};
var functorRouteDuplex = {
  map: function(f) {
    return function(m) {
      return new RouteDuplex(m.value0, map104(f)(m.value1));
    };
  }
};
var end3 = function(v) {
  return new RouteDuplex(v.value0, applyFirst3(v.value1)(end2));
};
var buildParamsNil = {
  buildParams: function(v) {
    return function(v1) {
      return identity34;
    };
  }
};
var buildParams = function(dict) {
  return dict.buildParams;
};
var buildParamsCons = function(dictIsSymbol) {
  var prop1 = prop3(dictIsSymbol)()()();
  var get6 = get3(dictIsSymbol)();
  var reflectSymbol2 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function() {
        return function() {
          return function(dictRouteDuplexBuildParams) {
            var buildParams1 = buildParams(dictRouteDuplexBuildParams);
            return {
              buildParams: function(v) {
                return function(r) {
                  return function(prev) {
                    return buildParams1($$Proxy.value)(r)(prop1($$Proxy.value)(get6($$Proxy.value)(r)(param3(reflectSymbol2($$Proxy.value))))(prev));
                  };
                };
              }
            };
          };
        };
      };
    };
  };
};
var routeDuplexParams = function() {
  return function(dictRouteDuplexBuildParams) {
    var buildParams1 = buildParams(dictRouteDuplexBuildParams);
    return {
      params: function(r) {
        return buildParams1($$Proxy.value)(r)(record3);
      }
    };
  };
};
var as2 = function(f) {
  return function(g) {
    return function(v) {
      return new RouteDuplex(function($142) {
        return v.value0(f($142));
      }, as(identity34)(g)(v.value1));
    };
  };
};
var applyRouteDuplex = {
  apply: function(v) {
    return function(v1) {
      return new RouteDuplex(apply110(map145(append45)(v.value0))(v1.value0), apply25(v.value1)(v1.value1));
    };
  },
  Functor0: function() {
    return functorRouteDuplex;
  }
};
var applicativeRouteDuplex = {
  pure: /* @__PURE__ */ function() {
    var $143 = RouteDuplex.create($$const(mempty29));
    return function($144) {
      return $143(pure86($144));
    };
  }(),
  Apply0: function() {
    return applyRouteDuplex;
  }
};

// output/Routing.Duplex.Generic/index.js
var identity35 = /* @__PURE__ */ identity(categoryFn);
var append46 = /* @__PURE__ */ append(semigroupRoutePrinter);
var apply26 = /* @__PURE__ */ apply2(applyRouteParser);
var map105 = /* @__PURE__ */ map(functorRouteParser);
var alt35 = /* @__PURE__ */ alt(altRouteParser);
var dimap5 = /* @__PURE__ */ dimap(profunctorRouteDuplex);
var noArgs = /* @__PURE__ */ function() {
  return pure(applicativeRouteDuplex)(NoArguments.value);
}();
var gRouteProduct = {
  gRouteDuplexCtr: identity35
};
var gRouteNoArguments = {
  gRouteDuplexCtr: identity35
};
var gRouteDuplexCtr = function(dict) {
  return dict.gRouteDuplexCtr;
};
var product2 = function(dictGRouteDuplexCtr) {
  var gRouteDuplexCtr1 = gRouteDuplexCtr(dictGRouteDuplexCtr);
  return function(v) {
    return function(l) {
      var v1 = gRouteDuplexCtr1(l);
      var enc = function(v2) {
        return append46(v.value0(v2.value0))(v1.value0(v2.value1));
      };
      var dec = apply26(map105(Product.create)(map105(Argument)(v.value1)))(v1.value1);
      return new RouteDuplex(enc, dec);
    };
  };
};
var gRouteDuplex = function(dict) {
  return dict.gRouteDuplex;
};
var gRouteSum = function(dictGRouteDuplex) {
  var gRouteDuplex1 = gRouteDuplex(dictGRouteDuplex);
  return function(dictGRouteDuplex1) {
    var gRouteDuplex2 = gRouteDuplex(dictGRouteDuplex1);
    return {
      gRouteDuplex: function(end$prime) {
        return function(r) {
          var v = gRouteDuplex1(end$prime)(r);
          var v1 = gRouteDuplex2(end$prime)(r);
          var enc = function(v2) {
            if (v2 instanceof Inl) {
              return v.value0(v2.value0);
            }
            ;
            if (v2 instanceof Inr) {
              return v1.value0(v2.value0);
            }
            ;
            throw new Error("Failed pattern match at Routing.Duplex.Generic (line 51, column 11 - line 53, column 22): " + [v2.constructor.name]);
          };
          var dec = alt35(map105(Inl.create)(v.value1))(map105(Inr.create)(v1.value1));
          return new RouteDuplex(enc, dec);
        };
      }
    };
  };
};
var sum3 = function(dictGeneric) {
  var from4 = from(dictGeneric);
  var to2 = to(dictGeneric);
  return function(dictGRouteDuplex) {
    var $71 = dimap5(from4)(to2);
    var $72 = gRouteDuplex(dictGRouteDuplex)(end3);
    return function($73) {
      return $71($72($73));
    };
  };
};
var gRouteConstructor = function(dictIsSymbol) {
  var get6 = get3(dictIsSymbol)();
  return function() {
    return function(dictGRouteDuplexCtr) {
      var gRouteDuplexCtr1 = gRouteDuplexCtr(dictGRouteDuplexCtr);
      return {
        gRouteDuplex: function(end$prime) {
          return function(r) {
            var v = end$prime(gRouteDuplexCtr1(get6($$Proxy.value)(r)));
            var enc = function(v1) {
              return v.value0(v1);
            };
            var dec = map105(Constructor)(v.value1);
            return new RouteDuplex(enc, dec);
          };
        }
      };
    };
  };
};
var gRouteAll = {
  gRouteDuplexCtr: function(v) {
    return new RouteDuplex(function(v1) {
      return v.value0(v1);
    }, map105(Argument)(v.value1));
  }
};

// output/Routing.Duplex.Generic.Syntax/index.js
var product3 = /* @__PURE__ */ product2(gRouteAll);
var gsepStringRoute = function(dictGRouteDuplexCtr) {
  var gRouteDuplexCtr2 = gRouteDuplexCtr(dictGRouteDuplexCtr);
  return {
    gsep: function(a) {
      var $15 = prefix3(a);
      return function($16) {
        return $15(gRouteDuplexCtr2($16));
      };
    }
  };
};
var gsep = function(dict) {
  return dict.gsep;
};
var gparamsRoute = function(dictRouteDuplexParams) {
  var params2 = params(dictRouteDuplexParams);
  return {
    gparams: function(a) {
      var $21 = product3(a);
      return function($22) {
        return $21(params2($22));
      };
    }
  };
};
var gparams = function(dict) {
  return dict.gparams;
};

// output/Registry.API.V1/index.js
var show50 = /* @__PURE__ */ show(showString);
var gsep2 = /* @__PURE__ */ gsep(/* @__PURE__ */ gsepStringRoute(gRouteNoArguments));
var levelIsSymbol = {
  reflectSymbol: function() {
    return "level";
  }
};
var object11 = /* @__PURE__ */ object2();
var rowListCodecCons10 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var jobIdIsSymbol = {
  reflectSymbol: function() {
    return "jobId";
  }
};
var Debug = /* @__PURE__ */ function() {
  function Debug2() {
  }
  ;
  Debug2.value = new Debug2();
  return Debug2;
}();
var Info = /* @__PURE__ */ function() {
  function Info2() {
  }
  ;
  Info2.value = new Info2();
  return Info2;
}();
var Warn = /* @__PURE__ */ function() {
  function Warn2() {
  }
  ;
  Warn2.value = new Warn2();
  return Warn2;
}();
var $$Error3 = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var PublishJob = /* @__PURE__ */ function() {
  function PublishJob2() {
  }
  ;
  PublishJob2.value = new PublishJob2();
  return PublishJob2;
}();
var UnpublishJob = /* @__PURE__ */ function() {
  function UnpublishJob2() {
  }
  ;
  UnpublishJob2.value = new UnpublishJob2();
  return UnpublishJob2;
}();
var TransferJob = /* @__PURE__ */ function() {
  function TransferJob2() {
  }
  ;
  TransferJob2.value = new TransferJob2();
  return TransferJob2;
}();
var JobId = function(x) {
  return x;
};
var Publish = /* @__PURE__ */ function() {
  function Publish3() {
  }
  ;
  Publish3.value = new Publish3();
  return Publish3;
}();
var Unpublish = /* @__PURE__ */ function() {
  function Unpublish2() {
  }
  ;
  Unpublish2.value = new Unpublish2();
  return Unpublish2;
}();
var Transfer = /* @__PURE__ */ function() {
  function Transfer2() {
  }
  ;
  Transfer2.value = new Transfer2();
  return Transfer2;
}();
var Jobs = /* @__PURE__ */ function() {
  function Jobs2() {
  }
  ;
  Jobs2.value = new Jobs2();
  return Jobs2;
}();
var Job = /* @__PURE__ */ function() {
  function Job2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Job2.create = function(value0) {
    return function(value12) {
      return new Job2(value0, value12);
    };
  };
  return Job2;
}();
var Status = /* @__PURE__ */ function() {
  function Status2() {
  }
  ;
  Status2.value = new Status2();
  return Status2;
}();
var genericRoute_ = {
  to: function(x) {
    if (x instanceof Inl) {
      return Publish.value;
    }
    ;
    if (x instanceof Inr && x.value0 instanceof Inl) {
      return Unpublish.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && x.value0.value0 instanceof Inl)) {
      return Transfer.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inl))) {
      return Jobs.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && (x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inl)))) {
      return new Job(x.value0.value0.value0.value0.value0.value0, x.value0.value0.value0.value0.value0.value1);
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && (x.value0.value0.value0 instanceof Inr && x.value0.value0.value0.value0 instanceof Inr)))) {
      return Status.value;
    }
    ;
    throw new Error("Failed pattern match at Registry.API.V1 (line 33, column 1 - line 33, column 32): " + [x.constructor.name]);
  },
  from: function(x) {
    if (x instanceof Publish) {
      return new Inl(NoArguments.value);
    }
    ;
    if (x instanceof Unpublish) {
      return new Inr(new Inl(NoArguments.value));
    }
    ;
    if (x instanceof Transfer) {
      return new Inr(new Inr(new Inl(NoArguments.value)));
    }
    ;
    if (x instanceof Jobs) {
      return new Inr(new Inr(new Inr(new Inl(NoArguments.value))));
    }
    ;
    if (x instanceof Job) {
      return new Inr(new Inr(new Inr(new Inr(new Inl(new Product(x.value0, x.value1))))));
    }
    ;
    if (x instanceof Status) {
      return new Inr(new Inr(new Inr(new Inr(new Inr(NoArguments.value)))));
    }
    ;
    throw new Error("Failed pattern match at Registry.API.V1 (line 33, column 1 - line 33, column 32): " + [x.constructor.name]);
  }
};
var timestampP = /* @__PURE__ */ function() {
  var printTimestamp = function(t) {
    return format(iso8601DateTime)(t);
  };
  var parseTimestamp = function(s) {
    return unformat(iso8601DateTime)(s);
  };
  return as2(printTimestamp)(parseTimestamp);
}();
var printLogLevel = function(v) {
  if (v instanceof Debug) {
    return "DEBUG";
  }
  ;
  if (v instanceof Info) {
    return "INFO";
  }
  ;
  if (v instanceof Warn) {
    return "WARN";
  }
  ;
  if (v instanceof $$Error3) {
    return "ERROR";
  }
  ;
  throw new Error("Failed pattern match at Registry.API.V1 (line 138, column 17 - line 142, column 19): " + [v.constructor.name]);
};
var printJobType = function(v) {
  if (v instanceof PublishJob) {
    return "publish";
  }
  ;
  if (v instanceof UnpublishJob) {
    return "unpublish";
  }
  ;
  if (v instanceof TransferJob) {
    return "transfer";
  }
  ;
  throw new Error("Failed pattern match at Registry.API.V1 (line 109, column 16 - line 112, column 28): " + [v.constructor.name]);
};
var parseLogLevel = function(v) {
  if (v === "DEBUG") {
    return new Right(Debug.value);
  }
  ;
  if (v === "INFO") {
    return new Right(Info.value);
  }
  ;
  if (v === "WARN") {
    return new Right(Warn.value);
  }
  ;
  if (v === "ERROR") {
    return new Right($$Error3.value);
  }
  ;
  return new Left("Invalid log level: " + v);
};
var parseJobType = function(v) {
  if (v === "publish") {
    return new Right(PublishJob.value);
  }
  ;
  if (v === "unpublish") {
    return new Right(UnpublishJob.value);
  }
  ;
  if (v === "transfer") {
    return new Right(TransferJob.value);
  }
  ;
  return new Left("Invalid job type " + show50(v));
};
var logLevelP = /* @__PURE__ */ as2(printLogLevel)(parseLogLevel);
var jobTypeCodec = /* @__PURE__ */ enumSum(printJobType)(function($187) {
  return hush(parseJobType($187));
});
var jobIdS = /* @__PURE__ */ _Newtype()()(profunctorRouteDuplex)(segment);
var routes = /* @__PURE__ */ root(/* @__PURE__ */ prefix3("api")(/* @__PURE__ */ prefix3("v1")(/* @__PURE__ */ sum3(genericRoute_)(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Publish";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Unpublish";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Transfer";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Jobs";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Job";
  }
})()(gRouteProduct))(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Status";
  }
})()(gRouteNoArguments)))))))({
  Publish: /* @__PURE__ */ gsep2("publish")(noArgs),
  Unpublish: /* @__PURE__ */ gsep2("unpublish")(noArgs),
  Transfer: /* @__PURE__ */ gsep2("transfer")(noArgs),
  Jobs: /* @__PURE__ */ gsep2("jobs")(noArgs),
  Job: /* @__PURE__ */ gsep(/* @__PURE__ */ gsepStringRoute(gRouteProduct))("jobs")(/* @__PURE__ */ gparams(/* @__PURE__ */ gparamsRoute(/* @__PURE__ */ routeDuplexParams()(/* @__PURE__ */ buildParamsCons(levelIsSymbol)()()()()(/* @__PURE__ */ buildParamsCons({
    reflectSymbol: function() {
      return "since";
    }
  })()()()()(buildParamsNil)))))(jobIdS)({
    level: function($188) {
      return optional7(logLevelP(string6($188)));
    },
    since: function($189) {
      return optional7(timestampP(string6($189)));
    }
  })),
  Status: /* @__PURE__ */ gsep2("status")(noArgs)
}))));
var jobIdCodec = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(/* @__PURE__ */ functorExceptT(functorIdentity)))()(JobId)(string);
var logLineCodec = /* @__PURE__ */ named("LogLine")(/* @__PURE__ */ object11(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons10({
  reflectSymbol: function() {
    return "timestamp";
  }
}))()()({
  reflectSymbol: function() {
    return "message";
  }
}))()()(levelIsSymbol))()()(jobIdIsSymbol))({
  level: /* @__PURE__ */ enumSum(printLogLevel)(function($190) {
    return hush(parseLogLevel($190));
  }),
  message: string,
  jobId: jobIdCodec,
  timestamp: iso8601DateTime2
}));
var jobCreatedResponseCodec = /* @__PURE__ */ named("JobCreatedResponse")(/* @__PURE__ */ object11(/* @__PURE__ */ rowListCodecCons10(jobIdIsSymbol))({
  jobId: jobIdCodec
}));
var jobCodec = /* @__PURE__ */ named("Job")(/* @__PURE__ */ object11(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons10({
  reflectSymbol: function() {
    return "success";
  }
}))()()({
  reflectSymbol: function() {
    return "ref";
  }
}))()()({
  reflectSymbol: function() {
    return "packageName";
  }
}))()()({
  reflectSymbol: function() {
    return "logs";
  }
}))()()({
  reflectSymbol: function() {
    return "jobType";
  }
}))()()(jobIdIsSymbol))()()({
  reflectSymbol: function() {
    return "finishedAt";
  }
}))()()({
  reflectSymbol: function() {
    return "createdAt";
  }
}))({
  jobId: jobIdCodec,
  jobType: jobTypeCodec,
  packageName: codec2,
  ref: string,
  createdAt: iso8601DateTime2,
  finishedAt: /* @__PURE__ */ optional4(iso8601DateTime2),
  success: $$boolean,
  logs: /* @__PURE__ */ array(logLineCodec)
}));

// output/Registry.Internal.Path/index.js
var pure87 = /* @__PURE__ */ pure(applicativeAff);
var bind125 = /* @__PURE__ */ bind(bindAff);
var foldMap28 = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAff(monoidArray));
var pursFileExtensionRegex = /* @__PURE__ */ unsafeRegex("\\.purs$")(noFlags);
var readPursFiles = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  return function(init4) {
    var go = function(depth) {
      return function(root2) {
        return bind125(readdir3(root2))(foldMap28(function(file) {
          var path14 = concat3([root2, sep, file]);
          return bind125(stat3(path14))(function(stats) {
            var $19 = isDirectory(stats);
            if ($19) {
              return go(depth + 1 | 0)(path14);
            }
            ;
            var $20 = test(pursFileExtensionRegex)(path14);
            if ($20) {
              return pure87([path14]);
            }
            ;
            return pure87([]);
          });
        }));
      };
    };
    return liftAff13(bind125(attempt(go(0)(init4)))(function(result) {
      if (result instanceof Left) {
        return pure87(Nothing.value);
      }
      ;
      if (result instanceof Right) {
        return pure87(fromArray(result.value0));
      }
      ;
      throw new Error("Failed pattern match at Registry.Internal.Path (line 43, column 3 - line 45, column 46): " + [result.constructor.name]);
    }));
  };
};

// output/Registry.SSH/foreign.js
var import_ssh2 = __toESM(require_lib4(), 1);

// output/Registry.Operation/index.js
var object13 = /* @__PURE__ */ object2();
var nameIsSymbol4 = {
  reflectSymbol: function() {
    return "name";
  }
};
var compilerIsSymbol3 = {
  reflectSymbol: function() {
    return "compiler";
  }
};
var publishCodec = /* @__PURE__ */ named("Publish")(/* @__PURE__ */ object13(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "resolutions";
  }
}))()()({
  reflectSymbol: function() {
    return "ref";
  }
}))()()(nameIsSymbol4))()()({
  reflectSymbol: function() {
    return "location";
  }
}))()()(compilerIsSymbol3))({
  name: codec2,
  location: /* @__PURE__ */ optional4(codec5),
  ref: string,
  compiler: codec3,
  resolutions: /* @__PURE__ */ optional4(/* @__PURE__ */ packageMap(codec3))
}));

// output/PureScript.CST.Types/index.js
var ASCII2 = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var Unicode = /* @__PURE__ */ function() {
  function Unicode2() {
  }
  ;
  Unicode2.value = new Unicode2();
  return Unicode2;
}();
var Nominal2 = /* @__PURE__ */ function() {
  function Nominal3() {
  }
  ;
  Nominal3.value = new Nominal3();
  return Nominal3;
}();
var Representational2 = /* @__PURE__ */ function() {
  function Representational3() {
  }
  ;
  Representational3.value = new Representational3();
  return Representational3;
}();
var Phantom2 = /* @__PURE__ */ function() {
  function Phantom3() {
  }
  ;
  Phantom3.value = new Phantom3();
  return Phantom3;
}();
var LF = /* @__PURE__ */ function() {
  function LF2() {
  }
  ;
  LF2.value = new LF2();
  return LF2;
}();
var CRLF = /* @__PURE__ */ function() {
  function CRLF2() {
  }
  ;
  CRLF2.value = new CRLF2();
  return CRLF2;
}();
var SmallInt = /* @__PURE__ */ function() {
  function SmallInt2(value0) {
    this.value0 = value0;
  }
  ;
  SmallInt2.create = function(value0) {
    return new SmallInt2(value0);
  };
  return SmallInt2;
}();
var BigInt2 = /* @__PURE__ */ function() {
  function BigInt3(value0) {
    this.value0 = value0;
  }
  ;
  BigInt3.create = function(value0) {
    return new BigInt3(value0);
  };
  return BigInt3;
}();
var BigHex = /* @__PURE__ */ function() {
  function BigHex2(value0) {
    this.value0 = value0;
  }
  ;
  BigHex2.create = function(value0) {
    return new BigHex2(value0);
  };
  return BigHex2;
}();
var TokLeftParen = /* @__PURE__ */ function() {
  function TokLeftParen2() {
  }
  ;
  TokLeftParen2.value = new TokLeftParen2();
  return TokLeftParen2;
}();
var TokRightParen = /* @__PURE__ */ function() {
  function TokRightParen2() {
  }
  ;
  TokRightParen2.value = new TokRightParen2();
  return TokRightParen2;
}();
var TokLeftBrace = /* @__PURE__ */ function() {
  function TokLeftBrace2() {
  }
  ;
  TokLeftBrace2.value = new TokLeftBrace2();
  return TokLeftBrace2;
}();
var TokRightBrace = /* @__PURE__ */ function() {
  function TokRightBrace2() {
  }
  ;
  TokRightBrace2.value = new TokRightBrace2();
  return TokRightBrace2;
}();
var TokLeftSquare = /* @__PURE__ */ function() {
  function TokLeftSquare2() {
  }
  ;
  TokLeftSquare2.value = new TokLeftSquare2();
  return TokLeftSquare2;
}();
var TokRightSquare = /* @__PURE__ */ function() {
  function TokRightSquare2() {
  }
  ;
  TokRightSquare2.value = new TokRightSquare2();
  return TokRightSquare2;
}();
var TokLeftArrow = /* @__PURE__ */ function() {
  function TokLeftArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokLeftArrow2.create = function(value0) {
    return new TokLeftArrow2(value0);
  };
  return TokLeftArrow2;
}();
var TokRightArrow = /* @__PURE__ */ function() {
  function TokRightArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightArrow2.create = function(value0) {
    return new TokRightArrow2(value0);
  };
  return TokRightArrow2;
}();
var TokRightFatArrow = /* @__PURE__ */ function() {
  function TokRightFatArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightFatArrow2.create = function(value0) {
    return new TokRightFatArrow2(value0);
  };
  return TokRightFatArrow2;
}();
var TokDoubleColon = /* @__PURE__ */ function() {
  function TokDoubleColon2(value0) {
    this.value0 = value0;
  }
  ;
  TokDoubleColon2.create = function(value0) {
    return new TokDoubleColon2(value0);
  };
  return TokDoubleColon2;
}();
var TokForall = /* @__PURE__ */ function() {
  function TokForall2(value0) {
    this.value0 = value0;
  }
  ;
  TokForall2.create = function(value0) {
    return new TokForall2(value0);
  };
  return TokForall2;
}();
var TokEquals = /* @__PURE__ */ function() {
  function TokEquals2() {
  }
  ;
  TokEquals2.value = new TokEquals2();
  return TokEquals2;
}();
var TokPipe = /* @__PURE__ */ function() {
  function TokPipe2() {
  }
  ;
  TokPipe2.value = new TokPipe2();
  return TokPipe2;
}();
var TokTick = /* @__PURE__ */ function() {
  function TokTick2() {
  }
  ;
  TokTick2.value = new TokTick2();
  return TokTick2;
}();
var TokDot = /* @__PURE__ */ function() {
  function TokDot2() {
  }
  ;
  TokDot2.value = new TokDot2();
  return TokDot2;
}();
var TokComma = /* @__PURE__ */ function() {
  function TokComma2() {
  }
  ;
  TokComma2.value = new TokComma2();
  return TokComma2;
}();
var TokUnderscore = /* @__PURE__ */ function() {
  function TokUnderscore2() {
  }
  ;
  TokUnderscore2.value = new TokUnderscore2();
  return TokUnderscore2;
}();
var TokBackslash = /* @__PURE__ */ function() {
  function TokBackslash2() {
  }
  ;
  TokBackslash2.value = new TokBackslash2();
  return TokBackslash2;
}();
var TokAt = /* @__PURE__ */ function() {
  function TokAt2() {
  }
  ;
  TokAt2.value = new TokAt2();
  return TokAt2;
}();
var TokLowerName = /* @__PURE__ */ function() {
  function TokLowerName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokLowerName2.create = function(value0) {
    return function(value12) {
      return new TokLowerName2(value0, value12);
    };
  };
  return TokLowerName2;
}();
var TokUpperName = /* @__PURE__ */ function() {
  function TokUpperName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokUpperName2.create = function(value0) {
    return function(value12) {
      return new TokUpperName2(value0, value12);
    };
  };
  return TokUpperName2;
}();
var TokOperator = /* @__PURE__ */ function() {
  function TokOperator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokOperator2.create = function(value0) {
    return function(value12) {
      return new TokOperator2(value0, value12);
    };
  };
  return TokOperator2;
}();
var TokSymbolName = /* @__PURE__ */ function() {
  function TokSymbolName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokSymbolName2.create = function(value0) {
    return function(value12) {
      return new TokSymbolName2(value0, value12);
    };
  };
  return TokSymbolName2;
}();
var TokSymbolArrow = /* @__PURE__ */ function() {
  function TokSymbolArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokSymbolArrow2.create = function(value0) {
    return new TokSymbolArrow2(value0);
  };
  return TokSymbolArrow2;
}();
var TokHole = /* @__PURE__ */ function() {
  function TokHole2(value0) {
    this.value0 = value0;
  }
  ;
  TokHole2.create = function(value0) {
    return new TokHole2(value0);
  };
  return TokHole2;
}();
var TokChar = /* @__PURE__ */ function() {
  function TokChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokChar2.create = function(value0) {
    return function(value12) {
      return new TokChar2(value0, value12);
    };
  };
  return TokChar2;
}();
var TokString = /* @__PURE__ */ function() {
  function TokString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokString2.create = function(value0) {
    return function(value12) {
      return new TokString2(value0, value12);
    };
  };
  return TokString2;
}();
var TokRawString = /* @__PURE__ */ function() {
  function TokRawString2(value0) {
    this.value0 = value0;
  }
  ;
  TokRawString2.create = function(value0) {
    return new TokRawString2(value0);
  };
  return TokRawString2;
}();
var TokInt = /* @__PURE__ */ function() {
  function TokInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokInt2.create = function(value0) {
    return function(value12) {
      return new TokInt2(value0, value12);
    };
  };
  return TokInt2;
}();
var TokNumber = /* @__PURE__ */ function() {
  function TokNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokNumber2.create = function(value0) {
    return function(value12) {
      return new TokNumber2(value0, value12);
    };
  };
  return TokNumber2;
}();
var TokLayoutStart = /* @__PURE__ */ function() {
  function TokLayoutStart2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutStart2.create = function(value0) {
    return new TokLayoutStart2(value0);
  };
  return TokLayoutStart2;
}();
var TokLayoutSep = /* @__PURE__ */ function() {
  function TokLayoutSep2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutSep2.create = function(value0) {
    return new TokLayoutSep2(value0);
  };
  return TokLayoutSep2;
}();
var TokLayoutEnd = /* @__PURE__ */ function() {
  function TokLayoutEnd2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutEnd2.create = function(value0) {
    return new TokLayoutEnd2(value0);
  };
  return TokLayoutEnd2;
}();
var Infix2 = /* @__PURE__ */ function() {
  function Infix3() {
  }
  ;
  Infix3.value = new Infix3();
  return Infix3;
}();
var Infixl2 = /* @__PURE__ */ function() {
  function Infixl3() {
  }
  ;
  Infixl3.value = new Infixl3();
  return Infixl3;
}();
var Infixr2 = /* @__PURE__ */ function() {
  function Infixr3() {
  }
  ;
  Infixr3.value = new Infixr3();
  return Infixr3;
}();
var Comment = /* @__PURE__ */ function() {
  function Comment2(value0) {
    this.value0 = value0;
  }
  ;
  Comment2.create = function(value0) {
    return new Comment2(value0);
  };
  return Comment2;
}();
var Space = /* @__PURE__ */ function() {
  function Space2(value0) {
    this.value0 = value0;
  }
  ;
  Space2.create = function(value0) {
    return new Space2(value0);
  };
  return Space2;
}();
var Line2 = /* @__PURE__ */ function() {
  function Line3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Line3.create = function(value0) {
    return function(value12) {
      return new Line3(value0, value12);
    };
  };
  return Line3;
}();
var FixityValue = /* @__PURE__ */ function() {
  function FixityValue2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FixityValue2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FixityValue2(value0, value12, value22);
      };
    };
  };
  return FixityValue2;
}();
var FixityType = /* @__PURE__ */ function() {
  function FixityType2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  FixityType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new FixityType2(value0, value12, value22, value32);
        };
      };
    };
  };
  return FixityType2;
}();
var RecordPun = /* @__PURE__ */ function() {
  function RecordPun2(value0) {
    this.value0 = value0;
  }
  ;
  RecordPun2.create = function(value0) {
    return new RecordPun2(value0);
  };
  return RecordPun2;
}();
var RecordField = /* @__PURE__ */ function() {
  function RecordField2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordField2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordField2(value0, value12, value22);
      };
    };
  };
  return RecordField2;
}();
var DataAll = /* @__PURE__ */ function() {
  function DataAll2(value0) {
    this.value0 = value0;
  }
  ;
  DataAll2.create = function(value0) {
    return new DataAll2(value0);
  };
  return DataAll2;
}();
var DataEnumerated = /* @__PURE__ */ function() {
  function DataEnumerated2(value0) {
    this.value0 = value0;
  }
  ;
  DataEnumerated2.create = function(value0) {
    return new DataEnumerated2(value0);
  };
  return DataEnumerated2;
}();
var ExportValue = /* @__PURE__ */ function() {
  function ExportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ExportValue2.create = function(value0) {
    return new ExportValue2(value0);
  };
  return ExportValue2;
}();
var ExportOp = /* @__PURE__ */ function() {
  function ExportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ExportOp2.create = function(value0) {
    return new ExportOp2(value0);
  };
  return ExportOp2;
}();
var ExportType = /* @__PURE__ */ function() {
  function ExportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportType2.create = function(value0) {
    return function(value12) {
      return new ExportType2(value0, value12);
    };
  };
  return ExportType2;
}();
var ExportTypeOp = /* @__PURE__ */ function() {
  function ExportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ExportTypeOp2(value0, value12);
    };
  };
  return ExportTypeOp2;
}();
var ExportClass = /* @__PURE__ */ function() {
  function ExportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportClass2.create = function(value0) {
    return function(value12) {
      return new ExportClass2(value0, value12);
    };
  };
  return ExportClass2;
}();
var ExportModule = /* @__PURE__ */ function() {
  function ExportModule2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportModule2.create = function(value0) {
    return function(value12) {
      return new ExportModule2(value0, value12);
    };
  };
  return ExportModule2;
}();
var ImportValue = /* @__PURE__ */ function() {
  function ImportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ImportValue2.create = function(value0) {
    return new ImportValue2(value0);
  };
  return ImportValue2;
}();
var ImportOp = /* @__PURE__ */ function() {
  function ImportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ImportOp2.create = function(value0) {
    return new ImportOp2(value0);
  };
  return ImportOp2;
}();
var ImportType = /* @__PURE__ */ function() {
  function ImportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportType2.create = function(value0) {
    return function(value12) {
      return new ImportType2(value0, value12);
    };
  };
  return ImportType2;
}();
var ImportTypeOp = /* @__PURE__ */ function() {
  function ImportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ImportTypeOp2(value0, value12);
    };
  };
  return ImportTypeOp2;
}();
var ImportClass = /* @__PURE__ */ function() {
  function ImportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportClass2.create = function(value0) {
    return function(value12) {
      return new ImportClass2(value0, value12);
    };
  };
  return ImportClass2;
}();
var One = /* @__PURE__ */ function() {
  function One2(value0) {
    this.value0 = value0;
  }
  ;
  One2.create = function(value0) {
    return new One2(value0);
  };
  return One2;
}();
var Many = /* @__PURE__ */ function() {
  function Many2(value0) {
    this.value0 = value0;
  }
  ;
  Many2.create = function(value0) {
    return new Many2(value0);
  };
  return Many2;
}();
var TypeVarKinded = /* @__PURE__ */ function() {
  function TypeVarKinded2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarKinded2.create = function(value0) {
    return new TypeVarKinded2(value0);
  };
  return TypeVarKinded2;
}();
var TypeVarName = /* @__PURE__ */ function() {
  function TypeVarName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarName2.create = function(value0) {
    return new TypeVarName2(value0);
  };
  return TypeVarName2;
}();
var TypeVar2 = /* @__PURE__ */ function() {
  function TypeVar3(value0) {
    this.value0 = value0;
  }
  ;
  TypeVar3.create = function(value0) {
    return new TypeVar3(value0);
  };
  return TypeVar3;
}();
var TypeConstructor2 = /* @__PURE__ */ function() {
  function TypeConstructor3(value0) {
    this.value0 = value0;
  }
  ;
  TypeConstructor3.create = function(value0) {
    return new TypeConstructor3(value0);
  };
  return TypeConstructor3;
}();
var TypeWildcard2 = /* @__PURE__ */ function() {
  function TypeWildcard3(value0) {
    this.value0 = value0;
  }
  ;
  TypeWildcard3.create = function(value0) {
    return new TypeWildcard3(value0);
  };
  return TypeWildcard3;
}();
var TypeHole = /* @__PURE__ */ function() {
  function TypeHole2(value0) {
    this.value0 = value0;
  }
  ;
  TypeHole2.create = function(value0) {
    return new TypeHole2(value0);
  };
  return TypeHole2;
}();
var TypeString = /* @__PURE__ */ function() {
  function TypeString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeString2.create = function(value0) {
    return function(value12) {
      return new TypeString2(value0, value12);
    };
  };
  return TypeString2;
}();
var TypeInt = /* @__PURE__ */ function() {
  function TypeInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeInt2(value0, value12, value22);
      };
    };
  };
  return TypeInt2;
}();
var TypeRow = /* @__PURE__ */ function() {
  function TypeRow2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRow2.create = function(value0) {
    return new TypeRow2(value0);
  };
  return TypeRow2;
}();
var TypeRecord = /* @__PURE__ */ function() {
  function TypeRecord2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRecord2.create = function(value0) {
    return new TypeRecord2(value0);
  };
  return TypeRecord2;
}();
var TypeForall = /* @__PURE__ */ function() {
  function TypeForall2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TypeForall2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TypeForall2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TypeForall2;
}();
var TypeKinded = /* @__PURE__ */ function() {
  function TypeKinded2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeKinded2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeKinded2(value0, value12, value22);
      };
    };
  };
  return TypeKinded2;
}();
var TypeApp2 = /* @__PURE__ */ function() {
  function TypeApp3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeApp3.create = function(value0) {
    return function(value12) {
      return new TypeApp3(value0, value12);
    };
  };
  return TypeApp3;
}();
var TypeOp2 = /* @__PURE__ */ function() {
  function TypeOp3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeOp3.create = function(value0) {
    return function(value12) {
      return new TypeOp3(value0, value12);
    };
  };
  return TypeOp3;
}();
var TypeOpName = /* @__PURE__ */ function() {
  function TypeOpName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeOpName2.create = function(value0) {
    return new TypeOpName2(value0);
  };
  return TypeOpName2;
}();
var TypeArrow = /* @__PURE__ */ function() {
  function TypeArrow2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeArrow2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeArrow2(value0, value12, value22);
      };
    };
  };
  return TypeArrow2;
}();
var TypeArrowName = /* @__PURE__ */ function() {
  function TypeArrowName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeArrowName2.create = function(value0) {
    return new TypeArrowName2(value0);
  };
  return TypeArrowName2;
}();
var TypeConstrained = /* @__PURE__ */ function() {
  function TypeConstrained2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeConstrained2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeConstrained2(value0, value12, value22);
      };
    };
  };
  return TypeConstrained2;
}();
var TypeParens = /* @__PURE__ */ function() {
  function TypeParens2(value0) {
    this.value0 = value0;
  }
  ;
  TypeParens2.create = function(value0) {
    return new TypeParens2(value0);
  };
  return TypeParens2;
}();
var ForeignValue = /* @__PURE__ */ function() {
  function ForeignValue2(value0) {
    this.value0 = value0;
  }
  ;
  ForeignValue2.create = function(value0) {
    return new ForeignValue2(value0);
  };
  return ForeignValue2;
}();
var ForeignData = /* @__PURE__ */ function() {
  function ForeignData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignData2.create = function(value0) {
    return function(value12) {
      return new ForeignData2(value0, value12);
    };
  };
  return ForeignData2;
}();
var ForeignKind = /* @__PURE__ */ function() {
  function ForeignKind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignKind2.create = function(value0) {
    return function(value12) {
      return new ForeignKind2(value0, value12);
    };
  };
  return ForeignKind2;
}();
var FundepDetermined = /* @__PURE__ */ function() {
  function FundepDetermined2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FundepDetermined2.create = function(value0) {
    return function(value12) {
      return new FundepDetermined2(value0, value12);
    };
  };
  return FundepDetermined2;
}();
var FundepDetermines = /* @__PURE__ */ function() {
  function FundepDetermines2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FundepDetermines2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FundepDetermines2(value0, value12, value22);
      };
    };
  };
  return FundepDetermines2;
}();
var BinderWildcard = /* @__PURE__ */ function() {
  function BinderWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  BinderWildcard2.create = function(value0) {
    return new BinderWildcard2(value0);
  };
  return BinderWildcard2;
}();
var BinderVar = /* @__PURE__ */ function() {
  function BinderVar2(value0) {
    this.value0 = value0;
  }
  ;
  BinderVar2.create = function(value0) {
    return new BinderVar2(value0);
  };
  return BinderVar2;
}();
var BinderNamed = /* @__PURE__ */ function() {
  function BinderNamed2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNamed2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNamed2(value0, value12, value22);
      };
    };
  };
  return BinderNamed2;
}();
var BinderConstructor = /* @__PURE__ */ function() {
  function BinderConstructor2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderConstructor2.create = function(value0) {
    return function(value12) {
      return new BinderConstructor2(value0, value12);
    };
  };
  return BinderConstructor2;
}();
var BinderBoolean = /* @__PURE__ */ function() {
  function BinderBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderBoolean2.create = function(value0) {
    return function(value12) {
      return new BinderBoolean2(value0, value12);
    };
  };
  return BinderBoolean2;
}();
var BinderChar = /* @__PURE__ */ function() {
  function BinderChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderChar2.create = function(value0) {
    return function(value12) {
      return new BinderChar2(value0, value12);
    };
  };
  return BinderChar2;
}();
var BinderString = /* @__PURE__ */ function() {
  function BinderString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderString2.create = function(value0) {
    return function(value12) {
      return new BinderString2(value0, value12);
    };
  };
  return BinderString2;
}();
var BinderInt = /* @__PURE__ */ function() {
  function BinderInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderInt2(value0, value12, value22);
      };
    };
  };
  return BinderInt2;
}();
var BinderNumber = /* @__PURE__ */ function() {
  function BinderNumber2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNumber2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNumber2(value0, value12, value22);
      };
    };
  };
  return BinderNumber2;
}();
var BinderArray = /* @__PURE__ */ function() {
  function BinderArray2(value0) {
    this.value0 = value0;
  }
  ;
  BinderArray2.create = function(value0) {
    return new BinderArray2(value0);
  };
  return BinderArray2;
}();
var BinderRecord = /* @__PURE__ */ function() {
  function BinderRecord2(value0) {
    this.value0 = value0;
  }
  ;
  BinderRecord2.create = function(value0) {
    return new BinderRecord2(value0);
  };
  return BinderRecord2;
}();
var BinderParens = /* @__PURE__ */ function() {
  function BinderParens2(value0) {
    this.value0 = value0;
  }
  ;
  BinderParens2.create = function(value0) {
    return new BinderParens2(value0);
  };
  return BinderParens2;
}();
var BinderTyped = /* @__PURE__ */ function() {
  function BinderTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderTyped2(value0, value12, value22);
      };
    };
  };
  return BinderTyped2;
}();
var BinderOp = /* @__PURE__ */ function() {
  function BinderOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderOp2.create = function(value0) {
    return function(value12) {
      return new BinderOp2(value0, value12);
    };
  };
  return BinderOp2;
}();
var AppType = /* @__PURE__ */ function() {
  function AppType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AppType2.create = function(value0) {
    return function(value12) {
      return new AppType2(value0, value12);
    };
  };
  return AppType2;
}();
var AppTerm = /* @__PURE__ */ function() {
  function AppTerm2(value0) {
    this.value0 = value0;
  }
  ;
  AppTerm2.create = function(value0) {
    return new AppTerm2(value0);
  };
  return AppTerm2;
}();
var DoLet = /* @__PURE__ */ function() {
  function DoLet2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DoLet2.create = function(value0) {
    return function(value12) {
      return new DoLet2(value0, value12);
    };
  };
  return DoLet2;
}();
var DoDiscard = /* @__PURE__ */ function() {
  function DoDiscard2(value0) {
    this.value0 = value0;
  }
  ;
  DoDiscard2.create = function(value0) {
    return new DoDiscard2(value0);
  };
  return DoDiscard2;
}();
var DoBind = /* @__PURE__ */ function() {
  function DoBind2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DoBind2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DoBind2(value0, value12, value22);
      };
    };
  };
  return DoBind2;
}();
var DoError = /* @__PURE__ */ function() {
  function DoError2(value0) {
    this.value0 = value0;
  }
  ;
  DoError2.create = function(value0) {
    return new DoError2(value0);
  };
  return DoError2;
}();
var LetBindingSignature = /* @__PURE__ */ function() {
  function LetBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingSignature2.create = function(value0) {
    return new LetBindingSignature2(value0);
  };
  return LetBindingSignature2;
}();
var LetBindingName = /* @__PURE__ */ function() {
  function LetBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingName2.create = function(value0) {
    return new LetBindingName2(value0);
  };
  return LetBindingName2;
}();
var LetBindingPattern = /* @__PURE__ */ function() {
  function LetBindingPattern2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  LetBindingPattern2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new LetBindingPattern2(value0, value12, value22);
      };
    };
  };
  return LetBindingPattern2;
}();
var LetBindingError = /* @__PURE__ */ function() {
  function LetBindingError2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingError2.create = function(value0) {
    return new LetBindingError2(value0);
  };
  return LetBindingError2;
}();
var Unconditional = /* @__PURE__ */ function() {
  function Unconditional2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Unconditional2.create = function(value0) {
    return function(value12) {
      return new Unconditional2(value0, value12);
    };
  };
  return Unconditional2;
}();
var Guarded = /* @__PURE__ */ function() {
  function Guarded2(value0) {
    this.value0 = value0;
  }
  ;
  Guarded2.create = function(value0) {
    return new Guarded2(value0);
  };
  return Guarded2;
}();
var ExprHole = /* @__PURE__ */ function() {
  function ExprHole2(value0) {
    this.value0 = value0;
  }
  ;
  ExprHole2.create = function(value0) {
    return new ExprHole2(value0);
  };
  return ExprHole2;
}();
var ExprSection = /* @__PURE__ */ function() {
  function ExprSection2(value0) {
    this.value0 = value0;
  }
  ;
  ExprSection2.create = function(value0) {
    return new ExprSection2(value0);
  };
  return ExprSection2;
}();
var ExprIdent = /* @__PURE__ */ function() {
  function ExprIdent2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIdent2.create = function(value0) {
    return new ExprIdent2(value0);
  };
  return ExprIdent2;
}();
var ExprConstructor = /* @__PURE__ */ function() {
  function ExprConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprConstructor2.create = function(value0) {
    return new ExprConstructor2(value0);
  };
  return ExprConstructor2;
}();
var ExprBoolean = /* @__PURE__ */ function() {
  function ExprBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprBoolean2.create = function(value0) {
    return function(value12) {
      return new ExprBoolean2(value0, value12);
    };
  };
  return ExprBoolean2;
}();
var ExprChar = /* @__PURE__ */ function() {
  function ExprChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprChar2.create = function(value0) {
    return function(value12) {
      return new ExprChar2(value0, value12);
    };
  };
  return ExprChar2;
}();
var ExprString = /* @__PURE__ */ function() {
  function ExprString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprString2.create = function(value0) {
    return function(value12) {
      return new ExprString2(value0, value12);
    };
  };
  return ExprString2;
}();
var ExprInt = /* @__PURE__ */ function() {
  function ExprInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInt2.create = function(value0) {
    return function(value12) {
      return new ExprInt2(value0, value12);
    };
  };
  return ExprInt2;
}();
var ExprNumber = /* @__PURE__ */ function() {
  function ExprNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNumber2.create = function(value0) {
    return function(value12) {
      return new ExprNumber2(value0, value12);
    };
  };
  return ExprNumber2;
}();
var ExprArray = /* @__PURE__ */ function() {
  function ExprArray2(value0) {
    this.value0 = value0;
  }
  ;
  ExprArray2.create = function(value0) {
    return new ExprArray2(value0);
  };
  return ExprArray2;
}();
var ExprRecord = /* @__PURE__ */ function() {
  function ExprRecord2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecord2.create = function(value0) {
    return new ExprRecord2(value0);
  };
  return ExprRecord2;
}();
var ExprParens = /* @__PURE__ */ function() {
  function ExprParens2(value0) {
    this.value0 = value0;
  }
  ;
  ExprParens2.create = function(value0) {
    return new ExprParens2(value0);
  };
  return ExprParens2;
}();
var ExprTyped = /* @__PURE__ */ function() {
  function ExprTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ExprTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ExprTyped2(value0, value12, value22);
      };
    };
  };
  return ExprTyped2;
}();
var ExprInfix = /* @__PURE__ */ function() {
  function ExprInfix2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInfix2.create = function(value0) {
    return function(value12) {
      return new ExprInfix2(value0, value12);
    };
  };
  return ExprInfix2;
}();
var ExprOp = /* @__PURE__ */ function() {
  function ExprOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprOp2.create = function(value0) {
    return function(value12) {
      return new ExprOp2(value0, value12);
    };
  };
  return ExprOp2;
}();
var ExprOpName = /* @__PURE__ */ function() {
  function ExprOpName2(value0) {
    this.value0 = value0;
  }
  ;
  ExprOpName2.create = function(value0) {
    return new ExprOpName2(value0);
  };
  return ExprOpName2;
}();
var ExprNegate = /* @__PURE__ */ function() {
  function ExprNegate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNegate2.create = function(value0) {
    return function(value12) {
      return new ExprNegate2(value0, value12);
    };
  };
  return ExprNegate2;
}();
var ExprRecordAccessor = /* @__PURE__ */ function() {
  function ExprRecordAccessor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecordAccessor2.create = function(value0) {
    return new ExprRecordAccessor2(value0);
  };
  return ExprRecordAccessor2;
}();
var ExprRecordUpdate = /* @__PURE__ */ function() {
  function ExprRecordUpdate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprRecordUpdate2.create = function(value0) {
    return function(value12) {
      return new ExprRecordUpdate2(value0, value12);
    };
  };
  return ExprRecordUpdate2;
}();
var ExprApp = /* @__PURE__ */ function() {
  function ExprApp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprApp2.create = function(value0) {
    return function(value12) {
      return new ExprApp2(value0, value12);
    };
  };
  return ExprApp2;
}();
var ExprLambda = /* @__PURE__ */ function() {
  function ExprLambda2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLambda2.create = function(value0) {
    return new ExprLambda2(value0);
  };
  return ExprLambda2;
}();
var ExprIf = /* @__PURE__ */ function() {
  function ExprIf2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIf2.create = function(value0) {
    return new ExprIf2(value0);
  };
  return ExprIf2;
}();
var ExprCase = /* @__PURE__ */ function() {
  function ExprCase2(value0) {
    this.value0 = value0;
  }
  ;
  ExprCase2.create = function(value0) {
    return new ExprCase2(value0);
  };
  return ExprCase2;
}();
var ExprLet = /* @__PURE__ */ function() {
  function ExprLet2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLet2.create = function(value0) {
    return new ExprLet2(value0);
  };
  return ExprLet2;
}();
var ExprDo = /* @__PURE__ */ function() {
  function ExprDo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprDo2.create = function(value0) {
    return new ExprDo2(value0);
  };
  return ExprDo2;
}();
var ExprAdo = /* @__PURE__ */ function() {
  function ExprAdo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprAdo2.create = function(value0) {
    return new ExprAdo2(value0);
  };
  return ExprAdo2;
}();
var RecordUpdateLeaf = /* @__PURE__ */ function() {
  function RecordUpdateLeaf2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordUpdateLeaf2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordUpdateLeaf2(value0, value12, value22);
      };
    };
  };
  return RecordUpdateLeaf2;
}();
var RecordUpdateBranch = /* @__PURE__ */ function() {
  function RecordUpdateBranch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RecordUpdateBranch2.create = function(value0) {
    return function(value12) {
      return new RecordUpdateBranch2(value0, value12);
    };
  };
  return RecordUpdateBranch2;
}();
var InstanceBindingSignature = /* @__PURE__ */ function() {
  function InstanceBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingSignature2.create = function(value0) {
    return new InstanceBindingSignature2(value0);
  };
  return InstanceBindingSignature2;
}();
var InstanceBindingName = /* @__PURE__ */ function() {
  function InstanceBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingName2.create = function(value0) {
    return new InstanceBindingName2(value0);
  };
  return InstanceBindingName2;
}();
var DeclData = /* @__PURE__ */ function() {
  function DeclData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclData2.create = function(value0) {
    return function(value12) {
      return new DeclData2(value0, value12);
    };
  };
  return DeclData2;
}();
var DeclType = /* @__PURE__ */ function() {
  function DeclType2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclType2(value0, value12, value22);
      };
    };
  };
  return DeclType2;
}();
var DeclNewtype = /* @__PURE__ */ function() {
  function DeclNewtype2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  DeclNewtype2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new DeclNewtype2(value0, value12, value22, value32);
        };
      };
    };
  };
  return DeclNewtype2;
}();
var DeclClass = /* @__PURE__ */ function() {
  function DeclClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclClass2.create = function(value0) {
    return function(value12) {
      return new DeclClass2(value0, value12);
    };
  };
  return DeclClass2;
}();
var DeclInstanceChain = /* @__PURE__ */ function() {
  function DeclInstanceChain2(value0) {
    this.value0 = value0;
  }
  ;
  DeclInstanceChain2.create = function(value0) {
    return new DeclInstanceChain2(value0);
  };
  return DeclInstanceChain2;
}();
var DeclDerive = /* @__PURE__ */ function() {
  function DeclDerive2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclDerive2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclDerive2(value0, value12, value22);
      };
    };
  };
  return DeclDerive2;
}();
var DeclKindSignature = /* @__PURE__ */ function() {
  function DeclKindSignature2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclKindSignature2.create = function(value0) {
    return function(value12) {
      return new DeclKindSignature2(value0, value12);
    };
  };
  return DeclKindSignature2;
}();
var DeclSignature = /* @__PURE__ */ function() {
  function DeclSignature2(value0) {
    this.value0 = value0;
  }
  ;
  DeclSignature2.create = function(value0) {
    return new DeclSignature2(value0);
  };
  return DeclSignature2;
}();
var DeclValue = /* @__PURE__ */ function() {
  function DeclValue2(value0) {
    this.value0 = value0;
  }
  ;
  DeclValue2.create = function(value0) {
    return new DeclValue2(value0);
  };
  return DeclValue2;
}();
var DeclFixity = /* @__PURE__ */ function() {
  function DeclFixity2(value0) {
    this.value0 = value0;
  }
  ;
  DeclFixity2.create = function(value0) {
    return new DeclFixity2(value0);
  };
  return DeclFixity2;
}();
var DeclForeign = /* @__PURE__ */ function() {
  function DeclForeign2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclForeign2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclForeign2(value0, value12, value22);
      };
    };
  };
  return DeclForeign2;
}();
var DeclRole = /* @__PURE__ */ function() {
  function DeclRole2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  DeclRole2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new DeclRole2(value0, value12, value22, value32);
        };
      };
    };
  };
  return DeclRole2;
}();
var DeclError = /* @__PURE__ */ function() {
  function DeclError2(value0) {
    this.value0 = value0;
  }
  ;
  DeclError2.create = function(value0) {
    return new DeclError2(value0);
  };
  return DeclError2;
}();

// output/PureScript.CST.Print/index.js
var unwrap22 = /* @__PURE__ */ unwrap();
var printQualified = function(moduleName3) {
  return function(name5) {
    if (moduleName3 instanceof Nothing) {
      return name5;
    }
    ;
    if (moduleName3 instanceof Just) {
      return unwrap22(moduleName3.value0) + ("." + name5);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Print (line 124, column 34 - line 126, column 38): " + [moduleName3.constructor.name]);
  };
};

// output/PureScript.CST.Errors/index.js
var UnexpectedEof = /* @__PURE__ */ function() {
  function UnexpectedEof2() {
  }
  ;
  UnexpectedEof2.value = new UnexpectedEof2();
  return UnexpectedEof2;
}();
var ExpectedEof = /* @__PURE__ */ function() {
  function ExpectedEof2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectedEof2.create = function(value0) {
    return new ExpectedEof2(value0);
  };
  return ExpectedEof2;
}();
var UnexpectedToken = /* @__PURE__ */ function() {
  function UnexpectedToken2(value0) {
    this.value0 = value0;
  }
  ;
  UnexpectedToken2.create = function(value0) {
    return new UnexpectedToken2(value0);
  };
  return UnexpectedToken2;
}();
var ExpectedToken = /* @__PURE__ */ function() {
  function ExpectedToken2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExpectedToken2.create = function(value0) {
    return function(value12) {
      return new ExpectedToken2(value0, value12);
    };
  };
  return ExpectedToken2;
}();
var ExpectedClass = /* @__PURE__ */ function() {
  function ExpectedClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExpectedClass2.create = function(value0) {
    return function(value12) {
      return new ExpectedClass2(value0, value12);
    };
  };
  return ExpectedClass2;
}();
var LexExpected = /* @__PURE__ */ function() {
  function LexExpected2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexExpected2.create = function(value0) {
    return function(value12) {
      return new LexExpected2(value0, value12);
    };
  };
  return LexExpected2;
}();
var LexInvalidCharEscape = /* @__PURE__ */ function() {
  function LexInvalidCharEscape2(value0) {
    this.value0 = value0;
  }
  ;
  LexInvalidCharEscape2.create = function(value0) {
    return new LexInvalidCharEscape2(value0);
  };
  return LexInvalidCharEscape2;
}();
var LexCharEscapeOutOfRange = /* @__PURE__ */ function() {
  function LexCharEscapeOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexCharEscapeOutOfRange2.create = function(value0) {
    return new LexCharEscapeOutOfRange2(value0);
  };
  return LexCharEscapeOutOfRange2;
}();
var LexHexOutOfRange = /* @__PURE__ */ function() {
  function LexHexOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexHexOutOfRange2.create = function(value0) {
    return new LexHexOutOfRange2(value0);
  };
  return LexHexOutOfRange2;
}();
var LexIntOutOfRange = /* @__PURE__ */ function() {
  function LexIntOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexIntOutOfRange2.create = function(value0) {
    return new LexIntOutOfRange2(value0);
  };
  return LexIntOutOfRange2;
}();
var LexNumberOutOfRange = /* @__PURE__ */ function() {
  function LexNumberOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexNumberOutOfRange2.create = function(value0) {
    return new LexNumberOutOfRange2(value0);
  };
  return LexNumberOutOfRange2;
}();
var printTokenError = function(v) {
  if (v instanceof TokLeftParen) {
    return "'('";
  }
  ;
  if (v instanceof TokRightParen) {
    return "')'";
  }
  ;
  if (v instanceof TokLeftBrace) {
    return "'{'";
  }
  ;
  if (v instanceof TokRightBrace) {
    return "'}'";
  }
  ;
  if (v instanceof TokLeftSquare) {
    return "'['";
  }
  ;
  if (v instanceof TokRightSquare) {
    return "']'";
  }
  ;
  if (v instanceof TokLeftArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'<-'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2190'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 72, column 5 - line 74, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokRightArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'->'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2192'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 76, column 5 - line 78, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokRightFatArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'=>'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u21D2'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 80, column 5 - line 82, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokDoubleColon) {
    if (v.value0 instanceof ASCII2) {
      return "'::'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2237'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 84, column 5 - line 86, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokForall) {
    if (v.value0 instanceof ASCII2) {
      return "forall";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2200'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 88, column 5 - line 90, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokEquals) {
    return "'='";
  }
  ;
  if (v instanceof TokPipe) {
    return "'|'";
  }
  ;
  if (v instanceof TokTick) {
    return "`";
  }
  ;
  if (v instanceof TokDot) {
    return ".";
  }
  ;
  if (v instanceof TokComma) {
    return "','";
  }
  ;
  if (v instanceof TokUnderscore) {
    return "'_'";
  }
  ;
  if (v instanceof TokBackslash) {
    return "'\\'";
  }
  ;
  if (v instanceof TokAt) {
    return "'@'";
  }
  ;
  if (v instanceof TokLowerName) {
    return "identifier " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokUpperName) {
    return "proper identifier " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokOperator) {
    return "operator " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokSymbolName) {
    return "symbol " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokSymbolArrow) {
    if (v.value0 instanceof ASCII2) {
      return "(->)";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "(\u2192)";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 116, column 5 - line 118, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokHole) {
    return "hole ?" + v.value0;
  }
  ;
  if (v instanceof TokChar) {
    return "char literal '" + (v.value0 + "'");
  }
  ;
  if (v instanceof TokString) {
    return "string literal";
  }
  ;
  if (v instanceof TokRawString) {
    return "raw string literal";
  }
  ;
  if (v instanceof TokInt) {
    return "int literal " + v.value0;
  }
  ;
  if (v instanceof TokNumber) {
    return "number literal " + v.value0;
  }
  ;
  if (v instanceof TokLayoutStart) {
    return "start of indented block";
  }
  ;
  if (v instanceof TokLayoutSep) {
    return "new indented block item";
  }
  ;
  if (v instanceof TokLayoutEnd) {
    return "end of indented block";
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Errors (line 58, column 19 - line 136, column 28): " + [v.constructor.name]);
};
var printParseError = function(v) {
  if (v instanceof UnexpectedEof) {
    return "Unexpected end of file";
  }
  ;
  if (v instanceof ExpectedEof) {
    return "Expected end of file, saw " + printTokenError(v.value0);
  }
  ;
  if (v instanceof UnexpectedToken) {
    return "Unexpected " + printTokenError(v.value0);
  }
  ;
  if (v instanceof ExpectedToken) {
    return "Expected " + (printTokenError(v.value0) + (", saw " + printTokenError(v.value1)));
  }
  ;
  if (v instanceof ExpectedClass) {
    return "Expected " + (v.value0 + (", saw " + printTokenError(v.value1)));
  }
  ;
  if (v instanceof LexExpected) {
    return "Expected " + (v.value0 + (", saw " + v.value1));
  }
  ;
  if (v instanceof LexInvalidCharEscape) {
    return "Invalid character escape \\" + v.value0;
  }
  ;
  if (v instanceof LexCharEscapeOutOfRange) {
    return "Character escape out of range \\" + v.value0;
  }
  ;
  if (v instanceof LexHexOutOfRange) {
    return "Hex integer out of range 0x" + v.value0;
  }
  ;
  if (v instanceof LexIntOutOfRange) {
    return "Int out of range " + v.value0;
  }
  ;
  if (v instanceof LexNumberOutOfRange) {
    return "Number out of range " + v.value0;
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Errors (line 33, column 19 - line 55, column 34): " + [v.constructor.name]);
};

// output/PureScript.CST.Layout/index.js
var find4 = /* @__PURE__ */ find(foldableList);
var LytRoot = /* @__PURE__ */ function() {
  function LytRoot2() {
  }
  ;
  LytRoot2.value = new LytRoot2();
  return LytRoot2;
}();
var LytTopDecl = /* @__PURE__ */ function() {
  function LytTopDecl2() {
  }
  ;
  LytTopDecl2.value = new LytTopDecl2();
  return LytTopDecl2;
}();
var LytTopDeclHead = /* @__PURE__ */ function() {
  function LytTopDeclHead2() {
  }
  ;
  LytTopDeclHead2.value = new LytTopDeclHead2();
  return LytTopDeclHead2;
}();
var LytDeclGuard = /* @__PURE__ */ function() {
  function LytDeclGuard2() {
  }
  ;
  LytDeclGuard2.value = new LytDeclGuard2();
  return LytDeclGuard2;
}();
var LytCase = /* @__PURE__ */ function() {
  function LytCase2() {
  }
  ;
  LytCase2.value = new LytCase2();
  return LytCase2;
}();
var LytCaseBinders = /* @__PURE__ */ function() {
  function LytCaseBinders2() {
  }
  ;
  LytCaseBinders2.value = new LytCaseBinders2();
  return LytCaseBinders2;
}();
var LytCaseGuard = /* @__PURE__ */ function() {
  function LytCaseGuard2() {
  }
  ;
  LytCaseGuard2.value = new LytCaseGuard2();
  return LytCaseGuard2;
}();
var LytLambdaBinders = /* @__PURE__ */ function() {
  function LytLambdaBinders2() {
  }
  ;
  LytLambdaBinders2.value = new LytLambdaBinders2();
  return LytLambdaBinders2;
}();
var LytParen = /* @__PURE__ */ function() {
  function LytParen2() {
  }
  ;
  LytParen2.value = new LytParen2();
  return LytParen2;
}();
var LytBrace = /* @__PURE__ */ function() {
  function LytBrace2() {
  }
  ;
  LytBrace2.value = new LytBrace2();
  return LytBrace2;
}();
var LytSquare = /* @__PURE__ */ function() {
  function LytSquare2() {
  }
  ;
  LytSquare2.value = new LytSquare2();
  return LytSquare2;
}();
var LytIf = /* @__PURE__ */ function() {
  function LytIf2() {
  }
  ;
  LytIf2.value = new LytIf2();
  return LytIf2;
}();
var LytThen = /* @__PURE__ */ function() {
  function LytThen2() {
  }
  ;
  LytThen2.value = new LytThen2();
  return LytThen2;
}();
var LytProperty = /* @__PURE__ */ function() {
  function LytProperty2() {
  }
  ;
  LytProperty2.value = new LytProperty2();
  return LytProperty2;
}();
var LytForall = /* @__PURE__ */ function() {
  function LytForall2() {
  }
  ;
  LytForall2.value = new LytForall2();
  return LytForall2;
}();
var LytTick = /* @__PURE__ */ function() {
  function LytTick2() {
  }
  ;
  LytTick2.value = new LytTick2();
  return LytTick2;
}();
var LytLet = /* @__PURE__ */ function() {
  function LytLet2() {
  }
  ;
  LytLet2.value = new LytLet2();
  return LytLet2;
}();
var LytLetStmt = /* @__PURE__ */ function() {
  function LytLetStmt2() {
  }
  ;
  LytLetStmt2.value = new LytLetStmt2();
  return LytLetStmt2;
}();
var LytWhere = /* @__PURE__ */ function() {
  function LytWhere2() {
  }
  ;
  LytWhere2.value = new LytWhere2();
  return LytWhere2;
}();
var LytOf = /* @__PURE__ */ function() {
  function LytOf2() {
  }
  ;
  LytOf2.value = new LytOf2();
  return LytOf2;
}();
var LytDo = /* @__PURE__ */ function() {
  function LytDo2() {
  }
  ;
  LytDo2.value = new LytDo2();
  return LytDo2;
}();
var LytAdo = /* @__PURE__ */ function() {
  function LytAdo2() {
  }
  ;
  LytAdo2.value = new LytAdo2();
  return LytAdo2;
}();
var lytToken = function(pos2) {
  return function(value4) {
    return {
      range: {
        start: pos2,
        end: pos2
      },
      leadingComments: [],
      trailingComments: [],
      value: value4
    };
  };
};
var isTopDecl = function(tokPos) {
  return function(v) {
    if (v instanceof Cons && (v.value0.value1 instanceof LytWhere && (v.value1 instanceof Cons && (v.value1.value0.value1 instanceof LytRoot && (v.value1.value1 instanceof Nil && tokPos.column === v.value0.value0.column))))) {
      return true;
    }
    ;
    return false;
  };
};
var isIndented = function(v) {
  if (v instanceof LytLet) {
    return true;
  }
  ;
  if (v instanceof LytLetStmt) {
    return true;
  }
  ;
  if (v instanceof LytWhere) {
    return true;
  }
  ;
  if (v instanceof LytOf) {
    return true;
  }
  ;
  if (v instanceof LytDo) {
    return true;
  }
  ;
  if (v instanceof LytAdo) {
    return true;
  }
  ;
  return false;
};
var eqLayoutDelim = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LytRoot && y instanceof LytRoot) {
        return true;
      }
      ;
      if (x instanceof LytTopDecl && y instanceof LytTopDecl) {
        return true;
      }
      ;
      if (x instanceof LytTopDeclHead && y instanceof LytTopDeclHead) {
        return true;
      }
      ;
      if (x instanceof LytDeclGuard && y instanceof LytDeclGuard) {
        return true;
      }
      ;
      if (x instanceof LytCase && y instanceof LytCase) {
        return true;
      }
      ;
      if (x instanceof LytCaseBinders && y instanceof LytCaseBinders) {
        return true;
      }
      ;
      if (x instanceof LytCaseGuard && y instanceof LytCaseGuard) {
        return true;
      }
      ;
      if (x instanceof LytLambdaBinders && y instanceof LytLambdaBinders) {
        return true;
      }
      ;
      if (x instanceof LytParen && y instanceof LytParen) {
        return true;
      }
      ;
      if (x instanceof LytBrace && y instanceof LytBrace) {
        return true;
      }
      ;
      if (x instanceof LytSquare && y instanceof LytSquare) {
        return true;
      }
      ;
      if (x instanceof LytIf && y instanceof LytIf) {
        return true;
      }
      ;
      if (x instanceof LytThen && y instanceof LytThen) {
        return true;
      }
      ;
      if (x instanceof LytProperty && y instanceof LytProperty) {
        return true;
      }
      ;
      if (x instanceof LytForall && y instanceof LytForall) {
        return true;
      }
      ;
      if (x instanceof LytTick && y instanceof LytTick) {
        return true;
      }
      ;
      if (x instanceof LytLet && y instanceof LytLet) {
        return true;
      }
      ;
      if (x instanceof LytLetStmt && y instanceof LytLetStmt) {
        return true;
      }
      ;
      if (x instanceof LytWhere && y instanceof LytWhere) {
        return true;
      }
      ;
      if (x instanceof LytOf && y instanceof LytOf) {
        return true;
      }
      ;
      if (x instanceof LytDo && y instanceof LytDo) {
        return true;
      }
      ;
      if (x instanceof LytAdo && y instanceof LytAdo) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq115 = /* @__PURE__ */ eq(eqLayoutDelim);
var insertLayout = function(v) {
  return function(nextPos) {
    return function(stack) {
      var sepP = function(lytPos) {
        return v.range.start.column === lytPos.column && v.range.start.line !== lytPos.line;
      };
      var pushStack = function(lytPos) {
        return function(lyt) {
          return function(v1) {
            return new Tuple(new Cons(new Tuple(lytPos, lyt), v1.value0), v1.value1);
          };
        };
      };
      var popStack = function(v1) {
        return function(v2) {
          if (v2.value0 instanceof Cons && v1(v2.value0.value0.value1)) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return v2;
        };
      };
      var offsideP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column < lytPos.column;
        };
      };
      var offsideEndP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column <= lytPos.column;
        };
      };
      var insertToken = function(token2) {
        return function(v1) {
          return new Tuple(v1.value0, snoc(v1.value1)(new Tuple(token2, v1.value0)));
        };
      };
      var insertStart = function(lyt) {
        return function(v1) {
          var v2 = find4(function($307) {
            return isIndented(snd($307));
          })(v1.value0);
          if (v2 instanceof Just && nextPos.column <= v2.value0.value0.column) {
            return v1;
          }
          ;
          return insertToken(lytToken(nextPos)(new TokLayoutStart(nextPos.column)))(pushStack(nextPos)(lyt)(v1));
        };
      };
      var insertEnd = function(indent3) {
        return insertToken(lytToken(v.range.start)(new TokLayoutEnd(indent3)));
      };
      var indentedP = $$const(isIndented);
      var indentSepP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && sepP(lytPos);
        };
      };
      var insertSep = function(v1) {
        var sepTok = lytToken(v.range.start)(new TokLayoutSep(v.range.start.column));
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDecl && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDeclHead && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && indentSepP(v1.value0.value0.value0)(v1.value0.value0.value1)) {
          if (v1.value0.value0.value1 instanceof LytOf) {
            return pushStack(v.range.start)(LytCaseBinders.value)(insertToken(sepTok)(v1));
          }
          ;
          return insertToken(sepTok)(v1);
        }
        ;
        return v1;
      };
      var collapse = function(p) {
        var go = function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1, v2) {
              if (v1 instanceof Cons && p(v1.value0.value0)(v1.value0.value1)) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = function() {
                  var $120 = isIndented(v1.value0.value1);
                  if ($120) {
                    return snoc(v2)(new Tuple(lytToken(v.range.start)(new TokLayoutEnd(v1.value0.value0.column)), v1.value1));
                  }
                  ;
                  return v2;
                }();
                return;
              }
              ;
              $tco_done = true;
              return new Tuple(v1, v2);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
        return uncurry(go);
      };
      var insertDefault = function(state2) {
        return insertToken(v)(insertSep(collapse(offsideP)(state2)));
      };
      var insertKwProperty = function(k) {
        return function(state2) {
          var v1 = insertDefault(state2);
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return new Tuple(v1.value0.value1, v1.value1);
          }
          ;
          return k(v1);
        };
      };
      var insert22 = function(v1) {
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "data")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDecl.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq115(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "class")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDeclHead.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq115(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "where")) {
          var whereP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytTopDeclHead) {
            return insertStart(LytWhere.value)(insertToken(v)(new Tuple(v1.value0.value1, v1.value1)));
          }
          ;
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return insertToken(v)(new Tuple(v1.value0.value1, v1.value1));
          }
          ;
          return insertStart(LytWhere.value)(insertToken(v)(collapse(whereP)(v1)));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "in")) {
          var inP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytLet) {
                return false;
              }
              ;
              if (v32 instanceof LytAdo) {
                return false;
              }
              ;
              return isIndented(v32);
            };
          };
          var v2 = collapse(inP)(v1);
          if (v2.value0 instanceof Cons && (v2.value0.value0.value1 instanceof LytLetStmt && (v2.value0.value1 instanceof Cons && v2.value0.value1.value0.value1 instanceof LytAdo))) {
            return insertToken(v)(insertEnd(v2.value0.value1.value0.value0.column)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1.value1, v2.value1))));
          }
          ;
          if (v2.value0 instanceof Cons && isIndented(v2.value0.value0.value1)) {
            return insertToken(v)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq115(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "let")) {
          var next2 = function(v22) {
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytDo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytAdo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            return insertStart(LytLet.value)(v22);
          };
          return insertKwProperty(next2)(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "do") {
          return insertKwProperty(insertStart(LytDo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "ado") {
          return insertKwProperty(insertStart(LytAdo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "case")) {
          return insertKwProperty(pushStack(v.range.start)(LytCase.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "of")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytCase) {
            return pushStack(nextPos)(LytCaseBinders.value)(insertStart(LytOf.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1))));
          }
          ;
          return popStack(function(v32) {
            return eq115(v32)(LytProperty.value);
          })(insertDefault(v2));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "if")) {
          return insertKwProperty(pushStack(v.range.start)(LytIf.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "then")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytIf) {
            return pushStack(v.range.start)(LytThen.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq115(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "else")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytThen) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          var v3 = collapse(offsideP)(v1);
          if (isTopDecl(v.range.start)(v3.value0)) {
            return insertToken(v)(v3);
          }
          ;
          return popStack(function(v4) {
            return eq115(v4)(LytProperty.value);
          })(insertToken(v)(insertSep(v3)));
        }
        ;
        if (v.value instanceof TokForall) {
          return insertKwProperty(pushStack(v.range.start)(LytForall.value))(v1);
        }
        ;
        if (v.value instanceof TokBackslash) {
          return pushStack(v.range.start)(LytLambdaBinders.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightArrow) {
          var guardP = function(v22) {
            if (v22 instanceof LytCaseBinders) {
              return true;
            }
            ;
            if (v22 instanceof LytCaseGuard) {
              return true;
            }
            ;
            if (v22 instanceof LytLambdaBinders) {
              return true;
            }
            ;
            return false;
          };
          var arrowP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              if (v32 instanceof LytOf) {
                return false;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          return insertToken(v)(popStack(guardP)(collapse(arrowP)(v1)));
        }
        ;
        if (v.value instanceof TokEquals) {
          var equalsP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytWhere) {
                return true;
              }
              ;
              if (v32 instanceof LytLet) {
                return true;
              }
              ;
              if (v32 instanceof LytLetStmt) {
                return true;
              }
              ;
              return false;
            };
          };
          var v2 = collapse(equalsP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytDeclGuard) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokPipe) {
          var v2 = collapse(offsideEndP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytOf) {
            return insertToken(v)(pushStack(v.range.start)(LytCaseGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLet) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLetStmt) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytWhere) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokTick) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytTick) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return pushStack(v.range.start)(LytTick.value)(insertToken(v)(insertSep(collapse(offsideEndP)(v1))));
        }
        ;
        if (v.value instanceof TokComma) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytBrace) {
            return pushStack(v.range.start)(LytProperty.value)(insertToken(v)(v2));
          }
          ;
          return insertToken(v)(v2);
        }
        ;
        if (v.value instanceof TokDot) {
          var v2 = insertDefault(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytForall) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return pushStack(v.range.start)(LytProperty.value)(v2);
        }
        ;
        if (v.value instanceof TokLeftParen) {
          return pushStack(v.range.start)(LytParen.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLeftBrace) {
          return pushStack(v.range.start)(LytProperty.value)(pushStack(v.range.start)(LytBrace.value)(insertDefault(v1)));
        }
        ;
        if (v.value instanceof TokLeftSquare) {
          return pushStack(v.range.start)(LytSquare.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightParen) {
          return insertToken(v)(popStack(function(v22) {
            return eq115(v22)(LytParen.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokRightBrace) {
          return insertToken(v)(popStack(function(v22) {
            return eq115(v22)(LytBrace.value);
          })(popStack(function(v22) {
            return eq115(v22)(LytProperty.value);
          })(collapse(indentedP)(v1))));
        }
        ;
        if (v.value instanceof TokRightSquare) {
          return insertToken(v)(popStack(function(v22) {
            return eq115(v22)(LytSquare.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokString) {
          return popStack(function(v22) {
            return eq115(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
          return popStack(function(v22) {
            return eq115(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokOperator) {
          return insertToken(v)(insertSep(collapse(offsideEndP)(v1)));
        }
        ;
        return insertDefault(v1);
      };
      return insert22(new Tuple(stack, []));
    };
  };
};
var currentIndent = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Cons) {
        if (isIndented(v.value0.value1)) {
          $tco_done = true;
          return new Just(v.value0.value0);
        }
        ;
        if (otherwise) {
          $copy_v = v.value1;
          return;
        }
        ;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return go;
}();

// output/PureScript.CST.TokenStream/index.js
var TokenEOF = /* @__PURE__ */ function() {
  function TokenEOF2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokenEOF2.create = function(value0) {
    return function(value12) {
      return new TokenEOF2(value0, value12);
    };
  };
  return TokenEOF2;
}();
var TokenError = /* @__PURE__ */ function() {
  function TokenError2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TokenError2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TokenError2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TokenError2;
}();
var TokenCons = /* @__PURE__ */ function() {
  function TokenCons2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TokenCons2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TokenCons2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TokenCons2;
}();
var step2 = /* @__PURE__ */ function() {
  var $32 = unwrap();
  return function($33) {
    return force($32($33));
  };
}();
var unwindLayout = function(pos2) {
  return function(eof5) {
    var go = function(stk) {
      return defer2(function(v) {
        if (stk instanceof Nil) {
          return step2(eof5);
        }
        ;
        if (stk instanceof Cons) {
          if (stk.value0.value1 instanceof LytRoot) {
            return step2(eof5);
          }
          ;
          if (isIndented(stk.value0.value1)) {
            return new TokenCons(lytToken(pos2)(new TokLayoutEnd(stk.value0.value0.column)), pos2, go(stk.value1), stk.value1);
          }
          ;
          if (otherwise) {
            return step2(go(stk.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 59, column 7 - line 66, column 27): " + [stk.value0.value1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 56, column 43 - line 66, column 27): " + [stk.constructor.name]);
      });
    };
    return go;
  };
};
var layoutStack = function(stream3) {
  var v = step2(stream3);
  if (v instanceof TokenEOF) {
    return Nil.value;
  }
  ;
  if (v instanceof TokenError) {
    return v.value3;
  }
  ;
  if (v instanceof TokenCons) {
    return v.value3;
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 48, column 22 - line 51, column 29): " + [v.constructor.name]);
};
var consTokens = function(dictFoldable) {
  var go = function(v) {
    return function(v1) {
      return new Tuple(v.value0.range.start, defer2(function(v2) {
        return new TokenCons(v.value0, v1.value0, v1.value1, v.value1);
      }));
    };
  };
  return flip(foldr(dictFoldable)(go));
};

// output/PureScript.CST.Lexer/index.js
var add3 = /* @__PURE__ */ add(semiringInt);
var div5 = /* @__PURE__ */ div(euclideanRingInt);
var bindFlipped12 = /* @__PURE__ */ bindFlipped(bindMaybe);
var foldMap29 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidString);
var fold24 = /* @__PURE__ */ fold(foldableMaybe)(monoidString);
var fold112 = /* @__PURE__ */ fold(foldableArray)(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "raw";
  }
})(monoidString)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "string";
  }
})(monoidString)()(monoidRecordNil))));
var foldl18 = /* @__PURE__ */ foldl(foldableArray);
var consTokens2 = /* @__PURE__ */ consTokens(foldableArray);
var LexFail = /* @__PURE__ */ function() {
  function LexFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexFail2.create = function(value0) {
    return function(value12) {
      return new LexFail2(value0, value12);
    };
  };
  return LexFail2;
}();
var LexSucc = /* @__PURE__ */ function() {
  function LexSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexSucc2.create = function(value0) {
    return function(value12) {
      return new LexSucc2(value0, value12);
    };
  };
  return LexSucc2;
}();
var Lex = function(x) {
  return x;
};
var isCharCodePoint = {
  fromChar: codePointFromChar,
  fromCharCode: /* @__PURE__ */ toEnum(boundedEnumCodePoint)
};
var isCharChar = {
  fromChar: /* @__PURE__ */ identity(categoryFn),
  fromCharCode: fromCharCode3
};
var $$try10 = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      return new LexFail(v1.value0, str2);
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(v1.value0, v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 102, column 3 - line 104, column 31): " + [v1.constructor.name]);
  };
};
var toModuleName2 = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(dropRight(1)(v));
};
var qualLength = /* @__PURE__ */ maybe(0)(/* @__PURE__ */ function() {
  var $305 = add3(1);
  var $306 = unwrap();
  return function($307) {
    return $305(length5($306($307)));
  };
}());
var optional8 = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      if (length4(str2) === length4(v1.value1)) {
        return new LexSucc(Nothing.value, str2);
      }
      ;
      if (otherwise) {
        return new LexFail(v1.value0, v1.value1);
      }
      ;
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(new Just(v1.value0), v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 151, column 3 - line 158, column 25): " + [v1.constructor.name]);
  };
};
var mkUnexpected = function(str2) {
  var start = take3(6)(str2);
  var len = length5(start);
  var $142 = len === 0;
  if ($142) {
    return "end of file";
  }
  ;
  var $143 = len < 6;
  if ($143) {
    return start;
  }
  ;
  return start + "...";
};
var regex4 = function(mkErr) {
  return function(regexStr) {
    var matchRegex = unsafeRegex("^(?:" + (regexStr + ")"))(unicode);
    return function(str2) {
      var v = match(matchRegex)(str2);
      var v1 = function(v2) {
        return new LexFail(function(v3) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
      if (v instanceof Just) {
        var $145 = head2(v.value0);
        if ($145 instanceof Just) {
          return new LexSucc($145.value0, drop2(length4($145.value0))(str2));
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    };
  };
};
var satisfy3 = function(mkErr) {
  return function(p) {
    return function(str2) {
      var v = charAt2(0)(str2);
      if (v instanceof Just && p(v.value0)) {
        return new LexSucc(v.value0, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v1) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var string7 = function(mkErr) {
  return function(match5) {
    return function(str2) {
      var $150 = take2(length4(match5))(str2) === match5;
      if ($150) {
        return new LexSucc(match5, drop2(length4(match5))(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var many7 = function(v) {
  return function(str2) {
    return function __do3() {
      var valuesRef = newSTArray();
      var strRef = str2;
      var contRef = true;
      var resRef = new LexSucc([], str2);
      (function() {
        while (contRef) {
          (function __do4() {
            var str$prime = strRef;
            var v1 = v(str$prime);
            if (v1 instanceof LexFail) {
              if (length4(str$prime) === length4(v1.value1)) {
                var values4 = unsafeFreeze(valuesRef)();
                resRef = new LexSucc(values4, v1.value1);
                contRef = false;
                return unit;
              }
              ;
              if (otherwise) {
                resRef = new LexFail(v1.value0, v1.value1);
                contRef = false;
                return unit;
              }
              ;
            }
            ;
            if (v1 instanceof LexSucc) {
              push(v1.value0)(valuesRef)();
              strRef = v1.value1;
              return unit;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 176, column 5 - line 190, column 18): " + [v1.constructor.name]);
          })();
        }
        ;
        return {};
      })();
      return resRef;
    }();
  };
};
var functorLex = {
  map: function(f) {
    return function(v) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          return new LexSucc(f(v1.value0), v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 64, column 5 - line 66, column 37): " + [v1.constructor.name]);
      };
    };
  }
};
var map106 = /* @__PURE__ */ map(functorLex);
var spaceComment = /* @__PURE__ */ function() {
  return map106(length4)(regex4(LexExpected.create("spaces"))(" +"));
}();
var fromCharCode4 = function(dict) {
  return dict.fromCharCode;
};
var fromChar = function(dict) {
  return dict.fromChar;
};
var fail6 = function($308) {
  return Lex(LexFail.create($$const($308)));
};
var char$prime = function(mkErr) {
  return function(res) {
    return function(match5) {
      return function(str2) {
        var $166 = singleton6(match5) === take2(1)(str2);
        if ($166) {
          return new LexSucc(res, drop2(1)(str2));
        }
        ;
        return new LexFail(function(v) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
    };
  };
};
var $$char5 = function(mkErr) {
  return function(match5) {
    return function(str2) {
      var $167 = singleton6(match5) === take2(1)(str2);
      if ($167) {
        return new LexSucc(match5, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var bumpText = function(v) {
  return function(colOffset) {
    return function(str2) {
      var go = function($copy_n) {
        return function($copy_ix) {
          var $tco_var_n = $copy_n;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(n, ix) {
            var v1 = indexOf$prime("\n")(ix)(str2);
            if (v1 instanceof Just) {
              $tco_var_n = n + 1 | 0;
              $copy_ix = v1.value0 + 1 | 0;
              return;
            }
            ;
            if (v1 instanceof Nothing) {
              if (n === 0) {
                $tco_done = true;
                return {
                  line: v.line,
                  column: (v.column + length5(str2) | 0) + (colOffset * 2 | 0) | 0
                };
              }
              ;
              if (otherwise) {
                $tco_done = true;
                return {
                  line: v.line + n | 0,
                  column: length5(drop2(ix)(str2)) + colOffset | 0
                };
              }
              ;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 338, column 13 - line 347, column 12): " + [v1.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_n, $copy_ix);
          }
          ;
          return $tco_result;
        };
      };
      return go(0)(0);
    };
  };
};
var bumpToken = function(v) {
  return function(v1) {
    if (v1 instanceof TokLeftParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 6 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokEquals) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokPipe) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokTick) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDot) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokComma) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokUnderscore) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokBackslash) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokAt) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLowerName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokUpperName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokOperator) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolName) {
      return {
        line: v.line,
        column: ((v.column + qualLength(v1.value0) | 0) + length5(v1.value1) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 3 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 4 | 0
      };
    }
    ;
    if (v1 instanceof TokHole) {
      return {
        line: v.line,
        column: (v.column + length5(v1.value0) | 0) + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokChar) {
      return {
        line: v.line,
        column: (v.column + length5(v1.value0) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokInt) {
      return {
        line: v.line,
        column: v.column + length5(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokNumber) {
      return {
        line: v.line,
        column: v.column + length5(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokString) {
      return bumpText(v)(1)(v1.value0);
    }
    ;
    if (v1 instanceof TokRawString) {
      return bumpText(v)(3)(v1.value0);
    }
    ;
    if (v1 instanceof TokLayoutStart) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutSep) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutEnd) {
      return v;
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 255, column 34 - line 333, column 8): " + [v1.constructor.name]);
  };
};
var bumpComment = function(v) {
  return function(v1) {
    if (v1 instanceof Comment) {
      return bumpText(v)(0)(v1.value0);
    }
    ;
    if (v1 instanceof Space) {
      return {
        line: v.line,
        column: v.column + v1.value0 | 0
      };
    }
    ;
    if (v1 instanceof Line2) {
      return {
        line: v.line + v1.value1 | 0,
        column: 0
      };
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 350, column 36 - line 356, column 34): " + [v1.constructor.name]);
  };
};
var applyLex = {
  apply: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          return new LexFail(v2.value0, v2.value1);
        }
        ;
        if (v2 instanceof LexSucc) {
          var v3 = v1(v2.value1);
          if (v3 instanceof LexFail) {
            return new LexFail(v3.value0, v3.value1);
          }
          ;
          if (v3 instanceof LexSucc) {
            return new LexSucc(v2.value0(v3.value0), v3.value1);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 73, column 9 - line 76, column 32): " + [v3.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 70, column 5 - line 76, column 32): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var applyFirst4 = /* @__PURE__ */ applyFirst(applyLex);
var applySecond9 = /* @__PURE__ */ applySecond(applyLex);
var apply27 = /* @__PURE__ */ apply2(applyLex);
var bindLex = {
  bind: function(v) {
    return function(k) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          var v2 = k(v1.value0);
          return v2(v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 83, column 5 - line 87, column 16): " + [v1.constructor.name]);
      };
    };
  },
  Apply0: function() {
    return applyLex;
  }
};
var bind126 = /* @__PURE__ */ bind(bindLex);
var applicativeLex = {
  pure: function($309) {
    return Lex(LexSucc.create($309));
  },
  Apply0: function() {
    return applyLex;
  }
};
var pure126 = /* @__PURE__ */ pure(applicativeLex);
var altLex = {
  alt: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          if (length4(str2) === length4(v2.value1)) {
            return v1(str2);
          }
          ;
          if (otherwise) {
            return new LexFail(v2.value0, v2.value1);
          }
          ;
        }
        ;
        if (v2 instanceof LexSucc) {
          return new LexSucc(v2.value0, v2.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 91, column 5 - line 98, column 20): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var alt36 = /* @__PURE__ */ alt(altLex);
var comment = /* @__PURE__ */ function() {
  return alt36(regex4(LexExpected.create("block comment"))("\\{-(-(?!\\})|[^-]+)*(-\\}|$)"))(regex4(LexExpected.create("line comment"))("--[^\\r\\n]*"));
}();
var lineComment = /* @__PURE__ */ function() {
  return alt36(map106(function() {
    var $310 = Line2.create(LF.value);
    return function($311) {
      return $310(length5($311));
    };
  }())(regex4(LexExpected.create("newline"))("\n+")))(map106(function() {
    var $312 = Line2.create(CRLF.value);
    return function($313) {
      return $312(function(v) {
        return div5(v)(2);
      }(length5($313)));
    };
  }())(regex4(LexExpected.create("newline"))("(?:\r\n)+")));
}();
var leadingComments = /* @__PURE__ */ function() {
  return many7(alt36(map106(Comment.create)(comment))(alt36(map106(Space.create)(spaceComment))(lineComment)));
}();
var token = /* @__PURE__ */ function() {
  var tokenTick = char$prime(LexExpected.create("backtick"))(TokTick.value)("`");
  var tokenRightSquare = char$prime(LexExpected.create("right square"))(TokRightSquare.value)("]");
  var tokenRightParen = char$prime(LexExpected.create("right paren"))(TokRightParen.value)(")");
  var tokenRightBrace = char$prime(LexExpected.create("right brace"))(TokRightBrace.value)("}");
  var tokenLeftSquare = char$prime(LexExpected.create("left square"))(TokLeftSquare.value)("[");
  var tokenLeftParen = char$prime(LexExpected.create("left paren"))(TokLeftParen.value)("(");
  var tokenLeftBrace = char$prime(LexExpected.create("left brace"))(TokLeftBrace.value)("{");
  var tokenComma = char$prime(LexExpected.create("comma"))(TokComma.value)(",");
  var stripUnderscores = replaceAll("_")("");
  var stringSpaceEscapeRegex = regex4(LexExpected.create("whitespace escape"))("\\\\[ \\r\\n]+\\\\");
  var stringCharsRegex = regex4(LexExpected.create("string characters"))('[^"\\\\]+');
  var rawStringCharsRegex = regex4(LexExpected.create("raw string characters"))('""""{0,2}([^"]+"{1,2})*[^"]*"""');
  var parseSymbolIdent = regex4(LexExpected.create("symbol"))("(?:[:!#$%&*+./<=>?@\\\\^|~-]|(?!\\p{P})\\p{S})+");
  var parseSymbol2 = map106(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "->") {
          return new TokSymbolArrow(ASCII2.value);
        }
        ;
        if (v === "\u2192") {
          return new TokSymbolArrow(Unicode.value);
        }
        ;
        return new TokSymbolName(Nothing.value, v);
      }
      ;
      return new TokSymbolName(v1, v);
    };
  })($$try10(applyFirst4(applySecond9(tokenLeftParen)(parseSymbolIdent))(tokenRightParen)));
  var parseStringSpaceEscape = map106(function(v) {
    return {
      raw: v,
      string: ""
    };
  })(stringSpaceEscapeRegex);
  var parseStringChars = map106(function(v) {
    return {
      raw: v,
      string: v
    };
  })(stringCharsRegex);
  var parseRawString = map106(function(v) {
    return new TokRawString(dropRight(3)(drop2(3)(v)));
  })(rawStringCharsRegex);
  var parseProper2 = regex4(LexExpected.create("proper name"))("\\p{Lu}[\\p{L}0-9_']*");
  var parseUpper = map106(flip(TokUpperName.create))(parseProper2);
  var parseOperator2 = map106(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "<-") {
          return new TokLeftArrow(ASCII2.value);
        }
        ;
        if (v === "\u2190") {
          return new TokLeftArrow(Unicode.value);
        }
        ;
        if (v === "->") {
          return new TokRightArrow(ASCII2.value);
        }
        ;
        if (v === "\u2192") {
          return new TokRightArrow(Unicode.value);
        }
        ;
        if (v === "=>") {
          return new TokRightFatArrow(ASCII2.value);
        }
        ;
        if (v === "\u21D2") {
          return new TokRightFatArrow(Unicode.value);
        }
        ;
        if (v === "::") {
          return new TokDoubleColon(ASCII2.value);
        }
        ;
        if (v === "\u2237") {
          return new TokDoubleColon(Unicode.value);
        }
        ;
        if (v === "\u2200") {
          return new TokForall(Unicode.value);
        }
        ;
        if (v === "=") {
          return TokEquals.value;
        }
        ;
        if (v === ".") {
          return TokDot.value;
        }
        ;
        if (v === "\\") {
          return TokBackslash.value;
        }
        ;
        if (v === "|") {
          return TokPipe.value;
        }
        ;
        if (v === "@") {
          return TokAt.value;
        }
        ;
        if (v === "`") {
          return TokTick.value;
        }
        ;
        return new TokOperator(Nothing.value, v);
      }
      ;
      return new TokOperator(v1, v);
    };
  })(parseSymbolIdent);
  var parseModuleNamePrefix = regex4(LexExpected.create("module name"))("(?:(?:\\p{Lu}[\\p{L}0-9_']*)\\.)*");
  var parseIdent2 = regex4(LexExpected.create("ident"))("[\\p{Ll}_][\\p{L}0-9_']*");
  var parseLower = map106(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "forall") {
          return new TokForall(ASCII2.value);
        }
        ;
        if (v === "_") {
          return TokUnderscore.value;
        }
        ;
        return new TokLowerName(Nothing.value, v);
      }
      ;
      return new TokLowerName(v1, v);
    };
  })(parseIdent2);
  var parseName = alt36(parseLower)(alt36(parseUpper)(alt36(parseOperator2)(parseSymbol2)));
  var parseModuleName3 = apply27(map106(function(v) {
    return function(v1) {
      return v1(toModuleName2(v));
    };
  })(parseModuleNamePrefix))(parseName);
  var parseExponentSign = alt36(string7(LexExpected.create("negative"))("-"))(string7(LexExpected.create("positive"))("+"));
  var intPartRegex = regex4(LexExpected.create("int part"))("(0|[1-9][0-9_]*)");
  var parseExponentPart = apply27(map106(function(v) {
    return function(v1) {
      return {
        sign: v,
        exponent: v1
      };
    };
  })(optional8(parseExponentSign)))(intPartRegex);
  var hexIntRegex = regex4(LexExpected.create("hex int"))("[a-fA-F0-9]+");
  var hexIntPrefix = string7(LexExpected.create("hex int prefix"))("0x");
  var parseHexInt = bind126(applySecond9(hexIntPrefix)(hexIntRegex))(function(raw2) {
    var v = fromStringAs(hexadecimal)(raw2);
    if (v instanceof Just) {
      return pure126(new TokInt("0x" + raw2, new SmallInt(v.value0)));
    }
    ;
    if (v instanceof Nothing) {
      return pure126(new TokInt("0x" + raw2, new BigHex(raw2)));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 602, column 5 - line 606, column 49): " + [v.constructor.name]);
  });
  var hexEscapeRegex = regex4(LexExpected.create("hex"))("[a-fA-F0-9]{1,6}");
  var parseHexEscape = function(dictIsChar) {
    var fromCharCode1 = fromCharCode4(dictIsChar);
    return bind126(hexEscapeRegex)(function(esc) {
      var v = bindFlipped12(fromCharCode1)(fromStringAs(hexadecimal)(esc));
      if (v instanceof Just) {
        return pure126({
          raw: "\\x" + esc,
          "char": v.value0
        });
      }
      ;
      if (v instanceof Nothing) {
        return fail6(new LexCharEscapeOutOfRange(esc));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Lexer (line 550, column 5 - line 554, column 43): " + [v.constructor.name]);
    });
  };
  var fractionPartRegex = regex4(LexExpected.create("fraction part"))("[0-9_]+");
  var charSingleQuote = $$char5(LexExpected.create("single quote"))("'");
  var charQuote = $$char5(LexExpected.create("quote"))('"');
  var charQuestionMark = $$char5(LexExpected.create("question mark"))("?");
  var parseHole2 = map106(function(v) {
    return new TokHole(v);
  })($$try10(applySecond9(charQuestionMark)(alt36(parseIdent2)(parseProper2))));
  var charExponent = $$char5(LexExpected.create("exponent"))("e");
  var parseNumberExponentPart = optional8(applySecond9(charExponent)(parseExponentPart));
  var charDot = $$char5(LexExpected.create("dot"))(".");
  var parseNumberFractionPart = optional8($$try10(applySecond9(charDot)(fractionPartRegex)));
  var parseNumber2 = bind126(intPartRegex)(function(intPart) {
    return bind126(parseNumberFractionPart)(function(fractionPart) {
      return bind126(parseNumberExponentPart)(function(exponentPart) {
        var $268 = isNothing(fractionPart) && isNothing(exponentPart);
        if ($268) {
          var intVal = stripUnderscores(intPart);
          var v = fromString3(intVal);
          if (v instanceof Just) {
            return pure126(new TokInt(intPart, new SmallInt(v.value0)));
          }
          ;
          if (v instanceof Nothing) {
            return pure126(new TokInt(intPart, new BigInt2(intVal)));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 614, column 7 - line 618, column 48): " + [v.constructor.name]);
        }
        ;
        var raw2 = intPart + (foldMap29(function(fr) {
          return "." + fr;
        })(fractionPart) + foldMap29(function(ex) {
          return "e" + (fold24(ex.sign) + ex.exponent);
        })(exponentPart));
        var v = fromString2(stripUnderscores(raw2));
        if (v instanceof Just) {
          return pure126(new TokNumber(raw2, v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return fail6(new LexNumberOutOfRange(raw2));
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 625, column 7 - line 629, column 41): " + [v.constructor.name]);
      });
    });
  });
  var parseNumericLiteral = alt36(parseHexInt)(parseNumber2);
  var charBackslash = $$char5(LexExpected.create("backslash"))("\\");
  var charAny = satisfy3(LexExpected.create("char"))($$const(true));
  var parseEscape = function(dictIsChar) {
    var fromChar1 = fromChar(dictIsChar);
    var parseHexEscape1 = parseHexEscape(dictIsChar);
    return bind126(charAny)(function(ch) {
      if (ch === "t") {
        return pure126({
          raw: "\\t",
          "char": fromChar1("	")
        });
      }
      ;
      if (ch === "r") {
        return pure126({
          raw: "\\r",
          "char": fromChar1("\r")
        });
      }
      ;
      if (ch === "n") {
        return pure126({
          raw: "\\n",
          "char": fromChar1("\n")
        });
      }
      ;
      if (ch === '"') {
        return pure126({
          raw: '\\"',
          "char": fromChar1('"')
        });
      }
      ;
      if (ch === "'") {
        return pure126({
          raw: "\\'",
          "char": fromChar1("'")
        });
      }
      ;
      if (ch === "\\") {
        return pure126({
          raw: "\\\\",
          "char": fromChar1("\\")
        });
      }
      ;
      if (ch === "x") {
        return parseHexEscape1;
      }
      ;
      return fail6(new LexInvalidCharEscape(singleton6(ch)));
    });
  };
  var parseEscape1 = parseEscape(isCharChar);
  var parseChar2 = bind126(charAny)(function(ch) {
    if (ch === "\\") {
      return parseEscape1;
    }
    ;
    if (ch === "'") {
      return fail6(new LexExpected("character", "empty character literal"));
    }
    ;
    return pure126({
      raw: singleton6(ch),
      "char": ch
    });
  });
  var parseCharLiteral = map106(function(v) {
    return new TokChar(v.raw, v["char"]);
  })(applyFirst4(applySecond9(charSingleQuote)(parseChar2))(charSingleQuote));
  var parseStringEscape = map106(function(v) {
    return {
      raw: v.raw,
      string: singleton7(v["char"])
    };
  })(applySecond9(charBackslash)(parseEscape(isCharCodePoint)));
  var parseStringPart = alt36(parseStringChars)(alt36(parseStringSpaceEscape)(parseStringEscape));
  var parseString2 = map106(function(v) {
    var v1 = fold112(v);
    return new TokString(v1.raw, v1.string);
  })(applyFirst4(applySecond9(charQuote)(many7(parseStringPart)))(charQuote));
  var parseStringLiteral = alt36(parseRawString)(parseString2);
  return alt36(parseHole2)(alt36(parseModuleName3)(alt36(parseCharLiteral)(alt36(parseStringLiteral)(alt36(parseNumericLiteral)(alt36(tokenLeftParen)(alt36(tokenRightParen)(alt36(tokenLeftBrace)(alt36(tokenRightBrace)(alt36(tokenLeftSquare)(alt36(tokenRightSquare)(alt36(tokenTick)(tokenComma))))))))))));
}();
var trailingComments = /* @__PURE__ */ function() {
  return many7(alt36(map106(Comment.create)(comment))(map106(Space.create)(spaceComment)));
}();
var lexWithState = /* @__PURE__ */ function() {
  var token$prime = apply27(apply27(map106(function(v) {
    return function(v1) {
      return function(v2) {
        return {
          token: v,
          trailing: v1,
          nextLeading: v2
        };
      };
    };
  })(token))(trailingComments))(leadingComments);
  var go = function(stack) {
    return function(startPos) {
      return function(leading) {
        return function(str2) {
          return defer2(function(v) {
            var $289 = str2 === "";
            if ($289) {
              return step2(unwindLayout(startPos)(defer2(function(v12) {
                return new TokenEOF(startPos, leading);
              }))(stack));
            }
            ;
            var v1 = token$prime(str2);
            if (v1 instanceof LexFail) {
              var errPos = bumpText(startPos)(0)(take2(length4(str2) - length4(v1.value1) | 0)(str2));
              return new TokenError(errPos, v1.value0(unit), Nothing.value, stack);
            }
            ;
            if (v1 instanceof LexSucc) {
              var endPos = bumpToken(startPos)(v1.value0.token);
              var nextStart = foldl18(bumpComment)(foldl18(bumpComment)(endPos)(v1.value0.trailing))(v1.value0.nextLeading);
              var posToken = {
                range: {
                  start: startPos,
                  end: endPos
                },
                leadingComments: leading,
                trailingComments: v1.value0.trailing,
                value: v1.value0.token
              };
              var v2 = insertLayout(posToken)(nextStart)(stack);
              return step2(snd(consTokens2(v2.value1)(new Tuple(nextStart, go(v2.value0)(nextStart)(v1.value0.nextLeading)(v1.value1)))));
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 218, column 7 - line 237, column 63): " + [v1.constructor.name]);
          });
        };
      };
    };
  };
  var init4 = function(initStack) {
    return function(initPos) {
      return function(str2) {
        return defer2(function(v) {
          var v1 = leadingComments(str2);
          if (v1 instanceof LexFail) {
            return unsafeCrashWith("Leading comments can't fail.");
          }
          ;
          if (v1 instanceof LexSucc) {
            var nextPos = foldl18(bumpComment)(initPos)(v1.value0);
            return step2(go(initStack)(nextPos)(v1.value0)(v1.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 205, column 5 - line 210, column 51): " + [v1.constructor.name]);
        });
      };
    };
  };
  return init4;
}();
var lex = /* @__PURE__ */ function() {
  return lexWithState(new Cons(new Tuple({
    line: 0,
    column: 0
  }, LytRoot.value), Nil.value))({
    line: 0,
    column: 0
  });
}();

// output/PureScript.CST.Parser.Monad/index.js
var $runtime_lazy15 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var toUnfoldable32 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var More2 = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Done2 = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var ParseFail = /* @__PURE__ */ function() {
  function ParseFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseFail2.create = function(value0) {
    return function(value12) {
      return new ParseFail2(value0, value12);
    };
  };
  return ParseFail2;
}();
var ParseSucc = /* @__PURE__ */ function() {
  function ParseSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucc2.create = function(value0) {
    return function(value12) {
      return new ParseSucc2(value0, value12);
    };
  };
  return ParseSucc2;
}();
var lazyParser2 = {
  defer: function(k) {
    var parser6 = defer2(k);
    return function(state2, more, resume2, done) {
      var v = force(parser6);
      return v(state2, more, resume2, done);
    };
  }
};
var functorParser2 = {
  map: function(f) {
    return function(v) {
      return function(state1, more, resume2, done) {
        return v(state1, more, resume2, function(state2, a) {
          return done(state2, f(a));
        });
      };
    };
  }
};
var map107 = /* @__PURE__ */ map(functorParser2);
var applyParser2 = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, resume2, done) {
        return v(state1, more, resume2, function(state2, f) {
          return more(function(v2) {
            return v1(state2, more, resume2, function(state3, a) {
              return done(state3, f(a));
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParser2;
  }
};
var bindParser2 = {
  bind: function(v) {
    return function(k) {
      return function(state1, more, resume2, done) {
        return v(state1, more, resume2, function(state2, a) {
          return more(function(v1) {
            var v2 = k(a);
            return v2(state2, more, resume2, done);
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParser2;
  }
};
var applicativeParser2 = {
  pure: function(a) {
    return function(state1, v, v1, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParser2;
  }
};
var pure88 = /* @__PURE__ */ pure(applicativeParser2);
var altParser2 = {
  alt: function(v) {
    return function(v1) {
      return function(state1, more, resume2, done) {
        var state2 = function() {
          if (state1.consumed) {
            return {
              errors: state1.errors,
              stream: state1.stream,
              consumed: false
            };
          }
          ;
          return state1;
        }();
        return v(state2, more, function(state3, error5) {
          if (state3.consumed) {
            return resume2(state3, error5);
          }
          ;
          return v1(state1, more, resume2, done);
        }, done);
      };
    };
  },
  Functor0: function() {
    return functorParser2;
  }
};
var alt37 = /* @__PURE__ */ alt(altParser2);
var $$try11 = function(v) {
  return function(state1, more, resume2, done) {
    return v(state1, more, function(state2, error5) {
      return resume2({
        errors: state2.errors,
        stream: state2.stream,
        consumed: state1.consumed
      }, error5);
    }, done);
  };
};
var take8 = function(k) {
  return function(state2, v, resume2, done) {
    var v1 = step2(state2.stream);
    if (v1 instanceof TokenError) {
      return resume2(state2, {
        error: v1.value1,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenEOF) {
      return resume2(state2, {
        error: UnexpectedEof.value,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenCons) {
      var v2 = k(v1.value0);
      if (v2 instanceof Left) {
        return resume2(state2, {
          error: v2.value0,
          position: v1.value0.range.start
        });
      }
      ;
      if (v2 instanceof Right) {
        return done({
          errors: state2.errors,
          consumed: true,
          stream: v1.value2
        }, v2.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 172, column 11 - line 182, column 18): " + [v2.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 166, column 7 - line 182, column 18): " + [v1.constructor.name]);
  };
};
var runParser$prime = function(state1) {
  return function(v) {
    var run16 = function($copy_v1) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v1) {
        if (v1 instanceof More2) {
          $copy_v1 = v1.value0(unit);
          return;
        }
        ;
        if (v1 instanceof Done2) {
          $tco_done = true;
          return v1.value0;
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 241, column 9 - line 243, column 16): " + [v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v1);
      }
      ;
      return $tco_result;
    };
    return run16(v(state1, More2.create, function(state2, error5) {
      return new Done2(new ParseFail(error5, state2));
    }, function(state2, value4) {
      return new Done2(new ParseSucc(value4, state2));
    }));
  };
};
var recover = function(k) {
  return function(v) {
    return function(state1, more, resume2, done) {
      return v({
        errors: state1.errors,
        stream: state1.stream,
        consumed: false
      }, more, function(state2, error5) {
        var v1 = k(error5)(state1.stream);
        if (v1 instanceof Nothing) {
          return resume2({
            errors: state2.errors,
            stream: state2.stream,
            consumed: state1.consumed
          }, error5);
        }
        ;
        if (v1 instanceof Just) {
          return done({
            consumed: true,
            errors: snoc(state2.errors)(error5),
            stream: v1.value0.value1
          }, v1.value0.value0);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 149, column 13 - line 158, column 20): " + [v1.constructor.name]);
      }, done);
    };
  };
};
var optional9 = function(p) {
  return alt37(map107(Just.create)(p))(pure88(Nothing.value));
};
var many8 = function(v) {
  return function(state1, more, resume2, done) {
    var $lazy_go = $runtime_lazy15("go", "PureScript.CST.Parser.Monad", function() {
      return function(acc, state2) {
        var state2$prime = function() {
          if (state2.consumed) {
            return {
              errors: state2.errors,
              stream: state2.stream,
              consumed: false
            };
          }
          ;
          return state2;
        }();
        return v(state2$prime, more, function(state3, error5) {
          if (state3.consumed) {
            return resume2(state3, error5);
          }
          ;
          return done(state2, reverse(toUnfoldable32(acc)));
        }, function(state3, value4) {
          return $lazy_go(225)(new Cons(value4, acc), state3);
        });
      };
    });
    var go = $lazy_go(212);
    return go(Nil.value, state1);
  };
};
var lookAhead2 = function(v) {
  return function(state1, more, resume2, done) {
    return v(state1, more, function(v1, error5) {
      return resume2(state1, error5);
    }, function(v1, value4) {
      return done(state1, value4);
    });
  };
};
var initialParserState = function(stream3) {
  return {
    consumed: false,
    errors: [],
    stream: stream3
  };
};
var fromParserResult = function(v) {
  if (v instanceof ParseFail) {
    return new Left(v.value0);
  }
  ;
  if (v instanceof ParseSucc) {
    return new Right(new Tuple(v.value0, v.value1.errors));
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 253, column 20 - line 257, column 29): " + [v.constructor.name]);
};
var eof4 = function(state2, v, resume2, done) {
  var v1 = step2(state2.stream);
  if (v1 instanceof TokenError) {
    return resume2(state2, {
      error: v1.value1,
      position: v1.value0
    });
  }
  ;
  if (v1 instanceof TokenEOF) {
    return done({
      stream: state2.stream,
      errors: state2.errors,
      consumed: true
    }, new Tuple(v1.value0, v1.value1));
  }
  ;
  if (v1 instanceof TokenCons) {
    return resume2(state2, {
      error: new ExpectedEof(v1.value0.value),
      position: v1.value0.range.start
    });
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 188, column 7 - line 197, column 14): " + [v1.constructor.name]);
};

// output/PureScript.CST.Parser/index.js
var $runtime_lazy16 = function(name5, moduleName3, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name5 + " was needed before it finished initializing (module " + moduleName3 + ", line " + lineNumber + ")", moduleName3, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var bind71 = /* @__PURE__ */ bind(bindParser2);
var pure89 = /* @__PURE__ */ pure(applicativeParser2);
var apply28 = /* @__PURE__ */ apply2(applyParser2);
var map108 = /* @__PURE__ */ map(functorParser2);
var member11 = /* @__PURE__ */ member2(ordString);
var alt38 = /* @__PURE__ */ alt(altParser2);
var applyFirst5 = /* @__PURE__ */ applyFirst(applyParser2);
var applySecond10 = /* @__PURE__ */ applySecond(applyParser2);
var defer5 = /* @__PURE__ */ defer(lazyParser2);
var voidRight9 = /* @__PURE__ */ voidRight(functorParser2);
var wrapped = function(openTok) {
  return function(closeTok) {
    return function(valueParser) {
      return bind71(openTok)(function(open3) {
        return bind71(valueParser)(function(value4) {
          return bind71(closeTok)(function(close2) {
            return pure89({
              open: open3,
              value: value4,
              close: close2
            });
          });
        });
      });
    };
  };
};
var separated = function(sepParser) {
  return function(valueParser) {
    return apply28(map108(function(v) {
      return function(v1) {
        return {
          head: v,
          tail: v1
        };
      };
    })(valueParser))(many8(apply28(map108(Tuple.create)(sepParser))(valueParser)));
  };
};
var reservedKeywords = /* @__PURE__ */ fromFoldable8(foldableArray)(ordString)(["ado", "case", "class", "data", "derive", "do", "else", "false", "foreign", "if", "import", "in", "infix", "infixl", "infixr", "instance", "let", "module", "newtype", "of", "then", "true", "type", "where"]);
var recoverTokensWhile = function(p) {
  return function(initStream) {
    var indent3 = maybe(0)(function(v) {
      return v.column;
    })(currentIndent(layoutStack(initStream)));
    var go = function($copy_acc) {
      return function($copy_stream) {
        var $tco_var_acc = $copy_acc;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(acc, stream3) {
          var v = step2(stream3);
          if (v instanceof TokenError) {
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          if (v instanceof TokenEOF) {
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          if (v instanceof TokenCons) {
            var $135 = p(v.value0)(indent3);
            if ($135) {
              $tco_var_acc = snoc(acc)(v.value0);
              $copy_stream = v.value2;
              return;
            }
            ;
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 1194, column 19 - line 1203, column 25): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_acc, $copy_stream);
        }
        ;
        return $tco_result;
      };
    };
    return go([])(initStream);
  };
};
var recoverIndent = function(mkNode) {
  return recover(function(v) {
    return function(stream3) {
      var v1 = recoverTokensWhile(function(tok) {
        return function(indent3) {
          if (tok.value instanceof TokLayoutEnd) {
            return tok.value.value0 > indent3;
          }
          ;
          if (tok.value instanceof TokLayoutSep) {
            return tok.value.value0 > indent3;
          }
          ;
          return true;
        };
      })(stream3);
      var $145 = $$null(v1.value0);
      if ($145) {
        return Nothing.value;
      }
      ;
      return new Just(new Tuple(mkNode({
        position: v.position,
        error: v.error,
        tokens: v1.value0
      }), v1.value1));
    };
  });
};
var recoverLetBinding = /* @__PURE__ */ function() {
  return recoverIndent(LetBindingError.create);
}();
var recoverDoStatement = /* @__PURE__ */ function() {
  return recoverIndent(DoError.create);
}();
var recoverDecl = /* @__PURE__ */ function() {
  return recoverIndent(DeclError.create);
}();
var parseSmallInt = /* @__PURE__ */ take8(function(v) {
  if (v.value instanceof TokInt && v.value.value1 instanceof SmallInt) {
    return new Right(new Tuple(v, v.value.value1.value0));
  }
  ;
  if (v.value instanceof TokInt) {
    return new Left(new LexIntOutOfRange(v.value.value0));
  }
  ;
  return new Left(new UnexpectedToken(v.value));
});
var many13 = function(parser6) {
  return apply28(map108(cons$prime)(parser6))(many8(parser6));
};
var expectMap = function(k) {
  return take8(function(tok) {
    var v = k(tok);
    if (v instanceof Just) {
      return new Right(v.value0);
    }
    ;
    if (v instanceof Nothing) {
      return new Left(new UnexpectedToken(tok.value));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser (line 46, column 3 - line 50, column 39): " + [v.constructor.name]);
  });
};
var parseBoolean = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "true")) {
    return new Just(new Tuple(v, true));
  }
  ;
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "false")) {
    return new Just(new Tuple(v, false));
  }
  ;
  return Nothing.value;
});
var parseChar = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokChar) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseHole = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokHole) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  return Nothing.value;
});
var parseIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && !member11(v.value.value1)(reservedKeywords))) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var $$parseInt2 = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokInt) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseLabel = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokRawString) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  if (v.value instanceof TokString) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseModuleName2 = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Just) {
    return new Just({
      token: v,
      name: v.value.value0.value0 + ("." + v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseNumber = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokNumber) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && !member11(v.value.value1)(reservedKeywords)) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdentOrProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Left(v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Right(v.value.value1)
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseString = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokString) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  if (v.value instanceof TokRawString) {
    return new Just(new Tuple(v, v.value.value0));
  }
  ;
  return Nothing.value;
});
var parseSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var expect = function(pred2) {
  return expectMap(function(tok) {
    var $244 = pred2(tok.value);
    if ($244) {
      return new Just(tok);
    }
    ;
    return Nothing.value;
  });
};
var tokAt = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokAt) {
    return true;
  }
  ;
  return false;
});
var tokBackslash = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokBackslash) {
    return true;
  }
  ;
  return false;
});
var tokComma = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokComma) {
    return true;
  }
  ;
  return false;
});
var tokDot = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDot) {
    return true;
  }
  ;
  return false;
});
var parseRecordAccessor = function(expr) {
  return bind71(tokDot)(function(dot2) {
    return bind71(separated(tokDot)(parseLabel))(function(path14) {
      return pure89(new ExprRecordAccessor({
        expr,
        dot: dot2,
        path: path14
      }));
    });
  });
};
var tokDoubleColon = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDoubleColon) {
    return true;
  }
  ;
  return false;
});
var parseInstanceName = /* @__PURE__ */ function() {
  return apply28(map108(Tuple.create)(parseIdent))(tokDoubleColon);
}();
var tokEquals = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokEquals) {
    return true;
  }
  ;
  return false;
});
var tokForall = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokForall) {
    return true;
  }
  ;
  return false;
});
var tokKeyOperator = function(sym) {
  return expect(function(v) {
    if (v instanceof TokOperator && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var parseBinderNegative = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return alt38(map108(uncurry(BinderInt.create(new Just(negative))))($$parseInt2))(map108(uncurry(BinderNumber.create(new Just(negative))))(parseNumber));
});
var parseRecordLabeled = function(valueParser) {
  var parseRecordField = apply28(map108(uncurry(RecordField.create))($$try11(apply28(map108(Tuple.create)(parseLabel))(tokKeyOperator(":")))))(valueParser);
  return alt38(parseRecordField)(map108(RecordPun.create)(parseIdent));
};
var parseTypeNegative = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return map108(uncurry(TypeInt.create(new Just(negative))))($$parseInt2);
});
var tokKeySymbol = function(sym) {
  return expect(function(v) {
    if (v instanceof TokSymbolName && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var tokKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName && v.value0 instanceof Nothing) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var parseFixityKeyword = /* @__PURE__ */ function() {
  return alt38(map108(flip(Tuple.create)(Infix2.value))(tokKeyword("infix")))(alt38(map108(flip(Tuple.create)(Infixl2.value))(tokKeyword("infixl")))(map108(flip(Tuple.create)(Infixr2.value))(tokKeyword("infixr"))));
}();
var parseFixityOp = /* @__PURE__ */ function() {
  return alt38(apply28(apply28(apply28(map108(FixityType.create)(tokKeyword("type")))(parseQualifiedProper))(tokKeyword("as")))(parseOperator))(apply28(apply28(map108(FixityValue.create)(parseQualifiedIdentOrProper))(tokKeyword("as")))(parseOperator));
}();
var parseDeclFixity = /* @__PURE__ */ bind71(parseFixityKeyword)(function(keyword) {
  return bind71(parseSmallInt)(function(prec) {
    return bind71(parseFixityOp)(function(operator) {
      return pure89(new DeclFixity({
        keyword,
        prec,
        operator
      }));
    });
  });
});
var parseForeignKind = /* @__PURE__ */ function() {
  return $$try11(apply28(map108(ForeignKind.create)(tokKeyword("kind")))(parseProper));
}();
var parseRole = /* @__PURE__ */ function() {
  return alt38(map108(flip(Tuple.create)(Representational2.value))(tokKeyword("representational")))(alt38(map108(flip(Tuple.create)(Nominal2.value))(tokKeyword("nominal")))(map108(flip(Tuple.create)(Phantom2.value))(tokKeyword("phantom"))));
}();
var parseDeclRole = function(keyword1) {
  return bind71(tokKeyword("role"))(function(keyword2) {
    return bind71(parseProper)(function(name5) {
      return bind71(many13(parseRole))(function(roles) {
        return pure89(new DeclRole(keyword1, keyword2, name5, roles));
      });
    });
  });
};
var tokLayoutEnd = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutEnd) {
    return true;
  }
  ;
  return false;
});
var tokLayoutSep = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutSep) {
    return true;
  }
  ;
  return false;
});
var parseInstanceChainSeparator = /* @__PURE__ */ applyFirst5(/* @__PURE__ */ tokKeyword("else"))(/* @__PURE__ */ optional9(tokLayoutSep));
var tokLayoutStart = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutStart) {
    return true;
  }
  ;
  return false;
});
var layoutNonEmpty = function(valueParser) {
  return apply28(map108(function(v) {
    return function(v1) {
      return cons$prime(v)(v1);
    };
  })(applySecond10(tokLayoutStart)(valueParser)))(applyFirst5(many8(applySecond10(tokLayoutSep)(valueParser)))(tokLayoutEnd));
};
var tokLeftArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftArrow) {
    return true;
  }
  ;
  return false;
});
var tokLeftBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftBrace) {
    return true;
  }
  ;
  return false;
});
var tokLeftFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokOperator && v.value0 instanceof Nothing) {
    return v.value1 === "<=" || v.value1 === "\u21D0";
  }
  ;
  return false;
});
var tokLeftParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftParen) {
    return true;
  }
  ;
  return false;
});
var tokLeftSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftSquare) {
    return true;
  }
  ;
  return false;
});
var tokPipe = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokPipe) {
    return true;
  }
  ;
  return false;
});
var tokQualifiedKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var tokRightArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightArrow) {
    return true;
  }
  ;
  return false;
});
var parseFundep = /* @__PURE__ */ function() {
  return alt38(apply28(map108(FundepDetermined.create)(tokRightArrow))(many13(parseIdent)))(apply28(apply28(map108(FundepDetermines.create)(many13(parseIdent)))(tokRightArrow))(many13(parseIdent)));
}();
var tokRightBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightBrace) {
    return true;
  }
  ;
  return false;
});
var tokRightFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightFatArrow) {
    return true;
  }
  ;
  return false;
});
var tokRightParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightParen) {
    return true;
  }
  ;
  return false;
});
var parens2 = /* @__PURE__ */ wrapped(tokLeftParen)(tokRightParen);
var parseEmptyRow = function(open3) {
  return bind71(tokRightParen)(function(close2) {
    return pure89(new TypeRow({
      open: open3,
      value: {
        labels: Nothing.value,
        tail: Nothing.value
      },
      close: close2
    }));
  });
};
var tokRightSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightSquare) {
    return true;
  }
  ;
  return false;
});
var tokSymbolArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokSymbolArrow) {
    return true;
  }
  ;
  return false;
});
var tokTick = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokTick) {
    return true;
  }
  ;
  return false;
});
var tokUnderscore = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokUnderscore) {
    return true;
  }
  ;
  return false;
});
var delimited = function(openTok) {
  return function(closeTok) {
    return function(sepTok) {
      return function(valueParser) {
        var parseNonEmpty = function(open3) {
          return apply28(map108(function(v) {
            return function(v1) {
              return {
                open: open3,
                value: new Just(v),
                close: v1
              };
            };
          })(separated(sepTok)(valueParser)))(closeTok);
        };
        var parseEmpty = function(open3) {
          return map108(function(v) {
            return {
              open: open3,
              value: Nothing.value,
              close: v
            };
          })(closeTok);
        };
        return bind71(openTok)(function(open3) {
          return alt38(parseEmpty(open3))(parseNonEmpty(open3));
        });
      };
    };
  };
};
var parseDataMembers = /* @__PURE__ */ function() {
  return alt38(map108(DataAll.create)(tokKeySymbol("..")))(map108(DataEnumerated.create)(delimited(tokLeftParen)(tokRightParen)(tokComma)(parseProper)));
}();
var parseExport = /* @__PURE__ */ function() {
  return alt38(apply28(map108(ExportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt38(apply28(map108(ExportClass.create)(tokKeyword("class")))(parseProper))(alt38(apply28(map108(ExportModule.create)(tokKeyword("module")))(parseModuleName2))(alt38(map108(ExportOp.create)(parseSymbol))(alt38(map108(ExportValue.create)(parseIdent))(apply28(map108(ExportType.create)(parseProper))(optional9(parseDataMembers)))))));
}();
var parseImport = /* @__PURE__ */ function() {
  return alt38(map108(ImportOp.create)(parseSymbol))(alt38(apply28(map108(ImportType.create)(parseProper))(optional9(parseDataMembers)))(alt38(apply28(map108(ImportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt38(apply28(map108(ImportClass.create)(tokKeyword("class")))(parseProper))(map108(ImportValue.create)(parseIdent)))));
}();
var parseImportDecl = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("import"))(function(keyword) {
  return bind71(parseModuleName2)(function(module_) {
    return bind71(optional9(apply28(map108(Tuple.create)(optional9(tokKeyword("hiding"))))(parens2(separated(tokComma)(parseImport)))))(function(names) {
      return bind71(optional9(apply28(map108(Tuple.create)(tokKeyword("as")))(parseModuleName2)))(function(qualified) {
        return pure89({
          keyword,
          module: module_,
          names,
          qualified
        });
      });
    });
  });
});
var parseModuleImportDecls = /* @__PURE__ */ many8(/* @__PURE__ */ applyFirst5(parseImportDecl)(/* @__PURE__ */ alt38(tokLayoutSep)(/* @__PURE__ */ lookAhead2(tokLayoutEnd))));
var parseModuleHeader = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("module"))(function(keyword) {
  return bind71(parseModuleName2)(function(name5) {
    return bind71(optional9(parens2(separated(tokComma)(parseExport))))(function(exports) {
      return bind71(tokKeyword("where"))(function(where_) {
        return bind71(applySecond10(tokLayoutStart)(parseModuleImportDecls))(function(imports) {
          return pure89({
            keyword,
            name: name5,
            exports,
            where: where_,
            imports
          });
        });
      });
    });
  });
});
var braces = /* @__PURE__ */ wrapped(tokLeftBrace)(tokRightBrace);
var parseTypeVarKinded = function(parseBindingName) {
  return map108(TypeVarKinded.create)(parens2(bind71(parseBindingName)(function(label) {
    return bind71(tokDoubleColon)(function(separator) {
      return bind71($lazy_parseType(550))(function(value4) {
        return pure89({
          label,
          separator,
          value: value4
        });
      });
    });
  })));
};
var parseTypeVarBinding = function(parseBindingName) {
  return alt38(parseTypeVarKinded(parseBindingName))(map108(TypeVarName.create)(parseBindingName));
};
var parseTypeParen = function(open3) {
  return bind71($lazy_parseType(507))(function(value4) {
    return bind71(tokRightParen)(function(close2) {
      return pure89(new TypeParens({
        open: open3,
        value: value4,
        close: close2
      }));
    });
  });
};
var parseRowTailParen = function(open3) {
  return bind71(apply28(map108(Tuple.create)(tokPipe))($lazy_parseType(477)))(function(tail4) {
    return bind71(tokRightParen)(function(close2) {
      return pure89(new TypeRow({
        open: open3,
        value: {
          labels: Nothing.value,
          tail: new Just(tail4)
        },
        close: close2
      }));
    });
  });
};
var parseRowParen = function(open3) {
  return bind71($$try11(apply28(map108(Tuple.create)(parseLabel))(tokDoubleColon)))(function(v) {
    return bind71($lazy_parseType(459))(function(value4) {
      return bind71(many8(apply28(map108(Tuple.create)(tokComma))($lazy_parseRowLabel(460))))(function(rest2) {
        return bind71(optional9(apply28(map108(Tuple.create)(tokPipe))($lazy_parseType(461))))(function(tail4) {
          return bind71(tokRightParen)(function(close2) {
            return pure89(new TypeRow({
              open: open3,
              value: {
                labels: new Just({
                  head: {
                    label: v.value0,
                    separator: v.value1,
                    value: value4
                  },
                  tail: rest2
                }),
                tail: tail4
              },
              close: close2
            }));
          });
        });
      });
    });
  });
};
var parseKindedVar = function(open3) {
  return bind71($$try11(apply28(map108(Tuple.create)(parens2(map108(TypeVar2.create)(parseIdent))))(tokDoubleColon)))(function(v) {
    return bind71($lazy_parseType(497))(function(kind) {
      return bind71(tokRightParen)(function(close2) {
        return pure89(new TypeParens({
          open: open3,
          value: new TypeKinded(new TypeParens(v.value0), v.value1, kind),
          close: close2
        }));
      });
    });
  });
};
var $lazy_parseForall = /* @__PURE__ */ $runtime_lazy16("parseForall", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return apply28(apply28(apply28(map108(TypeForall.create)(tokForall))(many13($lazy_parseTypeVarBindingWithVisibility(528))))(tokDot))($lazy_parseType1(530));
  });
});
var $lazy_parseRow = /* @__PURE__ */ $runtime_lazy16("parseRow", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71(optional9(separated(tokComma)($lazy_parseRowLabel(513))))(function(labels) {
      return bind71(optional9(apply28(map108(Tuple.create)(tokPipe))($lazy_parseType(514))))(function(tail4) {
        return pure89({
          labels,
          tail: tail4
        });
      });
    });
  });
});
var $lazy_parseRowLabel = /* @__PURE__ */ $runtime_lazy16("parseRowLabel", "PureScript.CST.Parser", function() {
  return bind71(parseLabel)(function(label) {
    return bind71(tokDoubleColon)(function(separator) {
      return bind71($lazy_parseType(521))(function(value4) {
        return pure89({
          label,
          separator,
          value: value4
        });
      });
    });
  });
});
var $lazy_parseType = /* @__PURE__ */ $runtime_lazy16("parseType", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseType1(393))(function(ty) {
      return alt38(apply28(map108(TypeKinded.create(ty))(tokDoubleColon))($lazy_parseType(394)))(pure89(ty));
    });
  });
});
var $lazy_parseType1 = /* @__PURE__ */ $runtime_lazy16("parseType1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38($lazy_parseForall(399))($lazy_parseType2(400));
  });
});
var $lazy_parseType2 = /* @__PURE__ */ $runtime_lazy16("parseType2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseType3(404))(function(ty) {
      return alt38(apply28(map108(TypeArrow.create(ty))(tokRightArrow))($lazy_parseType1(405)))(alt38(apply28(map108(TypeConstrained.create(ty))(tokRightFatArrow))($lazy_parseType1(406)))(pure89(ty)));
    });
  });
});
var $lazy_parseType3 = /* @__PURE__ */ $runtime_lazy16("parseType3", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseType4(411))(function(ty) {
      return bind71(many8(apply28(map108(Tuple.create)(parseQualifiedOperator))($lazy_parseType4(412))))(function(ops) {
        return pure89(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeOp2(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 413, column 8 - line 415, column 28): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseType4 = /* @__PURE__ */ $runtime_lazy16("parseType4", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(parseTypeNegative)($lazy_parseType5(419));
  });
});
var $lazy_parseType5 = /* @__PURE__ */ $runtime_lazy16("parseType5", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseTypeAtom(423))(function(ty) {
      return bind71(many8($lazy_parseTypeAtom(424)))(function(args) {
        return pure89(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeApp2(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 425, column 8 - line 427, column 29): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseTypeAtom = /* @__PURE__ */ $runtime_lazy16("parseTypeAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(map108(TypeVar2.create)(parseIdent))(alt38(map108(TypeConstructor2.create)(parseQualifiedProper))(alt38(map108(uncurry(TypeString.create))(parseString))(alt38(map108(uncurry(TypeInt.create(Nothing.value)))($$parseInt2))(alt38($lazy_parseTypeParens(435))(alt38(map108(TypeRecord.create)(braces($lazy_parseRow(436))))(alt38(map108(TypeOpName.create)(parseQualifiedSymbol))(alt38(map108(TypeHole.create)(parseHole))(alt38(map108(TypeWildcard2.create)(tokUnderscore))(map108(TypeArrowName.create)(tokSymbolArrow))))))))));
  });
});
var $lazy_parseTypeParens = /* @__PURE__ */ $runtime_lazy16("parseTypeParens", "PureScript.CST.Parser", function() {
  return bind71(tokLeftParen)(function(open3) {
    return alt38(parseRowParen(open3))(alt38(parseRowTailParen(open3))(alt38(parseKindedVar(open3))(alt38(parseTypeParen(open3))(parseEmptyRow(open3)))));
  });
});
var $lazy_parseTypeVarBindingWithVisibility = /* @__PURE__ */ $runtime_lazy16("parseTypeVarBindingWithVisibility", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return parseTypeVarBinding(apply28(map108(function(v1) {
      return function(v2) {
        return {
          prefix: v1,
          value: v2
        };
      };
    })(optional9(tokAt)))(parseIdent));
  });
});
var parseType = /* @__PURE__ */ $lazy_parseType(391);
var parseType3 = /* @__PURE__ */ $lazy_parseType3(409);
var parseType5 = /* @__PURE__ */ $lazy_parseType5(421);
var parseTypeAtom = /* @__PURE__ */ $lazy_parseTypeAtom(429);
var parseDataCtor = /* @__PURE__ */ apply28(/* @__PURE__ */ map108(function(v) {
  return function(v1) {
    return {
      name: v,
      fields: v1
    };
  };
})(parseProper))(/* @__PURE__ */ many8(parseTypeAtom));
var $lazy_parseBinder = /* @__PURE__ */ $runtime_lazy16("parseBinder", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseBinder1(825))(function(binder) {
      return alt38(apply28(map108(BinderTyped.create(binder))(tokDoubleColon))(parseType))(pure89(binder));
    });
  });
});
var $lazy_parseBinder1 = /* @__PURE__ */ $runtime_lazy16("parseBinder1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseBinder2(831))(function(binder) {
      return bind71(many8(apply28(map108(Tuple.create)(parseQualifiedOperator))($lazy_parseBinder2(832))))(function(ops) {
        return pure89(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return binder;
          }
          ;
          if (v1 instanceof Just) {
            return new BinderOp(binder, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 833, column 8 - line 835, column 34): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseBinder2 = /* @__PURE__ */ $runtime_lazy16("parseBinder2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(parseBinderNegative)(alt38($lazy_parseBinderConstructor(840))($lazy_parseBinderAtom(841)));
  });
});
var $lazy_parseBinderAtom = /* @__PURE__ */ $runtime_lazy16("parseBinderAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38($lazy_parseIdentBinder(857))(alt38(map108(flip(BinderConstructor.create)([]))(parseQualifiedProper))(alt38(map108(BinderWildcard.create)(tokUnderscore))(alt38(map108(uncurry(BinderString.create))(parseString))(alt38(map108(uncurry(BinderChar.create))(parseChar))(alt38(map108(uncurry(BinderBoolean.create))(parseBoolean))(alt38(map108(uncurry(BinderInt.create(Nothing.value)))($$parseInt2))(alt38(map108(uncurry(BinderNumber.create(Nothing.value)))(parseNumber))(alt38(map108(BinderArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseBinder(865))))(alt38(map108(BinderRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseBinder(866)))))(map108(BinderParens.create)(parens2($lazy_parseBinder(867)))))))))))));
  });
});
var $lazy_parseBinderConstructor = /* @__PURE__ */ $runtime_lazy16("parseBinderConstructor", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71(parseQualifiedProper)(function(name5) {
      return bind71(many8($lazy_parseBinderAtom(852)))(function(apps2) {
        return pure89(new BinderConstructor(name5, apps2));
      });
    });
  });
});
var $lazy_parseIdentBinder = /* @__PURE__ */ $runtime_lazy16("parseIdentBinder", "PureScript.CST.Parser", function() {
  return bind71(parseIdent)(function(ident) {
    return alt38(apply28(map108(BinderNamed.create(ident))(tokAt))($lazy_parseBinderAtom(872)))(pure89(new BinderVar(ident)));
  });
});
var parseBinder = /* @__PURE__ */ $lazy_parseBinder(823);
var parseBinder1 = /* @__PURE__ */ $lazy_parseBinder1(829);
var parseBinderAtom = /* @__PURE__ */ $lazy_parseBinderAtom(855);
var parseClassConstraints = function(parseOneConstraint) {
  return alt38(map108(Many.create)(parens2(separated(tokComma)(parseType))))(map108(One.create)(parseOneConstraint));
};
var parseDeclDerive = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("derive"))(function(derive_) {
  return bind71(optional9(tokKeyword("newtype")))(function(newtype_) {
    return bind71(tokKeyword("instance"))(function(keyword) {
      return bind71(optional9(parseInstanceName))(function(name5) {
        return bind71(optional9($$try11(apply28(map108(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
          return bind71(parseQualifiedProper)(function(className) {
            return bind71(many8(parseTypeAtom))(function(types2) {
              return pure89(new DeclDerive(derive_, newtype_, {
                keyword,
                name: name5,
                constraints,
                className,
                types: types2
              }));
            });
          });
        });
      });
    });
  });
});
var parseClassMember = /* @__PURE__ */ bind71(parseIdent)(function(label) {
  return bind71(tokDoubleColon)(function(separator) {
    return bind71(parseType)(function(value4) {
      return pure89({
        label,
        separator,
        value: value4
      });
    });
  });
});
var parseDeclClassSignature = function(keyword) {
  return bind71($$try11(apply28(map108(Tuple.create)(parseProper))(tokDoubleColon)))(function(v) {
    return bind71(parseType)(function(value4) {
      return pure89(new DeclKindSignature(keyword, {
        label: v.value0,
        separator: v.value1,
        value: value4
      }));
    });
  });
};
var parseDeclKindSignature = function(keyword) {
  return function(label) {
    return bind71(tokDoubleColon)(function(separator) {
      return bind71(parseType)(function(value4) {
        return pure89(new DeclKindSignature(keyword, {
          label,
          separator,
          value: value4
        }));
      });
    });
  };
};
var parseDeclSignature = function(label) {
  return bind71(tokDoubleColon)(function(separator) {
    return bind71(parseType)(function(value4) {
      return pure89(new DeclSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseForeignData = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind71(parseProper)(function(label) {
    return bind71(tokDoubleColon)(function(separator) {
      return bind71(parseType)(function(value4) {
        return pure89(new ForeignData(keyword, {
          label,
          separator,
          value: value4
        }));
      });
    });
  });
});
var parseForeignValue = /* @__PURE__ */ bind71(parseIdent)(function(label) {
  return bind71(tokDoubleColon)(function(separator) {
    return bind71(parseType)(function(value4) {
      return pure89(new ForeignValue({
        label,
        separator,
        value: value4
      }));
    });
  });
});
var parseDeclForeign = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("foreign"))(function(keyword1) {
  return bind71(tokKeyword("import"))(function(keyword2) {
    return bind71(alt38(parseForeignData)(alt38(parseForeignKind)(parseForeignValue)))(function(foreign_) {
      return pure89(new DeclForeign(keyword1, keyword2, foreign_));
    });
  });
});
var parseInstanceBindingSignature = function(label) {
  return bind71(tokDoubleColon)(function(separator) {
    return bind71(parseType)(function(value4) {
      return pure89(new InstanceBindingSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseLetBindingSignature = function(label) {
  return bind71(tokDoubleColon)(function(separator) {
    return bind71(parseType)(function(value4) {
      return pure89(new LetBindingSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseRecordUpdates = function(expr) {
  return bind71($$try11(applyFirst5(tokLeftBrace)(lookAhead2(applySecond10(parseLabel)(alt38(tokEquals)(tokLeftBrace))))))(function(open3) {
    return bind71(separated(tokComma)($lazy_parseRecordUpdate(709)))(function(value4) {
      return bind71(tokRightBrace)(function(close2) {
        return pure89(new ExprRecordUpdate(expr, {
          open: open3,
          value: value4,
          close: close2
        }));
      });
    });
  });
};
var parseRecordUpdateLeaf = function(label) {
  return apply28(map108(RecordUpdateLeaf.create(label))(tokEquals))($lazy_parseExpr(723));
};
var parseRecordUpdateBranch = function(label) {
  return map108(RecordUpdateBranch.create(label))(braces(separated(tokComma)($lazy_parseRecordUpdate(728))));
};
var parseLetBindingName = function(name5) {
  return bind71(many8(parseBinderAtom))(function(binders) {
    return bind71(parseGuarded(tokEquals))(function(guarded) {
      return pure89(new LetBindingName({
        name: name5,
        binders,
        guarded
      }));
    });
  });
};
var parseGuarded = function(sepParser) {
  var parsePatternGuard = apply28(map108(function(v) {
    return function(v1) {
      return {
        binder: v,
        expr: v1
      };
    };
  })(optional9($$try11(apply28(map108(Tuple.create)(parseBinder))(tokLeftArrow)))))($lazy_parseExpr(814));
  var parseGuardedExpr = apply28(apply28(apply28(map108(function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return {
            bar: v,
            patterns: v1,
            separator: v2,
            where: v3
          };
        };
      };
    };
  })(tokPipe))(separated(tokComma)(parsePatternGuard)))(sepParser))($lazy_parseWhere(808));
  return alt38(apply28(map108(Unconditional.create)(sepParser))($lazy_parseWhere(800)))(map108(Guarded.create)(many13(parseGuardedExpr)));
};
var parseBadSingleCaseWhere = function(binder) {
  return bind71(tokRightArrow)(function(arrow) {
    return bind71(applySecond10(tokLayoutEnd)($lazy_parseWhere(665)))(function(body) {
      return pure89(singleton4(new Tuple({
        head: binder,
        tail: []
      }, new Unconditional(arrow, body))));
    });
  });
};
var parseBadSingleCaseGuarded = function(binder) {
  return bind71(applySecond10(tokLayoutEnd)(parseGuarded(tokRightArrow)))(function(body) {
    return pure89(singleton4(new Tuple({
      head: binder,
      tail: []
    }, body)));
  });
};
var $lazy_parseAdo = /* @__PURE__ */ $runtime_lazy16("parseAdo", "PureScript.CST.Parser", function() {
  return bind71(tokQualifiedKeyword("ado"))(function(keyword) {
    return bind71(function() {
      var valueParser = recoverDoStatement($lazy_parseDoStatement(690));
      var nonEmptyCase = apply28(map108(cons)(valueParser))(many8(applySecond10(tokLayoutSep)(valueParser)));
      return bind71(tokLayoutStart)(function() {
        return alt38(voidRight9([])(tokLayoutEnd))(applyFirst5(nonEmptyCase)(tokLayoutEnd));
      });
    }())(function(statements) {
      return bind71(tokKeyword("in"))(function(in_) {
        return bind71($lazy_parseExpr(697))(function(result) {
          return pure89(new ExprAdo({
            keyword,
            statements,
            "in": in_,
            result
          }));
        });
      });
    });
  });
});
var $lazy_parseBadSingleCaseBranch = /* @__PURE__ */ $runtime_lazy16("parseBadSingleCaseBranch", "PureScript.CST.Parser", function() {
  return bind71(applySecond10(tokLayoutStart)(parseBinder1))(function(binder) {
    return alt38(parseBadSingleCaseWhere(binder))(parseBadSingleCaseGuarded(binder));
  });
});
var $lazy_parseCase = /* @__PURE__ */ $runtime_lazy16("parseCase", "PureScript.CST.Parser", function() {
  return bind71(tokKeyword("case"))(function(keyword) {
    return bind71(separated(tokComma)($lazy_parseExpr(647)))(function(head6) {
      return bind71(tokKeyword("of"))(function(of_) {
        return bind71(alt38($$try11($lazy_parseBadSingleCaseBranch(649)))($lazy_parseCaseBranches(649)))(function(branches) {
          return pure89(new ExprCase({
            keyword,
            head: head6,
            of: of_,
            branches
          }));
        });
      });
    });
  });
});
var $lazy_parseCaseBranches = /* @__PURE__ */ $runtime_lazy16("parseCaseBranches", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return layoutNonEmpty(apply28(map108(Tuple.create)(separated(tokComma)(parseBinder1)))(parseGuarded(tokRightArrow)));
  });
});
var $lazy_parseDo = /* @__PURE__ */ $runtime_lazy16("parseDo", "PureScript.CST.Parser", function() {
  return bind71(tokQualifiedKeyword("do"))(function(keyword) {
    return bind71(layoutNonEmpty(recoverDoStatement($lazy_parseDoStatement(676))))(function(statements) {
      return pure89(new ExprDo({
        keyword,
        statements
      }));
    });
  });
});
var $lazy_parseDoStatement = /* @__PURE__ */ $runtime_lazy16("parseDoStatement", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(apply28(map108(DoLet.create)(tokKeyword("let")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(771)))))(alt38(apply28(map108(uncurry(DoBind.create))($$try11(apply28(map108(Tuple.create)(parseBinder))(tokLeftArrow))))($lazy_parseExpr(772)))(map108(DoDiscard.create)($lazy_parseExpr(773))));
  });
});
var $lazy_parseExpr = /* @__PURE__ */ $runtime_lazy16("parseExpr", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr1(555))(function(expr) {
      return alt38(apply28(map108(ExprTyped.create(expr))(tokDoubleColon))(parseType))(pure89(expr));
    });
  });
});
var $lazy_parseExpr1 = /* @__PURE__ */ $runtime_lazy16("parseExpr1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr2(561))(function(expr) {
      return bind71(many8(apply28(map108(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr2(562))))(function(ops) {
        return pure89(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 563, column 8 - line 565, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr2 = /* @__PURE__ */ $runtime_lazy16("parseExpr2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr3(569))(function(expr) {
      return bind71(many8(apply28(map108(Tuple.create)($lazy_parseTickExpr(570)))($lazy_parseExpr3(570))))(function(ops) {
        return pure89(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprInfix(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 571, column 8 - line 573, column 33): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr3 = /* @__PURE__ */ $runtime_lazy16("parseExpr3", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(apply28(map108(ExprNegate.create)(tokKeyOperator("-")))($lazy_parseExpr3(592)))($lazy_parseExpr4(593));
  });
});
var $lazy_parseExpr4 = /* @__PURE__ */ $runtime_lazy16("parseExpr4", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr5(597))(function(expr) {
      return bind71(many8($lazy_parseExprAppSpine(598)))(function(args) {
        return pure89(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprApp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 599, column 8 - line 601, column 31): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr5 = /* @__PURE__ */ $runtime_lazy16("parseExpr5", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38($lazy_parseIf(605))(alt38($lazy_parseLetIn(606))(alt38($lazy_parseLambda(607))(alt38($lazy_parseCase(608))(alt38($lazy_parseDo(609))(alt38($lazy_parseAdo(610))($lazy_parseExpr6(611)))))));
  });
});
var $lazy_parseExpr6 = /* @__PURE__ */ $runtime_lazy16("parseExpr6", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr7(702))(function(expr) {
      return alt38(parseRecordUpdates(expr))(pure89(expr));
    });
  });
});
var $lazy_parseExpr7 = /* @__PURE__ */ $runtime_lazy16("parseExpr7", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExprAtom(732))(function(expr) {
      return alt38(parseRecordAccessor(expr))(pure89(expr));
    });
  });
});
var $lazy_parseExprAppSpine = /* @__PURE__ */ $runtime_lazy16("parseExprAppSpine", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(apply28(map108(AppType.create)(tokAt))(parseTypeAtom))(map108(AppTerm.create)($lazy_parseExpr5(616)));
  });
});
var $lazy_parseExprAtom = /* @__PURE__ */ $runtime_lazy16("parseExprAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38(map108(ExprIdent.create)(parseQualifiedIdent))(alt38(map108(ExprConstructor.create)(parseQualifiedProper))(alt38(map108(ExprOpName.create)(parseQualifiedSymbol))(alt38(map108(ExprSection.create)(tokUnderscore))(alt38(map108(ExprHole.create)(parseHole))(alt38(map108(uncurry(ExprString.create))(parseString))(alt38(map108(uncurry(ExprChar.create))(parseChar))(alt38(map108(uncurry(ExprBoolean.create))(parseBoolean))(alt38(map108(uncurry(ExprInt.create))($$parseInt2))(alt38(map108(uncurry(ExprNumber.create))(parseNumber))(alt38(map108(ExprArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseExpr(754))))(alt38(map108(ExprRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseExpr(755)))))(map108(ExprParens.create)(parens2($lazy_parseExpr(756)))))))))))))));
  });
});
var $lazy_parseIdentBinding = /* @__PURE__ */ $runtime_lazy16("parseIdentBinding", "PureScript.CST.Parser", function() {
  return bind71(parseIdent)(function(ident) {
    return alt38(parseLetBindingSignature(ident))(parseLetBindingName(ident));
  });
});
var $lazy_parseIf = /* @__PURE__ */ $runtime_lazy16("parseIf", "PureScript.CST.Parser", function() {
  return bind71(tokKeyword("if"))(function(keyword) {
    return bind71($lazy_parseExpr(621))(function(cond) {
      return bind71(tokKeyword("then"))(function(then_) {
        return bind71($lazy_parseExpr(623))(function(true_) {
          return bind71(tokKeyword("else"))(function(else_) {
            return bind71($lazy_parseExpr(625))(function(false_) {
              return pure89(new ExprIf({
                keyword,
                cond,
                then: then_,
                "true": true_,
                "else": else_,
                "false": false_
              }));
            });
          });
        });
      });
    });
  });
});
var $lazy_parseLambda = /* @__PURE__ */ $runtime_lazy16("parseLambda", "PureScript.CST.Parser", function() {
  return bind71(tokBackslash)(function(symbol) {
    return bind71(many13(parseBinderAtom))(function(binders) {
      return bind71(tokRightArrow)(function(arrow) {
        return bind71($lazy_parseExpr(641))(function(body) {
          return pure89(new ExprLambda({
            symbol,
            binders,
            arrow,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseLetBinding = /* @__PURE__ */ $runtime_lazy16("parseLetBinding", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt38($$try11($lazy_parseIdentBinding(777)))(apply28(apply28(map108(LetBindingPattern.create)(parseBinder1))(tokEquals))($lazy_parseWhere(778)));
  });
});
var $lazy_parseLetIn = /* @__PURE__ */ $runtime_lazy16("parseLetIn", "PureScript.CST.Parser", function() {
  return bind71(tokKeyword("let"))(function(keyword) {
    return bind71(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(631))))(function(bindings) {
      return bind71(tokKeyword("in"))(function(in_) {
        return bind71($lazy_parseExpr(633))(function(body) {
          return pure89(new ExprLet({
            keyword,
            bindings,
            "in": in_,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseRecordUpdate = /* @__PURE__ */ $runtime_lazy16("parseRecordUpdate", "PureScript.CST.Parser", function() {
  return bind71(parseLabel)(function(label) {
    return alt38(parseRecordUpdateLeaf(label))(parseRecordUpdateBranch(label));
  });
});
var $lazy_parseTickExpr = /* @__PURE__ */ $runtime_lazy16("parseTickExpr", "PureScript.CST.Parser", function() {
  return bind71(tokTick)(function(open3) {
    return bind71($lazy_parseTickExpr1(578))(function(value4) {
      return bind71(tokTick)(function(close2) {
        return pure89({
          open: open3,
          value: value4,
          close: close2
        });
      });
    });
  });
});
var $lazy_parseTickExpr1 = /* @__PURE__ */ $runtime_lazy16("parseTickExpr1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr3(584))(function(expr) {
      return bind71(many8(apply28(map108(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr3(585))))(function(ops) {
        return pure89(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 586, column 8 - line 588, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseWhere = /* @__PURE__ */ $runtime_lazy16("parseWhere", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind71($lazy_parseExpr(819))(function(expr) {
      return bind71(optional9(apply28(map108(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(820))))))(function(bindings) {
        return pure89({
          expr,
          bindings
        });
      });
    });
  });
});
var parseDeclValue1 = function(name5) {
  return bind71(many8(parseBinderAtom))(function(binders) {
    return bind71(parseGuarded(tokEquals))(function(guarded) {
      return pure89(new DeclValue({
        name: name5,
        binders,
        guarded
      }));
    });
  });
};
var parseDeclValue = /* @__PURE__ */ bind71(parseIdent)(function(ident) {
  return alt38(parseDeclSignature(ident))(parseDeclValue1(ident));
});
var parseInstanceBindingName = function(name5) {
  return bind71(many8(parseBinderAtom))(function(binders) {
    return bind71(parseGuarded(tokEquals))(function(guarded) {
      return pure89(new InstanceBindingName({
        name: name5,
        binders,
        guarded
      }));
    });
  });
};
var parseInstanceBinding = /* @__PURE__ */ bind71(parseIdent)(function(ident) {
  return alt38(parseInstanceBindingSignature(ident))(parseInstanceBindingName(ident));
});
var parseInstance = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("instance"))(function(keyword) {
  return bind71(optional9(parseInstanceName))(function(name5) {
    return bind71(optional9($$try11(apply28(map108(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
      return bind71(parseQualifiedProper)(function(className) {
        return bind71(many8(parseTypeAtom))(function(types2) {
          return bind71(optional9(apply28(map108(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseInstanceBinding))))(function(body) {
            return pure89({
              head: {
                keyword,
                name: name5,
                constraints,
                className,
                types: types2
              },
              body
            });
          });
        });
      });
    });
  });
});
var parseDeclInstanceChain = /* @__PURE__ */ function() {
  return map108(DeclInstanceChain.create)(separated(parseInstanceChainSeparator)(parseInstance));
}();
var parseTypeVarBindingPlain = /* @__PURE__ */ parseTypeVarBinding(parseIdent);
var parseDeclClass1 = function(keyword) {
  return bind71(optional9($$try11(apply28(map108(Tuple.create)(parseClassConstraints(parseType5)))(tokLeftFatArrow))))(function($$super) {
    return bind71(parseProper)(function(name5) {
      return bind71(many8(parseTypeVarBindingPlain))(function(vars) {
        return bind71(optional9(apply28(map108(Tuple.create)(tokPipe))(separated(tokComma)(parseFundep))))(function(fundeps) {
          return bind71(optional9(apply28(map108(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseClassMember))))(function(members) {
            return pure89(new DeclClass({
              keyword,
              "super": $$super,
              name: name5,
              vars,
              fundeps
            }, members));
          });
        });
      });
    });
  });
};
var parseDeclClass = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("class"))(function(keyword) {
  return alt38(parseDeclClassSignature(keyword))(parseDeclClass1(keyword));
});
var parseDeclData1 = function(keyword) {
  return function(name5) {
    return bind71(many8(parseTypeVarBindingPlain))(function(vars) {
      return bind71(optional9(apply28(map108(Tuple.create)(tokEquals))(separated(tokPipe)(parseDataCtor))))(function(ctors) {
        return pure89(new DeclData({
          keyword,
          name: name5,
          vars
        }, ctors));
      });
    });
  };
};
var parseDeclData = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind71(parseProper)(function(name5) {
    return alt38(parseDeclKindSignature(keyword)(name5))(parseDeclData1(keyword)(name5));
  });
});
var parseDeclNewtype1 = function(keyword) {
  return function(name5) {
    return bind71(many8(parseTypeVarBindingPlain))(function(vars) {
      return bind71(tokEquals)(function(tok) {
        return bind71(parseProper)(function(wrapper) {
          return bind71(parseTypeAtom)(function(body) {
            return pure89(new DeclNewtype({
              keyword,
              name: name5,
              vars
            }, tok, wrapper, body));
          });
        });
      });
    });
  };
};
var parseDeclNewtype = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("newtype"))(function(keyword) {
  return bind71(parseProper)(function(name5) {
    return alt38(parseDeclKindSignature(keyword)(name5))(parseDeclNewtype1(keyword)(name5));
  });
});
var parseDeclType2 = function(keyword) {
  return function(name5) {
    return bind71(many8(parseTypeVarBindingPlain))(function(vars) {
      return bind71(tokEquals)(function(tok) {
        return bind71(parseType)(function(body) {
          return pure89(new DeclType({
            keyword,
            name: name5,
            vars
          }, tok, body));
        });
      });
    });
  };
};
var parseDeclType1 = function(keyword) {
  return bind71(parseProper)(function(name5) {
    return alt38(parseDeclKindSignature(keyword)(name5))(parseDeclType2(keyword)(name5));
  });
};
var parseDeclType = /* @__PURE__ */ bind71(/* @__PURE__ */ tokKeyword("type"))(function(keyword) {
  return alt38(parseDeclRole(keyword))(parseDeclType1(keyword));
});
var parseDecl = /* @__PURE__ */ alt38(parseDeclData)(/* @__PURE__ */ alt38(parseDeclNewtype)(/* @__PURE__ */ alt38(parseDeclType)(/* @__PURE__ */ alt38(parseDeclClass)(/* @__PURE__ */ alt38(parseDeclInstanceChain)(/* @__PURE__ */ alt38(parseDeclDerive)(/* @__PURE__ */ alt38(parseDeclValue)(/* @__PURE__ */ alt38(parseDeclForeign)(parseDeclFixity))))))));
var parseModuleDecls = /* @__PURE__ */ many8(/* @__PURE__ */ applyFirst5(/* @__PURE__ */ recoverDecl(parseDecl))(/* @__PURE__ */ alt38(tokLayoutSep)(/* @__PURE__ */ lookAhead2(tokLayoutEnd))));
var parseModuleBody = /* @__PURE__ */ bind71(/* @__PURE__ */ applyFirst5(parseModuleDecls)(tokLayoutEnd))(function(decls) {
  return bind71(eof4)(function(v) {
    return pure89({
      decls,
      trailingComments: v.value1,
      end: v.value0
    });
  });
});

// output/PureScript.CST/index.js
var bind73 = /* @__PURE__ */ bind(bindParser2);
var pure90 = /* @__PURE__ */ pure(applicativeParser2);
var ParseSucceeded = /* @__PURE__ */ function() {
  function ParseSucceeded2(value0) {
    this.value0 = value0;
  }
  ;
  ParseSucceeded2.create = function(value0) {
    return new ParseSucceeded2(value0);
  };
  return ParseSucceeded2;
}();
var ParseSucceededWithErrors = /* @__PURE__ */ function() {
  function ParseSucceededWithErrors2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucceededWithErrors2.create = function(value0) {
    return function(value12) {
      return new ParseSucceededWithErrors2(value0, value12);
    };
  };
  return ParseSucceededWithErrors2;
}();
var ParseFailed = /* @__PURE__ */ function() {
  function ParseFailed2(value0) {
    this.value0 = value0;
  }
  ;
  ParseFailed2.create = function(value0) {
    return new ParseFailed2(value0);
  };
  return ParseFailed2;
}();
var toRecoveredParserResult = function(v) {
  var v1 = function(v2) {
    if (v instanceof Right && otherwise) {
      return new ParseSucceeded(v.value0.value0);
    }
    ;
    if (v instanceof Left) {
      return new ParseFailed(v.value0);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST (line 41, column 1 - line 44, column 29): " + [v.constructor.name]);
  };
  if (v instanceof Right) {
    var $21 = fromArray(v.value0.value1);
    if ($21 instanceof Just) {
      return new ParseSucceededWithErrors(v.value0.value0, $21.value0);
    }
    ;
    return v1(true);
  }
  ;
  return v1(true);
};
var parsePartialModule = function(src) {
  return toRecoveredParserResult(function() {
    var v = runParser$prime(initialParserState(lex(src)))(parseModuleHeader);
    if (v instanceof ParseSucc) {
      var res = {
        header: v.value0,
        full: defer2(function(v1) {
          return toRecoveredParserResult(fromParserResult(runParser$prime(v.value1)(bind73(parseModuleBody)(function(body) {
            return pure90({
              header: v.value0,
              body
            });
          }))));
        })
      };
      return new Right(new Tuple(res, v.value1.errors));
    }
    ;
    if (v instanceof ParseFail) {
      return new Left(v.value0);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST (line 85, column 29 - line 97, column 17): " + [v.constructor.name]);
  }());
};

// output/Registry.Operation.Validation/index.js
var lookup18 = /* @__PURE__ */ lookup3(ordVersion);
var eq212 = /* @__PURE__ */ eq(eqLocation);
var notElem3 = /* @__PURE__ */ notElem2(eqString);
var bind74 = /* @__PURE__ */ bind(bindAff);
var pure91 = /* @__PURE__ */ pure(applicativeAff);
var traverse10 = /* @__PURE__ */ traverse(traversableNonEmptyArray);
var foldMap30 = /* @__PURE__ */ foldMap2(monoidString);
var locationMatches = function(v) {
  return function(v1) {
    return eq212(v.location)(v1.location);
  };
};
var isNotUnpublished = function(v) {
  return function(v1) {
    return lookup18(v.version)(v1.unpublished);
  };
};
var isNotPublished = function(v) {
  return function(v1) {
    return lookup18(v.version)(v1.published);
  };
};
var isMetadataPackage = function(v) {
  return print5(v.name) === "metadata";
};
var forbiddenModules = ["Main", "Test.Main"];
var validatePursModule = function(moduleString) {
  var verifyHeader = function(v2) {
    var $103 = notElem3(v2.name.name)(forbiddenModules);
    if ($103) {
      return new Right(unit);
    }
    ;
    return new Left("Module name is " + (v2.name.name + (" but PureScript libraries cannot publish modules named: " + joinWith(", ")(forbiddenModules))));
  };
  var v = parsePartialModule(moduleString);
  if (v instanceof ParseFailed) {
    return new Left("Failed to parse PureScript module: " + printParseError(v.value0.error));
  }
  ;
  if (v instanceof ParseSucceededWithErrors) {
    return verifyHeader(v.value0.header);
  }
  ;
  if (v instanceof ParseSucceeded) {
    return verifyHeader(v.value0.header);
  }
  ;
  throw new Error("Failed pattern match at Registry.Operation.Validation (line 213, column 35 - line 219, column 24): " + [v.constructor.name]);
};
var validatePursModules = function(dictMonadAff) {
  var liftAff13 = liftAff(dictMonadAff);
  var Monad0 = dictMonadAff.MonadEffect0().Monad0();
  var bind128 = bind(Monad0.Bind1());
  var Applicative0 = Monad0.Applicative0();
  var traverse13 = traverse10(Applicative0);
  var pure129 = pure(Applicative0);
  return function(files) {
    var convertErrors = function() {
      var $136 = concatMap(function(v) {
        if (v.value1 instanceof Left) {
          return [new Tuple(v.value0, v.value1.value0)];
        }
        ;
        if (v.value1 instanceof Right) {
          return [];
        }
        ;
        throw new Error("Failed pattern match at Registry.Operation.Validation (line 191, column 53 - line 193, column 30): " + [v.constructor.name]);
      });
      return function($137) {
        return $136(toArray($137));
      };
    }();
    var acceptedPursModule = function(path14) {
      return liftAff13(bind74(attempt(readTextFile2(UTF8.value)(path14)))(function(eitherModule) {
        return pure91(new Tuple(path14, function() {
          if (eitherModule instanceof Left) {
            return new Left("Could not read PureScript module from disk at path " + (path14 + (": " + message(eitherModule.value0))));
          }
          ;
          if (eitherModule instanceof Right) {
            return validatePursModule(eitherModule.value0);
          }
          ;
          throw new Error("Failed pattern match at Registry.Operation.Validation (line 186, column 27 - line 188, column 62): " + [eitherModule.constructor.name]);
        }()));
      }));
    };
    return bind128(traverse13(acceptedPursModule)(files))(function(results) {
      var v = convertErrors(results);
      if (v.length === 0) {
        return pure129(new Right(unit));
      }
      ;
      return pure129(new Left(foldMap30(function(v1) {
        return "\n  - " + (v1.value0 + (": " + v1.value1));
      })(v)));
    });
  };
};

// output/Spago.Command.Publish/index.js
var bind75 = /* @__PURE__ */ bind(bindSpago);
var exists10 = /* @__PURE__ */ exists2(monadEffectSpago);
var pure92 = /* @__PURE__ */ pure(applicativeSpago);
var die16 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die17 = /* @__PURE__ */ die16(loggableDocc);
var toDoc8 = /* @__PURE__ */ toDoc2(loggableDocc);
var eq41 = /* @__PURE__ */ eq(eqString);
var ask15 = /* @__PURE__ */ ask(monadAskSpago);
var die26 = /* @__PURE__ */ die16(loggableString);
var discard40 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug17 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug18 = /* @__PURE__ */ logDebug17(loggableString);
var liftAff10 = /* @__PURE__ */ liftAff(monadAffSpago);
var notEq10 = /* @__PURE__ */ notEq(eqStatusCode);
var show51 = /* @__PURE__ */ show(showStatusCode);
var show119 = /* @__PURE__ */ show(showDecodeError);
var for_10 = /* @__PURE__ */ for_(applicativeSpago);
var for_13 = /* @__PURE__ */ for_10(foldableArray);
var toDoc16 = /* @__PURE__ */ toDoc2(loggableString);
var logDebug26 = /* @__PURE__ */ logDebug17(loggableDocc);
var logInfo10 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago);
var logInfo1 = /* @__PURE__ */ logInfo10(loggableDocc);
var logWarn8 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableDocc);
var logError2 = /* @__PURE__ */ logError(monadEffectSpago)(monadAskSpago)(loggableDocc);
var logSuccess6 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var runSpago7 = /* @__PURE__ */ runSpago(monadAffSpago);
var liftEffect14 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var when18 = /* @__PURE__ */ when(applicativeSpago);
var mapFlipped24 = /* @__PURE__ */ mapFlipped(functorMap);
var map109 = /* @__PURE__ */ map(functorSpago);
var union13 = /* @__PURE__ */ union5();
var pure127 = /* @__PURE__ */ pure(applicativeArray);
var map146 = /* @__PURE__ */ map(functorArray);
var toUnfoldable33 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var unwrap23 = /* @__PURE__ */ unwrap();
var fromFoldable51 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var unless8 = /* @__PURE__ */ unless(applicativeSpago);
var toDoc24 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc33 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableString));
var fromFoldable118 = /* @__PURE__ */ fromFoldable(foldableArray);
var unlessM4 = /* @__PURE__ */ unlessM(monadSpago);
var append125 = /* @__PURE__ */ append(semigroupDoc);
var lines7 = /* @__PURE__ */ lines(foldableArray);
var mapFlipped111 = /* @__PURE__ */ mapFlipped(functorArray);
var readPursFiles2 = /* @__PURE__ */ readPursFiles(monadAffSpago);
var validatePursModules2 = /* @__PURE__ */ validatePursModules(monadAffSpago);
var for_23 = /* @__PURE__ */ for_10(foldableMaybe);
var append212 = /* @__PURE__ */ append(semigroupArray);
var show215 = /* @__PURE__ */ show(showString);
var show310 = /* @__PURE__ */ show(showInt);
var die$prime2 = /* @__PURE__ */ die$prime(monadEffectSpago)(monadAskSpago)(loggableDocc);
var fromFoldable213 = /* @__PURE__ */ fromFoldable(foldableList);
var logInfo22 = /* @__PURE__ */ logInfo10(loggableString);
var map230 = /* @__PURE__ */ map(functorMap);
var locationIsInGitRemotes = function(location) {
  return bind75(exists10(".git"))(function(isGitRepo) {
    var $103 = !isGitRepo;
    if ($103) {
      return pure92(false);
    }
    ;
    return bind75(getRemotes(Nothing.value))(function(v) {
      if (v instanceof Left) {
        return die17(toDoc8(v.value0));
      }
      ;
      if (v instanceof Right) {
        return pure92(any2(function(r) {
          if (location instanceof Git) {
            return r.url === location.value0.url;
          }
          ;
          if (location instanceof GitHub) {
            return r.owner === location.value0.owner && r.repo === location.value0.repo;
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 474, column 42 - line 476, column 80): " + [location.constructor.name]);
        })(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Publish (line 470, column 32 - line 476, column 80): " + [v.constructor.name]);
    });
  });
};
var callRegistry = function(url2) {
  return function(outputCodec) {
    return function(maybeInput) {
      var handleError = function(a) {
        return bind75(ask15)(function(v) {
          if (v.offline instanceof Offline) {
            return die26("Spago is offline - not able to call the Registry.");
          }
          ;
          if (v.offline instanceof Online) {
            return bind75(a)(function(v1) {
              if (v1 instanceof Left) {
                return die26(v1.value0);
              }
              ;
              if (v1 instanceof Right) {
                return pure92(v1.value0);
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 420, column 15 - line 422, column 32): " + [v1.constructor.name]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 417, column 5 - line 422, column 32): " + [v.offline.constructor.name]);
        });
      };
      return handleError(discard40(logDebug18("Calling registry at " + url2))(function() {
        return bind75(liftAff10(withBackoff$prime(function() {
          if (maybeInput instanceof Just) {
            return post2(string4)(url2)(new Just(json3(encode2(maybeInput.value0.codec)(maybeInput.value0.data))));
          }
          ;
          if (maybeInput instanceof Nothing) {
            return get5(string4)(url2);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 401, column 40 - line 403, column 50): " + [maybeInput.constructor.name]);
        }())))(function(response) {
          if (response instanceof Nothing) {
            return pure92(new Left("Could not reach the registry at " + url2));
          }
          ;
          if (response instanceof Just && response.value0 instanceof Left) {
            return pure92(new Left("Error while calling the registry:\n  " + printError2(response.value0.value0)));
          }
          ;
          if (response instanceof Just && (response.value0 instanceof Right && notEq10(response.value0.value0.status)(200))) {
            return pure92(new Left("Registry did not like this and answered with status " + (show51(response.value0.value0.status) + (", got answer:\n  " + response.value0.value0.body))));
          }
          ;
          if (response instanceof Just && response.value0 instanceof Right) {
            return pure92(function() {
              var v = parseJson(outputCodec)(response.value0.value0.body);
              if (v instanceof Right) {
                return new Right(v.value0);
              }
              ;
              if (v instanceof Left) {
                return new Left("Could not parse response from the registry, error: " + show119(v.value0));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 410, column 14 - line 412, column 93): " + [v.constructor.name]);
            }());
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 404, column 3 - line 412, column 93): " + [response.constructor.name]);
        });
      }));
    };
  };
};
var baseApi = "https://registry.purescript.org";
var waitForJobFinish = function(jobId) {
  var go = function(lastTimestamp) {
    return bind75(ask15)(function(v) {
      var url2 = baseApi + print11(routes)(new Job(jobId, {
        since: lastTimestamp,
        level: function() {
          if (v.logOptions.verbosity instanceof LogVerbose) {
            return new Just(Debug.value);
          }
          ;
          return new Just(Info.value);
        }()
      }));
      return bind75(callRegistry(url2)(jobCodec)(Nothing.value))(function(v1) {
        return discard40(for_13(v1.logs)(function(log5) {
          var line2 = indent(toDoc16(format(iso8601DateTime)(log5.timestamp) + (" " + log5.message)));
          if (log5.level instanceof Debug) {
            return logDebug26(line2);
          }
          ;
          if (log5.level instanceof Info) {
            return logInfo1(line2);
          }
          ;
          if (log5.level instanceof Warn) {
            return logWarn8(line2);
          }
          ;
          if (log5.level instanceof $$Error3) {
            return logError2(line2);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 443, column 7 - line 447, column 34): " + [log5.level.constructor.name]);
        }))(function() {
          if (v1.finishedAt instanceof Nothing) {
            var latestTimestamp = function(v2) {
              if (v2 instanceof Just) {
                return new Just(v2.value0.timestamp);
              }
              ;
              if (v2 instanceof Nothing) {
                return lastTimestamp;
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 452, column 57 - line 454, column 37): " + [v2.constructor.name]);
            }(last(v1.logs));
            return discard40(liftAff10(delay(500)))(function() {
              return go(latestTimestamp);
            });
          }
          ;
          if (v1.finishedAt instanceof Just) {
            return discard40(logDebug18("Job: " + printJson(jobCodec)(v1)))(function() {
              if (v1.success) {
                return logSuccess6("Registry finished processing the package. Your package was published successfully!");
              }
              ;
              if (!v1.success) {
                return die26("Registry finished processing the package, but it failed. Please fix it and try again.");
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 460, column 9 - line 462, column 113): " + [v1.success.constructor.name]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 448, column 5 - line 462, column 113): " + [v1.finishedAt.constructor.name]);
        });
      });
    });
  };
  return go(Nothing.value);
};
var publish = function(_args) {
  var runBuild = function(v) {
    return function(action) {
      return bind75(ask15)(function(env3) {
        return runSpago7({
          purs: env3.purs,
          git: env3.git,
          dependencies: v.dependencies,
          logOptions: env3.logOptions,
          workspace: {
            backend: env3.workspace.backend,
            buildOptions: env3.workspace.buildOptions,
            compatibleCompiler: env3.workspace.compatibleCompiler,
            doc: env3.workspace.doc,
            packageSet: env3.workspace.packageSet,
            rootPackage: env3.workspace.rootPackage,
            workspaceConfig: env3.workspace.workspaceConfig,
            selected: new Just(v.selected)
          },
          strictWarnings: Nothing.value,
          pedanticPackages: false
        })(action);
      });
    };
  };
  return bind75(liftEffect14($$new(new Left(Nil.value))))(function(resultRef) {
    var setResult = function(r) {
      return liftEffect14(modify_(function(v) {
        if (v instanceof Left && v.value0 instanceof Nil) {
          return new Right(r);
        }
        ;
        return v;
      })(resultRef));
    };
    var addError = function(err) {
      return liftEffect14(modify_(function(v) {
        if (v instanceof Left) {
          return new Left(new Cons(err, v.value0));
        }
        ;
        if (v instanceof Right) {
          return new Left(new Cons(err, Nil.value));
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Publish (line 94, column 11 - line 96, column 54): " + [v.constructor.name]);
      })(resultRef));
    };
    return bind75(ask15)(function(v) {
      var v1 = {
        doc: v.selected.doc,
        "package": v["selected"]["package"],
        path: v.selected.path,
        hasTests: false
      };
      var strName = print5(v1["package"].name);
      return discard40(logDebug18("Publishing package " + strName))(function() {
        return bind75(runBuild({
          selected: v1,
          dependencies: v.dependencies
        })(run4({
          depsOnly: false,
          pursArgs: [],
          jsonErrors: false
        })))(function(built) {
          return discard40(when18(!built)(liftEffect14(exit)))(function() {
            var allCoreDependencies = toAllDependencies(mapFlipped24(v.dependencies)(function(v2) {
              return {
                core: v2.core,
                test: empty4
              };
            }));
            var globs = getBuildGlobs({
              selected: singleton4(v1),
              withTests: false,
              dependencies: allCoreDependencies,
              depsOnly: false
            });
            return bind75(runGraph(globs)([]))(function(eitherGraph) {
              return discard40(function() {
                if (eitherGraph instanceof Right) {
                  return bind75(map109(toImportErrors(v1)({
                    reportSrc: true,
                    reportTest: false
                  }))(runSpago7(union13({
                    selected: v1,
                    workspacePackages: getWorkspacePackages(v.workspace.packageSet)
                  })(v))(checkImports(eitherGraph.value0))))(function(graphCheckErrors) {
                    return for_13(graphCheckErrors)(function($214) {
                      return addError(formatImportErrors(pure127($214)));
                    });
                  });
                }
                ;
                if (eitherGraph instanceof Left) {
                  return die26(eitherGraph.value0);
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Publish (line 123, column 3 - line 129, column 14): " + [eitherGraph.constructor.name]);
              }())(function() {
                var v2 = partitionEithers(map146(function(v3) {
                  if (v3.value1 instanceof Nothing) {
                    return new Left(v3.value0);
                  }
                  ;
                  if (v3.value1 instanceof Just) {
                    return new Right(new Tuple(v3.value0, v3.value1.value0));
                  }
                  ;
                  throw new Error("Failed pattern match at Spago.Command.Publish (line 135, column 13 - line 137, column 64): " + [v3.constructor.name]);
                })(toUnfoldable33(unwrap23(v1["package"].dependencies))));
                var depsRanges = fromFoldable51(v2.success);
                return discard40(unless8($$null(v2.fail))(addError(toDoc24([toDoc16("The configuration is missing version bounds for some packages. Run `spago fetch --ensure-ranges` to add them:"), indent(toDoc33(map146(function(p) {
                  return "- " + print5(p);
                })(fromFoldable118(v2.fail))))]))))(function() {
                  return bind75(getTransitiveDepsFromRegistry(depsRanges)(empty4))(function(buildPlan) {
                    return discard40(function() {
                      if (v1["package"].publish instanceof Nothing) {
                        return addError(toDoc33(["Did not find publishing config: add a valid one in `package.publish`.", "See the configuration file's documentation: https://github.com/purescript/spago#the-configuration-file"]));
                      }
                      ;
                      if (v1["package"].publish instanceof Just) {
                        if (v1["package"].publish.value0.location instanceof Nothing) {
                          return addError(toDoc16("Need to specify a publish.location field."));
                        }
                        ;
                        if (v1["package"].publish.value0.location instanceof Just) {
                          return bind75(bind75(getMetadata(v1["package"].name))(function(v3) {
                            if (v3 instanceof Right) {
                              return pure92(v3.value0);
                            }
                            ;
                            if (v3 instanceof Left) {
                              return discard40(logDebug18("Got error while reading metadata file: " + v3.value0))(function() {
                                return pure92({
                                  location: v1["package"].publish.value0.location.value0,
                                  owners: Nothing.value,
                                  published: empty4,
                                  unpublished: empty4
                                });
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Publish (line 163, column 51 - line 172, column 16): " + [v3.constructor.name]);
                          }))(function(metadata) {
                            var manifest = {
                              name: v1["package"].name,
                              location: v1["package"].publish.value0.location.value0,
                              description: v1["package"].description,
                              dependencies: depsRanges,
                              version: v1["package"].publish.value0.version,
                              license: v1["package"].publish.value0.license,
                              owners: Nothing.value,
                              excludeFiles: Nothing.value,
                              includeFiles: Nothing.value
                            };
                            return discard40(unless8(locationMatches(manifest)(metadata))(addError(toDoc33(["The manifest file specifies a location (", stringifyJson(codec5)(manifest.location), ") that differs from the location in the registry metadata (", stringifyJson(codec5)(metadata.location), "). If you would like to change the location of your package you should ", "submit a transfer operation."]))))(function() {
                              return discard40(unlessM4(locationIsInGitRemotes(v1["package"].publish.value0.location.value0))(addError(toDoc33(["The location specified in the manifest file", "(" + (stringifyJson(codec5)(v1["package"].publish.value0.location.value0) + ")"), " is not one of the remotes in the git repository."]))))(function() {
                                var v3 = partitionEithers(map146(function(v4) {
                                  if (v4.value1 instanceof RegistryVersion) {
                                    return new Right(new Tuple(v4.value0, v4.value1.value0));
                                  }
                                  ;
                                  return new Left(v4.value0);
                                })(toUnfoldable33(allCoreDependencies)));
                                var $178 = length(v3.fail) > 0;
                                if ($178) {
                                  return addError(append125(toDoc33(["Some of the packages you specified as `extraPackages` do not point to the Registry.", "To be able to publish a package to the registry, all of its dependencies have to be packages registered on the Registry.", "Please replace the following packages with versions that are present in the Registry:"]))(append125($$break)(lines7(mapFlipped111(v3.fail)(function(p) {
                                    return indent(toDoc16("- " + print5(p)));
                                  })))));
                                }
                                ;
                                return discard40(bind75(readPursFiles2(concat3([v1.path, "src"])))(function(v4) {
                                  if (v4 instanceof Nothing) {
                                    return addError(toDoc33(["This package has no PureScript files in its `src` directory. ", "All package sources must be in the `src` directory, with any additional ", "sources indicated by the `files` key in your manifest."]));
                                  }
                                  ;
                                  if (v4 instanceof Just) {
                                    return bind75(validatePursModules2(v4.value0))(function(v5) {
                                      if (v5 instanceof Left) {
                                        return addError(toDoc33(["This package has either malformed or disallowed PureScript module names", "in its `src` directory. All package sources must be in the `src` directory,", "with any additional sources indicated by the `files` key in your manifest.", v5.value0]));
                                      }
                                      ;
                                      if (v5 instanceof Right) {
                                        return pure92(unit);
                                      }
                                      ;
                                      throw new Error("Failed pattern match at Spago.Command.Publish (line 231, column 66 - line 238, column 37): " + [v5.constructor.name]);
                                    });
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Command.Publish (line 224, column 82 - line 238, column 37): " + [v4.constructor.name]);
                                }))(function() {
                                  return discard40(when18(isMetadataPackage(manifest))(addError(toDoc16("The `metadata` package cannot be uploaded to the registry because it is a protected package."))))(function() {
                                    return discard40(for_23(isNotPublished(manifest)(metadata))(function(info4) {
                                      return addError(toDoc33(["You tried to upload a version that already exists: " + print6(manifest.version), "Its metadata is:", "```json", printJson(publishedMetadataCodec)(info4), "```"]));
                                    }))(function() {
                                      return discard40(for_23(isNotUnpublished(manifest)(metadata))(function(info4) {
                                        return addError(toDoc33(["You tried to upload a version that has been unpublished: " + print6(manifest.version), "", "```json", printJson(unpublishedMetadataCodec)(info4), "```"]));
                                      }))(function() {
                                        var expectedTag = "v" + print6(v1["package"].publish.value0.version);
                                        return discard40(bind75(getStatus(Nothing.value))(function(v4) {
                                          if (v4 instanceof Left) {
                                            return die17(toDoc24([toDoc16("Could not verify whether the git tree is clean due to the below error:"), indent(v4.value0)]));
                                          }
                                          ;
                                          if (v4 instanceof Right) {
                                            if (v4.value0 !== "") {
                                              return addError(toDoc24([toDoc16("The git tree is not clean. Please commit or stash these files:"), indent(toDoc33(split("\n")(v4.value0)))]));
                                            }
                                            ;
                                            if (otherwise) {
                                              return bind75(map109(hush)(tagCheckedOut(Nothing.value)))(function(maybeCurrentTag) {
                                                if (maybeCurrentTag instanceof Just) {
                                                  return when18(maybeCurrentTag.value0 !== expectedTag)(addError(toDoc33(["The tag (" + (maybeCurrentTag.value0 + (") does not match the expected tag (" + (expectedTag + ")."))), "Fix all other publishing-related errors first before creating the correct tag. Do not push your created tag to its remote. Prematurely creating and pushing a tag can lead to unpublishable tags.", "", "To create the tag, you can run:", "", "  git tag " + expectedTag])));
                                                }
                                                ;
                                                if (maybeCurrentTag instanceof Nothing) {
                                                  return bind75(listTags(Nothing.value))(function(v5) {
                                                    if (v5 instanceof Left) {
                                                      return die17(toDoc24([toDoc16("Cannot check whether publish config's `version` matches any existing git tags due to the below error:"), v5.value0]));
                                                    }
                                                    ;
                                                    if (v5 instanceof Right) {
                                                      var tagExists = any2(eq41(expectedTag))(v5.value0);
                                                      var emptyUnless = function(b) {
                                                        return function(xs) {
                                                          if (b) {
                                                            return [];
                                                          }
                                                          ;
                                                          return xs;
                                                        };
                                                      };
                                                      return discard40(when18(tagExists)(addError(toDoc33(["The expected tag (" + (expectedTag + ") has already been defined but is not checked out."), "The publish config's `version` may need to be bumped to a newer version if it currently refers to a version that has already been published."]))))(function() {
                                                        return addError(toDoc33(append212(["No git tag is currently checked out.", "Please fix all other publishing-related errors before resolving this one. Prematurely creating and pushing a tag may lead to unpublishable tags."])(emptyUnless(tagExists)(["To create the tag, you can run:", "", "  git tag " + expectedTag]))));
                                                      });
                                                    }
                                                    ;
                                                    throw new Error("Failed pattern match at Spago.Command.Publish (line 297, column 48 - line 320, column 32): " + [v5.constructor.name]);
                                                  });
                                                }
                                                ;
                                                throw new Error("Failed pattern match at Spago.Command.Publish (line 284, column 19 - line 320, column 32): " + [maybeCurrentTag.constructor.name]);
                                              });
                                            }
                                            ;
                                          }
                                          ;
                                          throw new Error("Failed pattern match at Spago.Command.Publish (line 268, column 37 - line 320, column 32): " + [v4.constructor.name]);
                                        }))(function() {
                                          return setResult({
                                            expectedVersion: v1["package"].publish.value0.version,
                                            publishingData: {
                                              name: v1["package"].name,
                                              location: new Just(v1["package"].publish.value0.location.value0),
                                              ref: expectedTag,
                                              compiler: v.purs.version,
                                              resolutions: buildPlan
                                            }
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Publish (line 157, column 27 - line 325, column 14): " + [v1["package"].publish.value0.location.constructor.name]);
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Publish (line 152, column 3 - line 325, column 14): " + [v1["package"].publish.constructor.name]);
                    }())(function() {
                      return bind75(liftEffect14(read(resultRef)))(function(result) {
                        if (result instanceof Left) {
                          return discard40(logError2(append125(bold(toDoc16("Your package " + (show215(strName) + (" is not ready for publishing yet, encountered " + (show310(length6(result.value0)) + function() {
                            var $198 = length6(result.value0) === 1;
                            if ($198) {
                              return " error:";
                            }
                            ;
                            return " errors:";
                          }()))))))($$break)))(function() {
                            return die$prime2(fromFoldable213(result.value0));
                          });
                        }
                        ;
                        if (result instanceof Right) {
                          return discard40(logInfo22("Passed preliminary checks."))(function() {
                            return discard40(bind75(pushTag(Nothing.value)(result.value0.expectedVersion))(function(v3) {
                              if (v3 instanceof Left) {
                                return die17(toDoc24([v3.value0, toDoc16("You can try to push the tag manually by running:"), toDoc16(""), toDoc16("  git push origin v" + print6(result.value0.expectedVersion))]));
                              }
                              ;
                              if (v3 instanceof Right) {
                                return pure92(unit);
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Command.Publish (line 344, column 47 - line 351, column 29): " + [v3.constructor.name]);
                            }))(function() {
                              return discard40(logInfo22("Building again with the build plan from the solver..."))(function() {
                                var buildPlanDependencies = map230(RegistryVersion.create)(result.value0.publishingData.resolutions);
                                return bind75(runBuild({
                                  selected: v1,
                                  dependencies: singleton10(v1["package"].name)({
                                    core: buildPlanDependencies,
                                    test: empty4
                                  })
                                })(run4({
                                  depsOnly: false,
                                  pursArgs: [],
                                  jsonErrors: false
                                })))(function(builtAgain) {
                                  return discard40(when18(!builtAgain)(liftEffect14(exit)))(function() {
                                    return discard40(logDebug18(unsafeStringify(result.value0.publishingData)))(function() {
                                      return discard40(logSuccess6("Ready for publishing. Calling the registry.."))(function() {
                                        var newPublishingData = {
                                          name: result.value0.publishingData.name,
                                          location: result.value0.publishingData.location,
                                          ref: result.value0.publishingData.ref,
                                          compiler: result.value0.publishingData.compiler,
                                          resolutions: new Just(result.value0.publishingData.resolutions)
                                        };
                                        return bind75(callRegistry(baseApi + print11(routes)(Publish.value))(jobCreatedResponseCodec)(new Just({
                                          codec: publishCodec,
                                          data: newPublishingData
                                        })))(function(v3) {
                                          return discard40(logSuccess6("Registry accepted the Publish request and is processing..."))(function() {
                                            return discard40(logDebug18("Job ID: " + unwrap23(v3.jobId)))(function() {
                                              return discard40(logInfo22("Logs from the Registry pipeline:"))(function() {
                                                return discard40(waitForJobFinish(v3.jobId))(function() {
                                                  return pure92(newPublishingData);
                                                });
                                              });
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Publish (line 328, column 3 - line 380, column 29): " + [result.constructor.name]);
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Registry/index.js
var discard41 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo11 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var show53 = /* @__PURE__ */ show(showString);
var bind76 = /* @__PURE__ */ bind(bindSpago);
var logError3 = /* @__PURE__ */ logError(monadEffectSpago)(monadAskSpago)(loggableString);
var map147 = /* @__PURE__ */ map(functorSpago);
var fromFoldable55 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableArray);
var $$for11 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var logWarn9 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var pure93 = /* @__PURE__ */ pure(applicativeSpago);
var output5 = /* @__PURE__ */ output(monadEffectSpago);
var object14 = /* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "version";
  }
}))()()({
  reflectSymbol: function() {
    return "publishedTime";
  }
}));
var map148 = /* @__PURE__ */ map(functorArray);
var toUnfoldable34 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var fromFoldable119 = /* @__PURE__ */ fromFoldable(foldableList);
var foldl19 = /* @__PURE__ */ foldl(foldableArray);
var lookup19 = /* @__PURE__ */ lookup3(ordVersion);
var insert20 = /* @__PURE__ */ insert2(ordVersion);
var greaterThan6 = /* @__PURE__ */ greaterThan(ordVersion);
var bottom4 = /* @__PURE__ */ bottom(boundedTime);
var die18 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die19 = /* @__PURE__ */ die18(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc9 = /* @__PURE__ */ toDoc2(loggableString);
var logDebug19 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var die27 = /* @__PURE__ */ die18(loggableString);
var search = function(v) {
  return discard41(logInfo11("Searching for " + (show53(v["package"]) + " in the Registry package names...")))(function() {
    return bind76(listMetadataFiles)(function(metadataFiles) {
      var matches = filter(contains(v["package"]))(mapMaybe(stripSuffix(".json"))(metadataFiles));
      var $64 = $$null(matches);
      if ($64) {
        return logError3("Did not find any packages matching the search string.");
      }
      ;
      return bind76(map147(function($107) {
        return fromFoldable55(catMaybes($107));
      })($$for11(matches)(function(match5) {
        var v1 = parse3(match5);
        if (v1 instanceof Left) {
          return discard41(logWarn9("Couldn't parse package name: " + v1.value0))(function() {
            return pure93(Nothing.value);
          });
        }
        ;
        if (v1 instanceof Right) {
          return bind76(getMetadata(v1.value0))(function(v2) {
            if (v2 instanceof Left) {
              return discard41(logWarn9("Couldn't read metadata for pacakge " + (print5(v1.value0) + (", error: " + v2.value0))))(function() {
                return pure93(Nothing.value);
              });
            }
            ;
            if (v2 instanceof Right) {
              return pure93(new Just(function() {
                var v3 = findMax(v2.value0.published);
                if (v3 instanceof Nothing) {
                  return new Tuple(v1.value0, {
                    version: Nothing.value,
                    publishedTime: Nothing.value
                  });
                }
                ;
                if (v3 instanceof Just) {
                  return new Tuple(v1.value0, {
                    version: new Just(v3.value0.key),
                    publishedTime: new Just(v3.value0.value.publishedTime)
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Registry (line 48, column 48 - line 50, column 140): " + [v3.constructor.name]);
              }()));
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Registry (line 44, column 65 - line 50, column 140): " + [v2.constructor.name]);
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Registry (line 40, column 81 - line 50, column 140): " + [v1.constructor.name]);
      })))(function(infos) {
        return discard41(logInfo11("Use `spago registry info $package` to get more details on a package."))(function() {
          return output5(function() {
            if (v.json) {
              var infoDataCodec = named("InfoData")(object14({
                publishedTime: optional4(iso8601DateTime2),
                version: optional4(codec3)
              }));
              return new OutputJson(packageMap(infoDataCodec), infos);
            }
            ;
            if (!v.json) {
              return new OutputTable({
                titles: ["NAME", "VERSION", "PUBLISHED TIME"],
                rows: map148(function(v1) {
                  return [print5(v1.value0), maybe("-")(print6)(v1.value1.version), maybe("-")(format(iso8601DateTime))(v1.value1.publishedTime)];
                })(toUnfoldable34(infos))
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Registry (line 54, column 14 - line 70, column 10): " + [v.json.constructor.name]);
          }());
        });
      });
    });
  });
};
var packageSets = function(v) {
  return bind76(listPackageSets)(function(availableSets) {
    var sets = function() {
      if (!v.latest) {
        return availableSets;
      }
      ;
      if (v.latest) {
        return fromFoldable119(values(foldl19(function(acc) {
          return function(newSet) {
            var v1 = lookup19(newSet.compiler)(acc);
            if (v1 instanceof Nothing) {
              return insert20(newSet.compiler)(newSet)(acc);
            }
            ;
            if (v1 instanceof Just) {
              var v2 = greaterThan6(newSet.version)(v1.value0.version);
              if (v2) {
                return insert20(newSet.compiler)(newSet)(acc);
              }
              ;
              if (!v2) {
                return acc;
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Registry (line 113, column 39 - line 115, column 33): " + [v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Registry (line 111, column 32 - line 115, column 33): " + [v1.constructor.name]);
          };
        })(empty4)(availableSets)));
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Registry (line 103, column 12 - line 118, column 28): " + [v.latest.constructor.name]);
    }();
    return output5(function() {
      if (v.json) {
        return new OutputJson(array(packageSetCodec2), sets);
      }
      ;
      if (!v.json) {
        return new OutputTable({
          titles: ["VERSION", "DATE", "COMPILER"],
          rows: map148(function(v1) {
            return [print6(v1.version), format(iso8601Date)(new DateTime(v1.date, bottom4)), print6(v1.compiler)];
          })(sets)
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Registry (line 120, column 10 - line 129, column 8): " + [v.json.constructor.name]);
    }());
  });
};
var info3 = function(v) {
  return bind76(function() {
    var v1 = parse3(v["package"]);
    if (v1 instanceof Left) {
      return die19([toDoc9("Could not parse package name, error:"), indent(toDoc9(show53(v1.value0)))]);
    }
    ;
    if (v1 instanceof Right) {
      return pure93(v1.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Registry (line 79, column 18 - line 81, column 28): " + [v1.constructor.name]);
  }())(function(packageName) {
    return bind76(getMetadata(packageName))(function(v1) {
      if (v1 instanceof Left) {
        return discard41(logDebug19(v1.value0))(function() {
          return die27("Could not find package " + print5(packageName));
        });
      }
      ;
      if (v1 instanceof Right) {
        return output5(function() {
          if (v.json) {
            return new OutputJson(codec10, v1.value0);
          }
          ;
          if (!v.json) {
            return new OutputYaml(codec10, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Registry (line 89, column 14 - line 91, column 48): " + [v.json.constructor.name]);
        }());
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Registry (line 83, column 40 - line 91, column 48): " + [v1.constructor.name]);
    });
  });
};

// output/Spago.Command.Repl/index.js
var discard42 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var unlessM5 = /* @__PURE__ */ unlessM(monadSpago);
var exists11 = /* @__PURE__ */ exists2(monadEffectSpago);
var writeTextFile6 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var unionWith5 = /* @__PURE__ */ unionWith(ordPackageName);
var $$void21 = /* @__PURE__ */ $$void(functorSpago);
var run10 = /* @__PURE__ */ bind(bindSpago)(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  return discard42(unlessM5(exists11(pursReplFile.name))(writeTextFile6(pursReplFile.name)(pursReplFile.content)))(function() {
    var allDependencies = unionWith5(function(l) {
      return function(v1) {
        return l;
      };
    })(v.supportPackage)(toAllDependencies(v.dependencies));
    var globs = getBuildGlobs({
      selected: v.selected,
      dependencies: allDependencies,
      depsOnly: v.depsOnly,
      withTests: true
    });
    return $$void21(repl(globs)(v.pursArgs));
  });
});

// output/Spago.Command.Run/index.js
var bind77 = /* @__PURE__ */ bind(bindSpago);
var discard43 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug20 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var mkdirp5 = /* @__PURE__ */ mkdirp(monadAffSpago);
var liftEffect15 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var fold25 = /* @__PURE__ */ fold2(monoidString);
var append47 = /* @__PURE__ */ append(semigroupArray);
var logWarn10 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var when19 = /* @__PURE__ */ when(applicativeSpago);
var lookup20 = /* @__PURE__ */ lookup3(ordString);
var die20 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die110 = /* @__PURE__ */ die20(/* @__PURE__ */ loggableArray(loggableString));
var show54 = /* @__PURE__ */ show(showString);
var writeTextFile7 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var chmod5 = /* @__PURE__ */ chmod4(monadAffSpago);
var showArray3 = /* @__PURE__ */ showArray(showString);
var show120 = /* @__PURE__ */ show(showArray3);
var exec10 = /* @__PURE__ */ exec5(monadAffSpago);
var logSuccess7 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var pure94 = /* @__PURE__ */ pure(applicativeSpago);
var die28 = /* @__PURE__ */ die20(loggableString);
var show216 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "args";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "cmd";
  }
})(showString))(/* @__PURE__ */ showMaybe(showArray3))));
var run11 = /* @__PURE__ */ bind77(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  var execOptions = {
    cwd: defaultExecOptions.cwd,
    pipeStderr: defaultExecOptions.pipeStderr,
    pipeStdout: defaultExecOptions.pipeStdout,
    pipeStdin: StdinPipeParent.value
  };
  if (v.workspace.backend instanceof Nothing) {
    return discard43(logDebug20("Running with backend: nodejs"))(function() {
      var runDir = concat3([localCachePath, "run"]);
      return discard43(mkdirp5(runDir))(function() {
        return bind77(liftEffect15(resolve([])(fromMaybe("output")(v.workspace.buildOptions.output))))(function(absOutput) {
          var runJsPath = concat3([runDir, "run.js"]);
          var packageJsonPath = concat3([runDir, "package.json"]);
          var nodeContents = fold25(["import { main } from 'file://", withForwardSlashes(absOutput), "/", v.runOptions.moduleName, "/", "index.js", "'\n\n", "main()"]);
          var nodeArgs = append47([runJsPath])(v.runOptions.execArgs);
          var globs = getBuildGlobs({
            dependencies: toAllDependencies(v.dependencies),
            depsOnly: false,
            withTests: true,
            selected: singleton4(v.selected)
          });
          return discard43(bind77(graph(globs)([]))(function(v1) {
            if (v1 instanceof Left) {
              return logWarn10("Could not decode the output of `purs graph`, error: " + print3(v1.value0));
            }
            ;
            if (v1 instanceof Right) {
              return when19(isNothing(lookup20(v.runOptions.moduleName)(v1.value0)))(die110([v.runOptions.failureMessage, "Module " + (v.runOptions.moduleName + " not found! Are you including it in your build?")]));
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Run (line 106, column 31 - line 110, column 123): " + [v1.constructor.name]);
          }))(function() {
            return discard43(logDebug20("Writing " + show54(runJsPath)))(function() {
              return discard43(writeTextFile7(runJsPath)(nodeContents))(function() {
                return discard43(chmod5(runJsPath)(mkPerms(all4)(all4)(all4)))(function() {
                  return discard43(logDebug20("Writing " + show54(packageJsonPath)))(function() {
                    return discard43(writeTextFile7(packageJsonPath)('{"type":"module" }'))(function() {
                      return discard43(logDebug20("Executing from: " + show54(v.runOptions.executeDir)))(function() {
                        return discard43(logDebug20("Running node command with args: `" + (show120(nodeArgs) + "`")))(function() {
                          return bind77(exec10(v.node.cmd)(nodeArgs)({
                            pipeStdin: execOptions.pipeStdin,
                            pipeStdout: execOptions.pipeStdout,
                            pipeStderr: execOptions.pipeStderr,
                            cwd: new Just(v.runOptions.executeDir)
                          }))(function(v1) {
                            if (v1 instanceof Right) {
                              if (v.runOptions.successMessage instanceof Just) {
                                return logSuccess7(v.runOptions.successMessage.value0);
                              }
                              ;
                              if (v.runOptions.successMessage instanceof Nothing) {
                                return pure94(unit);
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Command.Run (line 120, column 20 - line 122, column 31): " + [v.runOptions.successMessage.constructor.name]);
                            }
                            ;
                            if (v1 instanceof Left) {
                              return discard43(logDebug20(printExecResult(v1.value0)))(function() {
                                return die28(v.runOptions.failureMessage);
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Run (line 119, column 83 - line 125, column 34): " + [v1.constructor.name]);
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  }
  ;
  if (v.workspace.backend instanceof Just) {
    var args = append47(["--run", v.runOptions.moduleName + ".main"])(v.runOptions.execArgs);
    return discard43(logDebug20("Running command `" + (v.workspace.backend.value0.cmd + (" " + (show120(args) + "`")))))(function() {
      return bind77(exec10(v.workspace.backend.value0.cmd)(args)(execOptions))(function(v1) {
        if (v1 instanceof Right) {
          if (v.runOptions.successMessage instanceof Just) {
            return logSuccess7(v.runOptions.successMessage.value0);
          }
          ;
          if (v.runOptions.successMessage instanceof Nothing) {
            return pure94(unit);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Run (line 130, column 20 - line 132, column 31): " + [v.runOptions.successMessage.constructor.name]);
        }
        ;
        if (v1 instanceof Left) {
          return discard43(logDebug20(printExecResult(v1.value0)))(function() {
            return die110([v.runOptions.failureMessage, "Backend " + (show216(v.workspace.backend.value0) + (" exited with error:" + v1.value0.shortMessage))]);
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Run (line 129, column 49 - line 135, column 109): " + [v1.constructor.name]);
      });
    });
  }
  ;
  throw new Error("Failed pattern match at Spago.Command.Run (line 72, column 3 - line 135, column 109): " + [v.workspace.backend.constructor.name]);
});
var nodeVersion = /* @__PURE__ */ function() {
  return bind77(exec10("node")(["--version"])({
    pipeStdin: defaultExecOptions.pipeStdin,
    cwd: defaultExecOptions.cwd,
    pipeStdout: false,
    pipeStderr: false
  }))(function(v) {
    if (v instanceof Left) {
      return discard43(logDebug20(printExecResult(v.value0)))(function() {
        return die110(["Failed to find node. Have you installed it, and is it in your PATH?"]);
      });
    }
    ;
    if (v instanceof Right) {
      var v1 = parseLenientVersion(v.value0.stdout);
      if (v1 instanceof Left) {
        return die28("Failed to parse NodeJS version. Was: " + v.value0.stdout);
      }
      ;
      if (v1 instanceof Right) {
        var $79 = major(v1.value0) >= 13;
        if ($79) {
          return pure94(v1.value0);
        }
        ;
        return die110(["Unsupported Node version " + print6(v1.value0), "Please install a Node v13 or higher."]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Run (line 54, column 16 - line 60, column 105): " + [v1.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Run (line 50, column 105 - line 60, column 105): " + [v.constructor.name]);
  });
}();
var getNode = /* @__PURE__ */ bind77(nodeVersion)(function(version4) {
  return pure94({
    cmd: "node",
    version: version4
  });
});

// output/Spago.Command.Sources/index.js
var bind78 = /* @__PURE__ */ bind(bindSpago);
var ask16 = /* @__PURE__ */ ask(monadAskSpago);
var traverse11 = /* @__PURE__ */ traverse(traversableMap)(applicativeSpago);
var fromFoldable56 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableNonEmptyArray);
var map149 = /* @__PURE__ */ map(functorNonEmptyArray);
var union14 = /* @__PURE__ */ union2(ordPackageName);
var foldMap31 = /* @__PURE__ */ foldMap2(monoidArray);
var toUnfoldable35 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var output6 = /* @__PURE__ */ output(monadEffectSpago);
var run12 = function(v) {
  return bind78(ask16)(function(v1) {
    var selectedPackages = function() {
      if (v1.workspace.selected instanceof Just) {
        return singleton4(v1.workspace.selected.value0);
      }
      ;
      if (v1.workspace.selected instanceof Nothing) {
        return getWorkspacePackages(v1.workspace.packageSet);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Sources (line 21, column 24 - line 23, column 66): " + [v1.workspace.selected.constructor.name]);
    }();
    return bind78(traverse11(getTransitiveDeps)(fromFoldable56(map149(function(p) {
      return new Tuple(p["package"].name, p);
    })(selectedPackages))))(function(transitiveDeps) {
      var transitivePackages = union14(fromFoldable56(map149(function(p) {
        return new Tuple(p["package"].name, new WorkspacePackage(p));
      })(selectedPackages)))(toAllDependencies(transitiveDeps));
      var globs = foldMap31(function(v2) {
        return sourceGlob(WithTestGlobs.value)(v2.value0)(v2.value1);
      })(toUnfoldable35(transitivePackages));
      return output6(function() {
        if (v.json) {
          return new OutputJson(array(string), globs);
        }
        ;
        if (!v.json) {
          return new OutputLines(globs);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Sources (line 36, column 10 - line 38, column 31): " + [v.json.constructor.name]);
      }());
    });
  });
};

// output/Spago.Command.Test/index.js
var $$void22 = /* @__PURE__ */ $$void(functorSpago);
var $$for12 = /* @__PURE__ */ $$for(applicativeSpago)(traversableNonEmptyArray);
var discard44 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo12 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var runSpago8 = /* @__PURE__ */ runSpago(monadAffSpago);
var run13 = /* @__PURE__ */ bind(bindSpago)(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  return $$void22($$for12(v.selectedPackages)(function(v1) {
    var runOptions = {
      successMessage: new Just('Test succeeded for package "' + (print5(v1["selected"]["package"].name) + '".')),
      failureMessage: 'Tests failed for package "' + (print5(v1["selected"]["package"].name) + '".'),
      executeDir: cwd2,
      execArgs: v1.execArgs,
      moduleName: v1.moduleName
    };
    var runEnv = {
      logOptions: v.logOptions,
      workspace: v.workspace,
      selected: v1.selected,
      node: v.node,
      runOptions,
      dependencies: v.dependencies,
      purs: v.purs
    };
    return discard44(logInfo12("Running tests for package: " + print5(v1["selected"]["package"].name)))(function() {
      return runSpago8(runEnv)(run11);
    });
  }));
});

// output/Spago.Command.Uninstall/index.js
var bind79 = /* @__PURE__ */ bind(bindSpago);
var ask17 = /* @__PURE__ */ ask(monadAskSpago);
var traverse12 = /* @__PURE__ */ traverse(traversableMap)(applicativeSpago);
var fromFoldable57 = /* @__PURE__ */ fromFoldable7(ordPackageName)(foldableNonEmptyArray);
var map150 = /* @__PURE__ */ map(functorNonEmptyArray);
var discard45 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logWarn11 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago);
var logWarn12 = /* @__PURE__ */ logWarn11(loggableString);
var liftEffect16 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var pure95 = /* @__PURE__ */ pure(applicativeSpago);
var member13 = /* @__PURE__ */ member(ordPackageName);
var unwrap24 = /* @__PURE__ */ unwrap();
var insert21 = /* @__PURE__ */ insert3(ordPackageName);
var foldl20 = /* @__PURE__ */ foldl(foldableSet);
var mempty30 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidSet(ordPackageName));
var logInfo13 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var map151 = /* @__PURE__ */ map(functorArray);
var fromFoldable120 = /* @__PURE__ */ fromFoldable(foldableNonEmptyArray);
var logDebug21 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var fromFoldable1110 = /* @__PURE__ */ fromFoldable12(foldable1NonEmptyArray)(ordPackageName);
var liftAff11 = /* @__PURE__ */ liftAff(monadAffSpago);
var die21 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var fromFoldable214 = /* @__PURE__ */ fromFoldable2(foldableSet);
var wrap7 = /* @__PURE__ */ wrap();
var filterKeys6 = /* @__PURE__ */ filterKeys(ordPackageName);
var member14 = /* @__PURE__ */ member2(ordPackageName);
var fromFoldable311 = /* @__PURE__ */ fromFoldable(foldableSet);
var for_11 = /* @__PURE__ */ for_(applicativeSpago)(foldableMaybe);
var logWarn23 = /* @__PURE__ */ logWarn11(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc10 = /* @__PURE__ */ toDoc2(loggableString);
var $$void23 = /* @__PURE__ */ $$void(functorSpago);
var justOrDieWith3 = /* @__PURE__ */ justOrDieWith(monadEffectSpago)(monadAskSpago)(loggableString);
var eq45 = /* @__PURE__ */ eq(eqPackageName);
var map231 = /* @__PURE__ */ map(functorMaybe);
var insert110 = /* @__PURE__ */ insert2(ordPackageName);
var local3 = /* @__PURE__ */ local(monadReaderSpago);
var run14 = function(args) {
  var writeNewLockfile2 = function(reason) {
    return bind79(ask17)(function(v) {
      return bind79(traverse12(getTransitiveDeps)(fromFoldable57(map150(function(p) {
        return new Tuple(p["package"].name, p);
      })(getWorkspacePackages(v.workspace.packageSet)))))(function(dependencies) {
        return writeNewLockfile(reason)(dependencies);
      });
    });
  };
  var toContext = function(configPath) {
    return function(yamlDoc) {
      return function(pkgConfig) {
        if (args.testDeps) {
          if (pkgConfig.test instanceof Nothing) {
            return discard45(logWarn12("Could not uninstall test dependencies for " + (print5(pkgConfig.name) + " because it does not have a test configuration.")))(function() {
              return liftEffect16(exit$prime(0));
            });
          }
          ;
          if (pkgConfig.test instanceof Just) {
            return pure95({
              name: pkgConfig.name,
              deps: pkgConfig.test.value0.dependencies,
              sourceOrTestString: "test",
              yamlDoc,
              configPath
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Uninstall (line 94, column 13 - line 104, column 10): " + [pkgConfig.test.constructor.name]);
        }
        ;
        if (!args.testDeps) {
          return pure95({
            name: pkgConfig.name,
            deps: pkgConfig.dependencies,
            sourceOrTestString: "source",
            yamlDoc,
            configPath
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Uninstall (line 93, column 44 - line 111, column 8): " + [args.testDeps.constructor.name]);
      };
    };
  };
  var separate2 = function(deps) {
    var f = function(acc) {
      return function(next2) {
        var v = member13(next2)(unwrap24(deps));
        if (v) {
          return {
            warn: acc.warn,
            removed: insert21(next2)(acc.removed)
          };
        }
        ;
        if (!v) {
          return {
            removed: acc.removed,
            warn: insert21(next2)(acc.warn)
          };
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Uninstall (line 117, column 18 - line 119, column 55): " + [v.constructor.name]);
      };
    };
    return foldl20(f)({
      warn: mempty30,
      removed: mempty30
    })(args.dependenciesToRemove);
  };
  var modifyConfig = function(configPath) {
    return function(yamlDoc) {
      return function(sourceOrTestString) {
        return function(removedPackages) {
          return discard45(logInfo13("Removing the following " + (sourceOrTestString + (" dependencies: " + joinWith(", ")(map151(print5)(fromFoldable120(removedPackages)))))))(function() {
            return discard45(logDebug21("Editing config file at path: " + configPath))(function() {
              return discard45(liftEffect16(removePackagesFromConfig(yamlDoc)(args.testDeps)(fromFoldable1110(removedPackages))))(function() {
                return liftAff11(writeYamlDocFile(configPath)(yamlDoc));
              });
            });
          });
        };
      };
    };
  };
  return discard45(logDebug21("Running `spago uninstall`"))(function() {
    return bind79(ask17)(function(v) {
      return bind79(function() {
        if (v.workspace.selected instanceof Just) {
          return toContext(concat3([v.workspace.selected.value0.path, "spago.yaml"]))(v.workspace.selected.value0.doc)(v["workspace"]["selected"]["value0"]["package"]);
        }
        ;
        if (v.workspace.selected instanceof Nothing && v.workspace.rootPackage instanceof Just) {
          return toContext("spago.yaml")(v.workspace.doc)(v.workspace.rootPackage.value0);
        }
        ;
        if (v.workspace.selected instanceof Nothing && v.workspace.rootPackage instanceof Nothing) {
          return die21("No package was selected. Please select a package.");
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Uninstall (line 35, column 62 - line 38, column 80): " + [v.workspace.selected.constructor.name, v.workspace.rootPackage.constructor.name]);
      }())(function(v1) {
        var v2 = separate2(v1.deps);
        var warnAbout = fromFoldable214(v2.warn);
        var removed = fromFoldable214(v2.removed);
        var newDeps = wrap7(filterKeys6(function() {
          var $106 = flip(member14)(v2.removed);
          return function($107) {
            return !$106($107);
          };
        }())(unwrap24(v1.deps)));
        var modifyDoc = modifyConfig(v1.configPath)(v1.yamlDoc)(v1.sourceOrTestString);
        return discard45(logDebug21("Existing " + (v1.sourceOrTestString + (" dependencies are: " + joinWith(", ")(map151(print5)(fromFoldable311(keys3(unwrap24(v1.deps)))))))))(function() {
          return discard45(for_11(warnAbout)(function(undeclaredPkgs) {
            return logWarn23([toDoc10("The following packages cannot be uninstalled because they are not declared in the package's " + (v1.sourceOrTestString + " dependencies:")), indent22(toDoc10(joinWith(", ")(fromFoldable120(map150(print5)(undeclaredPkgs)))))]);
          }))(function() {
            if (removed instanceof Nothing) {
              return discard45(logWarn12("The package config for " + (print5(v1.name) + " was not updated.")))(function() {
                if (v.workspace.packageSet.lockfile instanceof Right) {
                  return pure95(unit);
                }
                ;
                if (v.workspace.packageSet.lockfile instanceof Left) {
                  return $$void23(writeNewLockfile2(v.workspace.packageSet.lockfile.value0));
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Uninstall (line 57, column 7 - line 59, column 54): " + [v.workspace.packageSet.lockfile.constructor.name]);
              });
            }
            ;
            if (removed instanceof Just) {
              return discard45(modifyDoc(removed.value0))(function() {
                return bind79(justOrDieWith3(find3(function(p) {
                  return eq45(p["package"].name)(v1.name);
                })(getWorkspacePackages(v.workspace.packageSet)))("Impossible: package must be in workspace packages"))(function(currentWorkspacePackage) {
                  var newWorkspacePackage = function() {
                    if (!args.testDeps) {
                      return {
                        doc: currentWorkspacePackage.doc,
                        hasTests: currentWorkspacePackage.hasTests,
                        path: currentWorkspacePackage.path,
                        "package": {
                          build: currentWorkspacePackage["package"].build,
                          bundle: currentWorkspacePackage["package"].bundle,
                          description: currentWorkspacePackage["package"].description,
                          name: currentWorkspacePackage["package"].name,
                          publish: currentWorkspacePackage["package"].publish,
                          run: currentWorkspacePackage["package"].run,
                          test: currentWorkspacePackage["package"].test,
                          dependencies: newDeps
                        }
                      };
                    }
                    ;
                    if (args.testDeps) {
                      return {
                        doc: currentWorkspacePackage.doc,
                        hasTests: currentWorkspacePackage.hasTests,
                        path: currentWorkspacePackage.path,
                        "package": {
                          build: currentWorkspacePackage["package"].build,
                          bundle: currentWorkspacePackage["package"].bundle,
                          dependencies: currentWorkspacePackage["package"].dependencies,
                          description: currentWorkspacePackage["package"].description,
                          name: currentWorkspacePackage["package"].name,
                          publish: currentWorkspacePackage["package"].publish,
                          run: currentWorkspacePackage["package"].run,
                          test: map231(function(t) {
                            return {
                              censorTestWarnings: t.censorTestWarnings,
                              execArgs: t.execArgs,
                              main: t.main,
                              pedanticPackages: t.pedanticPackages,
                              strict: t.strict,
                              dependencies: newDeps
                            };
                          })(currentWorkspacePackage["package"].test)
                        }
                      };
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Uninstall (line 65, column 31 - line 67, column 145): " + [args.testDeps.constructor.name]);
                  }();
                  var newWorkspace = function() {
                    var $91 = {};
                    for (var $92 in v.workspace) {
                      if ({}.hasOwnProperty.call(v.workspace, $92)) {
                        $91[$92] = v["workspace"][$92];
                      }
                      ;
                    }
                    ;
                    $91.packageSet = {
                      lockfile: new Left("Lockfile is out of date (installing new packages)"),
                      buildType: function() {
                        if (v.workspace.packageSet.buildType instanceof RegistrySolverBuild) {
                          return new RegistrySolverBuild(insert110(newWorkspacePackage["package"].name)(new WorkspacePackage(newWorkspacePackage))(v.workspace.packageSet.buildType.value0));
                        }
                        ;
                        if (v.workspace.packageSet.buildType instanceof PackageSetBuild) {
                          return new PackageSetBuild(v.workspace.packageSet.buildType.value0, insert110(newWorkspacePackage["package"].name)(new WorkspacePackage(newWorkspacePackage))(v.workspace.packageSet.buildType.value1));
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Uninstall (line 73, column 29 - line 75, column 170): " + [v.workspace.packageSet.buildType.constructor.name]);
                      }()
                    };
                    $91.selected = new Just(newWorkspacePackage);
                    return $91;
                  }();
                  return local3(function(v3) {
                    var $94 = {};
                    for (var $95 in v3) {
                      if ({}.hasOwnProperty.call(v3, $95)) {
                        $94[$95] = v3[$95];
                      }
                      ;
                    }
                    ;
                    $94.workspace = newWorkspace;
                    return $94;
                  })($$void23(writeNewLockfile2("Lockfile is out of date (uninstalled packages)")));
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Uninstall (line 53, column 3 - line 81, column 81): " + [removed.constructor.name]);
          });
        });
      });
    });
  });
};

// output/Spago.Command.Upgrade/index.js
var bind80 = /* @__PURE__ */ bind(bindSpago);
var ask18 = /* @__PURE__ */ ask(monadAskSpago);
var lessThanOrEq2 = /* @__PURE__ */ lessThanOrEq(ordVersion);
var logSuccess8 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var discard46 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo14 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var setPackageSetVersionInConfig2 = /* @__PURE__ */ setPackageSetVersionInConfig(monadAffSpago)(monadEffectSpago);
var die29 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var run15 = function(args) {
  return bind80(ask18)(function(v) {
    if (v.workspace.workspaceConfig.packageSet instanceof Just && v.workspace.workspaceConfig.packageSet.value0 instanceof SetFromRegistry) {
      return bind80(findPackageSet(args.setVersion))(function(latestPackageSet) {
        var whichVersion = maybe("latest")($$const("specified"))(args.setVersion);
        var v1 = lessThanOrEq2(latestPackageSet)(v.workspace.workspaceConfig.packageSet.value0.value0.registry);
        if (v1) {
          return logSuccess8("Nothing to upgrade, you already have the " + (whichVersion + " package set."));
        }
        ;
        if (!v1) {
          return discard46(logInfo14("Upgrading the package set to the " + (whichVersion + (" version: " + print6(latestPackageSet)))))(function() {
            return discard46(setPackageSetVersionInConfig2(v.workspace.doc)(latestPackageSet))(function() {
              return logSuccess8("Upgrade successful!");
            });
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Upgrade (line 24, column 7 - line 29, column 43): " + [v1.constructor.name]);
      });
    }
    ;
    if (v.workspace.workspaceConfig.packageSet instanceof Just) {
      return die29("This command is not yet implemented for projects using a custom package set.");
    }
    ;
    if (v.workspace.workspaceConfig.packageSet instanceof Nothing) {
      return die29("This command is not yet implemented for projects using a solver. See https://github.com/purescript/spago/issues/1001");
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Upgrade (line 18, column 3 - line 31, column 138): " + [v.workspace.workspaceConfig.packageSet.constructor.name]);
  });
};

// output/Spago.Esbuild/index.js
var pure96 = /* @__PURE__ */ pure(applicativeSpago);
var getEsbuild = /* @__PURE__ */ bind(bindSpago)(/* @__PURE__ */ getExecutable("esbuild"))(function(v) {
  return pure96({
    cmd: v.cmd,
    version: v.output
  });
});

// output/Main/index.js
var fromRecord3 = /* @__PURE__ */ fromRecord();
var buildArgsCons2 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "setVersion";
  }
})()()();
var selectedPackageIsSymbol = {
  reflectSymbol: function() {
    return "selectedPackage";
  }
};
var buildArgsCons1 = /* @__PURE__ */ buildArgsCons(selectedPackageIsSymbol)()()();
var buildArgsCons22 = /* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "testDeps";
  }
})()()()(buildRecordArgsNil));
var backendArgsIsSymbol = {
  reflectSymbol: function() {
    return "backendArgs";
  }
};
var buildArgsCons3 = /* @__PURE__ */ buildArgsCons(backendArgsIsSymbol)()()();
var execArgsIsSymbol = {
  reflectSymbol: function() {
    return "execArgs";
  }
};
var mainIsSymbol3 = {
  reflectSymbol: function() {
    return "main";
  }
};
var outputIsSymbol = {
  reflectSymbol: function() {
    return "output";
  }
};
var buildArgsCons4 = /* @__PURE__ */ buildArgsCons(outputIsSymbol)()()();
var pedanticPackagesIsSymbol = {
  reflectSymbol: function() {
    return "pedanticPackages";
  }
};
var buildArgsCons5 = /* @__PURE__ */ buildArgsCons(pedanticPackagesIsSymbol)()()();
var pureIsSymbol = {
  reflectSymbol: function() {
    return "pure";
  }
};
var buildArgsCons6 = /* @__PURE__ */ buildArgsCons(pureIsSymbol)()()();
var pursArgsIsSymbol = {
  reflectSymbol: function() {
    return "pursArgs";
  }
};
var buildArgsCons7 = /* @__PURE__ */ buildArgsCons(pursArgsIsSymbol)()()();
var statVerbosityIsSymbol = {
  reflectSymbol: function() {
    return "statVerbosity";
  }
};
var buildArgsCons8 = /* @__PURE__ */ buildArgsCons(statVerbosityIsSymbol)()()();
var strictIsSymbol = {
  reflectSymbol: function() {
    return "strict";
  }
};
var buildArgsCons9 = /* @__PURE__ */ buildArgsCons(strictIsSymbol)()()();
var buildArgsCons10 = /* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons7(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons8(/* @__PURE__ */ buildArgsCons9(buildRecordArgsNil)))))));
var buildArgsCons11 = /* @__PURE__ */ buildArgsCons(execArgsIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(mainIsSymbol3)()()()(buildArgsCons10));
var buildArgsCons12 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "json";
  }
})()()();
var buildArgsCons13 = /* @__PURE__ */ buildArgsCons1(buildRecordArgsNil);
var ensureRangesIsSymbol = {
  reflectSymbol: function() {
    return "ensureRanges";
  }
};
var buildArgsCons14 = /* @__PURE__ */ buildArgsCons(ensureRangesIsSymbol)()()();
var fromRecord12 = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "package";
  }
})()()()(buildRecordArgsNil)));
var bind81 = /* @__PURE__ */ bind(bindSpago);
var ask19 = /* @__PURE__ */ ask(monadAskSpago);
var discard47 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug27 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug110 = /* @__PURE__ */ logDebug27(loggableString);
var showRecord3 = /* @__PURE__ */ showRecord()();
var showRecordFieldsCons3 = /* @__PURE__ */ showRecordFieldsCons(backendArgsIsSymbol);
var showRecordFieldsCons1 = /* @__PURE__ */ showRecordFieldsCons(outputIsSymbol);
var showRecordFieldsCons22 = /* @__PURE__ */ showRecordFieldsCons(pedanticPackagesIsSymbol);
var showRecordFieldsCons32 = /* @__PURE__ */ showRecordFieldsCons(pureIsSymbol);
var showRecordFieldsCons4 = /* @__PURE__ */ showRecordFieldsCons(pursArgsIsSymbol);
var showRecordFieldsCons5 = /* @__PURE__ */ showRecordFieldsCons(selectedPackageIsSymbol);
var showRecordFieldsCons6 = /* @__PURE__ */ showRecordFieldsCons(statVerbosityIsSymbol);
var showMaybe2 = /* @__PURE__ */ showMaybe(showBoolean);
var showMaybe1 = /* @__PURE__ */ showMaybe(showStatVerbosity);
var showMaybe22 = /* @__PURE__ */ showMaybe(showString);
var showList3 = /* @__PURE__ */ showList(showString);
var showRecordFieldsCons7 = /* @__PURE__ */ showRecordFieldsCons(execArgsIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(mainIsSymbol3)(/* @__PURE__ */ showRecordFieldsCons1(/* @__PURE__ */ showRecordFieldsCons22(/* @__PURE__ */ showRecordFieldsCons32(/* @__PURE__ */ showRecordFieldsCons4(/* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons6(/* @__PURE__ */ showRecordFieldsConsNil(strictIsSymbol)(showMaybe2))(showMaybe1))(showMaybe22))(showList3))(showBoolean))(showBoolean))(showMaybe22))(showMaybe22))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showArray(showString)));
var show55 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(showRecordFieldsCons7)(showList3)));
var bind127 = /* @__PURE__ */ bind(bindMaybe);
var alt39 = /* @__PURE__ */ alt(altMaybe);
var pure97 = /* @__PURE__ */ pure(applicativeSpago);
var map152 = /* @__PURE__ */ map(functorNonEmptyArray);
var die30 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die111 = /* @__PURE__ */ die30(loggableString);
var showRecordFieldsCons8 = /* @__PURE__ */ showRecordFieldsCons(ensureRangesIsSymbol);
var show121 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons8(showRecordFieldsCons7)(showBoolean))(showList3)));
var die210 = /* @__PURE__ */ die30(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc11 = /* @__PURE__ */ toDoc2(loggableString);
var toDoc17 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableNonEmptyArray(loggablePackageName));
var show217 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons4(/* @__PURE__ */ showRecordFieldsConsNil(selectedPackageIsSymbol)(showMaybe22))(showList3))(showList3)));
var fromFoldable58 = /* @__PURE__ */ fromFoldable(foldableList);
var mkdirp6 = /* @__PURE__ */ mkdirp(monadAffSpago);
var show311 = /* @__PURE__ */ show(showString);
var liftEffect17 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var logDebug28 = /* @__PURE__ */ logDebug(/* @__PURE__ */ monadEffectReader(monadEffectEffect))(/* @__PURE__ */ monadAskReaderT(monadEffect))(loggableString);
var liftAff12 = /* @__PURE__ */ liftAff(monadAffSpago);
var union15 = /* @__PURE__ */ union5();
var partitionMap4 = /* @__PURE__ */ partitionMap(filterableArray);
var unless9 = /* @__PURE__ */ unless(applicativeSpago);
var append126 = /* @__PURE__ */ append(semigroupArray);
var map153 = /* @__PURE__ */ map(functorArray);
var $$for13 = /* @__PURE__ */ $$for(applicativeSpago)(traversableMaybe);
var show410 = /* @__PURE__ */ show(showMaybe22);
var runSpago9 = /* @__PURE__ */ runSpago(monadAffSpago);
var bundlerArgsIsSymbol = {
  reflectSymbol: function() {
    return "bundlerArgs";
  }
};
var forceIsSymbol = {
  reflectSymbol: function() {
    return "force";
  }
};
var minifyIsSymbol = {
  reflectSymbol: function() {
    return "minify";
  }
};
var moduleIsSymbol = {
  reflectSymbol: function() {
    return "module";
  }
};
var outfileIsSymbol = {
  reflectSymbol: function() {
    return "outfile";
  }
};
var platformIsSymbol = {
  reflectSymbol: function() {
    return "platform";
  }
};
var sourceMapsIsSymbol = {
  reflectSymbol: function() {
    return "sourceMaps";
  }
};
var typeIsSymbol4 = {
  reflectSymbol: function() {
    return "type";
  }
};
var show56 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons(bundlerArgsIsSymbol)(/* @__PURE__ */ showRecordFieldsCons8(/* @__PURE__ */ showRecordFieldsCons(forceIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(minifyIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(moduleIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(outfileIsSymbol)(/* @__PURE__ */ showRecordFieldsCons1(/* @__PURE__ */ showRecordFieldsCons22(/* @__PURE__ */ showRecordFieldsCons(platformIsSymbol)(/* @__PURE__ */ showRecordFieldsCons32(/* @__PURE__ */ showRecordFieldsCons4(/* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons(sourceMapsIsSymbol)(/* @__PURE__ */ showRecordFieldsCons6(/* @__PURE__ */ showRecordFieldsCons(strictIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(typeIsSymbol4)(showMaybe22))(showMaybe2))(showMaybe1))(showBoolean))(showMaybe22))(showList3))(showBoolean))(showMaybe22))(showBoolean))(showMaybe22))(showMaybe22))(showMaybe22))(showBoolean))(showBoolean))(showBoolean))(showList3))(showList3)));
var bindFlipped13 = /* @__PURE__ */ bindFlipped(bindMaybe);
var applySecond11 = /* @__PURE__ */ applySecond(applyMaybe);
var guard16 = /* @__PURE__ */ guard(alternativeMaybe);
var pure128 = /* @__PURE__ */ pure(applicativeMaybe);
var map232 = /* @__PURE__ */ map(functorMaybe);
var buildArgsCons15 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "packages";
  }
})()()();
var fromRecord22 = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "dot";
  }
})()()()(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "topo";
  }
})()()()(buildRecordArgsNil))));
var append213 = /* @__PURE__ */ append(modSemigroup);
var $$long4 = /* @__PURE__ */ $$long(flagFieldsHasName);
var $$short3 = /* @__PURE__ */ $$short(flagFieldsHasName);
var map316 = /* @__PURE__ */ map(parserFunctor);
var apply29 = /* @__PURE__ */ apply2(parserApply);
var fold26 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var loggableArray9 = /* @__PURE__ */ loggableArray(loggableString);
var die34 = /* @__PURE__ */ die30(loggableArray9);
var bind217 = /* @__PURE__ */ bind(bindAff);
var liftEffect18 = /* @__PURE__ */ liftEffect(monadEffectAff);
var and2 = /* @__PURE__ */ and(foldableArray)(heytingAlgebraBoolean);
var pure216 = /* @__PURE__ */ pure(applicativeAff);
var runSpago1 = /* @__PURE__ */ runSpago(monadAffAff);
var mempty31 = /* @__PURE__ */ mempty(monoidList);
var $$void24 = /* @__PURE__ */ $$void(functorSpago);
var logDebug33 = /* @__PURE__ */ logDebug27(loggableArray9);
var logInfo15 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var merge3 = /* @__PURE__ */ merge()();
var toUnfoldable36 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var fromFoldable121 = /* @__PURE__ */ fromFoldable8(foldableArray)(ordPackageName);
var exists12 = /* @__PURE__ */ exists2(monadEffectSpago);
var logWarn13 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var mkTemp3 = /* @__PURE__ */ mkTemp(monadAffSpago);
var fromFoldable215 = /* @__PURE__ */ fromFoldable6(foldableArray);
var when20 = /* @__PURE__ */ when(applicativeSpago);
var when110 = /* @__PURE__ */ when(applicativeAff);
var output7 = /* @__PURE__ */ output(monadEffectAff);
var Build = /* @__PURE__ */ function() {
  function Build2(value0) {
    this.value0 = value0;
  }
  ;
  Build2.create = function(value0) {
    return new Build2(value0);
  };
  return Build2;
}();
var Bundle = /* @__PURE__ */ function() {
  function Bundle2(value0) {
    this.value0 = value0;
  }
  ;
  Bundle2.create = function(value0) {
    return new Bundle2(value0);
  };
  return Bundle2;
}();
var Docs = /* @__PURE__ */ function() {
  function Docs2(value0) {
    this.value0 = value0;
  }
  ;
  Docs2.create = function(value0) {
    return new Docs2(value0);
  };
  return Docs2;
}();
var Fetch = /* @__PURE__ */ function() {
  function Fetch2(value0) {
    this.value0 = value0;
  }
  ;
  Fetch2.create = function(value0) {
    return new Fetch2(value0);
  };
  return Fetch2;
}();
var Init = /* @__PURE__ */ function() {
  function Init2(value0) {
    this.value0 = value0;
  }
  ;
  Init2.create = function(value0) {
    return new Init2(value0);
  };
  return Init2;
}();
var Install = /* @__PURE__ */ function() {
  function Install2(value0) {
    this.value0 = value0;
  }
  ;
  Install2.create = function(value0) {
    return new Install2(value0);
  };
  return Install2;
}();
var Uninstall = /* @__PURE__ */ function() {
  function Uninstall2(value0) {
    this.value0 = value0;
  }
  ;
  Uninstall2.create = function(value0) {
    return new Uninstall2(value0);
  };
  return Uninstall2;
}();
var LsPaths = /* @__PURE__ */ function() {
  function LsPaths2(value0) {
    this.value0 = value0;
  }
  ;
  LsPaths2.create = function(value0) {
    return new LsPaths2(value0);
  };
  return LsPaths2;
}();
var LsDeps = /* @__PURE__ */ function() {
  function LsDeps2(value0) {
    this.value0 = value0;
  }
  ;
  LsDeps2.create = function(value0) {
    return new LsDeps2(value0);
  };
  return LsDeps2;
}();
var LsPackages = /* @__PURE__ */ function() {
  function LsPackages2(value0) {
    this.value0 = value0;
  }
  ;
  LsPackages2.create = function(value0) {
    return new LsPackages2(value0);
  };
  return LsPackages2;
}();
var Publish2 = /* @__PURE__ */ function() {
  function Publish3(value0) {
    this.value0 = value0;
  }
  ;
  Publish3.create = function(value0) {
    return new Publish3(value0);
  };
  return Publish3;
}();
var RegistryInfo = /* @__PURE__ */ function() {
  function RegistryInfo2(value0) {
    this.value0 = value0;
  }
  ;
  RegistryInfo2.create = function(value0) {
    return new RegistryInfo2(value0);
  };
  return RegistryInfo2;
}();
var RegistryPackageSets = /* @__PURE__ */ function() {
  function RegistryPackageSets2(value0) {
    this.value0 = value0;
  }
  ;
  RegistryPackageSets2.create = function(value0) {
    return new RegistryPackageSets2(value0);
  };
  return RegistryPackageSets2;
}();
var RegistrySearch = /* @__PURE__ */ function() {
  function RegistrySearch2(value0) {
    this.value0 = value0;
  }
  ;
  RegistrySearch2.create = function(value0) {
    return new RegistrySearch2(value0);
  };
  return RegistrySearch2;
}();
var Repl = /* @__PURE__ */ function() {
  function Repl2(value0) {
    this.value0 = value0;
  }
  ;
  Repl2.create = function(value0) {
    return new Repl2(value0);
  };
  return Repl2;
}();
var Run = /* @__PURE__ */ function() {
  function Run2(value0) {
    this.value0 = value0;
  }
  ;
  Run2.create = function(value0) {
    return new Run2(value0);
  };
  return Run2;
}();
var Sources = /* @__PURE__ */ function() {
  function Sources2(value0) {
    this.value0 = value0;
  }
  ;
  Sources2.create = function(value0) {
    return new Sources2(value0);
  };
  return Sources2;
}();
var Test = /* @__PURE__ */ function() {
  function Test2(value0) {
    this.value0 = value0;
  }
  ;
  Test2.create = function(value0) {
    return new Test2(value0);
  };
  return Test2;
}();
var Upgrade = /* @__PURE__ */ function() {
  function Upgrade2(value0) {
    this.value0 = value0;
  }
  ;
  Upgrade2.create = function(value0) {
    return new Upgrade2(value0);
  };
  return Upgrade2;
}();
var GraphModules = /* @__PURE__ */ function() {
  function GraphModules2(value0) {
    this.value0 = value0;
  }
  ;
  GraphModules2.create = function(value0) {
    return new GraphModules2(value0);
  };
  return GraphModules2;
}();
var GraphPackages = /* @__PURE__ */ function() {
  function GraphPackages2(value0) {
    this.value0 = value0;
  }
  ;
  GraphPackages2.create = function(value0) {
    return new GraphPackages2(value0);
  };
  return GraphPackages2;
}();
var SpagoCmd = /* @__PURE__ */ function() {
  function SpagoCmd2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SpagoCmd2.create = function(value0) {
    return function(value12) {
      return new SpagoCmd2(value0, value12);
    };
  };
  return SpagoCmd2;
}();
var Cmd$primeSpagoCmd = /* @__PURE__ */ function() {
  function Cmd$primeSpagoCmd2(value0) {
    this.value0 = value0;
  }
  ;
  Cmd$primeSpagoCmd2.create = function(value0) {
    return new Cmd$primeSpagoCmd2(value0);
  };
  return Cmd$primeSpagoCmd2;
}();
var Cmd$primeVersionCmd = /* @__PURE__ */ function() {
  function Cmd$primeVersionCmd2(value0) {
    this.value0 = value0;
  }
  ;
  Cmd$primeVersionCmd2.create = function(value0) {
    return new Cmd$primeVersionCmd2(value0);
  };
  return Cmd$primeVersionCmd2;
}();
var upgradeArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons2(buildRecordArgsNil))({
  setVersion: maybeSetVersion
});
var uninstallArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "packagesToRemove";
  }
})()()()(buildArgsCons22))({
  packagesToRemove,
  selectedPackage,
  testDeps
});
var testArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(buildArgsCons11))({
  selectedPackage,
  pursArgs,
  backendArgs,
  execArgs,
  main: moduleName,
  output: output2,
  pedanticPackages,
  strict,
  statVerbosity,
  pure: pure41
});
var sourcesArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(buildArgsCons13))({
  selectedPackage,
  json: json2
});
var runArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons14(buildArgsCons11)))({
  selectedPackage,
  pursArgs,
  backendArgs,
  execArgs,
  output: output2,
  pedanticPackages,
  main: moduleName,
  ensureRanges,
  strict,
  statVerbosity,
  pure: pure41
});
var replArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons7(buildArgsCons13)))({
  selectedPackage,
  pursArgs,
  backendArgs
});
var registrySearchArgsParser = /* @__PURE__ */ fromRecord12({
  "package": $$package,
  json: json2
});
var registryPackageSetsArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "latest";
  }
})()()()(buildRecordArgsNil)))({
  json: json2,
  latest
});
var registryInfoArgsParser = /* @__PURE__ */ fromRecord12({
  "package": $$package,
  json: json2
});
var publishArgsParser = /* @__PURE__ */ fromRecord3(buildArgsCons13)({
  selectedPackage
});
var mkTestEnv = function(testArgs) {
  return function(v) {
    return bind81(ask19)(function(v1) {
      return discard47(logDebug110("Test args: " + show55(testArgs)))(function() {
        return bind81(getNode)(function(node) {
          var mkSelectedTest = function(selected) {
            var testConf = function(f) {
              return bind127(selected["package"].test)(f);
            };
            var moduleName3 = fromMaybe("Test.Main")(alt39(testArgs.main)(testConf(function($726) {
              return Just.create(function(v2) {
                return v2.main;
              }($726));
            })));
            var execArgs2 = fromMaybe([])(alt39(testArgs.execArgs)(testConf(function(v2) {
              return v2.execArgs;
            })));
            return {
              moduleName: moduleName3,
              execArgs: execArgs2,
              selected
            };
          };
          return bind81(function() {
            if (v1.workspace.selected instanceof Just) {
              return pure97(singleton4(mkSelectedTest(v1.workspace.selected.value0)));
            }
            ;
            if (v1.workspace.selected instanceof Nothing) {
              var workspacePackages = getWorkspacePackages(v1.workspace.packageSet);
              var v2 = uncons(filter2(function(v3) {
                return v3.hasTests;
              })(workspacePackages));
              if (v2 instanceof Just) {
                return pure97(map152(mkSelectedTest)(cons$prime(v2.value0.head)(v2.value0.tail)));
              }
              ;
              if (v2 instanceof Nothing) {
                return die111("No package found to test.");
              }
              ;
              throw new Error("Failed pattern match at Main (line 857, column 9 - line 859, column 53): " + [v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Main (line 851, column 23 - line 859, column 53): " + [v1.workspace.selected.constructor.name]);
          }())(function(selectedPackages) {
            return discard47(logDebug110("Selected packages to test: " + stringifyJson(nonEmptyArray(codec2))(map152(function(v2) {
              return v2["selected"]["package"].name;
            })(selectedPackages))))(function() {
              var newWorkspace = {
                packageSet: v1.workspace.packageSet,
                selected: v1.workspace.selected,
                backend: v1.workspace.backend,
                compatibleCompiler: v1.workspace.compatibleCompiler,
                doc: v1.workspace.doc,
                rootPackage: v1.workspace.rootPackage,
                workspaceConfig: v1.workspace.workspaceConfig,
                buildOptions: {
                  censorLibWarnings: v1.workspace.buildOptions.censorLibWarnings,
                  statVerbosity: v1.workspace.buildOptions.statVerbosity,
                  output: alt39(testArgs.output)(v1.workspace.buildOptions.output)
                }
              };
              var testEnv = {
                logOptions: v1.logOptions,
                workspace: newWorkspace,
                selectedPackages,
                node,
                dependencies: v.dependencies,
                purs: v.purs
              };
              return pure97(testEnv);
            });
          });
        });
      });
    });
  };
};
var mkRunEnv = function(runArgs) {
  return function(v) {
    return bind81(ask19)(function(v1) {
      return discard47(logDebug110("Run args: " + show121(runArgs)))(function() {
        return bind81(getNode)(function(node) {
          return bind81(function() {
            if (v1.workspace.selected instanceof Just) {
              return pure97(v1.workspace.selected.value0);
            }
            ;
            if (v1.workspace.selected instanceof Nothing) {
              var workspacePackages = getWorkspacePackages(v1.workspace.packageSet);
              var v2 = length2(workspacePackages);
              if (v2 === 1) {
                return pure97(head2(workspacePackages));
              }
              ;
              return discard47(logDebug110(unsafeStringify(workspacePackages)))(function() {
                return die210([toDoc11("No package was selected for running. Please select (with -p) one of the following packages:"), indent(toDoc17(map152(function(v3) {
                  return v3["package"].name;
                })(workspacePackages)))]);
              });
            }
            ;
            throw new Error("Failed pattern match at Main (line 789, column 15 - line 803, column 16): " + [v1.workspace.selected.constructor.name]);
          }())(function(selected) {
            return discard47(logDebug110("Selected package to run: " + print5(selected["package"].name)))(function() {
              var runConf = function(f) {
                return bind127(selected["package"].run)(f);
              };
              var moduleName3 = fromMaybe("Main")(alt39(runArgs.main)(runConf(function(v2) {
                return v2.main;
              })));
              var execArgs2 = fromMaybe([])(alt39(runArgs.execArgs)(runConf(function(v2) {
                return v2.execArgs;
              })));
              var runOptions = {
                moduleName: moduleName3,
                execArgs: execArgs2,
                executeDir: cwd2,
                successMessage: Nothing.value,
                failureMessage: "Running failed."
              };
              var newWorkspace = {
                packageSet: v1.workspace.packageSet,
                selected: v1.workspace.selected,
                backend: v1.workspace.backend,
                compatibleCompiler: v1.workspace.compatibleCompiler,
                doc: v1.workspace.doc,
                rootPackage: v1.workspace.rootPackage,
                workspaceConfig: v1.workspace.workspaceConfig,
                buildOptions: {
                  censorLibWarnings: v1.workspace.buildOptions.censorLibWarnings,
                  statVerbosity: v1.workspace.buildOptions.statVerbosity,
                  output: alt39(runArgs.output)(v1.workspace.buildOptions.output)
                }
              };
              var runEnv = {
                logOptions: v1.logOptions,
                workspace: newWorkspace,
                selected,
                node,
                runOptions,
                dependencies: v.dependencies,
                purs: v.purs
              };
              return pure97(runEnv);
            });
          });
        });
      });
    });
  };
};
var mkReplEnv = function(replArgs) {
  return function(dependencies) {
    return function(supportPackage2) {
      return bind81(ask19)(function(v) {
        return discard47(logDebug110("Repl args: " + show217(replArgs)))(function() {
          return bind81(getPurs)(function(purs) {
            var selected = function() {
              if (v.workspace.selected instanceof Just) {
                return singleton4(v.workspace.selected.value0);
              }
              ;
              if (v.workspace.selected instanceof Nothing) {
                return getWorkspacePackages(v.workspace.packageSet);
              }
              ;
              throw new Error("Failed pattern match at Main (line 934, column 16 - line 936, column 66): " + [v.workspace.selected.constructor.name]);
            }();
            return pure97({
              purs,
              dependencies,
              supportPackage: supportPackage2,
              depsOnly: false,
              logOptions: v.logOptions,
              pursArgs: fromFoldable58(replArgs.pursArgs),
              selected
            });
          });
        });
      });
    };
  };
};
var mkRegistryEnv = function(offline2) {
  return discard47(logDebug110("CWD: " + cwd2))(function() {
    return discard47(mkdirp6(globalCachePath))(function() {
      return discard47(mkdirp6(localCachePath))(function() {
        return discard47(mkdirp6(localCachePackagesPath))(function() {
          return discard47(logDebug110("Global cache: " + show311(globalCachePath)))(function() {
            return discard47(logDebug110("Local cache: " + show311(localCachePath)))(function() {
              return bind81(getGit)(function(git) {
                return bind81(getPurs)(function(purs) {
                  return bind81(ask19)(function(v) {
                    return bind81(liftEffect17(connect({
                      database: databasePath,
                      logger: function(str2) {
                        return runReaderT(logDebug28("DB: " + str2))({
                          logOptions: v.logOptions
                        });
                      }
                    })))(function(db) {
                      return bind81(liftAff12(empty8))(function(registryBox) {
                        return bind81(liftAff12($$new4(unit)))(function(registryLock) {
                          return pure97({
                            getRegistry: getRegistryFns(registryBox)(registryLock),
                            logOptions: v.logOptions,
                            offline: offline2,
                            purs,
                            git,
                            db
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};
var mkPublishEnv = function(dependencies) {
  return bind81(ask19)(function(env3) {
    return bind81(function() {
      if (env3.workspace.selected instanceof Just) {
        return pure97(env3.workspace.selected.value0);
      }
      ;
      if (env3.workspace.selected instanceof Nothing) {
        var workspacePackages = getWorkspacePackages(env3.workspace.packageSet);
        var v = length2(workspacePackages);
        if (v === 1) {
          return pure97(head2(workspacePackages));
        }
        ;
        return discard47(logDebug110(unsafeStringify(workspacePackages)))(function() {
          return die210([toDoc11("No package was selected for publishing. Please select (with -p) one of the following packages:"), indent(toDoc17(map152(function(v1) {
            return v1["package"].name;
          })(workspacePackages)))]);
        });
      }
      ;
      throw new Error("Failed pattern match at Main (line 909, column 15 - line 923, column 16): " + [env3.workspace.selected.constructor.name]);
    }())(function(selected) {
      return pure97(union15({
        selected,
        dependencies
      })(env3));
    });
  });
};
var mkLsEnv = function(dependencies) {
  return bind81(ask19)(function(v) {
    return bind81(function() {
      if (v.workspace.selected instanceof Just) {
        return pure97(v.workspace.selected.value0);
      }
      ;
      if (v.workspace.selected instanceof Nothing) {
        var workspacePackages = getWorkspacePackages(v.workspace.packageSet);
        var v1 = length2(workspacePackages);
        if (v1 === 1) {
          return pure97(head2(workspacePackages));
        }
        ;
        return discard47(logDebug110(unsafeStringify(workspacePackages)))(function() {
          return die210([toDoc11("No package was selected. Please select (with -p) one of the following packages:"), indent(toDoc17(map152(function(v2) {
            return v2["package"].name;
          })(workspacePackages)))]);
        });
      }
      ;
      throw new Error("Failed pattern match at Main (line 1001, column 15 - line 1015, column 16): " + [v.workspace.selected.constructor.name]);
    }())(function(selected) {
      return pure97({
        logOptions: v.logOptions,
        workspace: v.workspace,
        dependencies,
        selected
      });
    });
  });
};
var mkFetchEnv = function(v) {
  var parsePackageName2 = function(p) {
    var v12 = parse3(p);
    if (v12 instanceof Right) {
      return new Right(v12.value0);
    }
    ;
    if (v12 instanceof Left) {
      return new Left("- Could not parse package " + (show311(p) + (": " + v12.value0)));
    }
    ;
    throw new Error("Failed pattern match at Main (line 951, column 26 - line 953, column 79): " + [v12.constructor.name]);
  };
  var v1 = partitionMap4(parsePackageName2)(fromFoldable58(v.packages));
  return discard47(unless9($$null(v1.left))(die210(append126([toDoc11("Failed to parse some package name: ")])(map153(function($727) {
    return indent(toDoc11($727));
  })(v1.left)))))(function() {
    return bind81($$for13(v.selectedPackage)(function($728) {
      return function(v2) {
        if (v2 instanceof Right) {
          return pure97(v2.value0);
        }
        ;
        if (v2 instanceof Left) {
          return die111("Failed to parse selected package name, was: " + show410(v.selectedPackage));
        }
        ;
        throw new Error("Failed pattern match at Main (line 958, column 76 - line 960, column 99): " + [v2.constructor.name]);
      }(parse3($728));
    }))(function(maybeSelectedPackage) {
      return bind81(mkRegistryEnv(v.offline))(function(env3) {
        return bind81(runSpago9(env3)(readWorkspace({
          maybeSelectedPackage,
          pureBuild: v.pure,
          migrateConfig: v.migrateConfig
        })))(function(workspace) {
          var fetchOpts = {
            packages: v1.right,
            ensureRanges: v.ensureRanges,
            isTest: v.testDeps,
            isRepl: v.isRepl
          };
          return pure97({
            fetchOpts,
            env: union15({
              workspace
            })(env3)
          });
        });
      });
    });
  });
};
var mkDocsEnv = function(args) {
  return function(dependencies) {
    return bind81(ask19)(function(v) {
      return bind81(getPurs)(function(purs) {
        return pure97({
          purs,
          logOptions: v.logOptions,
          workspace: v.workspace,
          dependencies,
          depsOnly: args.depsOnly,
          docsFormat: args.docsFormat,
          open: args.open
        });
      });
    });
  };
};
var mkBundleEnv = function(bundleArgs) {
  return bind81(ask19)(function(v) {
    return discard47(logDebug110("Bundle args: " + show56(bundleArgs)))(function() {
      return bind81(function() {
        if (v.workspace.selected instanceof Just) {
          return pure97(v.workspace.selected.value0);
        }
        ;
        if (v.workspace.selected instanceof Nothing) {
          var workspacePackageNames = map152(function(v1) {
            return v1["package"].name;
          })(getWorkspacePackages(v.workspace.packageSet));
          return die210([toDoc11("No package was selected for bundling. Please select (with -p) one of the following packages:"), indent(toDoc17(workspacePackageNames))]);
        }
        ;
        throw new Error("Failed pattern match at Main (line 727, column 15 - line 733, column 155): " + [v.workspace.selected.constructor.name]);
      }())(function(selected) {
        return discard47(logDebug110("Selected package to bundle: " + print5(selected["package"].name)))(function() {
          var bundleConf = function(f) {
            return bind127(selected["package"].bundle)(f);
          };
          var minify2 = any2(function(v1) {
            return v1 === true;
          })([bundleArgs.minify, fromMaybe(false)(bindFlipped13(function(v1) {
            return v1.minify;
          })(selected["package"].bundle))]);
          var entrypoint2 = fromMaybe("Main")(alt39(bundleArgs.module)(bundleConf(function(v1) {
            return v1.module;
          })));
          var outfile2 = fromMaybe("index.js")(alt39(bundleArgs.outfile)(bundleConf(function(v1) {
            return v1.outfile;
          })));
          var platform9 = fromMaybe(BundleBrowser.value)(alt39(bindFlipped13(parsePlatform)(bundleArgs.platform))(bundleConf(function(v1) {
            return v1.platform;
          })));
          var bundleType2 = fromMaybe(BundleApp.value)(alt39(bindFlipped13(parseBundleType)(bundleArgs.type))(bundleConf(function(v1) {
            return v1.type;
          })));
          var extraArgs = fromMaybe([])(function() {
            var cliArgs = fromFoldable58(bundleArgs.bundlerArgs);
            return alt39(applySecond11(guard16(length(cliArgs) > 0))(pure128(cliArgs)))(bundleConf(function(v1) {
              return v1.extraArgs;
            }));
          }());
          var newWorkspace = {
            packageSet: v.workspace.packageSet,
            selected: v.workspace.selected,
            backend: v.workspace.backend,
            compatibleCompiler: v.workspace.compatibleCompiler,
            doc: v.workspace.doc,
            rootPackage: v.workspace.rootPackage,
            workspaceConfig: v.workspace.workspaceConfig,
            buildOptions: {
              censorLibWarnings: v.workspace.buildOptions.censorLibWarnings,
              statVerbosity: v.workspace.buildOptions.statVerbosity,
              output: alt39(bundleArgs.output)(v.workspace.buildOptions.output)
            }
          };
          var bundleOptions = {
            minify: minify2,
            module: entrypoint2,
            outfile: outfile2,
            force: bundleArgs.force,
            platform: platform9,
            type: bundleType2,
            sourceMaps: bundleArgs.sourceMaps,
            extraArgs
          };
          return bind81(getEsbuild)(function(esbuild) {
            var bundleEnv = {
              esbuild,
              logOptions: v.logOptions,
              workspace: newWorkspace,
              selected,
              bundleOptions
            };
            return pure97(bundleEnv);
          });
        });
      });
    });
  });
};
var mkBuildEnv = function(buildArgs) {
  return function(dependencies) {
    return bind81(ask19)(function(v) {
      return bind81(getPurs)(function(purs) {
        var newWorkspace = {
          compatibleCompiler: v.workspace.compatibleCompiler,
          doc: v.workspace.doc,
          packageSet: v.workspace.packageSet,
          rootPackage: v.workspace.rootPackage,
          selected: v.workspace.selected,
          workspaceConfig: v.workspace.workspaceConfig,
          buildOptions: {
            censorLibWarnings: v.workspace.buildOptions.censorLibWarnings,
            output: alt39(buildArgs.output)(v.workspace.buildOptions.output),
            statVerbosity: alt39(buildArgs.statVerbosity)(v.workspace.buildOptions.statVerbosity)
          },
          backend: map232(function(b) {
            var v2 = $$null5(buildArgs.backendArgs);
            if (v2) {
              return b;
            }
            ;
            if (!v2) {
              return {
                cmd: b.cmd,
                args: new Just(fromFoldable58(buildArgs.backendArgs))
              };
            }
            ;
            throw new Error("Failed pattern match at Main (line 889, column 19 - line 891, column 84): " + [v2.constructor.name]);
          })(v.workspace.backend)
        };
        return pure97({
          logOptions: v.logOptions,
          purs,
          git: v.git,
          dependencies,
          workspace: newWorkspace,
          strictWarnings: buildArgs.strict,
          pedanticPackages: buildArgs.pedanticPackages
        });
      });
    });
  };
};
var lsPathsArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(buildRecordArgsNil))({
  json: json2
});
var lsPackagesArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons6(buildRecordArgsNil)))({
  json: json2,
  pure: pure41
});
var lsDepsArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "transitive";
  }
})()()()(buildRecordArgsNil)))))({
  json: json2,
  transitive,
  selectedPackage,
  pure: pure41
});
var installArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons14(/* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons15(/* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons7(buildArgsCons22))))))))({
  packages,
  selectedPackage,
  pursArgs,
  backendArgs,
  output: output2,
  pedanticPackages,
  ensureRanges,
  testDeps,
  pure: pure41
});
var initArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "name";
  }
})()()()(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "useSolver";
  }
})()()()(buildRecordArgsNil))))({
  setVersion: maybeSetVersion,
  name: maybePackageName,
  useSolver
});
var graphPackagesArgsParser = /* @__PURE__ */ fromRecord22({
  dot,
  json: json2,
  topo
});
var graphModulesArgsParser = /* @__PURE__ */ fromRecord22({
  dot,
  json: json2,
  topo
});
var globalArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "migrateConfig";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "noColor";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "offline";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "quiet";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "verbose";
  }
})()()()(buildRecordArgsNil))))))({
  quiet,
  verbose,
  noColor,
  offline,
  migrateConfig
});
var fetchArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons14(/* @__PURE__ */ buildArgsCons15(/* @__PURE__ */ buildArgsCons6(buildArgsCons22))))({
  packages,
  selectedPackage,
  ensureRanges,
  testDeps,
  pure: pure41
});
var docsArgsParser = /* @__PURE__ */ function() {
  var parseFormat = function(val) {
    return fromMaybe(Html.value)(bind127(val)(parseDocsFormat));
  };
  return fromRecord3(buildArgsCons({
    reflectSymbol: function() {
      return "depsOnly";
    }
  })()()()(buildArgsCons({
    reflectSymbol: function() {
      return "docsFormat";
    }
  })()()()(buildArgsCons({
    reflectSymbol: function() {
      return "open";
    }
  })()()()(buildRecordArgsNil))))({
    depsOnly,
    open: $$switch(append213($$long4("open"))(append213($$short3("o"))(help("Open generated documentation in browser (for HTML format only)")))),
    docsFormat: map316(parseFormat)(optional(parserAlt)(parserApplicative)(strOption(append213($$long(optionFieldsHasName)("format"))(append213($$short(optionFieldsHasName)("f"))(append213(metavar(optionFieldsHasMetavar)("FORMAT"))(help("Docs output format (markdown | html | etags | ctags)")))))))
  });
}();
var commandParser = function(command_) {
  return function(parser_) {
    return function(description_) {
      return command(command_)(info(apply29(map316(SpagoCmd.create)(globalArgsParser))(parser_))(progDesc(description_)));
    };
  };
};
var bundleArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons(bundlerArgsIsSymbol)()()()(/* @__PURE__ */ buildArgsCons14(/* @__PURE__ */ buildArgsCons(forceIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(minifyIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(moduleIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(outfileIsSymbol)()()()(/* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons(platformIsSymbol)()()()(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons7(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons(sourceMapsIsSymbol)()()()(/* @__PURE__ */ buildArgsCons8(/* @__PURE__ */ buildArgsCons9(/* @__PURE__ */ buildArgsCons(typeIsSymbol4)()()()(buildRecordArgsNil))))))))))))))))))({
  minify,
  sourceMaps,
  module: entrypoint,
  type: bundleType,
  outfile,
  platform: platform2,
  selectedPackage,
  pursArgs,
  backendArgs,
  bundlerArgs,
  output: output2,
  force: forceBundle,
  pedanticPackages,
  ensureRanges,
  strict,
  statVerbosity,
  pure: pure41
});
var buildArgsParser = /* @__PURE__ */ fromRecord3(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons14(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "jsonErrors";
  }
})()()()(buildArgsCons10))))({
  selectedPackage,
  pursArgs,
  backendArgs,
  output: output2,
  pedanticPackages,
  ensureRanges,
  jsonErrors,
  strict,
  statVerbosity,
  pure: pure41
});
var argParser = /* @__PURE__ */ function() {
  return hsubparser(fold26([commandParser("init")(map316(Init.create)(initArgsParser))("Initialise a new project"), commandParser("fetch")(map316(Fetch.create)(fetchArgsParser))("Downloads all of the project's dependencies"), commandParser("install")(map316(Install.create)(installArgsParser))("Compile the project's dependencies"), commandParser("uninstall")(map316(Uninstall.create)(uninstallArgsParser))("Remove dependencies from a package"), commandParser("build")(map316(Build.create)(buildArgsParser))("Compile the project"), commandParser("run")(map316(Run.create)(runArgsParser))("Run the project"), commandParser("test")(map316(Test.create)(testArgsParser))("Test the project"), commandParser("bundle")(map316(Bundle.create)(bundleArgsParser))("Bundle the project in a single file"), commandParser("sources")(map316(Sources.create)(sourcesArgsParser))("List all the source paths (globs) for the dependencies of the project"), commandParser("repl")(map316(Repl.create)(replArgsParser))("Start a REPL"), commandParser("publish")(map316(Publish2.create)(publishArgsParser))("Publish a package"), commandParser("upgrade")(map316(Upgrade.create)(upgradeArgsParser))("Upgrade to the latest package set, or to the latest versions of Registry packages"), commandParser("docs")(map316(Docs.create)(docsArgsParser))("Generate docs for the project and its dependencies"), command("registry")(info(hsubparser(fold26([commandParser("search")(map316(RegistrySearch.create)(registrySearchArgsParser))("Search for package names in the Registry"), commandParser("info")(map316(RegistryInfo.create)(registryInfoArgsParser))("Query the Registry for information about packages and versions"), commandParser("package-sets")(map316(RegistryPackageSets.create)(registryPackageSetsArgsParser))("List the available package sets")])))(progDesc("Commands to interact with the Registry"))), command("ls")(info(hsubparser(fold26([commandParser("packages")(map316(LsPackages.create)(lsPackagesArgsParser))("List packages available in the local package set"), commandParser("deps")(map316(LsDeps.create)(lsDepsArgsParser))("List dependencies of the project"), commandParser("paths")(map316(LsPaths.create)(lsPathsArgsParser))("List the paths used by Spago")])))(progDesc("List packages or dependencies"))), command("graph")(info(hsubparser(fold26([commandParser("modules")(map316(GraphModules.create)(graphModulesArgsParser))("Generate a graph of the project's modules"), commandParser("packages")(map316(GraphPackages.create)(graphPackagesArgsParser))("Generate a graph of the project's dependencies")])))(progDesc("Generate a graph of modules or dependencies")))]));
}();
var parseArgs = /* @__PURE__ */ function() {
  return customExecParser(function(v) {
    return {
      prefMultiSuffix: v.prefMultiSuffix,
      prefDisambiguate: v.prefDisambiguate,
      prefBacktrack: v.prefBacktrack,
      prefColumns: v.prefColumns,
      prefShowHelpOnError: true,
      prefShowHelpOnEmpty: true
    };
  }(defaultPrefs))(info(apply29(helper)(alt(parserAlt)(map316(Cmd$primeSpagoCmd.create)(argParser))(map316(Cmd$primeVersionCmd.create)(flag$prime(true)(append213($$long4("version"))(append213($$short3("v"))(help("Show the current version"))))))))(progDesc("PureScript package manager and build tool")));
}();
var main = /* @__PURE__ */ function() {
  var parseSetVersion = function(maybeVersion) {
    return $$for13(maybeVersion)(function($729) {
      return function(v) {
        if (v instanceof Left) {
          return die34(["Could not parse provided set version. Error:", show311(v.value0)]);
        }
        ;
        if (v instanceof Right) {
          return pure97(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Main (line 718, column 48 - line 720, column 24): " + [v.constructor.name]);
      }(parseLenientVersion($729));
    });
  };
  var mkLogOptions = function(startingTime) {
    return function(v) {
      return bind217(liftEffect18(supportsColor2))(function(supports) {
        var verbosity = function() {
          if (v.quiet) {
            return LogQuiet.value;
          }
          ;
          if (v.verbose) {
            return LogVerbose.value;
          }
          ;
          return LogNormal.value;
        }();
        var color = and2([supports, !v.noColor]);
        return pure216({
          color,
          verbosity,
          startingTime
        });
      });
    };
  };
  return function __do3() {
    var startingTime = now();
    var c = parseArgs();
    return launchAff_(function() {
      if (c instanceof Cmd$primeSpagoCmd) {
        return bind217(mkLogOptions(startingTime)(c.value0.value0))(function(logOptions) {
          return runSpago1({
            logOptions
          })(function() {
            if (c.value0.value1 instanceof Sources) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                pure: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return $$void24(runSpago9(v.env)(run12({
                  json: c.value0.value1.value0.json
                })));
              });
            }
            ;
            if (c.value0.value1 instanceof Init) {
              var candidateName = fromMaybe(take3(150)(basename(cwd2)))(c.value0.value1.value0.name);
              return discard47(logDebug33([show311(cwd2), show311(candidateName)]))(function() {
                return bind81(function() {
                  var v = parse3(stripPureScriptPrefix(candidateName));
                  if (v instanceof Left) {
                    return die210([toDoc11("Could not figure out a name for the new package. Error:"), $$break, indent22(toDoc11(v.value0))]);
                  }
                  ;
                  if (v instanceof Right) {
                    return pure97(v.value0);
                  }
                  ;
                  throw new Error("Failed pattern match at Main (line 550, column 28 - line 556, column 32): " + [v.constructor.name]);
                }())(function(packageName) {
                  return bind81(parseSetVersion(c.value0.value1.value0.setVersion))(function(setVersion) {
                    return discard47(logDebug33(["Got packageName and setVersion:", print5(packageName), unsafeStringify(setVersion)]))(function() {
                      var initOpts = {
                        packageName,
                        setVersion,
                        useSolver: c.value0.value1.value0.useSolver
                      };
                      return bind81(mkRegistryEnv(c.value0.value0.offline))(function(env3) {
                        return discard47($$void24(runSpago9(env3)(run7(initOpts))))(function() {
                          return discard47(logInfo15("Set up a new Spago project."))(function() {
                            return logInfo15("Try running `spago run`");
                          });
                        });
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Fetch) {
              return bind81(mkFetchEnv(merge3({
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              })(c.value0.value1.value0)))(function(v) {
                return $$void24(runSpago9(v.env)(run3(v.fetchOpts)));
              });
            }
            ;
            if (c.value0.value1 instanceof RegistrySearch) {
              return bind81(mkRegistryEnv(c.value0.value0.offline))(function(env3) {
                return $$void24(runSpago9(env3)(search(c.value0.value1.value0)));
              });
            }
            ;
            if (c.value0.value1 instanceof RegistryInfo) {
              return bind81(mkRegistryEnv(c.value0.value0.offline))(function(env3) {
                return $$void24(runSpago9(env3)(info3(c.value0.value1.value0)));
              });
            }
            ;
            if (c.value0.value1 instanceof RegistryPackageSets) {
              return bind81(mkRegistryEnv(c.value0.value0.offline))(function(env3) {
                return $$void24(runSpago9(env3)(packageSets(c.value0.value1.value0)));
              });
            }
            ;
            if (c.value0.value1 instanceof Install) {
              return bind81(mkFetchEnv(merge3(c.value0.value1.value0)({
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              })))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  var buildArgs = merge3(c.value0.value1.value0)({
                    statVerbosity: Nothing.value,
                    strict: Nothing.value
                  });
                  return bind81(runSpago9(v.env)(mkBuildEnv(buildArgs)(dependencies)))(function(env$prime) {
                    var options = {
                      depsOnly: true,
                      pursArgs: toUnfoldable36(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return $$void24(runSpago9(env$prime)(run4(options)));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Uninstall) {
              return bind81(mkFetchEnv({
                packages: c.value0.value1.value0.packagesToRemove,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                pure: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                var options = {
                  testDeps: c.value0.value1.value0.testDeps,
                  dependenciesToRemove: fromFoldable121(v.fetchOpts.packages)
                };
                return runSpago9(v.env)(run14(options));
              });
            }
            ;
            if (c.value0.value1 instanceof Build) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges,
                pure: c.value0.value1.value0.pure,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable36(c.value0.value1.value0.pursArgs),
                      jsonErrors: c.value0.value1.value0.jsonErrors
                    };
                    return $$void24(runSpago9(buildEnv)(run4(options)));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Publish2) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                pure: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkPublishEnv(dependencies)))(function(publishEnv) {
                    return $$void24(runSpago9(publishEnv)(publish({})));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Repl) {
              return bind81(bind81(exists12("spago.yaml"))(function(v) {
                if (v) {
                  return pure97(mempty31);
                }
                ;
                if (!v) {
                  return discard47(logWarn13("No configuration found, creating a temporary project to run a repl in..."))(function() {
                    return bind81(mkTemp3)(function(tmpDir) {
                      return discard47(mkdirp6(tmpDir))(function() {
                        return discard47(logDebug110("Creating repl project in temp dir: " + tmpDir))(function() {
                          return discard47(liftEffect17(chdir(tmpDir)))(function() {
                            return bind81(mkRegistryEnv(c.value0.value0.offline))(function(env3) {
                              return discard47($$void24(runSpago9(env3)(run7({
                                setVersion: Nothing.value,
                                packageName: "repl",
                                useSolver: true
                              }))))(function() {
                                return pure97(fromFoldable215(["effect", "console"]));
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                }
                ;
                throw new Error("Failed pattern match at Main (line 606, column 52 - line 623, column 65): " + [v.constructor.name]);
              }))(function(packages3) {
                return bind81(mkFetchEnv({
                  packages: packages3,
                  selectedPackage: c.value0.value1.value0.selectedPackage,
                  ensureRanges: false,
                  testDeps: false,
                  isRepl: true,
                  pure: false,
                  migrateConfig: c.value0.value0.migrateConfig,
                  offline: c.value0.value0.offline
                }))(function(v) {
                  return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                    return bind81(runSpago9(v.env)(supportPackage(v.env.workspace.packageSet)))(function(supportPackages) {
                      return bind81(runSpago9(v.env)(mkReplEnv(c.value0.value1.value0)(dependencies)(supportPackages)))(function(replEnv) {
                        return $$void24(runSpago9(replEnv)(run10));
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Bundle) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges,
                pure: c.value0.value1.value0.pure,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable36(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return bind81(runSpago9(buildEnv)(run4(options)))(function(built) {
                      return when20(built)(bind81(runSpago9(v.env)(mkBundleEnv(c.value0.value1.value0)))(function(bundleEnv) {
                        return runSpago9(bundleEnv)(run5);
                      }));
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Run) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges,
                pure: c.value0.value1.value0.pure,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable36(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return bind81(runSpago9(buildEnv)(run4(options)))(function(built) {
                      return when20(built)(bind81(runSpago9(v.env)(mkRunEnv(c.value0.value1.value0)(buildEnv)))(function(runEnv) {
                        return runSpago9(runEnv)(run11);
                      }));
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Test) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                pure: c.value0.value1.value0.pure,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkBuildEnv(union15(c.value0.value1.value0)({
                    ensureRanges: false
                  }))(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable36(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return bind81(runSpago9(buildEnv)(run4(options)))(function(built) {
                      return when20(built)(bind81(runSpago9(v.env)(mkTestEnv(c.value0.value1.value0)(buildEnv)))(function(testEnv) {
                        return runSpago9(testEnv)(run13);
                      }));
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof LsPaths) {
              return runSpago9({
                logOptions
              })(listPaths(c.value0.value1.value0));
            }
            ;
            if (c.value0.value1 instanceof LsPackages) {
              var fetchArgs = {
                packages: mempty31,
                selectedPackage: Nothing.value,
                pure: c.value0.value1.value0.pure,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              };
              return bind81(mkFetchEnv(fetchArgs))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  var lsEnv = {
                    workspace: v.env.workspace,
                    dependencies,
                    logOptions
                  };
                  return runSpago9(lsEnv)(listPackageSet(c.value0.value1.value0));
                });
              });
            }
            ;
            if (c.value0.value1 instanceof LsDeps) {
              var fetchArgs = {
                packages: mempty31,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                pure: c.value0.value1.value0.pure,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              };
              return bind81(mkFetchEnv(fetchArgs))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkLsEnv(dependencies)))(function(lsEnv) {
                    return runSpago9(lsEnv)(listPackages({
                      json: c.value0.value1.value0.json,
                      transitive: c.value0.value1.value0.transitive
                    }));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Docs) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                pure: false,
                selectedPackage: Nothing.value,
                ensureRanges: false,
                testDeps: true,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(runSpago9(v.env)(mkDocsEnv(c.value0.value1.value0)(dependencies)))(function(docsEnv) {
                    return runSpago9(docsEnv)(run6);
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Upgrade) {
              return bind81(parseSetVersion(c.value0.value1.value0.setVersion))(function(setVersion) {
                return bind81(mkFetchEnv({
                  packages: mempty31,
                  selectedPackage: Nothing.value,
                  pure: false,
                  ensureRanges: false,
                  testDeps: false,
                  isRepl: false,
                  migrateConfig: c.value0.value0.migrateConfig,
                  offline: c.value0.value0.offline
                }))(function(v) {
                  return runSpago9(v.env)(run15({
                    setVersion
                  }));
                });
              });
            }
            ;
            if (c.value0.value1 instanceof GraphModules) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: Nothing.value,
                pure: false,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(getPurs)(function(purs) {
                    return runSpago9({
                      dependencies,
                      logOptions,
                      purs,
                      workspace: v.env.workspace
                    })(graphModules(c.value0.value1.value0));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof GraphPackages) {
              return bind81(mkFetchEnv({
                packages: mempty31,
                selectedPackage: Nothing.value,
                pure: false,
                ensureRanges: false,
                testDeps: false,
                isRepl: false,
                migrateConfig: c.value0.value0.migrateConfig,
                offline: c.value0.value0.offline
              }))(function(v) {
                return bind81(runSpago9(v.env)(run3(v.fetchOpts)))(function(dependencies) {
                  return bind81(getPurs)(function(purs) {
                    return runSpago9({
                      dependencies,
                      logOptions,
                      purs,
                      workspace: v.env.workspace
                    })(graphPackages(c.value0.value1.value0));
                  });
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Main (line 533, column 33 - line 699, column 109): " + [c.value0.value1.constructor.name]);
          }());
        });
      }
      ;
      if (c instanceof Cmd$primeVersionCmd) {
        return when110(c.value0)(output7(new OutputLines([packages2["spago-bin"]])));
      }
      ;
      throw new Error("Failed pattern match at Main (line 530, column 26 - line 702, column 64): " + [c.constructor.name]);
    }())();
  };
}();

// <stdin>
main();
/*! Bundled license information:

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
