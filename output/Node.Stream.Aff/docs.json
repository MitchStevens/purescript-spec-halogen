{"comments":"Asynchronous I/O with the [*Node.js* Stream API](https://nodejs.org/docs/latest/api/stream.html).\n\nOpen __file streams__ with\n[__Node.FS.Stream__](https://pursuit.purescript.org/packages/purescript-node-fs/docs/Node.FS.Stream).\n\nOpen __process streams__ with\n[__Node.Process__](https://pursuit.purescript.org/packages/purescript-node-process/docs/Node.Process).\n\nAll __I/O errors__ will be thrown through the `Aff` `MonadError` class\ninstance.\n\n`Aff` __cancellation__ will clean up all *Node.js* event listeners.\n\nAll of these `Aff` functions will prevent the *Node.js* __event loop__ from\nexiting until the `Aff` function completes.\n\n## Reading\n\n#### Implementation\n\nThe `read*` functions (not to be confused with the `readable*` functions)\nin this module all operate on a `Readable` stream\nin\n[“paused mode”](https://nodejs.org/docs/latest/api/stream.html#stream_two_reading_modes).\n\nInternally the reading functions use the\n[`readable.read([size])`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)\nfunction and are subject to the caveats of that function.\n\n#### Result Buffers\n\nThe result of a reading function may be chunked into more than one `Buffer`.\nThe `buffers` element of the result is an `Array Buffer` of what\nwas read.\nTo concatenate the result into a single `Buffer`, use\n[`Node.Buffer.concat :: Array Buffer -> m Buffer`](https://pursuit.purescript.org/packages/purescript-node-buffer/docs/Node.Buffer#t:MutableBuffer).\n\n```\ninput :: Buffer\n    <- liftEffect <<< concat <<< _.buffers =<< readSome stdin\n```\n\nTo calculate the number of bytes read, use\n`Node.Buffer.size :: Buffer -> m Int`.\n\n```\n{ buffers } :: Array Buffer <- readSome stdin\nbytesRead :: Int\n    <- liftEffect $ Array.foldM (\\a b -> (a+_) <$> size b) 0 buffers\n```\n\n#### Result `readagain` flag\n\nThe `readagain` field of the result is a `Boolean` flag which\nis `true` if the stream has not reached End-Of-File (and also if the stream\nhas not errored or been destroyed), so we know we can read again.\nIf the flag is `false` then the stream is not `readable`;\nno more bytes will ever be produced by the stream.\n\nReading from an ended, closed, errored, or destroyed stream\nwill complete immediately with `{ buffers: [], readagain: false }`.\n\nThe `readagain` flag will give the same answer as a\nsubsequent call to `readable`.\n\n## Writing\n\n#### Implementation\n\nThe writing functions in this module all operate on a `Writeable` stream.\n\nInternally the writing functions will call the\n[`writable.write(chunk[, encoding][, callback])`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)\nfunction on each of the `Buffer`s,\nand will asychronously wait if there is “backpressure” from the stream.\n\n#### Result\n\nThe writing functions will complete after all the data is flushed to the\nstream.\n\nIf a write fails then it will `throwError` in the `Aff`.\n","declarations":[{"children":[],"comments":"Works on streams in \"flowing\" mode. \nReads all of the stream's contents into a buffer\nand converts the result into a UTF8-encoded String.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"w","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"w","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[125,14],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[121,1]},"title":"readableToStringUtf8"},{"children":[],"comments":"Works on streams in \"flowing\" mode. \nReads all of the stream's contents into a buffer\nand converts the result into a String using the provided encoding.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"w","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"w","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Encoding"],"Encoding"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[136,14],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[131,1]},"title":"readableToString"},{"children":[],"comments":"Works on streams in \"flowing\" mode.\nReads all of the stream's buffered contents into an array.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"w","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"w","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[147,22],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[143,1]},"title":"readableToBuffers"},{"children":[],"comments":"Works on streams in \"paused\" mode. \nWait until there is some data available from the stream, then read it.\n\nThis function is useful for streams like __stdin__ which never\nreach End-Of-File.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"r","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"r","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["buffers",{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":["readagain",{"annotation":[],"contents":[["Prim"],"Boolean"],"tag":"TypeConstructor"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[190,57],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[186,1]},"title":"readSome"},{"children":[],"comments":"Works on streams in \"paused\" mode. \nRead all data until the end of the stream. After completion the stream\nwill no longer be `readable`.\n\nNote that __stdin__ will never end.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"r","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"r","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[275,22],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[271,1]},"title":"readAll"},{"children":[],"comments":"Works on streams in \"paused\" mode. \nWait for *N* bytes to become available from the stream.\n\nIf more than *N* bytes are available on the stream, then\ncompletes with *N* bytes and leaves the rest in the stream’s internal buffer.\n\nIf the end of the stream is reached before *N* bytes are available,\nthen completes with less than *N* bytes.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"r","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Readable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"r","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"Int"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Record"],"tag":"TypeConstructor"},{"annotation":[],"contents":["buffers",{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":["readagain",{"annotation":[],"contents":[["Prim"],"Boolean"],"tag":"TypeConstructor"},{"annotation":[],"tag":"REmpty"}],"tag":"RCons"}],"tag":"RCons"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[356,57],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[351,1]},"title":"readN"},{"children":[],"comments":"Write to a stream.\n\nWill complete after the data is flushed to the stream.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"w","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Writable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"w","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Data","Unit"],"Unit"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[450,12],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[445,1]},"title":"write"},{"children":[],"comments":"Signal that no more data will be written to the `Writable`. Will complete\nafter all data is written and flushed.\n\nWhen the `Writable` is an [__fs.WriteStream__](https://nodejs.org/api/fs.html#class-fswritestream)\nthen this will close the file descriptor because\n\n> “If `autoClose` is set to true (default behavior) on `'error'`\n> or `'finish'` the file descriptor will be closed automatically.”\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"w","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Node","Stream"],"Writable"],"tag":"TypeConstructor"},{"annotation":[],"contents":"w","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Data","Unit"],"Unit"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[495,12],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[491,1]},"title":"end"},{"children":[],"comments":"Concatenate an `Array` of UTF-8 encoded `Buffer`s into a `String`.\n\nExample:\n\n```\ninputstring <- toStringUTF8 =<< readAll stream\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[509,68],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[509,1]},"title":"toStringUTF8"},{"children":[],"comments":"Encode a `String` as an `Array` containing one UTF-8 encoded `Buffer`.\n\nExample:\n\n```\nwrite stream =<< fromStringUTF8 \"outputstring\"\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Effect","Class"],"MonadEffect"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Array"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Node","Buffer"],"Buffer"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[519,72],"name":".spago/p/node-streams-9.0.0/src/Node/Stream/Aff.purs","start":[519,1]},"title":"fromStringUTF8"}],"name":"Node.Stream.Aff","reExports":[]}