// Generated by purs version 0.15.15
import * as Control_Alt from "../Control.Alt/index.js";
import * as Control_Alternative from "../Control.Alternative/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Apply from "../Control.Apply/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Category from "../Control.Category/index.js";
import * as Control_Semigroupoid from "../Control.Semigroupoid/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_HeytingAlgebra from "../Data.HeytingAlgebra/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Map from "../Data.Map/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Set from "../Data.Set/index.js";
import * as Data_String_CodeUnits from "../Data.String.CodeUnits/index.js";
import * as Data_String_Common from "../Data.String.Common/index.js";
import * as Data_String_Regex from "../Data.String.Regex/index.js";
import * as Data_String_Regex_Flags from "../Data.String.Regex.Flags/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Effect_Aff_Class from "../Effect.Aff.Class/index.js";
import * as Effect_Class from "../Effect.Class/index.js";
import * as Options_Applicative_Builder from "../Options.Applicative.Builder/index.js";
import * as Options_Applicative_Builder_Internal from "../Options.Applicative.Builder.Internal/index.js";
import * as Options_Applicative_Extra from "../Options.Applicative.Extra/index.js";
import * as Options_Applicative_Types from "../Options.Applicative.Types/index.js";
import * as Partial from "../Partial/index.js";
import * as Test_Spec_Config from "../Test.Spec.Config/index.js";
import * as Test_Spec_Runner_Node_Persist from "../Test.Spec.Runner.Node.Persist/index.js";
import * as Test_Spec_Tree from "../Test.Spec.Tree/index.js";
var mapFlipped = /* #__PURE__ */ Data_Functor.mapFlipped(Data_Functor.functorArray);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var filter = /* #__PURE__ */ Data_Map_Internal.filter(Data_Ord.ordString);
var not = /* #__PURE__ */ Data_HeytingAlgebra.not(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraBoolean));
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit)(Data_Maybe.bindMaybe);
var guard = /* #__PURE__ */ Control_Alternative.guard(Data_Maybe.alternativeMaybe);
var pure = /* #__PURE__ */ Control_Applicative.pure(Data_Maybe.applicativeMaybe);
var member = /* #__PURE__ */ Data_Set.member(Data_Ord.ordString);
var sequence = /* #__PURE__ */ Data_Traversable.sequence(Data_Traversable.traversableArray);
var map1 = /* #__PURE__ */ Data_Functor.map(Options_Applicative_Types.parserFunctor);
var mapFlipped1 = /* #__PURE__ */ Data_Functor.mapFlipped(Data_Maybe.functorMaybe);
var alt = /* #__PURE__ */ Control_Alt.alt(Data_Maybe.altMaybe);
var optional = /* #__PURE__ */ Data_Maybe.optional(Options_Applicative_Types.parserAlt)(Options_Applicative_Types.parserApplicative);
var fold = /* #__PURE__ */ Data_Array.fold(Options_Applicative_Builder_Internal.modMonoid);
var $$long = /* #__PURE__ */ Options_Applicative_Builder["long"](Options_Applicative_Builder_Internal.optionFieldsHasName);
var metavar = /* #__PURE__ */ Options_Applicative_Builder.metavar(Options_Applicative_Builder_Internal.optionFieldsHasMetavar);
var long1 = /* #__PURE__ */ Options_Applicative_Builder["long"](Options_Applicative_Builder_Internal.flagFieldsHasName);
var identity = /* #__PURE__ */ Control_Category.identity(Control_Category.categoryFn);
var crashWith = /* #__PURE__ */ Partial.crashWith();
var $$short = /* #__PURE__ */ Options_Applicative_Builder["short"](Options_Applicative_Builder_Internal.optionFieldsHasName);
var apply = /* #__PURE__ */ Control_Apply.apply(Options_Applicative_Types.parserApply);
var append2 = /* #__PURE__ */ Data_Semigroup.append(Options_Applicative_Builder.infoModSemigroup);
var toSpecConfig = function (dictMonadAff) {
    var Monad0 = (dictMonadAff.MonadEffect0()).Monad0();
    var Applicative0 = Monad0.Applicative0();
    var pure1 = Control_Applicative.pure(Applicative0);
    var Bind1 = Monad0.Bind1();
    var Functor0 = (Bind1.Apply0()).Functor0();
    var mapFlipped2 = Data_Functor.mapFlipped(Functor0);
    var liftAff = Effect_Aff_Class.liftAff(dictMonadAff);
    var bind = Control_Bind.bind(Bind1);
    var map2 = Data_Functor.map(Functor0);
    var sequence1 = sequence(Applicative0);
    return function (cfg) {
        var combineFilters = function (v) {
            return function (v1) {
                return function (tree) {
                    return v(v1(tree));
                };
            };
        };
        var applyFilter = function (f) {
            return function (tests) {
                return mapFlipped(Test_Spec_Tree.filterTrees(function (v) {
                    return function (v1) {
                        return f(Data_String_Common.joinWith(" ")(append(Test_Spec_Tree.parentSuiteName(v.value1))([ v.value0 ])));
                    };
                })(Test_Spec_Tree.annotateWithPaths(tests)))(Test_Spec_Tree.mapTreeAnnotations(Data_Tuple.fst));
            };
        };
        var explicitFilter = pure1(map(applyFilter)(cfg.filter));
        var filterToFailures = (function () {
            if (cfg.onlyFailures) {
                return mapFlipped2(mapFlipped2(mapFlipped2(liftAff(Test_Spec_Runner_Node_Persist.lastPersistedResults))(filter(not(function (v) {
                    return v.success;
                }))))(Data_Map.keys))(function (names) {
                    return discard(guard(not(Data_Set.isEmpty)(names)))(function () {
                        return pure(applyFilter(function (v) {
                            return member(v)(names);
                        }));
                    });
                });
            };
            if (Data_Boolean.otherwise) {
                return pure1(Data_Maybe.Nothing.value);
            };
            throw new Error("Failed pattern match at Test.Spec.Runner.Node.Config (line 107, column 5 - line 117, column 23): " + [  ]);
        })();
        return bind(map2(Data_Array.catMaybes)(sequence1([ filterToFailures, explicitFilter ])))(function (filters) {
            return pure1({
                slow: Test_Spec_Config.defaultConfig.slow,
                exit: false,
                failFast: cfg.failFast,
                filterTree: Data_Array.foldl(combineFilters)(Test_Spec_Config.defaultConfig.filterTree)(filters),
                timeout: cfg.timeout
            });
        });
    };
};
var timeout = /* #__PURE__ */ map1(function (v) {
    var t = mapFlipped1(v)(function (s) {
        return Data_Int.toNumber(s) * 1000.0;
    });
    return function (r) {
        var $86 = {};
        for (var $87 in r) {
            if ({}.hasOwnProperty.call(r, $87)) {
                $86[$87] = r[$87];
            };
        };
        $86.timeout = alt(t)(r.timeout);
        return $86;
    };
})(/* #__PURE__ */ optional(/* #__PURE__ */ Options_Applicative_Builder.option(Options_Applicative_Builder["int"])(/* #__PURE__ */ fold([ /* #__PURE__ */ $$long("timeout"), /* #__PURE__ */ metavar("SECONDS"), /* #__PURE__ */ Options_Applicative_Builder.help("timeout for each individual test case, in seconds.") ]))));
var onlyFailuresKey = "only-failures";
var onlyFailures = /* #__PURE__ */ map1(function (v) {
    return function (r) {
        var $90 = {};
        for (var $91 in r) {
            if ({}.hasOwnProperty.call(r, $91)) {
                $90[$91] = r[$91];
            };
        };
        $90.onlyFailures = r.onlyFailures || v;
        return $90;
    };
})(/* #__PURE__ */ Options_Applicative_Builder["switch"](/* #__PURE__ */ fold([ /* #__PURE__ */ long1(onlyFailuresKey), /* #__PURE__ */ Options_Applicative_Builder.help("run only tests that failed on previous run.") ])));
var noTimeout = /* #__PURE__ */ map1(function (v) {
    if (v) {
        return function (v1) {
            var $95 = {};
            for (var $96 in v1) {
                if ({}.hasOwnProperty.call(v1, $96)) {
                    $95[$96] = v1[$96];
                };
            };
            $95.timeout = Data_Maybe.Nothing.value;
            return $95;
        };
    };
    return identity;
})(/* #__PURE__ */ Options_Applicative_Builder["switch"](/* #__PURE__ */ fold([ /* #__PURE__ */ long1("no-timeout"), /* #__PURE__ */ Options_Applicative_Builder.help("each individual test case is allowed to run for as long as it wants.") ])));
var filterByRegex = /* #__PURE__ */ map1(function (v) {
    var f = mapFlipped1(v)(function (r) {
        var v1 = Data_String_Regex.regex(r)(Data_String_Regex_Flags.ignoreCase);
        if (v1 instanceof Data_Either.Left) {
            return crashWith("Invalid regex: " + v1.value0);
        };
        if (v1 instanceof Data_Either.Right) {
            return Data_String_Regex.test(v1.value0);
        };
        throw new Error("Failed pattern match at Test.Spec.Runner.Node.Config (line 216, column 13 - line 218, column 46): " + [ v1.constructor.name ]);
    });
    return function (r) {
        var $102 = {};
        for (var $103 in r) {
            if ({}.hasOwnProperty.call(r, $103)) {
                $102[$103] = r[$103];
            };
        };
        $102.filter = alt(f)(r.filter);
        return $102;
    };
})(/* #__PURE__ */ optional(/* #__PURE__ */ Options_Applicative_Builder.strOption(/* #__PURE__ */ fold([ /* #__PURE__ */ $$long("example-matches"), /* #__PURE__ */ $$short("E"), /* #__PURE__ */ metavar("REGEX"), /* #__PURE__ */ Options_Applicative_Builder.help("\x0a        run only tests whose full names match the given regex.\x0a        This will unapologetically crash if the provided regex doesn't compile.\x0a        The regex is case-insensitive.\x0a      ") ]))));
var filterByName = /* #__PURE__ */ map1(function (v) {
    var f = mapFlipped1(v)(function (s) {
        var $118 = Data_String_CodeUnits.contains(Data_String_Common.toLower(s));
        return function ($119) {
            return $118(Data_String_Common.toLower($119));
        };
    });
    return function (r) {
        var $106 = {};
        for (var $107 in r) {
            if ({}.hasOwnProperty.call(r, $107)) {
                $106[$107] = r[$107];
            };
        };
        $106.filter = alt(f)(r.filter);
        return $106;
    };
})(/* #__PURE__ */ optional(/* #__PURE__ */ Options_Applicative_Builder.strOption(/* #__PURE__ */ fold([ /* #__PURE__ */ $$long("example"), /* #__PURE__ */ $$short("e"), /* #__PURE__ */ metavar("TEXT"), /* #__PURE__ */ Options_Applicative_Builder.help("run only tests whose full names contain the given text. Matching is case-sensitive.") ]))));
var failFastKey = "fail-fast";
var nextFailure = /* #__PURE__ */ (function () {
    return map1(function (v) {
        return function (r) {
            var $110 = {};
            for (var $111 in r) {
                if ({}.hasOwnProperty.call(r, $111)) {
                    $110[$111] = r[$111];
                };
            };
            $110.failFast = r.failFast || v;
            $110.onlyFailures = r.onlyFailures || v;
            return $110;
        };
    })(Options_Applicative_Builder["switch"](fold([ Options_Applicative_Builder["short"](Options_Applicative_Builder_Internal.flagFieldsHasName)("n"), long1("next-failure"), Options_Applicative_Builder.help("\x0a        run only failed tests and stop on first failure.\x0a        Equivalent to --" + (failFastKey + (" --" + onlyFailuresKey))) ])));
})();
var failFast = /* #__PURE__ */ map1(function (v) {
    return function (r) {
        var $114 = {};
        for (var $115 in r) {
            if ({}.hasOwnProperty.call(r, $115)) {
                $114[$115] = r[$115];
            };
        };
        $114.failFast = r.failFast || v;
        return $114;
    };
})(/* #__PURE__ */ Options_Applicative_Builder["switch"](/* #__PURE__ */ fold([ /* #__PURE__ */ long1(failFastKey), /* #__PURE__ */ Options_Applicative_Builder.help("stop the run after first failure") ])));
var emptyOptionParser = /* #__PURE__ */ Control_Applicative.pure(Options_Applicative_Types.parserApplicative)(identity);
var defaultConfig = /* #__PURE__ */ (function () {
    return {
        failFast: false,
        onlyFailures: false,
        filter: Data_Maybe.Nothing.value,
        timeout: new Data_Maybe.Just(10000.0)
    };
})();
var commandLineOptionParsers = [ failFast, onlyFailures, nextFailure, filterByName, filterByRegex, timeout, noTimeout ];
var combineOptionParsers = /* #__PURE__ */ Control_Apply.lift2(Options_Applicative_Types.parserApply)(/* #__PURE__ */ Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
var optionParser = function (options) {
    var combined = Data_Array.foldl(combineOptionParsers)(emptyOptionParser)(options);
    return Options_Applicative_Builder.info(apply(Options_Applicative_Extra.helper)(combined))(append2(Options_Applicative_Builder.fullDesc)(Options_Applicative_Builder.header("PureScript Spec test runner for Node")));
};
var fromCommandLine$prime = function (dictMonadEffect) {
    var mapFlipped2 = Data_Functor.mapFlipped((((dictMonadEffect.Monad0()).Bind1()).Apply0()).Functor0());
    var liftEffect = Effect_Class.liftEffect(dictMonadEffect);
    return function (defaultCfg) {
        return function (options) {
            var prefs = (function (v) {
                return {
                    prefMultiSuffix: v.prefMultiSuffix,
                    prefDisambiguate: v.prefDisambiguate,
                    prefShowHelpOnEmpty: v.prefShowHelpOnEmpty,
                    prefBacktrack: v.prefBacktrack,
                    prefColumns: v.prefColumns,
                    prefShowHelpOnError: true
                };
            })(Options_Applicative_Builder.defaultPrefs);
            return mapFlipped2(liftEffect(Options_Applicative_Extra.customExecParser(prefs)(optionParser(options))))(function (f) {
                return f(defaultCfg);
            });
        };
    };
};
var fromCommandLine = function (dictMonadEffect) {
    return fromCommandLine$prime(dictMonadEffect)(defaultConfig)(commandLineOptionParsers);
};
export {
    commandLineOptionParsers,
    defaultConfig,
    fromCommandLine,
    fromCommandLine$prime,
    toSpecConfig
};
//# sourceMappingURL=index.js.map
