// Generated by purs version 0.15.15
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Category from "../Control.Category/index.js";
import * as Control_Comonad_Cofree from "../Control.Comonad.Cofree/index.js";
import * as Control_Extend from "../Control.Extend/index.js";
import * as Control_Monad_Fork_Class from "../Control.Monad.Fork.Class/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_HeytingAlgebra from "../Data.HeytingAlgebra/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Newtype from "../Data.Newtype/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Effect_Class from "../Effect.Class/index.js";
import * as Effect_Ref from "../Effect.Ref/index.js";
import * as Halogen_Subscription from "../Halogen.Subscription/index.js";
import * as Matryoshka_Class_Recursive from "../Matryoshka.Class.Recursive/index.js";
import * as Matryoshka_Fold from "../Matryoshka.Fold/index.js";
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupString);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showBoolean);
var append1 = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupArray);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var intercalate = /* #__PURE__ */ Data_Array.intercalate(Data_Monoid.monoidString);
var unwrap = /* #__PURE__ */ Data_Newtype.unwrap();
var wrap = /* #__PURE__ */ Data_Newtype.wrap();
var identity = /* #__PURE__ */ Control_Category.identity(Control_Category.categoryFn);
var Unsatisfied = /* #__PURE__ */ (function () {
    function Unsatisfied() {

    };
    Unsatisfied.value = new Unsatisfied();
    return Unsatisfied;
})();
var Satisfied = /* #__PURE__ */ (function () {
    function Satisfied(value0) {
        this.value0 = value0;
    };
    Satisfied.create = function (value0) {
        return new Satisfied(value0);
    };
    return Satisfied;
})();
var Not = /* #__PURE__ */ (function () {
    function Not(value0) {
        this.value0 = value0;
    };
    Not.create = function (value0) {
        return new Not(value0);
    };
    return Not;
})();
var Or = /* #__PURE__ */ (function () {
    function Or(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Or.create = function (value0) {
        return function (value1) {
            return new Or(value0, value1);
        };
    };
    return Or;
})();
var And = /* #__PURE__ */ (function () {
    function And(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    And.create = function (value0) {
        return function (value1) {
            return new And(value0, value1);
        };
    };
    return And;
})();
var Sequence = /* #__PURE__ */ (function () {
    function Sequence(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Sequence.create = function (value0) {
        return function (value1) {
            return new Sequence(value0, value1);
        };
    };
    return Sequence;
})();
var Equals = /* #__PURE__ */ (function () {
    function Equals(value0) {
        this.value0 = value0;
    };
    Equals.create = function (value0) {
        return new Equals(value0);
    };
    return Equals;
})();
var Satisfies = /* #__PURE__ */ (function () {
    function Satisfies(value0) {
        this.value0 = value0;
    };
    Satisfies.create = function (value0) {
        return new Satisfies(value0);
    };
    return Satisfies;
})();
var None = /* #__PURE__ */ (function () {
    function None() {

    };
    None.value = new None();
    return None;
})();
var Incremental = function (x) {
    return x;
};
var showIsSatisfied = {
    show: function (v) {
        if (v instanceof Unsatisfied) {
            return "Unsatisfied";
        };
        if (v instanceof Satisfied) {
            return "Satisfied " + show(v.value0);
        };
        throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 81, column 10 - line 83, column 42): " + [ v.constructor.name ]);
    }
};
var show1 = /* #__PURE__ */ Data_Show.show(showIsSatisfied);
var newtypeIncrementalPredica = {
    Coercible0: function () {
        return undefined;
    }
};
var heytingAlgebraIsSatisfied = /* #__PURE__ */ (function () {
    return {
        ff: new Satisfied(false),
        tt: new Satisfied(true),
        not: function (v) {
            if (v instanceof Unsatisfied) {
                return Unsatisfied.value;
            };
            if (v instanceof Satisfied) {
                return new Satisfied(!v.value0);
            };
            throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 62, column 9 - line 64, column 37): " + [ v.constructor.name ]);
        },
        disj: function (a) {
            return function (b) {
                if (a instanceof Satisfied && a.value0) {
                    return new Satisfied(true);
                };
                if (b instanceof Satisfied && b.value0) {
                    return new Satisfied(true);
                };
                if (a instanceof Satisfied && (!a.value0 && (b instanceof Satisfied && !b.value0))) {
                    return new Satisfied(false);
                };
                return Unsatisfied.value;
            };
        },
        conj: function (a) {
            return function (b) {
                if (a instanceof Satisfied && !a.value0) {
                    return new Satisfied(false);
                };
                if (b instanceof Satisfied && !b.value0) {
                    return new Satisfied(false);
                };
                if (a instanceof Satisfied && (a.value0 && (b instanceof Satisfied && b.value0))) {
                    return new Satisfied(true);
                };
                return Unsatisfied.value;
            };
        },
        implies: function (a) {
            return function (b) {
                if (a instanceof Satisfied && !a.value0) {
                    return new Satisfied(true);
                };
                if (b instanceof Satisfied && b.value0) {
                    return new Satisfied(true);
                };
                if (a instanceof Satisfied && (a.value0 && (b instanceof Satisfied && !b.value0))) {
                    return new Satisfied(false);
                };
                return Unsatisfied.value;
            };
        }
    };
})();
var conj = /* #__PURE__ */ Data_HeytingAlgebra.conj(heytingAlgebraIsSatisfied);
var not1 = /* #__PURE__ */ Data_HeytingAlgebra.not(heytingAlgebraIsSatisfied);
var disj = /* #__PURE__ */ Data_HeytingAlgebra.disj(heytingAlgebraIsSatisfied);
var functorPredicateF = {
    map: function (f) {
        return function (m) {
            if (m instanceof Not) {
                return new Not(f(m.value0));
            };
            if (m instanceof Or) {
                return new Or(f(m.value0), f(m.value1));
            };
            if (m instanceof And) {
                return new And(f(m.value0), f(m.value1));
            };
            if (m instanceof Sequence) {
                return new Sequence(f(m.value0), f(m.value1));
            };
            if (m instanceof Equals) {
                return new Equals(m.value0);
            };
            if (m instanceof Satisfies) {
                return new Satisfies(m.value0);
            };
            if (m instanceof None) {
                return None.value;
            };
            throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var extendCofree = /* #__PURE__ */ Control_Comonad_Cofree.extendCofree(functorPredicateF);
var composeCoKleisliFlipped = /* #__PURE__ */ Control_Extend.composeCoKleisliFlipped(extendCofree);
var cata = /* #__PURE__ */ Matryoshka_Fold.cata(/* #__PURE__ */ Matryoshka_Class_Recursive.recursiveCofree(functorPredicateF));
var extend = /* #__PURE__ */ Control_Extend.extend(extendCofree);
var foldablePredicateF = {
    foldl: function (f) {
        return function (z) {
            return function (m) {
                if (m instanceof Not) {
                    return f(z)(m.value0);
                };
                if (m instanceof Or) {
                    return f(f(z)(m.value0))(m.value1);
                };
                if (m instanceof And) {
                    return f(f(z)(m.value0))(m.value1);
                };
                if (m instanceof Sequence) {
                    return f(f(z)(m.value0))(m.value1);
                };
                if (m instanceof Equals) {
                    return z;
                };
                if (m instanceof Satisfies) {
                    return z;
                };
                if (m instanceof None) {
                    return z;
                };
                throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
            };
        };
    },
    foldr: function (f) {
        return function (z) {
            return function (m) {
                if (m instanceof Not) {
                    return f(m.value0)(z);
                };
                if (m instanceof Or) {
                    return f(m.value0)(f(m.value1)(z));
                };
                if (m instanceof And) {
                    return f(m.value0)(f(m.value1)(z));
                };
                if (m instanceof Sequence) {
                    return f(m.value0)(f(m.value1)(z));
                };
                if (m instanceof Equals) {
                    return z;
                };
                if (m instanceof Satisfies) {
                    return z;
                };
                if (m instanceof None) {
                    return z;
                };
                throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
            };
        };
    },
    foldMap: function (dictMonoid) {
        var append2 = Data_Semigroup.append(dictMonoid.Semigroup0());
        var mempty = Data_Monoid.mempty(dictMonoid);
        return function (f) {
            return function (m) {
                if (m instanceof Not) {
                    return f(m.value0);
                };
                if (m instanceof Or) {
                    return append2(f(m.value0))(f(m.value1));
                };
                if (m instanceof And) {
                    return append2(f(m.value0))(f(m.value1));
                };
                if (m instanceof Sequence) {
                    return append2(f(m.value0))(f(m.value1));
                };
                if (m instanceof Equals) {
                    return mempty;
                };
                if (m instanceof Satisfies) {
                    return mempty;
                };
                if (m instanceof None) {
                    return mempty;
                };
                throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
            };
        };
    }
};
var fold = /* #__PURE__ */ Data_Foldable.fold(foldablePredicateF)(Data_Monoid.monoidArray);
var showIncrementalPredicate = function (dictShow) {
    var show2 = Data_Show.show(dictShow);
    return {
        show: function (v) {
            var printPred = function (v1) {
                return append1([ v1.value0 ])(map(append("  "))(fold(v1.value1)));
            };
            var printNode = function (v1) {
                return "(" + (show1(v1.value0) + (") " + (function () {
                    if (v1.value1 instanceof Not) {
                        return "Not:";
                    };
                    if (v1.value1 instanceof Or) {
                        return "Or:";
                    };
                    if (v1.value1 instanceof And) {
                        return "And:";
                    };
                    if (v1.value1 instanceof Sequence) {
                        return "Seq:";
                    };
                    if (v1.value1 instanceof Equals) {
                        return "Equals " + show2(v1.value1.value0);
                    };
                    if (v1.value1 instanceof Satisfies) {
                        return "Satisfied";
                    };
                    if (v1.value1 instanceof None) {
                        return "None";
                    };
                    throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 97, column 74 - line 104, column 23): " + [ v1.value1.constructor.name ]);
                })()));
            };
            return intercalate("\x0a")(composeCoKleisliFlipped(cata(printPred))(cata(printNode))(v));
        }
    };
};
var eqIsSatisfied = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Unsatisfied && y instanceof Unsatisfied) {
                return true;
            };
            if (x instanceof Satisfied && y instanceof Satisfied) {
                return x.value0 === y.value0;
            };
            return false;
        };
    }
};
var eq1 = /* #__PURE__ */ Data_Eq.eq(eqIsSatisfied);
var toArray = function (v) {
    if (v instanceof Not) {
        return [ v.value0 ];
    };
    if (v instanceof Or) {
        return [ v.value0, v.value1 ];
    };
    if (v instanceof And) {
        return [ v.value0, v.value1 ];
    };
    if (v instanceof Sequence) {
        return [ v.value0, v.value1 ];
    };
    return [  ];
};
var then_ = function (v) {
    return function (v1) {
        return Control_Comonad_Cofree.mkCofree(conj(Control_Comonad_Cofree.head(v))(Control_Comonad_Cofree.head(v1)))(new Sequence(v, v1));
    };
};
var satisfies = function (p) {
    return Control_Comonad_Cofree.mkCofree(Unsatisfied.value)(new Satisfies(function (a) {
        var $231 = p(a);
        if ($231) {
            return new Satisfied(true);
        };
        return Unsatisfied.value;
    }));
};
var runIncremental = function (dictEq) {
    var eq2 = Data_Eq.eq(dictEq);
    return function (a) {
        var go = function (cofree) {
            var tail = (function () {
                var v = Control_Comonad_Cofree.tail(cofree);
                if (v instanceof Not) {
                    return new Not(go(v.value0));
                };
                if (v instanceof Or) {
                    return new Or(go(v.value0), go(v.value1));
                };
                if (v instanceof And) {
                    return new And(go(v.value0), go(v.value1));
                };
                if (v instanceof Sequence) {
                    var v1 = Control_Comonad_Cofree.head(v.value0);
                    if (v1 instanceof Unsatisfied) {
                        return new Sequence(go(v.value0), v.value1);
                    };
                    if (v1 instanceof Satisfied && !v1.value0) {
                        return new Sequence(v.value0, v.value1);
                    };
                    if (v1 instanceof Satisfied && v1.value0) {
                        return new Sequence(v.value0, go(v.value1));
                    };
                    throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 156, column 27 - line 159, column 48): " + [ v1.constructor.name ]);
                };
                if (v instanceof Equals) {
                    return new Equals(v.value0);
                };
                if (v instanceof Satisfies) {
                    return new Satisfies(v.value0);
                };
                if (v instanceof None) {
                    return None.value;
                };
                throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 152, column 16 - line 162, column 23): " + [ v.constructor.name ]);
            })();
            var head = (function () {
                if (tail instanceof Not) {
                    return not1(Control_Comonad_Cofree.head(tail.value0));
                };
                if (tail instanceof Or) {
                    return disj(Control_Comonad_Cofree.head(tail.value0))(Control_Comonad_Cofree.head(tail.value1));
                };
                if (tail instanceof And) {
                    return conj(Control_Comonad_Cofree.head(tail.value0))(Control_Comonad_Cofree.head(tail.value1));
                };
                if (tail instanceof Sequence) {
                    return conj(Control_Comonad_Cofree.head(tail.value0))(Control_Comonad_Cofree.head(tail.value1));
                };
                if (tail instanceof Equals) {
                    var $253 = eq2(a)(tail.value0);
                    if ($253) {
                        return new Satisfied(true);
                    };
                    return Unsatisfied.value;
                };
                if (tail instanceof Satisfies) {
                    return tail.value0(a);
                };
                if (tail instanceof None) {
                    return Unsatisfied.value;
                };
                throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 142, column 16 - line 149, column 30): " + [ tail.constructor.name ]);
            })();
            var $256 = eq1(Control_Comonad_Cofree.head(cofree))(Unsatisfied.value);
            if ($256) {
                return Control_Comonad_Cofree.mkCofree(head)(tail);
            };
            return cofree;
        };
        return function ($283) {
            return wrap(go(unwrap($283)));
        };
    };
};
var runIncrementalFromEmitter = function (dictEq) {
    var runIncremental1 = runIncremental(dictEq);
    return function (dictShow) {
        return function (dictMonadBracket) {
            var bind = Control_Bind.bind((((dictMonadBracket.MonadError1()).MonadThrow0()).Monad0()).Bind1());
            var bracket = Control_Monad_Fork_Class.bracket(dictMonadBracket);
            return function (dictMonadEffect) {
                var liftEffect = Effect_Class.liftEffect(dictMonadEffect);
                return function (emitter) {
                    return function (pred) {
                        return function (incrementalPredicateAction) {
                            return bind(liftEffect(Effect_Ref["new"](pred)))(function (ref) {
                                var sub1 = liftEffect(Halogen_Subscription.subscribe(emitter)(function (a) {
                                    return Effect_Ref.modify_(runIncremental1(a))(ref);
                                }));
                                var unsub = function ($284) {
                                    return liftEffect(Halogen_Subscription.unsubscribe($284));
                                };
                                return bracket(sub1)(function (v) {
                                    return unsub;
                                })(function (v) {
                                    return incrementalPredicateAction(ref);
                                });
                            });
                        };
                    };
                };
            };
        };
    };
};
var or_ = function (v) {
    return function (v1) {
        return Control_Comonad_Cofree.mkCofree(disj(Control_Comonad_Cofree.head(v))(Control_Comonad_Cofree.head(v1)))(new Or(v, v1));
    };
};
var not_ = function (v) {
    return Control_Comonad_Cofree.mkCofree(not1(Control_Comonad_Cofree.head(v)))(new Not(v));
};
var isSatisfied = function (v) {
    return Control_Comonad_Cofree.head(v);
};
var runIncrementalFromFoldable = function (dictFoldable) {
    var foldM = Data_Foldable.foldM(dictFoldable)(Data_Either.monadEither);
    return function (dictEq) {
        var runIncremental1 = runIncremental(dictEq);
        return function (values) {
            return function (pred) {
                var f = function (a) {
                    return function (i) {
                        var i$prime = runIncremental1(a)(i);
                        var v = isSatisfied(i$prime);
                        if (v instanceof Unsatisfied) {
                            return new Data_Either.Right(i$prime);
                        };
                        if (v instanceof Satisfied) {
                            return new Data_Either.Left(i$prime);
                        };
                        throw new Error("Failed pattern match at Test.Spec.Halogen.Predicate (line 222, column 7 - line 224, column 31): " + [ v.constructor.name ]);
                    };
                };
                return Data_Either.either(identity)(identity)(foldM(Data_Function.flip(f))(pred)(values));
            };
        };
    };
};
var incrementalPredicate = function (pred) {
    var f = function (cofree) {
        var v = Control_Comonad_Cofree.tail(cofree);
        if (v instanceof Not) {
            return not1(Control_Comonad_Cofree.head(v.value0));
        };
        if (v instanceof Or) {
            return disj(Control_Comonad_Cofree.head(v.value0))(Control_Comonad_Cofree.head(v.value1));
        };
        if (v instanceof And) {
            return conj(Control_Comonad_Cofree.head(v.value0))(Control_Comonad_Cofree.head(v.value1));
        };
        if (v instanceof Sequence) {
            return conj(Control_Comonad_Cofree.head(v.value0))(Control_Comonad_Cofree.head(v.value1));
        };
        return Control_Comonad_Cofree.head(cofree);
    };
    return extend(f)(pred);
};
var finaliseIncremental = function (v) {
    var f = function (cofree) {
        var v1 = Control_Comonad_Cofree.tail(cofree);
        if (v1 instanceof Not) {
            var $273 = eq1(Control_Comonad_Cofree.head(v1.value0))(Unsatisfied.value);
            if ($273) {
                return new Satisfied(true);
            };
            return Control_Comonad_Cofree.head(v1.value0);
        };
        return Control_Comonad_Cofree.head(cofree);
    };
    return incrementalPredicate(extend(f)(v));
};
var equals = function (a) {
    return Control_Comonad_Cofree.mkCofree(Unsatisfied.value)(new Equals(a));
};
var and_ = function (v) {
    return function (v1) {
        return Control_Comonad_Cofree.mkCofree(conj(Control_Comonad_Cofree.head(v))(Control_Comonad_Cofree.head(v1)))(new And(v, v1));
    };
};
var heytingAlgebraIncremental = /* #__PURE__ */ (function () {
    return {
        ff: Control_Comonad_Cofree.mkCofree(new Satisfied(false))(None.value),
        tt: Control_Comonad_Cofree.mkCofree(new Satisfied(true))(None.value),
        not: not_,
        disj: or_,
        conj: and_,
        implies: function (x) {
            return function (y) {
                return and_(not_(x))(y);
            };
        }
    };
})();
var tt = /* #__PURE__ */ Data_HeytingAlgebra.tt(heytingAlgebraIncremental);
var not2 = /* #__PURE__ */ Data_HeytingAlgebra.not(heytingAlgebraIncremental);
var repeatAtLeast = function (v) {
    return function (v1) {
        if (v === 0) {
            return tt;
        };
        return then_(v1)(repeatAtLeast(v - 1 | 0)(v1));
    };
};
var repeatAtMost = function (v) {
    return function (v1) {
        if (v === 0) {
            return not2(v1);
        };
        return then_(v1)(repeatAtLeast(v - 1 | 0)(v1));
    };
};
var repeatExactly = function (v) {
    return function (v1) {
        if (v === 0) {
            return not2(v1);
        };
        return then_(v1)(repeatExactly(v - 1 | 0)(v1));
    };
};
export {
    Not,
    Or,
    And,
    Sequence,
    Equals,
    Satisfies,
    None,
    Unsatisfied,
    Satisfied,
    Incremental,
    incrementalPredicate,
    toArray,
    isSatisfied,
    runIncremental,
    finaliseIncremental,
    repeatExactly,
    repeatAtLeast,
    repeatAtMost,
    runIncrementalFromEmitter,
    runIncrementalFromFoldable,
    equals,
    satisfies,
    not_,
    or_,
    and_,
    then_,
    functorPredicateF,
    foldablePredicateF,
    eqIsSatisfied,
    heytingAlgebraIsSatisfied,
    showIsSatisfied,
    newtypeIncrementalPredica,
    showIncrementalPredicate,
    heytingAlgebraIncremental
};
//# sourceMappingURL=index.js.map
